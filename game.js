// Generated by Haxe 4.3.6
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Ball = function() {
	this.alive = true;
	this.dummy = false;
	Game.me.balls.push(this);
	this.skin = new h2d_Element();
	this.skin.goto(null,"ball");
	this.hand = false;
	this.we = 0.25 + Game.me.numHave(Malus.HEAVY) * 0.075;
	this.frict = 0.98;
	this.hand = false;
	this.x = this.y = this.vx = this.vy = 0;
	this.gy = Main.HEIGHT - 8 - Std.random(12);
	Game.me.dm.add(this.skin,GameDepth.DP_BALLS);
};
$hxClasses["Ball"] = Ball;
Ball.__name__ = "Ball";
Ball.prototype = {
	update: function() {
		if(this.hand) {
			return;
		}
		this.vx += Game.me.wind * 0.02;
		this.vy += this.we;
		this.x += this.vx;
		this.y += this.vy;
		this.x *= this.frict;
		this.y *= this.frict;
		this.updatePos();
		var s = Game.me.snowman;
		var h = s.hands[1];
		var dx = h.x + s.x - this.x;
		var dy = h.y + s.y - 9 - this.y;
		var dist = Math.sqrt(dx * dx + dy * dy);
		if(dist < 12 && !this.dummy) {
			s.grab(this);
			var an = Math.atan2(dy,dx);
			h.vx += Math.cos(an) * dist;
			h.vy += Math.sin(an) * dist;
		}
		if(this.y > this.gy) {
			s.head.emote(8 + Std.random(3),2,30);
			Main.playSound("drop_ball");
			this.skin.goto(1,"ball");
			HxOverrides.remove(Game.me.balls,this);
			var max = 12;
			var _g = 0;
			var _g1 = max;
			while(_g < _g1) {
				var i = _g++;
				var p = Game.me.fxSnow(this.skin.x,this.skin.y + 4);
				p.impulse(Math.random() * 3.14 - 1.57,0.5 + Math.random() * 2,3);
			}
			Game.me.drop(this.skin);
			if(Game.me.snowman.controlable) {
				new fx_h2d_Flash(Game.me.bg,16711680);
			}
			return;
		}
	}
	,setPos: function(nx,ny) {
		this.x = nx;
		this.y = ny;
		this.updatePos();
	}
	,updatePos: function() {
		var _this = this.skin;
		_this.posChanged = true;
		_this.x = this.x | 0;
		var _this = this.skin;
		_this.posChanged = true;
		_this.y = this.y | 0;
	}
	,kill: function() {
		this.alive = false;
		HxOverrides.remove(Game.me.balls,this);
		this.skin.kill();
	}
	,getScenePos: function() {
		var x = this.skin.x;
		var y = this.skin.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var pos = new h2d_col_PointImpl(x,y);
		if(this.hand) {
			pos.x += Game.me.snowman.x;
			pos.y += Game.me.snowman.y;
		}
		return pos;
	}
	,pop: function() {
		this.hand = false;
		Game.me.dm.add(this.skin,GameDepth.DP_BALLS);
		var s = Game.me.snowman;
		this.x = this.skin.x + s.x;
		this.y = this.skin.y + s.y;
		this.updatePos();
	}
	,__class__: Ball
};
var h2d_col_PointImpl = function(x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["h2d.col.PointImpl"] = h2d_col_PointImpl;
h2d_col_PointImpl.__name__ = "h2d.col.PointImpl";
h2d_col_PointImpl.prototype = {
	distanceSq: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return dx * dx + dy * dy;
	}
	,distance: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "}";
	}
	,sub: function(p) {
		var x = this.x - p.x;
		var y = this.y - p.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,add: function(p) {
		var x = this.x + p.x;
		var y = this.y + p.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,scaled: function(v) {
		var x = this.x * v;
		var y = this.y * v;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,equals: function(other) {
		if(this.x == other.x) {
			return this.y == other.y;
		} else {
			return false;
		}
	}
	,dot: function(p) {
		return this.x * p.x + this.y * p.y;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,normalize: function() {
		var k = this.x * this.x + this.y * this.y;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		this.x *= k;
		this.y *= k;
	}
	,normalized: function() {
		var k = this.x * this.x + this.y * this.y;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = this.x * k;
		var y = this.y * k;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,set: function(x,y) {
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
	}
	,load: function(p) {
		this.x = p.x;
		this.y = p.y;
	}
	,scale: function(f) {
		this.x *= f;
		this.y *= f;
	}
	,clone: function() {
		var x = this.x;
		var y = this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,cross: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,lerp: function(a,b,k) {
		var a1 = a.x;
		this.x = a1 + k * (b.x - a1);
		var a1 = a.y;
		this.y = a1 + k * (b.y - a1);
	}
	,transform: function(m) {
		var mx = m.a * this.x + m.c * this.y + m.x;
		var my = m.b * this.x + m.d * this.y + m.y;
		this.x = mx;
		this.y = my;
	}
	,transformed: function(m) {
		var mx = m.a * this.x + m.c * this.y + m.x;
		var my = m.b * this.x + m.d * this.y + m.y;
		var x = mx;
		var y = my;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,transform2x2: function(m) {
		var mx = m.a * this.x + m.c * this.y;
		var my = m.b * this.x + m.d * this.y;
		this.x = mx;
		this.y = my;
	}
	,transformed2x2: function(m) {
		var mx = m.a * this.x + m.c * this.y;
		var my = m.b * this.x + m.d * this.y;
		var x = mx;
		var y = my;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,toIPoint: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		return new h2d_col_IPoint(Math.round(this.x * scale),Math.round(this.y * scale));
	}
	,rotate: function(angle) {
		var c = Math.cos(angle);
		var s = Math.sin(angle);
		var x2 = this.x * c - this.y * s;
		var y2 = this.x * s + this.y * c;
		this.x = x2;
		this.y = y2;
	}
	,__class__: h2d_col_PointImpl
};
var h2d_Object = function(parent) {
	this.blendMode = h2d_BlendMode.Alpha;
	this.alpha = 1.;
	this.visible = true;
	this.rotation = 0;
	this.scaleY = 1;
	this.scaleX = 1;
	this.y = 0;
	this.x = 0;
	this.matA = 1;
	this.matB = 0;
	this.matC = 0;
	this.matD = 1;
	this.absX = 0;
	this.absY = 0;
	this.posChanged = parent != null;
	this.children = [];
	if(parent != null) {
		parent.addChild(this);
	}
};
$hxClasses["h2d.Object"] = h2d_Object;
h2d_Object.__name__ = "h2d.Object";
h2d_Object.prototype = {
	getBounds: function(relativeTo,out) {
		if(out == null) {
			out = new h2d_col_Bounds();
		} else {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
		}
		if(relativeTo != null) {
			relativeTo.syncPos();
		}
		if(relativeTo != this) {
			this.syncPos();
		}
		this.getBoundsRec(relativeTo,out,false);
		if(out.xMax <= out.xMin || out.yMax <= out.yMin) {
			this.addBounds(relativeTo,out,-1,-1,2,2);
			out.xMax = out.xMin = (out.xMax + out.xMin) * 0.5;
			out.yMax = out.yMin = (out.yMax + out.yMin) * 0.5;
		}
		return out;
	}
	,getSize: function(out) {
		if(out == null) {
			out = new h2d_col_Bounds();
		} else {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
		}
		this.syncPos();
		this.getBoundsRec(this.parent,out,true);
		if(out.xMax <= out.xMin || out.yMax <= out.yMin) {
			this.addBounds(this.parent,out,-1,-1,2,2);
			out.xMax = out.xMin = (out.xMax + out.xMin) * 0.5;
			out.yMax = out.yMin = (out.yMax + out.yMin) * 0.5;
		}
		var dx = -this.x;
		var dy = -this.y;
		out.xMin += dx;
		out.xMax += dx;
		out.yMin += dy;
		out.yMax += dy;
		return out;
	}
	,getAbsPos: function() {
		this.syncPos();
		var m = new h2d_col_Matrix();
		m.a = this.matA;
		m.b = this.matB;
		m.c = this.matC;
		m.d = this.matD;
		m.x = this.absX;
		m.y = this.absY;
		return m;
	}
	,contains: function(o) {
		while(o != null) {
			o = o.parent;
			if(o == this) {
				return true;
			}
		}
		return false;
	}
	,find: function(f) {
		var v = f(this);
		if(v != null) {
			return v;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var v = o.find(f);
			if(v != null) {
				return v;
			}
		}
		return null;
	}
	,findAll: function(f,arr) {
		if(arr == null) {
			arr = [];
		}
		var v = f(this);
		if(v != null) {
			arr.push(v);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.findAll(f,arr);
		}
		return arr;
	}
	,set_filter: function(f) {
		if(this.filter != null && this.allocated) {
			this.filter.unbind(this);
		}
		this.filter = f;
		if(f != null && this.allocated) {
			f.bind(this);
		}
		return f;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		var n = this.children.length;
		if(n == 0) {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
			return;
		}
		if(n == 1) {
			var c = this.children[0];
			if(c.visible) {
				c.getBoundsRec(relativeTo,out,forSize);
			} else {
				out.xMin = 1e20;
				out.yMin = 1e20;
				out.xMax = -1e20;
				out.yMax = -1e20;
			}
			return;
		}
		var xmin = Infinity;
		var ymin = Infinity;
		var xmax = -Infinity;
		var ymax = -Infinity;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(!c.visible) {
				continue;
			}
			c.getBoundsRec(relativeTo,out,forSize);
			if(out.xMin < xmin) {
				xmin = out.xMin;
			}
			if(out.yMin < ymin) {
				ymin = out.yMin;
			}
			if(out.xMax > xmax) {
				xmax = out.xMax;
			}
			if(out.yMax > ymax) {
				ymax = out.yMax;
			}
		}
		out.xMin = xmin;
		out.yMin = ymin;
		out.xMax = xmax;
		out.yMax = ymax;
	}
	,addBounds: function(relativeTo,out,dx,dy,width,height) {
		if(width <= 0 || height <= 0) {
			return;
		}
		if(relativeTo == null) {
			var x = dx * this.matA + dy * this.matC + this.absX;
			var y = dx * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = (dx + width) * this.matA + dy * this.matC + this.absX;
			var y = (dx + width) * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = dx * this.matA + (dy + height) * this.matC + this.absX;
			var y = dx * this.matB + (dy + height) * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			var x = (dx + width) * this.matA + (dy + height) * this.matC + this.absX;
			var y = (dx + width) * this.matB + (dy + height) * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			return;
		}
		if(relativeTo == this) {
			if(out.xMin > dx) {
				out.xMin = dx;
			}
			if(out.yMin > dy) {
				out.yMin = dy;
			}
			if(out.xMax < dx + width) {
				out.xMax = dx + width;
			}
			if(out.yMax < dy + height) {
				out.yMax = dy + height;
			}
			return;
		}
		var r = relativeTo.matA * relativeTo.matD - relativeTo.matB * relativeTo.matC;
		if(r == 0) {
			return;
		}
		var det = 1 / r;
		var rA = relativeTo.matD * det;
		var rB = -relativeTo.matB * det;
		var rC = -relativeTo.matC * det;
		var rD = relativeTo.matA * det;
		var rX = this.absX - relativeTo.absX;
		var rY = this.absY - relativeTo.absY;
		var x = dx * this.matA + dy * this.matC + rX;
		var y = dx * this.matB + dy * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + dy * this.matC + rX;
		y = (dx + width) * this.matB + dy * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = dx * this.matA + (dy + height) * this.matC + rX;
		y = dx * this.matB + (dy + height) * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + (dy + height) * this.matC + rX;
		y = (dx + width) * this.matB + (dy + height) * this.matD + rY;
		var x1 = x * rA + y * rC;
		var y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
	}
	,getObjectsCount: function() {
		var k = 0;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			k += c.getObjectsCount() + 1;
		}
		return k;
	}
	,localToGlobal: function(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h2d_col_PointImpl(0.,0.);
		}
		var px = pt.x * this.matA + pt.y * this.matC + this.absX;
		var py = pt.x * this.matB + pt.y * this.matD + this.absY;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	,globalToLocal: function(pt) {
		this.syncPos();
		pt.x -= this.absX;
		pt.y -= this.absY;
		var invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		var px = (pt.x * this.matD - pt.y * this.matC) * invDet;
		var py = (-pt.x * this.matB + pt.y * this.matA) * invDet;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	,getScene: function() {
		var p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h2d_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	,set_visible: function(b) {
		if(this.visible == b) {
			return b;
		}
		this.visible = b;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return b;
	}
	,addChild: function(s) {
		this.addChildAt(s,this.children.length);
	}
	,addChildAt: function(s,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		var p = this;
		while(p != null) {
			if(p == s) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(s.parent != null) {
			var old = s.allocated;
			s.allocated = false;
			s.parent.removeChild(s);
			s.allocated = old;
		}
		this.children.splice(pos,0,s);
		if(!this.allocated && s.allocated) {
			s.onRemove();
		}
		s.parent = this;
		s.parentContainer = this.parentContainer;
		s.posChanged = true;
		if(this.allocated) {
			if(!s.allocated) {
				s.onAdd();
			} else {
				s.onHierarchyMoved(true);
			}
		}
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,onContentChanged: function() {
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,onHierarchyMoved: function(parentChanged) {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onHierarchyMoved(parentChanged);
		}
	}
	,onAdd: function() {
		this.allocated = true;
		if(this.filter != null) {
			this.filter.bind(this);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	,onRemove: function() {
		this.allocated = false;
		if(this.filter != null) {
			this.filter.unbind(this);
		}
		var i = this.children.length - 1;
		while(i >= 0) {
			var c = this.children[i--];
			if(c != null) {
				c.onRemove();
			}
		}
	}
	,getMatrix: function(m) {
		m.a = this.matA;
		m.b = this.matB;
		m.c = this.matC;
		m.d = this.matD;
		m.x = this.absX;
		m.y = this.absY;
	}
	,removeChild: function(s) {
		if(HxOverrides.remove(this.children,s)) {
			if(s.allocated) {
				s.onRemove();
			}
			s.parent = null;
			if(s.parentContainer != null) {
				s.setParentContainer(null);
			}
			s.posChanged = true;
			if(this.parentContainer != null) {
				this.parentContainer.contentChanged(this);
			}
		}
	}
	,setParentContainer: function(c) {
		this.parentContainer = c;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.setParentContainer(c);
		}
	}
	,removeChildren: function() {
		while(this.children.length > 0) this.removeChild(this.getChildAt(0));
	}
	,remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,drawTo: function(t) {
		var s = this.getScene();
		var needDispose = s == null;
		if(s == null) {
			s = new h2d_Scene();
		}
		s.drawImplTo(this,[t]);
		if(needDispose) {
			s.dispose();
			this.onRemove();
		}
	}
	,drawToTextures: function(texs,outputs) {
		var s = this.getScene();
		var needDispose = s == null;
		if(s == null) {
			s = new h2d_Scene();
		}
		s.drawImplTo(this,texs,outputs);
		if(needDispose) {
			s.dispose();
			this.onRemove();
		}
	}
	,draw: function(ctx) {
	}
	,sync: function(ctx) {
		var changed = this.posChanged;
		if(changed) {
			this.calcAbsPos();
			this.posChanged = false;
		}
		this.lastFrame = ctx.frame;
		var p = 0;
		var len = this.children.length;
		while(p < len) {
			var c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					c.posChanged = true;
				}
				c.sync(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
	}
	,syncPos: function() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
	}
	,calcAbsPos: function() {
		if(this.parent == null) {
			var cr;
			var sr;
			if(this.rotation == 0) {
				cr = 1.;
				sr = 0.;
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				cr = Math.cos(this.rotation);
				sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = this.x;
			this.absY = this.y;
		} else {
			if(this.rotation == 0) {
				this.matA = this.scaleX * this.parent.matA;
				this.matB = this.scaleX * this.parent.matB;
				this.matC = this.scaleY * this.parent.matC;
				this.matD = this.scaleY * this.parent.matD;
			} else {
				var cr = Math.cos(this.rotation);
				var sr = Math.sin(this.rotation);
				var tmpA = this.scaleX * cr;
				var tmpB = this.scaleX * sr;
				var tmpC = this.scaleY * -sr;
				var tmpD = this.scaleY * cr;
				this.matA = tmpA * this.parent.matA + tmpB * this.parent.matC;
				this.matB = tmpA * this.parent.matB + tmpB * this.parent.matD;
				this.matC = tmpC * this.parent.matA + tmpD * this.parent.matC;
				this.matD = tmpC * this.parent.matB + tmpD * this.parent.matD;
			}
			this.absX = this.x * this.parent.matA + this.y * this.parent.matC + this.parent.absX;
			this.absY = this.x * this.parent.matB + this.y * this.parent.matD + this.parent.absY;
		}
	}
	,emitTile: function(ctx,tile) {
		if(h2d_Object.nullDrawable == null) {
			h2d_Object.nullDrawable = new h2d_Drawable(null);
		}
		h2d_Object.nullDrawable.smooth = this.filter != null && this.filter.smooth ? true : null;
		h2d_Object.nullDrawable.absX = this.absX;
		h2d_Object.nullDrawable.absY = this.absY;
		h2d_Object.nullDrawable.matA = this.matA;
		h2d_Object.nullDrawable.matB = this.matB;
		h2d_Object.nullDrawable.matC = this.matC;
		h2d_Object.nullDrawable.matD = this.matD;
		ctx.drawTile(h2d_Object.nullDrawable,tile);
	}
	,clipBounds: function(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		var view = ctx.tmpBounds;
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(ctx.inFilter != null) {
			var f1 = ctx.baseShader.filterMatrixA__;
			var f2 = ctx.baseShader.filterMatrixB__;
			var tmpA = this.matA * f1.x + this.matB * f1.y;
			var tmpB = this.matA * f2.x + this.matB * f2.y;
			var tmpC = this.matC * f1.x + this.matD * f1.y;
			var tmpD = this.matC * f2.x + this.matD * f2.y;
			var tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			var tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		var x = bounds.xMin;
		var y = bounds.yMin;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMax;
		var y = bounds.yMin;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMin;
		var y = bounds.yMax;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = bounds.xMax;
		var y = bounds.yMax;
		var x1 = x * matA + y * matC + absX;
		var y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		if(view.xMin < -1) {
			view.xMin = -1;
		}
		if(view.yMin < -1) {
			view.yMin = -1;
		}
		if(view.xMax > 1) {
			view.xMax = 1;
		}
		if(view.yMax > 1) {
			view.yMax = 1;
		}
		var invDet = 1 / (matA * matD - matB * matC);
		var sxMin = view.xMin;
		var syMin = view.yMin;
		var sxMax = view.xMax;
		var syMax = view.yMax;
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		var x = sxMin;
		var y = syMin;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMax;
		var y = syMin;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMin;
		var y = syMax;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var x = sxMax;
		var y = syMax;
		x -= absX;
		y -= absY;
		var x1 = (x * matD - y * matC) * invDet;
		var y1 = (-x * matB + y * matA) * invDet;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		var a = bounds.xMin;
		var b = view.xMin;
		bounds.xMin = a < b ? b : a;
		var a = bounds.yMin;
		var b = view.yMin;
		bounds.yMin = a < b ? b : a;
		var a = bounds.xMax;
		var b = view.xMax;
		bounds.xMax = a > b ? b : a;
		var a = bounds.yMax;
		var b = view.yMax;
		bounds.yMax = a > b ? b : a;
	}
	,drawFilters: function(ctx) {
		if(!ctx.pushFilter(this)) {
			return;
		}
		var bounds = ctx.tmpBounds;
		var total = new h2d_col_Bounds();
		this.filter.sync(ctx,this);
		var scaleX;
		var scaleY;
		if(this.filter.useScreenResolution) {
			var s = ctx.scene;
			scaleX = s.viewportScaleX * this.filter.resolutionScale;
			scaleY = s.viewportScaleY * this.filter.resolutionScale;
		} else {
			scaleX = this.filter.resolutionScale;
			scaleY = this.filter.resolutionScale;
		}
		if(this.filter.autoBounds) {
			var maxExtent = this.filter.boundsExtend;
			if(maxExtent >= 0) {
				this.getBounds(this,bounds);
				bounds.xMin = bounds.xMin * scaleX - maxExtent;
				bounds.yMin = bounds.yMin * scaleY - maxExtent;
				bounds.xMax = bounds.xMax * scaleX + maxExtent;
				bounds.yMax = bounds.yMax * scaleY + maxExtent;
				if(bounds.xMin < total.xMin) {
					total.xMin = bounds.xMin;
				}
				if(bounds.xMax > total.xMax) {
					total.xMax = bounds.xMax;
				}
				if(bounds.yMin < total.yMin) {
					total.yMin = bounds.yMin;
				}
				if(bounds.yMax > total.yMax) {
					total.yMax = bounds.yMax;
				}
			}
		} else {
			var scale = h2d_Object.tmpPoint;
			var _this = scale;
			var x = scaleX;
			var y = scaleY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			this.filter.getBounds(this,bounds,scale);
			if(bounds.xMin < total.xMin) {
				total.xMin = bounds.xMin;
			}
			if(bounds.xMax > total.xMax) {
				total.xMax = bounds.xMax;
			}
			if(bounds.yMin < total.yMin) {
				total.yMin = bounds.yMin;
			}
			if(bounds.yMax > total.yMax) {
				total.yMax = bounds.yMax;
			}
			scaleX = scale.x;
			scaleY = scale.y;
		}
		ctx.setFilterScale(scaleX,scaleY);
		this.clipBounds(ctx,total,scaleX,scaleY);
		var xMin = Math.floor(total.xMin + 1e-10);
		var yMin = Math.floor(total.yMin + 1e-10);
		var width = Math.ceil(total.xMax - xMin - 1e-10);
		var height = Math.ceil(total.yMax - yMin - 1e-10);
		if(width <= 0 || height <= 0 || total.xMax < total.xMin) {
			ctx.popFilter();
			return;
		}
		var t = ctx.textures.allocTarget("filterTemp",width,height,false);
		ctx.pushTarget(t,xMin,yMin,width,height);
		ctx.engine.clear(0);
		var oldAlpha = ctx.globalAlpha;
		var shader = ctx.baseShader;
		var _this = shader.filterMatrixA__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var oldA_x = x1;
		var oldA_y = y1;
		var oldA_z = z1;
		var _this = shader.filterMatrixB__;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var oldB_x = x1;
		var oldB_y = y1;
		var oldB_z = z1;
		var invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		var invA = this.matD * invDet * scaleX;
		var invB = -this.matB * invDet * scaleY;
		var invC = -this.matC * invDet * scaleX;
		var invD = this.matA * invDet * scaleY;
		var invX = -(this.absX * invA + this.absY * invC);
		var invY = -(this.absX * invB + this.absY * invD);
		var _this = shader.filterMatrixA__;
		var x = invA;
		var y = invC;
		var z = invX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = shader.filterMatrixB__;
		var x = invB;
		var y = invD;
		var z = invY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		ctx.globalAlpha = 1;
		this.drawContent(ctx);
		var finalTile = h2d_Tile.fromTexture(t);
		finalTile.dx = xMin / scaleX;
		finalTile.dy = yMin / scaleY;
		var prev = finalTile;
		finalTile = this.filter.draw(ctx,finalTile);
		if(finalTile != null) {
			if(finalTile != prev) {
				finalTile.dx = (finalTile.dx + xMin) / scaleX;
				finalTile.dy = (finalTile.dy + yMin) / scaleY;
			}
			finalTile.width /= scaleX;
			finalTile.height /= scaleY;
		}
		var _this = shader.filterMatrixA__;
		_this.x = oldA_x;
		_this.y = oldA_y;
		_this.z = oldA_z;
		var _this = shader.filterMatrixB__;
		_this.x = oldB_x;
		_this.y = oldB_y;
		_this.z = oldB_z;
		ctx.popTarget();
		ctx.popFilter();
		ctx.globalAlpha = oldAlpha;
		if(finalTile == null) {
			return;
		}
		this.drawFiltered(ctx,finalTile);
	}
	,drawFiltered: function(ctx,tile) {
		var oldAlpha = ctx.globalAlpha;
		ctx.currentBlend = null;
		ctx.inFilterBlend = this.blendMode;
		ctx.globalAlpha *= this.alpha;
		this.emitTile(ctx,tile);
		ctx.globalAlpha = oldAlpha;
		ctx.inFilterBlend = null;
		ctx.currentBlend = null;
	}
	,drawRec: function(ctx) {
		if(!this.visible) {
			return;
		}
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		if(this.filter != null && this.filter.get_enable()) {
			this.drawFilters(ctx);
		} else {
			var old = ctx.globalAlpha;
			ctx.globalAlpha *= this.alpha;
			this.drawContent(ctx);
			ctx.globalAlpha = old;
		}
	}
	,drawContent: function(ctx) {
		if(ctx.front2back) {
			var i = this.children.length;
			while(i-- > 0) this.children[i].drawRec(ctx);
			this.draw(ctx);
		} else {
			this.draw(ctx);
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.drawRec(ctx);
			}
		}
	}
	,set_x: function(v) {
		this.posChanged = true;
		return this.x = v;
	}
	,set_y: function(v) {
		this.posChanged = true;
		return this.y = v;
	}
	,set_scaleX: function(v) {
		this.posChanged = true;
		return this.scaleX = v;
	}
	,set_scaleY: function(v) {
		this.posChanged = true;
		return this.scaleY = v;
	}
	,set_rotation: function(v) {
		this.posChanged = true;
		return this.rotation = v;
	}
	,move: function(dx,dy) {
		var v = this.x + dx * Math.cos(this.rotation);
		this.posChanged = true;
		this.x = v;
		var v = this.y + dy * Math.sin(this.rotation);
		this.posChanged = true;
		this.y = v;
	}
	,setPosition: function(x,y) {
		this.posChanged = true;
		this.x = x;
		this.posChanged = true;
		this.y = y;
	}
	,rotate: function(v) {
		this.posChanged = true;
		this.rotation += v;
	}
	,scale: function(v) {
		this.posChanged = true;
		this.scaleX *= v;
		this.posChanged = true;
		this.scaleY *= v;
	}
	,setScale: function(v) {
		this.posChanged = true;
		this.scaleX = v;
		this.posChanged = true;
		this.scaleY = v;
	}
	,getChildAt: function(n) {
		return this.children[n];
	}
	,getChildIndex: function(o) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == o) {
				return i;
			}
		}
		return -1;
	}
	,getObjectByName: function(name) {
		if(this.name == name) {
			return this;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var o = c.getObjectByName(name);
			if(o != null) {
				return o;
			}
		}
		return null;
	}
	,get_numChildren: function() {
		return this.children.length;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$h2d_$Object(this.children);
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		var c1 = c.__name__;
		if(this.name == null) {
			return c1;
		} else {
			return this.name + "(" + c1 + ")";
		}
	}
	,contentChanged: function(s) {
	}
	,constraintSize: function(maxWidth,maxHeight) {
	}
	,__class__: h2d_Object
};
var h2d_Drawable = function(parent) {
	h2d_Object.call(this,parent);
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.color = new h3d_Vector4Impl(x,y,z,w);
};
$hxClasses["h2d.Drawable"] = h2d_Drawable;
h2d_Drawable.__name__ = "h2d.Drawable";
h2d_Drawable.__super__ = h2d_Object;
h2d_Drawable.prototype = $extend(h2d_Object.prototype,{
	set_tileWrap: function(b) {
		return this.tileWrap = b;
	}
	,get_colorAdd: function() {
		var s = this.getShader(h3d_shader_ColorAdd);
		if(s == null) {
			return null;
		} else {
			return s.color__;
		}
	}
	,set_colorAdd: function(c) {
		var s = this.getShader(h3d_shader_ColorAdd);
		if(s == null) {
			if(c != null) {
				s = this.addShader(new h3d_shader_ColorAdd());
				s.color__ = c;
			}
		} else if(c == null) {
			this.removeShader(s);
		} else {
			s.color__ = c;
		}
		return c;
	}
	,drawFiltered: function(ctx,tile) {
		var old = this.shaders;
		this.shaders = null;
		h2d_Object.prototype.drawFiltered.call(this,ctx,tile);
		this.shaders = old;
	}
	,set_colorKey: function(v) {
		var s = this.getShader(h3d_shader_ColorKey);
		if(s == null) {
			if(v != null) {
				s = this.addShader(new h3d_shader_ColorKey(-16777216 | v));
			}
		} else if(v == null) {
			this.removeShader(s);
		} else {
			var _this = s.colorKey__;
			var c = -16777216 | v;
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
		}
		return this.colorKey = v;
	}
	,adjustColor: function(col) {
		if(col == null) {
			this.set_colorMatrix(null);
		} else {
			var m = this.get_colorMatrix();
			if(m == null) {
				m = new h3d_MatrixImpl();
				this.set_colorMatrix(m);
			}
			m.identity();
			m.adjustColor(col);
		}
	}
	,get_colorMatrix: function() {
		var s = this.getShader(h3d_shader_ColorMatrix);
		if(s == null) {
			return null;
		} else {
			return s.matrix__;
		}
	}
	,set_colorMatrix: function(m) {
		var s = this.getShader(h3d_shader_ColorMatrix);
		if(s == null) {
			if(m != null) {
				s = this.addShader(new h3d_shader_ColorMatrix());
				s.matrix__ = m;
			}
		} else if(m == null) {
			this.removeShader(s);
		} else {
			s.matrix__ = m;
		}
		return m;
	}
	,getShader: function(stype) {
		if(this.shaders != null) {
			var _g_l = this.shaders;
			var _g_last = null;
			while(_g_l != _g_last) {
				var s = _g_l.s;
				_g_l = _g_l.next;
				var s1 = s;
				var s2 = js_Boot.__downcastCheck(s1,stype) ? s1 : null;
				if(s2 != null) {
					return s2;
				}
			}
		}
		return null;
	}
	,getShaders: function() {
		return new hxsl__$ShaderList_ShaderIterator(this.shaders,null);
	}
	,addShader: function(s) {
		if(s == null) {
			throw haxe_Exception.thrown("Can't add null shader");
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		return s;
	}
	,removeShader: function(s) {
		var prev = null;
		var cur = this.shaders;
		while(cur != null) {
			if(cur.s == s) {
				if(prev == null) {
					this.shaders = cur.next;
				} else {
					prev.next = cur.next;
				}
				return true;
			}
			prev = cur;
			cur = cur.next;
		}
		return false;
	}
	,emitTile: function(ctx,tile) {
		if(tile == null) {
			tile = new h2d_Tile(null,0,0,5,5);
		}
		if(!ctx.drawTile(this,tile)) {
			return;
		}
	}
	,__class__: h2d_Drawable
});
var h2d_Element = function() {
	h2d_Drawable.call(this,null);
	this.store = h2d_Element.DEFAULT_STORE;
	this.animated = false;
};
$hxClasses["h2d.Element"] = h2d_Element;
h2d_Element.__name__ = "h2d.Element";
h2d_Element.updateAnims = function() {
	var _g = 0;
	var _g1 = h2d_Element.ANIMATED.slice();
	while(_g < _g1.length) {
		var el = _g1[_g];
		++_g;
		el.updateAnim();
	}
};
h2d_Element.__super__ = h2d_Drawable;
h2d_Element.prototype = $extend(h2d_Drawable.prototype,{
	draw: function(ctx) {
		this.emitTile(ctx,this.tile);
	}
	,goto: function(id,str,center) {
		if(center == null) {
			center = false;
		}
		if(id == null) {
			id = 0;
		}
		var _this = this.store;
		var id1 = id;
		if(id1 == null) {
			id1 = 0;
		}
		if(str != null) {
			id1 += _this.index.h[str];
		}
		this.tile = _this.tiles[id1];
	}
	,play: function(str) {
		this.anim = new h2d_Animator();
		this.anim.timeline = this.store.timelines.h[str];
		this.goto(this.anim.getCurrentFrame());
		if(!this.animated) {
			h2d_Element.ANIMATED.push(this);
			this.animated = true;
		}
	}
	,stop: function() {
		if(this.anim == null) {
			return;
		}
		this.anim = null;
		this.animated = false;
		HxOverrides.remove(h2d_Element.ANIMATED,this);
	}
	,updateAnim: function() {
		this.anim.update();
		if(this.visible && this.anim != null) {
			this.goto(this.anim.getCurrentFrame());
		}
	}
	,swapAnim: function(newAnim) {
		newAnim.cursor = this.anim.cursor;
		newAnim.loop = this.anim.loop;
		this.anim = newAnim;
	}
	,kill: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
		if(this.animated) {
			HxOverrides.remove(h2d_Element.ANIMATED,this);
		}
	}
	,randomFlip: function() {
		var v = Std.random(2) * 2 - 1;
		this.posChanged = true;
		this.scaleX = v;
		var v = Std.random(2) * 2 - 1;
		this.posChanged = true;
		this.scaleY = v;
	}
	,makeButton: function(onClick,onOver,onOut) {
		if(this.button != null) {
			this.removeButton();
		}
		this.button = new h2d_Interactive(this.tile.width,this.tile.height,this);
		var _this = this.button;
		_this.posChanged = true;
		_this.x = this.tile.dx;
		var _this = this.button;
		_this.posChanged = true;
		_this.y = this.tile.dy;
		this.button.onClick = function(e) {
			if(onClick != null) {
				onClick();
			}
		};
		this.button.onOver = function(e) {
			if(onOver != null) {
				onOver();
			}
		};
		this.button.onOut = function(e) {
			if(onOut != null) {
				onOut();
			}
		};
		this.button.backgroundColor = 16711680;
	}
	,removeButton: function() {
		if(this.button == null) {
			return;
		}
	}
	,__class__: h2d_Element
});
var Bird = function() {
	h2d_Element.call(this);
	Game.me.birds.push(this);
	Game.me.dm.add(this,GameDepth.DP_BALLS);
	this.hit = false;
	this.sens = Std.random(2) * 2 - 1;
	this.speed = 2 + Math.random() * 2;
	this.posChanged = true;
	this.scaleX = this.sens;
	var x = 0.0;
	var y = 0.0;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.plomb = new h2d_col_PointImpl(x,y);
	var x = 0.0;
	var y = 0.0;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.inc = new h2d_col_PointImpl(x,y);
	var x = Main.WIDTH * 0.5 - (Main.WIDTH * 0.5 + 64) * this.sens;
	var y = 140 - Std.random(80);
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.pos = new h2d_col_PointImpl(x,y);
	this.updatePos();
};
$hxClasses["Bird"] = Bird;
Bird.__name__ = "Bird";
Bird.__super__ = h2d_Element;
Bird.prototype = $extend(h2d_Element.prototype,{
	update: function() {
		this.pos.x += this.speed * this.sens;
		this.pos.y--;
		this.goto((Main.t >> 1) % 5,"bird");
		if(!this.hit) {
			var _g = 0;
			var _g1 = Game.me.balls;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				if(b.hand) {
					continue;
				}
				var dx = b.x - this.x;
				var dy = b.y - this.y;
				if(Math.sqrt(dx * dx + dy * dy) < 28) {
					this.collide(b);
					break;
				}
			}
		}
		this.plomb.x *= 0.95;
		this.plomb.y *= 0.95;
		this.plomb.x -= this.inc.x * 0.05;
		this.plomb.y -= this.inc.y * 0.05;
		this.inc.x += this.plomb.x;
		this.inc.y += this.plomb.y;
		if(this.pos.y < -32) {
			this.kill();
		}
		this.updatePos();
	}
	,updatePos: function() {
		this.posChanged = true;
		this.x = this.pos.x + this.inc.x;
		this.posChanged = true;
		this.y = this.pos.y + this.inc.y;
	}
	,kill: function() {
		h2d_Element.prototype.kill.call(this);
		HxOverrides.remove(Game.me.birds,this);
	}
	,vanish: function() {
		this.kill();
	}
	,collide: function(b) {
		var pow = Math.sqrt(b.vx * b.vx + b.vy + b.vy);
		var max = 1 + (pow * 0.5 | 0);
		var _g = 0;
		var _g1 = max;
		while(_g < _g1) {
			var i = _g++;
			var el = new h2d_Element();
			el.goto(null,"feather");
			var v = Std.random(32) - 16;
			el.posChanged = true;
			el.x = v;
			var v1 = Std.random(32) - 16;
			el.posChanged = true;
			el.y = v1;
			var mc = new h2d_Drawable(Game.me);
			Game.me.dm.add(mc,GameDepth.DP_FX);
			mc.addChild(el);
			var p = new fx_h2d_Part(mc);
			p.setPos(this.x,this.y);
			p.impulse(Math.random() * 6.28,Math.random() * 2);
			p.twist(30,0.97);
			p.weight = 0.05 + Math.random() * 0.04;
			p.fadeType = 1;
			p.life = 40 + Std.random(40);
			p.vx += b.vx * Math.random();
			p.vy += b.vy * Math.random();
		}
		this.plomb.x = b.vx;
		this.plomb.y = b.vy;
		b.vy *= -1;
		this.sens *= -1;
		this.posChanged = true;
		this.scaleX = this.sens;
		this.speed += 2;
		this.hit = true;
	}
	,__class__: Bird
});
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,__class__: EReg
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var Fx = function() {
	Fx.ALL.push(this);
	this.alive = true;
	this.coef = 0;
	this.spc = 0.1;
	this.timer = 0;
	this.step = 0;
	this.sleep = 0;
	this.curve = function(n) {
		return n;
	};
};
$hxClasses["Fx"] = Fx;
Fx.__name__ = "Fx";
Fx.updateAll = function() {
	Fx.t++;
	Fx.PLAYING = Fx.ALL.slice();
	while(Fx.PLAYING.length > 0) {
		var e = Fx.PLAYING.shift();
		e.update();
	}
	var e = Fx.DEATH_CONDITIONS.keys();
	while(e.hasNext()) {
		var e1 = e.next();
		var f = Fx.DEATH_CONDITIONS.h[e1.__id__];
		if(f()) {
			e1.kill();
			Fx.DEATH_CONDITIONS.remove(e1);
		}
	}
};
Fx.chain = function(all,onFinish) {
	if(all.length == 0) {
		if(onFinish != null) {
			onFinish();
		}
		return;
	}
	var next = (all.shift())();
	if(next == null) {
		Fx.chain(all,onFinish);
	} else {
		var all1 = all;
		var onFinish1 = onFinish;
		next.onFinish = function() {
			Fx.chain(all1,onFinish1);
		};
	}
};
Fx.prototype = {
	update: function() {
		if(this.sleep-- > 0) {
			return;
		}
		this.coef = Num.mm(0,this.coef + this.spc,1);
		this.timer++;
	}
	,nextStep: function(spc) {
		if(spc != null) {
			this.spc = spc;
		}
		this.step++;
		this.coef = 0;
		this.timer = 0;
	}
	,fastKill: function() {
		this.alive = false;
		if(this.solo) {
			this.endSolo();
		}
		HxOverrides.remove(Fx.ALL,this);
		HxOverrides.remove(Fx.SOLO_BACKUP,this);
		if(this.onFinish != null) {
			this.onFinish();
		}
	}
	,kill: function() {
		HxOverrides.remove(Fx.PLAYING,this);
		this.fastKill();
	}
	,curveInOut: function() {
		this.curve = function(c) {
			return 0.5 - Math.cos(Math.PI * c) * 0.5;
		};
	}
	,curveIn: function(c) {
		this.curve = function(n) {
			return Math.pow(n,c);
		};
	}
	,curveAcos: function(pow) {
		if(pow == null) {
			pow = 1;
		}
		this.curve = function(n) {
			var _g = 0;
			var _g1 = pow;
			while(_g < _g1) {
				var i = _g++;
				n = Math.acos(1 - 2 * n) / Math.PI;
			}
			if(n < 0) {
				n = 0;
			}
			if(n > 1) {
				n = 1;
			}
			return n;
		};
	}
	,curveCos: function(pow) {
		if(pow == null) {
			pow = 1;
		}
		this.curve = function(n) {
			var _g = 0;
			var _g1 = pow;
			while(_g < _g1) {
				var i = _g++;
				n = 0.5 - Math.cos(Math.PI * n) * 0.5;
			}
			return n;
		};
	}
	,reverse: function() {
		this.curve = function(n) {
			return 1 - n;
		};
	}
	,setSolo: function() {
		this.solo = true;
		Fx.SOLO_BACKUP = Fx.ALL;
		Fx.PLAYING = [];
		Fx.ALL = [this];
	}
	,endSolo: function() {
		this.solo = false;
		HxOverrides.remove(Fx.ALL,this);
		Fx.ALL = Fx.ALL.concat(Fx.SOLO_BACKUP);
	}
	,addFinishEvent: function(f) {
		if(this.onFinish == null) {
			this.onFinish = f;
			return;
		}
		var old = this.onFinish;
		this.onFinish = function() {
			old();
			f();
		};
	}
	,dieOn: function(f) {
		if(Fx.DEATH_CONDITIONS.h.__keys__[this.__id__] != null) {
			throw haxe_Exception.thrown("Already have death condition for " + Std.string(this));
		}
		Fx.DEATH_CONDITIONS.set(this,f);
	}
	,__class__: Fx
};
var Game = function(s2d) {
	h2d_Drawable.call(this,s2d);
	Game.me = this;
	this.posChanged = true;
	this.posChanged = true;
	this.scaleX = this.scaleY = 2;
	this.balls = [];
	this.malus = [];
	this.scoreFx = [];
	this.trash = [];
	this.birds = [];
	this.initFonts();
	this.initScene();
	this.wind = 0;
	if(Dev.MODE == -1) {
		new seq_Menu();
	} else {
		this.launchMode(Dev.MODE);
	}
};
$hxClasses["Game"] = Game;
Game.__name__ = "Game";
Game.__super__ = h2d_Drawable;
Game.prototype = $extend(h2d_Drawable.prototype,{
	initFonts: function() {
		this.nokiaFont = hxd_Res.get_loader().loadCache("fonts/nokiafc22.ttf",hxd_res_Font).build(8);
		this.upFont = hxd_Res.get_loader().loadCache("fonts/upheavtt.ttf",hxd_res_Font).build(8);
	}
	,initScene: function() {
		this.scene = new h2d_Drawable(this);
		this.dm = new h2d_DepthManager(this.scene,GameDepth);
		this.bg = new h2d_Element();
		this.bg.store = Main.sky;
		this.bg.goto(null,"sky");
		this.dm.add(this.bg,GameDepth.DP_BG);
		var ground = new h2d_Element();
		this.dm.add(ground,GameDepth.DP_GROUND);
		ground.goto(null,"ground");
		ground.posChanged = true;
		ground.y = Main.HEIGHT - 64;
		this.snowman = new Snowman();
		var _this = this.snowman;
		_this.posChanged = true;
		_this.x = Main.WIDTH * 0.5;
		var _this = this.snowman;
		_this.posChanged = true;
		_this.y = Main.HEIGHT - 24;
		this.dm.add(this.snowman,GameDepth.DP_SNOWMAN);
	}
	,makeBut: function(f) {
		this.sbut = new h2d_Interactive(Main.WIDTH,Main.HEIGHT,this);
		this.sbut.onClick = function(e) {
			if(f != null) {
				f();
			}
		};
	}
	,removeBut: function() {
		if(this.sbut == null) {
			return;
		}
		var _this = this.sbut;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		this.sbut = null;
	}
	,fxSnow: function(x,y) {
		if(y == null) {
			y = 0.0;
		}
		if(x == null) {
			x = 0.0;
		}
		var el = new h2d_Element();
		el.goto(Std.random(4),"part_snow");
		this.dm.add(el,GameDepth.DP_FX);
		var p = new fx_Part(el);
		p.weight = 0.1 + Math.random() * 0.1;
		p.life = 10 + Std.random(30);
		p.setPos(x,y);
		return p;
	}
	,fxSnowFall: function() {
		var el = new h2d_Element();
		el.goto(3,"part_snow");
		this.dm.add(el,GameDepth.DP_FX);
		new fx_Snow();
	}
	,giveBall: function(i) {
		var ball = new Ball();
		var h = this.snowman.hands[i];
		ball.setPos(Main.WIDTH * 0.5 + (Main.WIDTH * 0.5 + 16) * (i * 2 - 1),this.snowman.y + h.y);
		new fx_GotoHand(ball,h,false);
		Main.playSound("new_ball");
	}
	,displayText: function(str,next) {
		var _gthis = this;
		Main.playSound("dialog",null,0.6);
		var pan = new h2d_Element();
		pan.goto(null,"dialog_box");
		this.addChild(pan);
		var ww = 224;
		var hh = 64;
		var tx = Main.WIDTH >> 1;
		pan.posChanged = true;
		pan.x = tx - 16;
		pan.posChanged = true;
		pan.y = 32;
		pan.alpha = 0;
		var e = new fx_Move(pan,tx,pan.y);
		e.curveIn(0.5);
		var e = new fx_Alpha(pan,1);
		e.curveIn(0.5);
		var ma = 4;
		var f = Tools.getField(16777215,this.nokiaFont,8);
		f.set_textAlign(h2d_Align.MultilineCenter);
		pan.addChild(f);
		f.set_lineBreak(true);
		f.posChanged = true;
		f.posChanged = true;
		f.x = f.y = ma;
		f.set_maxWidth(120);
		f.set_text(str);
		var v = (-f.get_textWidth() | 0) >> 1;
		f.posChanged = true;
		f.x = v;
		var v = (hh - f.get_textHeight() - 2 | 0) >> 1;
		f.posChanged = true;
		f.y = v;
		f.dropShadow = { dy : 2, dx : 1, color : 0, alpha : 0.9};
		var pass = function() {
			_gthis.removeBut();
			var e = new fx_Move(pan,tx + 32,pan.y);
			e.curveIn(2);
			var e = new fx_Alpha(pan,0);
			e.curveIn(2);
			e.onFinish = function() {
				if(pan != null && pan.parent != null) {
					pan.parent.removeChild(pan);
				}
				next();
			};
		};
		this.makeBut(pass);
		this.snowman.head.emote(5,3,40);
	}
	,setScore: function(n) {
		this.scoring = true;
		this.score = n;
		this.fxScoreMark();
	}
	,incScore: function(n) {
		if(n == null) {
			n = 1;
		}
		if(!this.scoring) {
			return;
		}
		this.score += n;
		this.fxScoreMark();
	}
	,fxScoreMark: function(erase) {
		if(erase == null) {
			erase = false;
		}
		if(this.scoreMark != null) {
			var mc = this.scoreMark;
			this.scoreMark = null;
			var e = new fx_Move(mc,mc.x,mc.y - 16);
			this.scoreFx.push(e);
			var e = new fx_Alpha(mc,0);
			this.scoreFx.push(e);
			e.onFinish = function() {
				mc.parent.removeChild(mc);
			};
		}
		if(erase) {
			return;
		}
		this.scoreMark = new h2d_Drawable(this);
		var _this = this.scoreMark;
		_this.posChanged = true;
		_this.x = Main.WIDTH >> 1;
		var _this = this.scoreMark;
		_this.posChanged = true;
		_this.y = 60;
		this.scoreMark.alpha = 0;
		var _this = this.scoreMark;
		var _this1 = this.scoreMark;
		_this1.posChanged = true;
		_this.posChanged = true;
		_this.scaleX = _this1.scaleY = 4;
		this.dm.add(this.scoreMark,GameDepth.DP_BG);
		if(this.score > 0) {
			var color = 3942549;
			if(this.score == this.contract) {
				color = 16777215;
			}
			var f = Tools.getField(color,this.nokiaFont,20);
			f.set_text(this.score + "");
			var v = -f.get_textWidth() * 0.5;
			f.posChanged = true;
			f.x = v;
			var v = -f.get_textHeight() * 0.5;
			f.posChanged = true;
			f.y = v;
			f.posChanged = true;
			f.posChanged = true;
			f.scaleX = f.scaleY = 1.5;
			this.scoreMark.addChild(f);
		}
		var e = new fx_Move(this.scoreMark,this.scoreMark.x,this.scoreMark.y - 16);
		this.scoreFx.push(e);
		var e = new fx_Alpha(this.scoreMark,1);
		this.scoreFx.push(e);
		var _g = 0;
		var _g1 = this.scoreFx.slice();
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(!e.alive) {
				HxOverrides.remove(this.scoreFx,e);
			}
		}
	}
	,setLife: function(n) {
		this.life = n;
		this.damage = 0;
		this.majLife();
	}
	,majLife: function() {
		if(this.lifebar != null) {
			var _this = this.lifebar;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.lifebar = new h2d_Drawable(this);
		var ma = 7;
		var _g = 0;
		var _g1 = this.life;
		while(_g < _g1) {
			var i = _g++;
			var el = new h2d_Element();
			el.posChanged = true;
			el.x = ma;
			el.posChanged = true;
			el.y = ma + 12 * i;
			el.goto(this.damage > i ? 1 : 0,"extra_ball");
			this.lifebar.addChild(el);
		}
	}
	,hit: function() {
		this.damage++;
		this.majLife();
	}
	,majMalus: function() {
		if(this.malusbar != null) {
			var _this = this.malusbar;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.malusbar = new h2d_Drawable(this);
		var _this = this.malusbar;
		_this.posChanged = true;
		_this.x = Main.WIDTH * 0.5;
		var _this = this.malusbar;
		_this.posChanged = true;
		_this.y = Main.HEIGHT - 9;
		var size = 16;
		var ec = 1;
		var tot = this.malus.length * size - (this.malus.length - 1) * ec;
		var ma = -(tot * 0.5 | 0);
		var n = 0;
		var _g = 0;
		var _g1 = this.malus;
		while(_g < _g1.length) {
			var mid = _g1[_g];
			++_g;
			var el = new h2d_Element();
			el.goto(mid._hx_index,"tiny_malus");
			el.posChanged = true;
			el.x = 8 + ma + n * (size + ec);
			this.malusbar.addChild(el);
			++n;
		}
	}
	,play: function() {
		this.snowman.lookMode = 1;
		this.snowman.controlable = true;
		this.makeBut(($_=this.snowman,$bind($_,$_.pass)));
	}
	,stop: function() {
		this.snowman.lookMode = 3;
		this.snowman.controlable = false;
		this.removeBut();
	}
	,launchMode: function(m) {
		this.mode = m;
		this.snowman.ingame = true;
		this.loop = new fx_Call($bind(this,this.update));
		switch(this.mode) {
		case 0:
			this.snowman.controlable = false;
			var e = new seq_Tuto();
			e.onFinish = $bind(this,this.reset);
			break;
		case 1:
			this.level = 0;
			this.malus = [];
			if(Dev.TEST_MALUS != null) {
				this.malus.push(Dev.TEST_MALUS);
			}
			Game.me.setScore(0);
			Game.me.setLife(Gameplay.LIFE_CHALLENGER);
			if(Main.profile.hiscoreChallenge > 0) {
				this.displayBestScore("best score: level " + Main.profile.hiscoreChallenge);
			}
			this.nextLevel();
			break;
		case 2:
			if(Main.profile.hiscoreSurvival > 1) {
				this.displayBestScore("best score: " + Main.profile.hiscoreSurvival + " balls");
			}
			if(Main.profile.hiscoreSurvival < 5) {
				var a = [TutotAction.TXT("This is the SURVIVAL mode"),TutotAction.TXT("Just try to juggle for the longest run !"),TutotAction.TXT("The accuracy of the throws will degrade throught time..."),TutotAction.TXT("... So never let your guard down !")];
				var e = new seq_Tuto(a);
				e.onFinish = $bind(this,this.startSurvival);
			} else {
				this.startSurvival();
			}
			break;
		}
	}
	,startChallenge: function() {
		this.birds = [];
		this.play();
		new fx_Call($bind(this,this.runChallenge));
	}
	,runChallenge: function(e) {
		var drunk = Game.me.numHave(Malus.WINE);
		if(drunk > 0 && 40 * Math.random() / drunk < 1) {
			new fx_Drunk();
		}
		var bdif = this.numHave(Malus.BIRD) - this.birds.length;
		if(Std.random(100) < bdif * 10) {
			new Bird();
		}
		var _g = 0;
		var _g1 = this.birds;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.update();
		}
		if(this.score >= this.contract) {
			this.snowman.head.emote(2,2,40);
			Main.playSound("tuto_success",1);
			this.stop();
			e.kill();
			var e1 = new fx_Wait(20,$bind(this,this.endLevel));
			e1.setSolo();
			e1.onFinish = $bind(this,this.endLevel);
			var _g = 0;
			var _g1 = Game.me.scoreFx;
			while(_g < _g1.length) {
				var e1 = _g1[_g];
				++_g;
				if(!e1.alive) {
					continue;
				}
				HxOverrides.remove(Fx.SOLO_BACKUP,e1);
				Fx.ALL.push(e1);
			}
			return;
		}
		this.checkRefill(e);
	}
	,checkBestScore: function() {
		var levelDone = this.level + 1;
		if(levelDone > Main.profile.hiscoreChallenge) {
			this.displayBestScore("best score: level " + levelDone);
		}
	}
	,endLevel: function() {
		var _g = 0;
		var _g1 = this.birds.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.vanish();
		}
		this.vanishBalls();
		var _g = this;
		var erase = true;
		new fx_Wait(20,function() {
			_g.fxScoreMark(erase);
		});
		new fx_Wait(40,$bind(this,this.startMalus));
	}
	,nextLevel: function() {
		this.contract = Gameplay.CHALLENGE_GOAL + this.numHave(Malus.EXTRA_FIVE) * 5;
		this.ballMax = 3 + this.numHave(Malus.EXTRA_BALL);
		this.setScore(0);
		var _g = this;
		var next = $bind(this,this.startChallenge);
		var next1 = function() {
			_g.fillBall(next);
		};
		if(Main.profile.level == 1 && this.level == 3) {
			var _g1 = this;
			var str = "You have unlocked the SURVIVAL mode !";
			var _g2 = this;
			var next2 = $bind(this,this.startChallenge);
			var next3 = function() {
				_g2.fillBall(next2);
			};
			next1 = function() {
				_g1.displayText(str,next3);
			};
			Main.profile.level++;
			Main.saveProfile();
		}
		this.displayText("lvl " + (this.level + 1) + " : make " + this.contract + " juggles !",next1);
	}
	,vanishBalls: function() {
		var _g = 0;
		var _g1 = this.balls.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var pos = b.getScenePos();
			var el = new h2d_Element();
			el.play("shockwave");
			this.dm.add(el,GameDepth.DP_FX);
			el.posChanged = true;
			el.x = pos.x;
			el.posChanged = true;
			el.y = pos.y;
			el.anim.onFinish = $bind(el,el.kill);
			var max = 8;
			var _g2 = 0;
			var _g3 = max;
			while(_g2 < _g3) {
				var i = _g2++;
				var an = i * 6.28 / max;
				var p = this.fxSnow(pos.x,pos.y);
				p.impulse(an,0.5 + Math.random() * 1.5);
			}
			b.kill();
		}
		var _g = 0;
		var _g1 = this.snowman.hands;
		while(_g < _g1.length) {
			var h = _g1[_g];
			++_g;
			h.balls = [];
		}
	}
	,startMalus: function() {
		var _gthis = this;
		var a = [];
		var _g = 0;
		var _g1 = Malus.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var id = _g1[_g];
			++_g;
			a.push(id);
			a.push(id);
		}
		var _g = 0;
		var _g1 = this.malus;
		while(_g < _g1.length) {
			var id = _g1[_g];
			++_g;
			HxOverrides.remove(a,id);
		}
		var buts = [];
		var rover = function(el,mid) {
			_gthis.displayHint(mid);
			Main.playSound("over");
			el.alpha = 1.0;
			_gthis.snowman.lookMode = -1;
			_gthis.snowman.head.trg.x = (el.x / Main.WIDTH * 2 - 1) * 0.5;
			_gthis.snowman.head.trg.y = (el.y / Main.HEIGHT * 2 - 1) * 0.5;
		};
		var rout = function(el) {
			_gthis.removeHint();
			el.alpha = 0.5;
			_gthis.snowman.lookMode = 3;
		};
		var select = function(el,mid) {
			rout(el);
			Main.playSound("select",1);
			var sens = -1;
			var _g = 0;
			while(_g < buts.length) {
				var b = [buts[_g]];
				++_g;
				b[0].removeButton();
				if(b[0] != el) {
					var e = new fx_Move(b[0],b[0].x + sens * 128,b[0].y);
					e.curveIn(2);
					e.onFinish = ($_=b[0],$bind($_,$_.kill));
				} else {
					var e1 = new fx_Move(b[0],(Main.WIDTH - 64) * 0.5,b[0].y);
					e1.curveCos();
					e1.onFinish = (function(b) {
						return function() {
							var e = new fx_h2d_Blink(b[0],32);
							e.onFinish = (function(b) {
								return function() {
									_gthis.malus.push(mid);
									_gthis.majMalus();
									b[0].kill();
									_gthis.level++;
									_gthis.checkBestScore();
									_gthis.nextLevel();
									_gthis.life++;
									_gthis.majLife();
								};
							})(b);
						};
					})(b);
				}
				sens *= -1;
			}
		};
		var ma = (Main.WIDTH - 128) / 3 | 0;
		var mid = h2d_MAll.rand(a);
		var tmp = mid == null;
		if(Dev.TEST_MALUS != null) {
			mid = Dev.TEST_MALUS;
		}
		while(HxOverrides.remove(a,mid)) {
		}
		var el = new h2d_Element();
		el.goto(mid._hx_index,"malus");
		this.addChild(el);
		var ty = 36;
		el.posChanged = true;
		el.x = ma + 0 * (64 + ma);
		el.posChanged = true;
		el.y = ty + 16;
		el.alpha = 0;
		var e = new fx_Move(el,el.x,ty);
		e.curveCos();
		var e = new fx_Alpha(el,0.5);
		e.onFinish = function() {
			var el1 = el;
			var mid1 = mid;
			var tmp = function() {
				select(el1,mid1);
			};
			var el2 = el;
			var mid2 = mid;
			var tmp1 = function() {
				rover(el2,mid2);
			};
			var el3 = el;
			var tmp2 = function() {
				rout(el3);
			};
			el.makeButton(tmp,tmp1,tmp2);
			buts.push(el);
		};
		var mid1 = h2d_MAll.rand(a);
		var tmp = mid1 == null;
		if(Dev.TEST_MALUS != null && false) {
			mid1 = Dev.TEST_MALUS;
		}
		while(HxOverrides.remove(a,mid1)) {
		}
		var el1 = new h2d_Element();
		el1.goto(mid1._hx_index,"malus");
		this.addChild(el1);
		var ty = 36;
		el1.posChanged = true;
		el1.x = ma + (64 + ma);
		el1.posChanged = true;
		el1.y = ty + 16;
		el1.alpha = 0;
		var e = new fx_Move(el1,el1.x,ty);
		e.curveCos();
		var e = new fx_Alpha(el1,0.5);
		e.onFinish = function() {
			var el = el1;
			var mid = mid1;
			var tmp = function() {
				select(el,mid);
			};
			var el2 = el1;
			var mid2 = mid1;
			var tmp1 = function() {
				rover(el2,mid2);
			};
			var el3 = el1;
			var tmp2 = function() {
				rout(el3);
			};
			el1.makeButton(tmp,tmp1,tmp2);
			buts.push(el1);
		};
	}
	,startSurvival: function() {
		var _gthis = this;
		this.ballMax = 3;
		this.setScore(0);
		this.setLife(3);
		var go = function() {
			_gthis.play();
			new fx_Call($bind(_gthis,_gthis.runSurvival));
		};
		this.fillBall(go);
	}
	,runSurvival: function(e) {
		this.checkRefill(e);
	}
	,numHave: function(mid) {
		var n = 0;
		var _g = 0;
		var _g1 = this.malus;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m == mid) {
				++n;
			}
		}
		return n;
	}
	,fillBall: function(next) {
		if(this.balls.length < this.ballMax) {
			var ball = new Ball();
			this.snowman.initBall(ball);
			Main.playSound("new_ball");
			var _g = this;
			var next1 = next;
			new fx_Wait(5,function() {
				_g.fillBall(next1);
			});
		} else {
			next();
		}
	}
	,checkRefill: function(e) {
		if(this.balls.length < this.ballMax) {
			if(this.life - this.damage == 0) {
				var _g = 0;
				var _g1 = this.birds.slice();
				while(_g < _g1.length) {
					var b = _g1[_g];
					++_g;
					b.vanish();
				}
				this.vanishBalls();
				new seq_Gameover();
				e.kill();
				this.stop();
				return;
			}
			this.giveBall(0);
			this.hit();
		}
	}
	,update: function(e) {
		this.snowman.update();
		var _g = 0;
		var _g1 = this.balls;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.update();
		}
		var _g = 0;
		var _g1 = 1 + this.numHave(Malus.SNOW);
		while(_g < _g1) {
			var i = _g++;
			if(Std.random(32) == 0) {
				new fx_Snow();
			}
		}
		var co = this.numHave(Malus.WIND) * 0.25;
		this.wind += (Math.random() * 2 - 1) * co;
		this.wind *= 0.95;
	}
	,reset: function() {
		var _gthis = this;
		var leave = function() {
			_gthis.kill();
			new Game(Main.me.s2d);
			new fx_h2d_Flash(Game.me,16777215);
		};
		var fade = new fx_h2d_Fade(this,16777215);
		fade.onFinish = leave;
	}
	,kill: function() {
		if(this.loop != null) {
			this.loop.kill();
			this.loop = null;
		}
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,drop: function(el) {
		this.trash.push(el);
		while(this.trash.length > 16) {
			var el = this.trash.shift();
			var e = new fx_Alpha(el,0,0.01);
			e.onFinish = $bind(el,el.kill);
		}
	}
	,displayHint: function(mid) {
		this.removeHint();
		this.malusHint = new h2d_Drawable(this);
		this.dm.add(this.malusHint,GameDepth.DP_FX);
		var _this = this.malusHint;
		_this.posChanged = true;
		_this.x = Main.WIDTH * 0.5;
		var _this = this.malusHint;
		_this.posChanged = true;
		_this.y = 132;
		var f = Tools.getField(16777215,this.nokiaFont,20);
		f.set_textAlign(h2d_Align.MultilineCenter);
		f.set_text(["heavy balls","arms shrinker","slow moves","strong wind","more ball","cheap wine","goal +5","silly bird"][mid._hx_index]);
		var v = -(f.get_textWidth() | 0) + 6;
		f.posChanged = true;
		f.x = v;
		var v = -(f.get_textHeight() | 0) + 10;
		f.posChanged = true;
		f.y = v;
		f.posChanged = true;
		f.posChanged = true;
		f.scaleX = f.scaleY = 1.5;
		this.malusHint.addChild(f);
		this.malusHint.alpha = 0;
		var e = new fx_Move(this.malusHint,this.malusHint.x,this.malusHint.y - 16);
		var e = new fx_Alpha(this.malusHint,1);
	}
	,removeHint: function() {
		if(this.malusHint == null) {
			return;
		}
		var e = new fx_Move(this.malusHint,this.malusHint.x,this.malusHint.y + 16);
		var ee = new fx_Alpha(this.malusHint,0);
		this.malusHint = null;
	}
	,displayBestScore: function(txt) {
		this.removeBestScore();
		this.bestScore = new h2d_Drawable(this);
		this.dm.add(this.bestScore,GameDepth.DP_FX);
		var _this = this.bestScore;
		_this.posChanged = true;
		_this.x = Main.WIDTH - 5;
		var _this = this.bestScore;
		_this.posChanged = true;
		_this.y = 3;
		var f = Tools.getField(15395562,this.nokiaFont);
		f.set_textAlign(h2d_Align.Right);
		f.set_text(txt);
		f.set_maxWidth(Main.WIDTH * 0.5);
		var v = -(f.get_textWidth() | 0) - 25;
		f.posChanged = true;
		f.x = v;
		f.posChanged = true;
		f.posChanged = true;
		f.scaleX = f.scaleY = 0.9;
		this.bestScore.addChild(f);
		this.bestScore.alpha = 0;
		var e = new fx_Alpha(this.bestScore,1);
	}
	,removeBestScore: function() {
		if(this.bestScore == null) {
			return;
		}
		var _this = this.bestScore;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		this.bestScore = null;
	}
	,__class__: Game
});
var Hand = function() {
	h2d_Drawable.call(this,Game.me.snowman);
	this.sm = Game.me.snowman;
	var el = new h2d_Element();
	el.goto(null,"hand");
	el.posChanged = true;
	el.y = -7;
	this.addChild(el);
	this.balls = [];
	this.max = 1;
	this.vx = this.vy = 0;
};
$hxClasses["Hand"] = Hand;
Hand.__name__ = "Hand";
Hand.__super__ = h2d_Drawable;
Hand.prototype = $extend(h2d_Drawable.prototype,{
	majBalls: function() {
		var n = 0;
		var _g = 0;
		var _g1 = this.balls;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var _this = b.skin;
			_this.posChanged = true;
			_this.x = this.x;
			var _this1 = b.skin;
			_this1.posChanged = true;
			_this1.y = this.y - n - 9;
			n += 8;
		}
		if(this.hint != null) {
			var _this = this.hint;
			_this.posChanged = true;
			_this.x = this.x + this.sm.x;
			var _this = this.hint;
			_this.posChanged = true;
			_this.y = this.y + this.sm.y - 32;
			this.hint.set_visible(this.balls.length > 0 || this.hintAlwaysVisible);
		}
	}
	,isFree: function() {
		return this.balls.length < this.max;
	}
	,grab: function(b,check) {
		if(check && this.balls.length >= this.max) {
			b.pop();
			return;
		}
		this.sm.arms.addChild(b.skin);
		this.balls.push(b);
		b.hand = true;
		b.x = b.y = b.vx = b.vy = 0;
		this.majBalls();
	}
	,setHint: function(str,alwaysVisible) {
		if(alwaysVisible == null) {
			alwaysVisible = false;
		}
		this.hintAlwaysVisible = alwaysVisible;
		this.hint = new h2d_Element();
		this.hint.play(str);
		Game.me.dm.add(this.hint,GameDepth.DP_BG);
	}
	,removeHint: function() {
		if(this.hint == null) {
			return;
		}
		this.hint.anim.stop();
		this.hint.kill();
		this.hint = null;
	}
	,__class__: Hand
});
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
HxOverrides.strDate = function(s) {
	switch(s.length) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k = s.split("-");
		return new Date(k[0],k[1] - 1,k[2],0,0,0);
	case 19:
		var k = s.split(" ");
		var y = k[0].split("-");
		var t = k[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw haxe_Exception.thrown("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.indexOf = function(it,v) {
	var i = 0;
	var v2 = $getIterator(it);
	while(v2.hasNext()) {
		var v21 = v2.next();
		if(v == v21) {
			return i;
		}
		++i;
	}
	return -1;
};
var Col = function() { };
$hxClasses["Col"] = Col;
Col.__name__ = "Col";
Col.colToObj = function(col) {
	return { r : col >> 16 & 255, g : col >> 8 & 255, b : col & 255};
};
Col.objToCol = function(o,r,g,b) {
	if(o == null) {
		return r << 16 | g << 8 | b;
	}
	return o.r << 16 | o.g << 8 | o.b;
};
Col.colToObj32 = function(col) {
	return { a : col >>> 24, r : col >> 16 & 255, g : col >> 8 & 255, b : col & 255};
};
Col.objToCol32 = function(o) {
	return o.a << 24 | o.r << 16 | o.g << 8 | o.b;
};
Col.getWeb = function(col) {
	return "#" + StringTools.hex(col);
};
var Arr = function() { };
$hxClasses["Arr"] = Arr;
Arr.__name__ = "Arr";
Arr.shuffle = function(a,f) {
	if(f == null) {
		f = Std.random;
	}
	var b = [];
	while(a.length > 0) b.push(a.pop());
	while(b.length > 0) {
		var pos = f(a.length + 1);
		var x = b.pop();
		a.splice(pos,0,x);
	}
};
var Tween = function(sx,sy,ex,ey) {
	this.sx = sx;
	this.sy = sy;
	this.ex = ex;
	this.ey = ey;
	this.coef = 0;
};
$hxClasses["Tween"] = Tween;
Tween.__name__ = "Tween";
Tween.prototype = {
	getPos: function(c) {
		if(c == null) {
			c = this.coef;
		}
		return { x : this.sx + (this.ex - this.sx) * c, y : this.sy + (this.ey - this.sy) * c};
	}
	,getVelocity: function(c) {
		return { vx : (this.ex - this.sx) * c, vy : (this.ey - this.sy) * c};
	}
	,getDist: function() {
		var dx = this.ex - this.sx;
		var dy = this.ey - this.sy;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,getAngle: function() {
		var dx = this.ex - this.sx;
		var dy = this.ey - this.sy;
		return Math.atan2(dy,dx);
	}
	,getModPos: function(c,mx,my) {
		var dx = Num.hMod(this.ex - this.sx,mx * 0.5);
		var dy = Num.hMod(this.ey - this.sy,my * 0.5);
		return { x : Num.sMod(this.sx + dx * c,mx), y : Num.sMod(this.sy + dy * c,my)};
	}
	,__class__: Tween
};
var En = function() { };
$hxClasses["En"] = En;
En.__name__ = "En";
En.get = function(e,id) {
	var _this = e.__constructs__;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = _this[i]._hx_name;
	}
	var a = result;
	return Type.createEnum(e,a[id]);
};
En.next = function(e) {
	return En.dec(e,1);
};
En.prev = function(e) {
	return En.dec(e,-1);
};
En.dec = function(e,inc) {
	var index = e._hx_index + inc;
	var en = Type.getEnum(e);
	var _this = en.__constructs__;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = _this[i]._hx_name;
	}
	var a = result;
	var n = a.length;
	while(index >= n) index -= n;
	while(index < 0) index += n;
	return Type.createEnum(en,a[index]);
};
var Num = function() { };
$hxClasses["Num"] = Num;
Num.__name__ = "Num";
Num.mm = function(a,b,c) {
	return Math.min(Math.max(a,b),c);
};
Num.clamp = function(a,b,c) {
	if(b < a) {
		return a;
	}
	if(b > c) {
		return c;
	}
	return b;
};
Num.sMod = function(n,mod) {
	if(mod == 0) {
		haxe_Log.trace("sMod ERROR! (" + n + "," + mod + ")",{ fileName : "../lib/Lib.hx", lineNumber : 154, className : "Num", methodName : "sMod"});
		return n;
	}
	while(n >= mod) n -= mod;
	while(n < 0) n += mod;
	return n;
};
Num.hMod = function(n,mod) {
	while(n > mod) n -= mod * 2;
	while(n < -mod) n += mod * 2;
	return n;
};
Num.angleAverage = function(angles) {
	var work = angles.slice();
	var an = 0.0;
	var div = 1;
	while(work.length > 0) {
		var ta = work.pop();
		var da = Num.hMod(ta - an,3.14);
		an += da / div;
		++div;
	}
	return an;
};
var Tools = function() { };
$hxClasses["Tools"] = Tools;
Tools.__name__ = "Tools";
Tools.getField = function(color,font,size) {
	if(size == null) {
		size = 8;
	}
	var f = new h2d_Text(font != null ? font : hxd_res_DefaultFont.get());
	f.set_textAlign(h2d_Align.Left);
	f.set_textColor(color);
	f.set_maxWidth(20);
	f.set_lineSpacing(1);
	return f;
};
Tools.bresenham = function(x0,y0,x1,y1) {
	var a = [];
	var error;
	var dx = x1 - x0;
	var dy = y1 - y0;
	var yi = 1;
	if(dx < dy) {
		x0 ^= x1;
		x1 ^= x0;
		x0 ^= x1;
		y0 ^= y1;
		y1 ^= y0;
		y0 ^= y1;
	}
	if(dx < 0) {
		dx = -dx;
		yi = -yi;
	}
	if(dy < 0) {
		dy = -dy;
		yi = -yi;
	}
	if(dy > dx) {
		error = -(dy >> 1);
		while(y1 <= y0) {
			a.push({ x : x1, y : y1});
			error += dx;
			if(error > 0) {
				x1 += yi;
				error -= dy;
			}
			++y1;
		}
	} else {
		error = -(dx >> 1);
		while(x0 <= x1) {
			a.push({ x : x0, y : y0});
			error += dy;
			if(error > 0) {
				y0 += yi;
				error -= dx;
			}
			++x0;
		}
	}
	return a;
};
Tools.bresenhamFull = function(x1,y1,x2,y2) {
	var a = [];
	var ystep;
	var xstep;
	var error;
	var errorprev;
	var y = y1;
	var x = x1;
	var dx = x2 - x1;
	var dy = y2 - y1;
	a.push({ x : x1, y : y1});
	if(dy < 0) {
		ystep = -1;
		dy = -dy;
	} else {
		ystep = 1;
	}
	if(dx < 0) {
		xstep = -1;
		dx = -dx;
	} else {
		xstep = 1;
	}
	var ddy = 2 * dy;
	var ddx = 2 * dx;
	if(ddx >= ddy) {
		error = dx;
		errorprev = error;
		var _g = 0;
		var _g1 = dx;
		while(_g < _g1) {
			var i = _g++;
			x += xstep;
			error += ddy;
			if(error > ddx) {
				y += ystep;
				error -= ddx;
				if(error + errorprev <= ddx) {
					a.push({ x : x, y : y - ystep});
				}
				if(error + errorprev >= ddx) {
					a.push({ x : x - xstep, y : y});
				}
			}
			a.push({ x : x, y : y});
			errorprev = error;
		}
	} else {
		error = dy;
		errorprev = error;
		var _g = 0;
		var _g1 = dy;
		while(_g < _g1) {
			var i = _g++;
			y += ystep;
			error += ddx;
			if(error > ddy) {
				x += xstep;
				error -= ddy;
				if(error + errorprev <= ddx) {
					a.push({ x : x - xstep, y : y});
				}
				if(error + errorprev >= ddx) {
					a.push({ x : x, y : y - ystep});
				}
			}
			a.push({ x : x, y : y});
			errorprev = error;
		}
	}
	return a;
};
var Cons = function() { };
$hxClasses["Cons"] = Cons;
Cons.__name__ = "Cons";
var h3d_IDrawable = function() { };
$hxClasses["h3d.IDrawable"] = h3d_IDrawable;
h3d_IDrawable.__name__ = "h3d.IDrawable";
h3d_IDrawable.__isInterface__ = true;
h3d_IDrawable.prototype = {
	__class__: h3d_IDrawable
};
var hxd_App = function() {
	var _gthis = this;
	var engine = h3d_Engine.CURRENT;
	if(engine != null) {
		this.engine = engine;
		engine.onReady = $bind(this,this.setup);
		haxe_Timer.delay($bind(this,this.setup),0);
	} else {
		hxd_System.start(function() {
			engine = new h3d_Engine();
			_gthis.engine = engine;
			engine.onReady = $bind(_gthis,_gthis.setup);
			engine.init();
		});
	}
};
$hxClasses["hxd.App"] = hxd_App;
hxd_App.__name__ = "hxd.App";
hxd_App.__interfaces__ = [h3d_IDrawable];
hxd_App.staticHandler = function() {
};
hxd_App.prototype = {
	onResize: function() {
	}
	,setScene: function(scene,disposePrevious) {
		if(disposePrevious == null) {
			disposePrevious = true;
		}
		var new2D = ((scene) instanceof h2d_Scene) ? scene : null;
		var new3D = ((scene) instanceof h3d_scene_Scene) ? scene : null;
		if(new2D != null) {
			this.sevents.removeScene(this.s2d);
			this.sevents.addScene(scene,0);
		} else {
			if(new3D != null) {
				this.sevents.removeScene(this.s3d);
			}
			this.sevents.addScene(scene);
		}
		if(disposePrevious) {
			if(new2D != null) {
				this.s2d.dispose();
			} else if(new3D != null) {
				this.s3d.dispose();
			} else {
				throw haxe_Exception.thrown("Can't dispose previous scene");
			}
		}
		if(new2D != null) {
			this.s2d = new2D;
		}
		if(new3D != null) {
			this.s3d = new3D;
		}
	}
	,setCurrent: function() {
		var _gthis = this;
		this.engine = h3d_Engine.CURRENT;
		this.isDisposed = false;
		this.engine.onReady = hxd_App.staticHandler;
		this.engine.onContextLost = $bind(this,this.onContextLost);
		this.engine.onResized = function() {
			if(_gthis.s2d == null) {
				return;
			}
			_gthis.s2d.checkResize();
			_gthis.onResize();
		};
		hxd_System.setLoop($bind(this,this.mainLoop));
	}
	,onContextLost: function() {
		if(this.s3d != null) {
			this.s3d.onContextLost();
		}
	}
	,setScene2D: function(s2d,disposePrevious) {
		if(disposePrevious == null) {
			disposePrevious = true;
		}
		this.sevents.removeScene(this.s2d);
		this.sevents.addScene(s2d,0);
		if(disposePrevious) {
			this.s2d.dispose();
		}
		this.s2d = s2d;
	}
	,setScene3D: function(s3d,disposePrevious) {
		if(disposePrevious == null) {
			disposePrevious = true;
		}
		this.sevents.removeScene(this.s3d);
		this.sevents.addScene(s3d);
		if(disposePrevious) {
			this.s3d.dispose();
		}
		this.s3d = s3d;
	}
	,render: function(e) {
		this.s3d.render(e);
		this.s2d.render(e);
	}
	,setup: function() {
		var _gthis = this;
		var initDone = false;
		this.engine.onReady = hxd_App.staticHandler;
		this.engine.onContextLost = $bind(this,this.onContextLost);
		this.engine.onResized = function() {
			if(_gthis.s2d == null) {
				return;
			}
			_gthis.s2d.checkResize();
			if(initDone) {
				_gthis.onResize();
			}
		};
		this.s3d = new h3d_scene_Scene();
		this.s2d = new h2d_Scene();
		this.sevents = new hxd_SceneEvents();
		this.sevents.addScene(this.s2d);
		this.sevents.addScene(this.s3d);
		this.loadAssets(function() {
			initDone = true;
			_gthis.init();
			hxd_Timer.skip();
			_gthis.mainLoop();
			hxd_System.setLoop($bind(_gthis,_gthis.mainLoop));
			hxd_Key.initialize();
		});
	}
	,dispose: function() {
		this.engine.onResized = hxd_App.staticHandler;
		this.engine.onContextLost = hxd_App.staticHandler;
		this.isDisposed = true;
		if(this.s2d != null) {
			this.s2d.dispose();
		}
		if(this.s3d != null) {
			this.s3d.dispose();
		}
		if(this.sevents != null) {
			this.sevents.dispose();
		}
	}
	,loadAssets: function(onLoaded) {
		onLoaded();
	}
	,init: function() {
	}
	,mainLoop: function() {
		hxd_Timer.update();
		this.sevents.checkEvents();
		if(this.isDisposed) {
			return;
		}
		this.update(hxd_Timer.dt);
		if(this.isDisposed) {
			return;
		}
		var dt = hxd_Timer.dt;
		if(this.s2d != null) {
			this.s2d.setElapsedTime(dt);
		}
		if(this.s3d != null) {
			this.s3d.setElapsedTime(dt);
		}
		this.engine.render(this);
	}
	,update: function(dt) {
	}
	,__class__: hxd_App
};
var Main = function() {
	hxd_App.call(this);
};
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
Main.main = function() {
	new Main();
};
Main.getMouse = function() {
	return { x : hxd_Window.getInstance().get_mouseX() / 2, y : hxd_Window.getInstance().get_mouseY() / 2};
};
Main.initTiles = function() {
	Main.gfx = new h2d_Store();
	Main.gfx.setImg(hxd_Res.get_loader().loadCache("gfx.png",hxd_res_Image),null,-1);
	Main.gfx.slice("snowman_head",h2d_TileCenter.Center,0,0,32,32);
	Main.gfx.slice("snowman_torso",h2d_TileCenter.Center,0,32,32,32);
	Main.gfx.slice("snowman_body",h2d_TileCenter.Center,0,64,48,48);
	Main.gfx.slice("ball",h2d_TileCenter.Center,32,0,16,16,2);
	Main.gfx.slice("hand",h2d_TileCenter.Center,32,16,16,16,1,1,true);
	Main.gfx.slice("ground",null,0,192,256,64);
	Main.gfx.slice("part_snow",null,64,0,8,8,2,2);
	Main.gfx.setAlign(0.0,0.5);
	Main.gfx.slice("snowman_arms",null,48,16,28,8,1,4);
	Main.gfx.setAlign(0.0,0.0);
	Main.gfx.slice("gradient_sky",null,64,64,64,64);
	Main.gfx.slice("menu_bg",null,0,256,256,256);
	Main.gfx.slice("menu_buts",h2d_TileCenter.Center,128,0,96,32,1,6);
	Main.gfx.slice("dialog_box",h2d_TileCenter.XCenter,0,128,128,64);
	Main.gfx.slice("hint_control",null,80,0,16,16,2,3);
	Main.gfx.addAnim("mouse_move",[0,1],[8]);
	Main.gfx.addAnim("mouse_clic",[2,3],[8]);
	Main.gfx.addAnim("spacebar",[4,5],[8]);
	Main.gfx.slice("malus",null,256,0,64,64,3,3);
	Main.gfx.slice("tiny_malus",h2d_TileCenter.Center,464,0,16,16,3,3);
	Main.gfx.slice("extra_ball",h2d_TileCenter.Center,32,32,11,11,1,2);
	Main.gfx.slice("spark_blue",h2d_TileCenter.Center,32,56,3,3,2,2);
	Main.gfx.addAnim("spark_blue",[0,1,2],[2,2,4]);
	Main.gfx.slice("gameover",h2d_TileCenter.XCenter,256,240,256,144);
	Main.gfx.slice("white_disc",h2d_TileCenter.Center,256,192,48,48);
	Main.gfx.slice("press_start",h2d_TileCenter.Center,256,384,192,96,2);
	Main.gfx.slice("luciole",null,304,192,16,16,1,2);
	Main.gfx.addAnim("twinkle",[0,1],[2]);
	Main.gfx.setAlign(0.0,0.5);
	Main.gfx.slice("nose",null,320,192,16,16);
	Main.gfx.slice(null,null,304,224,24,8);
	Main.gfx.setAlign(0.25,0.25);
	Main.gfx.slice("noseCenter",null,320,192,16,16);
	Main.gfx.slice(null,null,304,224,24,8);
	Main.gfx.setAlign(0.0,0.0);
	Main.gfx.slice("eye_close",h2d_TileCenter.Center,448,32,8,8,2,2);
	Main.gfx.slice("eyes",h2d_TileCenter.Center,448,48,8,8,32);
	Main.gfx.slice("eye",h2d_TileCenter.Center,448,48,8,8);
	Main.gfx.slice("mouth",h2d_TileCenter.Center,448,56,16,16);
	Main.gfx.slice("mouthes",h2d_TileCenter.Center,448,56,16,16,16);
	Main.gfx.slice("bird",null,448,128,64,64,5);
	Main.gfx.slice("feather",null,320,208,16,16);
	Main.gfx.slice("shockwave",h2d_TileCenter.Center,512,192,64,64,4,2);
	Main.gfx.addAnim("shockwave",[0,1,2,3,4,5,6,7],[2]);
	Main.gfx.slice("bubbles",h2d_TileCenter.Center,48,48,8,8,2,2);
	Main.gfx.slice("title",null,0,256,256,112);
	Main.gfx.slice("medals",h2d_TileCenter.Center,512,0,48,48,2);
	Main.gfx.slice(null,h2d_TileCenter.Center,448,80,48,48,2);
	Main.gfx.slice("olympio",h2d_TileCenter.Center,624,0,144,96);
	Main.gfx.slice("doors",null,784,0,128,512);
	Main.gfx.slice(null,null,912,0,128,208);
	h2d_Element.DEFAULT_STORE = Main.gfx;
	Main.sky = new h2d_Store();
	Main.sky.setImg(hxd_Res.get_loader().loadCache("sky.png",hxd_res_Image));
	Main.sky.slice("sky",null,0,0,256,256);
};
Main.initSounds = function() {
	Main.sRand = hxd_Rand.create();
	var _g = new haxe_ds_StringMap();
	var value = [hxd_Res.get_loader().loadCache("sounds/_over.mp3",hxd_res_Sound)];
	_g.h["over"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_select0.wav",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_select1.wav",hxd_res_Sound)];
	_g.h["select"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_dialog0.wav",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_dialog1.mp3",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_dialog2.wav",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_dialog3.wav",hxd_res_Sound)];
	_g.h["dialog"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_drop_ball.wav",hxd_res_Sound)];
	_g.h["drop_ball"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_new_ball.mp3",hxd_res_Sound)];
	_g.h["new_ball"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_pass0.mp3",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_pass1.mp3",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_pass2.mp3",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_pass3.mp3",hxd_res_Sound)];
	_g.h["throw"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_win.mp3",hxd_res_Sound)];
	_g.h["jingle_reach"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_body_explode0.mp3",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_body_explode1.mp3",hxd_res_Sound)];
	_g.h["body_explode"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_gameOver_impact0.wav",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_gameOver_impact1.wav",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_gameOver_impact2.wav",hxd_res_Sound)];
	_g.h["ground_game_over"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_gameOver_leave.mp3",hxd_res_Sound)];
	_g.h["leave_game_over"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_select0.wav",hxd_res_Sound)];
	_g.h["press_start"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_dialog1.mp3",hxd_res_Sound)];
	_g.h["music_on"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_over.mp3",hxd_res_Sound)];
	_g.h["music_off"] = value;
	var value = [hxd_Res.get_loader().loadCache("sounds/_tuto_success0.mp3",hxd_res_Sound),hxd_Res.get_loader().loadCache("sounds/_tuto_success1.mp3",hxd_res_Sound)];
	_g.h["tuto_success"] = value;
	Main.sounds = _g;
};
Main.playSound = function(str,index,volume) {
	if(volume == null) {
		volume = 1.0;
	}
	if(!Main.profile.music) {
		return;
	}
	var sound = Main.sounds.h[str];
	if(sound == null) {
		haxe_Log.trace("ERROR : Sound " + str + " is missing !",{ fileName : "src/Main.hx", lineNumber : 203, className : "Main", methodName : "playSound"});
		return;
	}
	var idx;
	if(index != null) {
		idx = index;
	} else {
		var _this = Main.sRand;
		_this.seed = 36969 * (_this.seed & 65535) + (_this.seed >> 16);
		_this.seed2 = 18000 * (_this.seed2 & 65535) + (_this.seed2 >> 16);
		idx = (((_this.seed << 16) + _this.seed2 | 0) & 1073741823) % sound.length;
	}
	if(sound[idx] == null) {
		haxe_Log.trace("ERROR : invalid index " + idx + " for sound " + str + " !",{ fileName : "src/Main.hx", lineNumber : 209, className : "Main", methodName : "playSound"});
		return;
	}
	sound[idx].play(false,volume);
};
Main.toggleMusic = function() {
	if(Main.profile.music) {
		Main.playSound("music_off");
	}
	Main.profile.music = !Main.profile.music;
	if(Main.profile.music) {
		Main.playSound("music_on");
	}
	Main.saveProfile();
};
Main.loadProfile = function() {
	var defaultProfile = { level : 0, hiscoreSurvival : 0, hiscoreChallenge : 0, music : true};
	Main.profile = hxd_Save.load(defaultProfile,Main.SAVE_ID);
};
Main.saveProfile = function() {
	hxd_Save.save(Main.profile,Main.SAVE_ID);
};
Main.__super__ = hxd_App;
Main.prototype = $extend(hxd_App.prototype,{
	init: function() {
		Main.me = this;
		hxd_Res.set_loader(new hxd_res_Loader(new hxd_fs_EmbedFileSystem(haxe_Unserializer.run("oy7:screensoy8:sc_0.pngty8:sc_4.pngty8:sc_2.pngty8:sc_1.pngty8:sc_3.pngtgy4:animoy8:bird.pngty13:shockwave.pngtgy9:.DS_Storety7:archiveoy9:tuto2.pngty10:tuto_2.pngtgy7:sky.pngty9:decor.pngty6:soundsoy13:_new_ball.mp3ty21:_gameOver_impact2.wavty10:_pass3.mp3ty19:_gameOver_leave.mp3ty18:_body_explode1.mp3ty10:_throw.mp3ty14:_drop_ball.wavty18:_tuto_success1.mp3ty10:_pass0.mp3ty21:_gameOver_impact0.wavty9:_over.mp3ty12:_dialog2.wavty10:_pass2.mp3tR9ty12:_dialog0.wavty12:_dialog1.mp3ty18:_tuto_success0.mp3ty10:_pass1.mp3ty18:_body_explode0.mp3ty21:_gameOver_impact1.wavty12:_select0.wavty8:_win.mp3ty12:_dialog3.wavty12:_select1.wavtgy5:fontsoy13:nokiafc22.ttftR9ty12:upheavtt.ttftgy7:gfx.pngtg"))));
		Fx.FIT_PIX = true;
		if(Dev.FINAL) {
			Dev.reset();
		}
		Main.loadProfile();
		hxd_Key.initialize();
		hxd_Key.ALLOW_KEY_REPEAT = false;
		Main.initTiles();
		Main.initSounds();
		Fx.FIT_PIX = true;
		hxd_Window.getInstance().useScreenPixels = false;
		new Game(this.s2d);
		this.lastDraw = 0.;
		this.engine.resize(512,512);
	}
	,update: function(dt) {
		this.lastDraw += dt;
		if(hxd_Key.isReleased(77)) {
			Main.toggleMusic();
		}
		if(this.lastDraw <= 0.021) {
			return;
		}
		this.lastDraw = 0.0;
		var max = hxd_Key.isDown(9) && !Dev.FINAL ? 40 : 1;
		if(Dev.FINAL) {
			max = 1;
		}
		var _g = 0;
		var _g1 = max;
		while(_g < _g1) {
			var i = _g++;
			this.loop();
		}
	}
	,loop: function() {
		Main.t++;
		Fx.updateAll();
		h2d_Element.updateAnims();
	}
	,__class__: Main
});
Math.__name__ = "Math";
var GameDepth = $hxEnums["GameDepth"] = { __ename__:"GameDepth",__constructs__:null
	,DP_BG: {_hx_name:"DP_BG",_hx_index:0,__enum__:"GameDepth",toString:$estr}
	,DP_GROUND: {_hx_name:"DP_GROUND",_hx_index:1,__enum__:"GameDepth",toString:$estr}
	,DP_SNOWMAN: {_hx_name:"DP_SNOWMAN",_hx_index:2,__enum__:"GameDepth",toString:$estr}
	,DP_BALLS: {_hx_name:"DP_BALLS",_hx_index:3,__enum__:"GameDepth",toString:$estr}
	,DP_FX: {_hx_name:"DP_FX",_hx_index:4,__enum__:"GameDepth",toString:$estr}
};
GameDepth.__constructs__ = [GameDepth.DP_BG,GameDepth.DP_GROUND,GameDepth.DP_SNOWMAN,GameDepth.DP_BALLS,GameDepth.DP_FX];
GameDepth.__empty_constructs__ = [GameDepth.DP_BG,GameDepth.DP_GROUND,GameDepth.DP_SNOWMAN,GameDepth.DP_BALLS,GameDepth.DP_FX];
var Dev = function() { };
$hxClasses["Dev"] = Dev;
Dev.__name__ = "Dev";
Dev.reset = function() {
	Dev.FORMAT = false;
	Dev.MODE = -1;
	Dev.TEST_MALUS = null;
};
var Gameplay = function() { };
$hxClasses["Gameplay"] = Gameplay;
Gameplay.__name__ = "Gameplay";
var Malus = $hxEnums["Malus"] = { __ename__:"Malus",__constructs__:null
	,HEAVY: {_hx_name:"HEAVY",_hx_index:0,__enum__:"Malus",toString:$estr}
	,SHRINK: {_hx_name:"SHRINK",_hx_index:1,__enum__:"Malus",toString:$estr}
	,SNOW: {_hx_name:"SNOW",_hx_index:2,__enum__:"Malus",toString:$estr}
	,WIND: {_hx_name:"WIND",_hx_index:3,__enum__:"Malus",toString:$estr}
	,EXTRA_BALL: {_hx_name:"EXTRA_BALL",_hx_index:4,__enum__:"Malus",toString:$estr}
	,WINE: {_hx_name:"WINE",_hx_index:5,__enum__:"Malus",toString:$estr}
	,EXTRA_FIVE: {_hx_name:"EXTRA_FIVE",_hx_index:6,__enum__:"Malus",toString:$estr}
	,BIRD: {_hx_name:"BIRD",_hx_index:7,__enum__:"Malus",toString:$estr}
};
Malus.__constructs__ = [Malus.HEAVY,Malus.SHRINK,Malus.SNOW,Malus.WIND,Malus.EXTRA_BALL,Malus.WINE,Malus.EXTRA_FIVE,Malus.BIRD];
Malus.__empty_constructs__ = [Malus.HEAVY,Malus.SHRINK,Malus.SNOW,Malus.WIND,Malus.EXTRA_BALL,Malus.WINE,Malus.EXTRA_FIVE,Malus.BIRD];
var TutotAction = $hxEnums["TutotAction"] = { __ename__:"TutotAction",__constructs__:null
	,TXT: ($_=function(str,snd) { return {_hx_index:0,str:str,snd:snd,__enum__:"TutotAction",toString:$estr}; },$_._hx_name="TXT",$_.__params__ = ["str","snd"],$_)
	,SAY_HELLO: {_hx_name:"SAY_HELLO",_hx_index:1,__enum__:"TutotAction",toString:$estr}
	,GIVE_BALL: ($_=function(id) { return {_hx_index:2,id:id,__enum__:"TutotAction",toString:$estr}; },$_._hx_name="GIVE_BALL",$_.__params__ = ["id"],$_)
	,TEST_MOVE: {_hx_name:"TEST_MOVE",_hx_index:3,__enum__:"TutotAction",toString:$estr}
	,TEST_CATCH: {_hx_name:"TEST_CATCH",_hx_index:4,__enum__:"TutotAction",toString:$estr}
	,TEST_SWAP: {_hx_name:"TEST_SWAP",_hx_index:5,__enum__:"TutotAction",toString:$estr}
	,TEST_JUGGLE: {_hx_name:"TEST_JUGGLE",_hx_index:6,__enum__:"TutotAction",toString:$estr}
	,UNLOCK_CHALLENGE: {_hx_name:"UNLOCK_CHALLENGE",_hx_index:7,__enum__:"TutotAction",toString:$estr}
};
TutotAction.__constructs__ = [TutotAction.TXT,TutotAction.SAY_HELLO,TutotAction.GIVE_BALL,TutotAction.TEST_MOVE,TutotAction.TEST_CATCH,TutotAction.TEST_SWAP,TutotAction.TEST_JUGGLE,TutotAction.UNLOCK_CHALLENGE];
TutotAction.__empty_constructs__ = [TutotAction.SAY_HELLO,TutotAction.TEST_MOVE,TutotAction.TEST_CATCH,TutotAction.TEST_SWAP,TutotAction.TEST_JUGGLE,TutotAction.UNLOCK_CHALLENGE];
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.isObject = function(v) {
	if(v == null) {
		return false;
	}
	var t = typeof(v);
	if(!(t == "string" || t == "object" && v.__enum__ == null)) {
		if(t == "function") {
			return (v.__name__ || v.__ename__) != null;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
var Snowman = function() {
	h2d_Drawable.call(this,Game.me);
	Game.me.snowman = this;
	this.dex = 0;
	this.dey = 0;
	this.angle = 0;
	this.power = 0;
	this.lookMode = 2;
	this.armLength = Snowman.ARM_LENGTH;
	this.readyToLaunch = false;
	this.ingame = false;
	this.body = new h2d_Element();
	this.body.goto(null,"snowman_body");
	this.torso = new h2d_Element();
	this.torso.goto(null,"snowman_torso");
	var _this = this.torso;
	_this.posChanged = true;
	_this.y = this.body.y - Snowman.TORSO_RAY;
	this.head = new Head();
	var _this = this.head;
	_this.posChanged = true;
	_this.y = this.torso.y - Snowman.HEAD_RAY;
	this.addChild(this.body);
	this.addChild(this.torso);
	this.addChild(this.head);
	this.arms = new h2d_Drawable(this);
	this.branch = [];
	var el = new h2d_Element();
	el.goto(0,"snowman_arms");
	this.arms.addChild(el);
	this.branch.push(el);
	var el = new h2d_Element();
	el.goto(1,"snowman_arms");
	this.arms.addChild(el);
	this.branch.push(el);
	var el = new h2d_Element();
	el.goto(2,"snowman_arms");
	this.arms.addChild(el);
	this.branch.push(el);
	var el = new h2d_Element();
	el.goto(3,"snowman_arms");
	this.arms.addChild(el);
	this.branch.push(el);
	this.hands = [];
	var h = new Hand();
	this.hands.push(h);
	this.addChild(h);
	var h = new Hand();
	this.hands.push(h);
	this.addChild(h);
};
$hxClasses["Snowman"] = Snowman;
Snowman.__name__ = "Snowman";
Snowman.__super__ = h2d_Drawable;
Snowman.prototype = $extend(h2d_Drawable.prototype,{
	update: function() {
		this.angle *= 0.75;
		if(hxd_Key.isDown(32) && this.controlable) {
			this.readyToLaunch = true;
			this.power = Math.min(this.power + 0.06,1);
		} else {
			if(this.readyToLaunch && this.hands[0].balls.length > 0) {
				this.launch();
			}
			this.readyToLaunch = false;
			this.power *= 0.5;
		}
		var x = hxd_Window.getInstance().get_mouseX();
		var y = hxd_Window.getInstance().get_mouseY();
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var localMouse = this.globalToLocal(new h2d_col_PointImpl(x,y));
		var mpx = localMouse.x;
		var mpy = localMouse.y;
		if(!this.controlable) {
			mpx = 54;
			mpy = -32;
		}
		if(this.recMouse != null) {
			mpx = Math.floor(this.recMouse.x);
			mpy = Math.floor(this.recMouse.y);
		}
		this.dex = (this.dex + 4) % 628;
		this.dey = (this.dey + 3) % 628;
		var left = this.hands[0];
		var v = -54 + this.angle * 16 + mpy * 0.08 + Math.cos(this.dex * 0.01) * 5;
		left.posChanged = true;
		left.x = v;
		var v = -32 - this.angle * 10 + mpx * 0.08 + Math.cos(this.dey * 0.01) * 5;
		left.posChanged = true;
		left.y = v;
		var nimbCoef = this.getNimbCoef();
		var right = this.hands[1];
		right.posChanged = true;
		right.x += (mpx - right.x) * nimbCoef;
		right.posChanged = true;
		right.y += (mpy - right.y) * nimbCoef;
		this.majBody();
	}
	,dance: function() {
		this.dex = (this.dex + 4) % 628;
		this.dex = (this.dex + 4) % 628;
		this.angle = Math.cos(this.dex * 0.01) * 0.1;
		this.majBody();
	}
	,majBody: function() {
		this.armLength = Snowman.ARM_LENGTH - Game.me.numHave(Malus.SHRINK) * 5;
		var lowest = 0.25;
		var _g = 0;
		var _g1 = Game.me.balls;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(!b.hand && b.x > this.x) {
				if(b.vy > 0 && b.y > Main.HEIGHT * lowest) {
					lowest = b.y / Main.HEIGHT;
				}
			}
		}
		var turnCoef = 0.2 + lowest;
		turnCoef *= Math.pow(0.5,Game.me.numHave(Malus.SNOW));
		var an = this.angle - 1.57;
		var drunk = 0.05 + Game.me.numHave(Malus.WINE) * 0.3;
		an += Math.cos(h2d_MAll.cmod(Main.t,168) * 6.28) * drunk;
		var _this = this.torso;
		var v = this.body.y + Math.cos(an) * Snowman.TORSO_RAY | 0;
		_this.posChanged = true;
		_this.x = v;
		var _this = this.torso;
		var v = this.body.y + Math.sin(an) * Snowman.TORSO_RAY | 0;
		_this.posChanged = true;
		_this.y = v;
		var _this = this.head;
		var v = this.torso.x + Math.cos(an) * Snowman.HEAD_RAY | 0;
		_this.posChanged = true;
		_this.x = v;
		var _this = this.head;
		var v = this.torso.y + Math.sin(an) * Snowman.HEAD_RAY | 0;
		_this.posChanged = true;
		_this.y = v;
		var _g = 0;
		while(_g < 2) {
			var i = _g++;
			var sens = i * 2 - 1;
			var h = this.hands[i];
			if(this.ingame) {
				h.posChanged = true;
				h.rotation *= 0.85;
			}
			var qa = this.angle + 1.3 * sens - 1.57;
			var ax = this.torso.x + Math.cos(qa) * 16;
			var ay = this.torso.y + Math.sin(qa) * 16;
			if(i == 1) {
				var dif = ax + 20 - h.x;
				if(dif > 0) {
					this.angle -= 0.04 * turnCoef * dif * 0.1;
				}
				if(h.x < ax + 5) {
					h.posChanged = true;
					h.x = ax + 5;
				}
			} else {
				h.vy = this.power * 32;
			}
			h.vx *= 0.9;
			h.vy *= 0.9;
			h.posChanged = true;
			h.x += h.vx;
			h.posChanged = true;
			h.y += h.vy;
			var dx = h.x - ax;
			var dy = h.y - ay;
			var an = Math.atan2(dy,dx);
			var dist = Math.sqrt(dx * dx + dy * dy);
			var max = this.armLength * 2;
			if(dist > max) {
				var v = ax + Math.cos(an) * max;
				h.posChanged = true;
				h.x = v;
				var v1 = ay + Math.sin(an) * max;
				h.posChanged = true;
				h.y = v1;
				var dif1 = Main.getMouse().x - ax - max;
				if(dif1 > 0) {
					this.angle += 0.08 * turnCoef * Math.min(dif1 * 0.1,2.5);
				}
			}
			var d = dist * 0.5 / this.armLength;
			var da = d >= 1 ? 0 : Math.acos(d);
			if(h.x < ax || !this.ingame && i == 1) {
				da *= -1;
			}
			var an2 = an + da;
			if(i == 1 && this.ingame) {
				an2 = h2d_MAll.fclamp(an2,-1.57 + this.angle,1.57 + this.angle);
			}
			var arm = this.branch[i * 2];
			arm.posChanged = true;
			arm.x = ax;
			arm.posChanged = true;
			arm.y = ay;
			arm.posChanged = true;
			arm.rotation = an2;
			arm.posChanged = true;
			arm.scaleX = this.armLength / Snowman.ARM_LENGTH;
			var arm1 = this.branch[i * 2 + 1];
			var v2 = ax + Math.cos(an2) * this.armLength;
			arm1.posChanged = true;
			arm1.x = v2;
			var v3 = ay + Math.sin(an2) * this.armLength;
			arm1.posChanged = true;
			arm1.y = v3;
			var dx1 = h.x - arm1.x;
			var dy1 = h.y - arm1.y;
			var v4 = Math.atan2(dy1,dx1);
			arm1.posChanged = true;
			arm1.rotation = v4;
			var v5 = Math.sqrt(dx1 * dx1 + dy1 * dy1) / 28;
			arm1.posChanged = true;
			arm1.scaleX = v5;
			h.posChanged = true;
			h.x = h.x | 0;
			h.posChanged = true;
			h.y = h.y | 0;
			h.majBalls();
		}
		switch(this.lookMode) {
		case 0:
			var mouse = Main.getMouse();
			this.head.lookScene(mouse.x,mouse.y);
			break;
		case 1:
			var highest = null;
			var _g = 0;
			var _g1 = Game.me.balls;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				if(highest == null || b.getScenePos().y < highest.getScenePos().y) {
					highest = b;
				}
			}
			if(highest != null) {
				var p = highest.getScenePos();
				this.head.lookScene(p.x,p.y);
				if(p.y < 34 && Std.random(320) == 0) {
					this.head.emote(3,1,80);
				}
			}
			break;
		case 2:
			var ma = 64;
			if(Std.random(60) == 0) {
				this.head.lookScene(ma + Math.random() * (Main.WIDTH - 2 * ma),ma + Math.random() * (Main.HEIGHT - 2 * ma));
			}
			break;
		case 3:
			var ma = 110;
			var d = Math.sqrt(this.head.pos.x * this.head.pos.x + this.head.pos.y * this.head.pos.y);
			if(Std.random(60) == 0 || d > 0.25) {
				this.head.lookScene(ma + Math.random() * (Main.WIDTH - 2 * ma),ma + Math.random() * (Main.HEIGHT - 2 * ma));
			}
			break;
		}
		this.head.update();
		if(this.angle > 0.77) {
			this.head.emote(4,1,20);
		}
	}
	,grab: function(b) {
		var _this = this.hands[1];
		if(_this.balls.length >= _this.max) {
			return;
		}
		Game.me.incScore(1);
		this.arms.addChild(b.skin);
		this.hands[1].balls.push(b);
		b.hand = true;
		this.hands[1].majBalls();
	}
	,pass: function() {
		var h = this.hands[1];
		if(h.balls.length == 0) {
			return;
		}
		Main.playSound("throw");
		var b = h.balls.shift();
		new fx_Pass(b);
		h.vx = -32 * this.getNimbCoef();
	}
	,endPass: function(b) {
		var h = this.hands[0];
		if(h.balls.length >= h.max) {
			b.pop();
			return;
		}
		h.balls.push(b);
	}
	,launch: function() {
		Main.playSound("throw");
		var rnd = 0.0;
		if(Game.me.mode == 2) {
			rnd = Game.me.score * 0.005;
		}
		var h = this.hands[0];
		var b = h.balls.shift();
		b.vy = -Math.pow(this.power,0.5) * 10;
		b.vx = 4.3 + Math.random() * (1.5 + rnd * 2) - rnd - this.power;
		b.pop();
	}
	,initBall: function(b) {
		b.hand = true;
		this.arms.addChild(b.skin);
		var h = this.hands[0];
		h.balls.push(b);
		h.majBalls();
		var _this = b.skin;
		var _this1 = b.skin;
		_this1.posChanged = true;
		_this.posChanged = true;
		_this.scaleX = _this1.scaleY = 0;
		var e = new fx_Scale(b.skin,1);
		e.curveIn(0.5);
	}
	,getNimbCoef: function() {
		return 1 / (1 + Game.me.numHave(Malus.SNOW) * 4);
	}
	,explode: function(n) {
		Main.playSound("body_explode",n < 2 ? 0 : 1);
		var trg = this.head;
		if(n == 1) {
			trg = this.torso;
		}
		if(n == 2) {
			trg = this.body;
		}
		trg.set_visible(false);
		var cex = this.x + trg.x;
		var cey = this.y + trg.y;
		var el = new h2d_Element();
		el.goto(null,"white_disc");
		if(n < 2) {
			el.posChanged = true;
			el.posChanged = true;
			el.scaleX = el.scaleY = 0.66;
		}
		Game.me.dm.add(el,GameDepth.DP_FX);
		el.posChanged = true;
		el.x = cex;
		el.posChanged = true;
		el.y = cey;
		var e = new fx_Scale(el,0);
		e.curveIn(0.5);
		var max = 16;
		if(n > 1) {
			max += 8;
		}
		var _g = 0;
		var _g1 = max;
		while(_g < _g1) {
			var i = _g++;
			var p = Game.me.fxSnow(cex,cey);
			var an = (i + Math.random()) * 6.28 / max;
			p.impulse(an,0.2 + Math.random() * 3,7);
			p.weight *= 0.5;
		}
		var _g = 0;
		var _g1 = max;
		while(_g < _g1) {
			var i = _g++;
			var el = new h2d_Element();
			el.play("spark_blue");
			el.anim.gotoRandom();
			Game.me.dm.add(el,GameDepth.DP_FX);
			var p = new fx_Part(el);
			p.onFinish = $bind(el,el.kill);
			p.life = 20 + Std.random(120);
			var an = (i + Math.random()) * 6.28 / max;
			p.setPos(cex,cey);
			p.impulse(an,4,4);
			p.frict = 0.8 + Math.random() * 0.16;
		}
		if(n == 1) {
			var _g = 0;
			var _g1 = this.branch;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				var dx = b.x - trg.x;
				var dy = b.y - trg.y;
				var p = new fx_h2d_Part(b);
				p.impulse(Math.atan2(dy,dx),1 + Math.random() * 3);
				p.vy -= 2 + Math.random() * 2;
				p.weight = 0.1 + Math.random() * 0.1;
				p.vr = Math.random() * 2 - 1;
				p.rfr = 0.97;
				p.life = 40 + Std.random(40);
				p.fadeType = 2;
			}
			var _g = 0;
			var _g1 = this.hands;
			while(_g < _g1.length) {
				var h = _g1[_g];
				++_g;
				var dx = h.x - trg.x;
				var dy = h.y - trg.y;
				var p = new fx_h2d_Part(h);
				p.impulse(Math.atan2(dy,dx),1 + Math.random() * 3);
				p.vy -= 2 + Math.random() * 2;
				p.weight = 0.1 + Math.random() * 0.1;
				p.life = 40 + Std.random(40);
				p.fadeType = 2;
			}
		}
	}
	,__class__: Snowman
});
var Head = function() {
	h2d_Element.call(this);
	this.goto(null,"snowman_head");
	var round = new h2d_Graphics(this);
	round.beginFill(16711680,0.3);
	round.drawCircle(0,0,Head.RAY);
	this.emoteStack = [];
	var _this = Main.gfx;
	var id = 0;
	id += _this.index.h["snowman_head"];
	this.masked = new h2d_Bitmap(_this.tiles[id],this);
	this.noseCenter = new h2d_Element();
	this.noseCenter.goto(null,"nose");
	this.nose = new h2d_Element();
	this.nose.goto(1,"nose");
	this.mouth = new h2d_Element();
	this.mouth.goto(null,"mouth");
	this.noseCenter.blendMode = this.mouth.blendMode = h2d_BlendMode.AlphaMultiply;
	this.eyes = [];
	var el = new h2d_Element();
	el.goto(null,"eye");
	this.eyes.push(el);
	this.masked.addChild(el);
	var el = new h2d_Element();
	el.goto(null,"eye");
	this.eyes.push(el);
	this.masked.addChild(el);
	this.masked.addChild(this.mouth);
	this.masked.addChild(this.noseCenter);
	this.addChild(this.nose);
	var x = 0.0;
	var y = 0.0;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.pos = new h2d_col_PointImpl(x,y);
	var x = 0.0;
	var y = 0.0;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.trg = new h2d_col_PointImpl(x,y);
	this.elements = [];
	var ecx = 0.25;
	var ecy = -0.2;
	this.elements.push({ el : this.eyes[0], dx : -ecx, dy : ecy});
	this.elements.push({ el : this.eyes[1], dx : ecx, dy : ecy});
	this.elements.push({ el : this.noseCenter, dx : -0.15, dy : 0.25});
	this.elements.push({ el : this.mouth, dx : 0, dy : 0.45});
	this.elements.push({ el : this.nose, dx : 0, dy : 0.1});
	this.masked.set_filter(new h2d_filter_Mask(round,true));
	this.emote(0);
};
$hxClasses["Head"] = Head;
Head.__name__ = "Head";
Head.__super__ = h2d_Element;
Head.prototype = $extend(h2d_Element.prototype,{
	update: function() {
		var top = null;
		var _g = 0;
		var _g1 = this.emoteStack.slice();
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(top == null || top.prio < e.prio) {
				top = e;
			}
			if(e.time-- == 0) {
				HxOverrides.remove(this.emoteStack,e);
			}
		}
		this.applyEmote(top.id);
		var dx = this.trg.x - this.pos.x;
		var dy = this.trg.y - this.pos.y;
		var lim = 0.25;
		var co = 0.25;
		if(Game.me.snowman.lookMode == 2) {
			co = 0.04;
		}
		this.pos.x += Num.mm(-lim,dx * co,lim);
		this.pos.y += Num.mm(-lim,dy * co,lim);
		var angle = Math.atan2(this.pos.y,this.pos.x);
		var dist = Math.sqrt(this.pos.x * this.pos.x + this.pos.y * this.pos.y);
		var _g = 0;
		var _g1 = this.elements;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			var cx = this.pos.x + e.dx;
			var cy = this.pos.y + e.dy;
			cx = h2d_MAll.fclamp(cx,-1,1);
			cy = h2d_MAll.fclamp(cy,-1,1);
			var ddx = Math.cos(1.57 * cx - 1.57);
			var ddy = Math.cos(1.57 * cy - 1.57);
			if(e.el == this.nose) {
				var a = Math.atan2(ddy,ddx);
				var d = Math.min(Math.sqrt(ddx * ddx + ddy * ddy),0.96);
				ddx = Math.cos(a) * d;
				ddy = Math.sin(a) * d;
			}
			var _this = e.el;
			var v = Math.round(ddx * Head.RAY);
			_this.posChanged = true;
			_this.x = v;
			var _this1 = e.el;
			var v1 = Math.round(ddy * Head.RAY);
			_this1.posChanged = true;
			_this1.y = v1;
		}
		var _this = this.nose;
		_this.posChanged = true;
		_this.rotation = angle;
		var _this = this.nose;
		var v = Math.min(dist,1.0);
		_this.posChanged = true;
		_this.scaleX = v;
	}
	,lookScene: function(tx,ty) {
		var ttx = Math.max(0.2,Math.min(tx / Main.WIDTH,0.8));
		var tty = Math.max(0.3,Math.min(ty / Main.WIDTH,0.7));
		this.trg.x = ttx * 2 - 1;
		this.trg.y = tty * 2 - 1;
	}
	,emote: function(n,prio,time) {
		if(time == null) {
			time = -1;
		}
		if(prio == null) {
			prio = 0;
		}
		var em = null;
		var _g = 0;
		var _g1 = this.emoteStack;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e.id == n) {
				em = e;
			}
		}
		if(em == null) {
			em = { id : n, prio : prio, time : time};
			this.emoteStack.push(em);
		}
		em.time = time;
		em.prio = prio;
	}
	,applyEmote: function(n) {
		if(n == 5) {
			n = [0,5,6,7][(Main.t >> 2) % 4];
		}
		var close = Main.t % 120 >> 1;
		var eye = this.eyes[0];
		if(close < 3) {
			eye.goto([0,1,0][close],"eye_close");
		} else {
			eye.goto(n * 2,"eyes");
		}
		var eye = this.eyes[1];
		if(close < 3) {
			eye.goto([0,1,0][close],"eye_close");
		} else {
			eye.goto(n * 2 + 1,"eyes");
		}
		this.mouth.goto(n,"mouthes");
	}
	,__class__: Head
});
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	do {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
	} while(n > 0);
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
ValueType.__empty_constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown];
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
Type.getEnum = function(o) {
	if(o == null) {
		return null;
	}
	return $hxEnums[o.__enum__];
};
Type.createInstance = function(cl,args) {
	var ctor = Function.prototype.bind.apply(cl,[null].concat(args));
	return new (ctor);
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.createEnumIndex = function(e,index,params) {
	var c;
	var _g = e.__constructs__[index];
	if(_g == null) {
		c = null;
	} else {
		var ctor = _g;
		c = ctor._hx_name;
	}
	if(c == null) {
		throw haxe_Exception.thrown(index + " is not a valid enum constructor index");
	}
	return Type.createEnum(e,c,params);
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var params = enm.__constructs__[a._hx_index].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		return false;
	}
	return true;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var XmlType = {};
XmlType.toString = function(this1) {
	switch(this1) {
	case 0:
		return "Element";
	case 1:
		return "PCData";
	case 2:
		return "CData";
	case 3:
		return "Comment";
	case 4:
		return "DocType";
	case 5:
		return "ProcessingInstruction";
	case 6:
		return "Document";
	}
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
$hxClasses["Xml"] = Xml;
Xml.__name__ = "Xml";
Xml.parse = function(str) {
	return haxe_xml_Parser.parse(str);
};
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createCData = function(data) {
	var xml = new Xml(Xml.CData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createComment = function(data) {
	var xml = new Xml(Xml.Comment);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocType = function(data) {
	var xml = new Xml(Xml.DocType);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createProcessingInstruction = function(data) {
	var xml = new Xml(Xml.ProcessingInstruction);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	,exists: function(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	,iterator: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_iterators_ArrayIterator(this.children);
	}
	,elements: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,elementsNamed: function(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			var tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		var ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	,firstElement: function() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,insertChild: function(x,pos) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			HxOverrides.remove(x.parent.children,x);
		}
		this.children.splice(pos,0,x);
		x.parent = this;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var format_gif_Block = $hxEnums["format.gif.Block"] = { __ename__:"format.gif.Block",__constructs__:null
	,BFrame: ($_=function(frame) { return {_hx_index:0,frame:frame,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BFrame",$_.__params__ = ["frame"],$_)
	,BExtension: ($_=function(extension) { return {_hx_index:1,extension:extension,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BExtension",$_.__params__ = ["extension"],$_)
	,BEOF: {_hx_name:"BEOF",_hx_index:2,__enum__:"format.gif.Block",toString:$estr}
};
format_gif_Block.__constructs__ = [format_gif_Block.BFrame,format_gif_Block.BExtension,format_gif_Block.BEOF];
format_gif_Block.__empty_constructs__ = [format_gif_Block.BEOF];
var format_gif_Extension = $hxEnums["format.gif.Extension"] = { __ename__:"format.gif.Extension",__constructs__:null
	,EGraphicControl: ($_=function(gce) { return {_hx_index:0,gce:gce,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EGraphicControl",$_.__params__ = ["gce"],$_)
	,EComment: ($_=function(text) { return {_hx_index:1,text:text,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EComment",$_.__params__ = ["text"],$_)
	,EText: ($_=function(pte) { return {_hx_index:2,pte:pte,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EText",$_.__params__ = ["pte"],$_)
	,EApplicationExtension: ($_=function(ext) { return {_hx_index:3,ext:ext,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EApplicationExtension",$_.__params__ = ["ext"],$_)
	,EUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EUnknown",$_.__params__ = ["id","data"],$_)
};
format_gif_Extension.__constructs__ = [format_gif_Extension.EGraphicControl,format_gif_Extension.EComment,format_gif_Extension.EText,format_gif_Extension.EApplicationExtension,format_gif_Extension.EUnknown];
format_gif_Extension.__empty_constructs__ = [];
var format_gif_ApplicationExtension = $hxEnums["format.gif.ApplicationExtension"] = { __ename__:"format.gif.ApplicationExtension",__constructs__:null
	,AENetscapeLooping: ($_=function(loops) { return {_hx_index:0,loops:loops,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AENetscapeLooping",$_.__params__ = ["loops"],$_)
	,AEUnknown: ($_=function(name,version,data) { return {_hx_index:1,name:name,version:version,data:data,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AEUnknown",$_.__params__ = ["name","version","data"],$_)
};
format_gif_ApplicationExtension.__constructs__ = [format_gif_ApplicationExtension.AENetscapeLooping,format_gif_ApplicationExtension.AEUnknown];
format_gif_ApplicationExtension.__empty_constructs__ = [];
var format_gif_Version = $hxEnums["format.gif.Version"] = { __ename__:"format.gif.Version",__constructs__:null
	,GIF87a: {_hx_name:"GIF87a",_hx_index:0,__enum__:"format.gif.Version",toString:$estr}
	,GIF89a: {_hx_name:"GIF89a",_hx_index:1,__enum__:"format.gif.Version",toString:$estr}
	,Unknown: ($_=function(version) { return {_hx_index:2,version:version,__enum__:"format.gif.Version",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["version"],$_)
};
format_gif_Version.__constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a,format_gif_Version.Unknown];
format_gif_Version.__empty_constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a];
var format_gif_DisposalMethod = $hxEnums["format.gif.DisposalMethod"] = { __ename__:"format.gif.DisposalMethod",__constructs__:null
	,UNSPECIFIED: {_hx_name:"UNSPECIFIED",_hx_index:0,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,NO_ACTION: {_hx_name:"NO_ACTION",_hx_index:1,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,FILL_BACKGROUND: {_hx_name:"FILL_BACKGROUND",_hx_index:2,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,RENDER_PREVIOUS: {_hx_name:"RENDER_PREVIOUS",_hx_index:3,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,UNDEFINED: ($_=function(index) { return {_hx_index:4,index:index,__enum__:"format.gif.DisposalMethod",toString:$estr}; },$_._hx_name="UNDEFINED",$_.__params__ = ["index"],$_)
};
format_gif_DisposalMethod.__constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS,format_gif_DisposalMethod.UNDEFINED];
format_gif_DisposalMethod.__empty_constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS];
var format_gif_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.gif.Reader"] = format_gif_Reader;
format_gif_Reader.__name__ = "format.gif.Reader";
format_gif_Reader.prototype = {
	read: function() {
		var b = 71;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 73;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 70;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var gifVer = this.i.readString(3);
		var version = format_gif_Version.GIF89a;
		switch(gifVer) {
		case "87a":
			version = format_gif_Version.GIF87a;
			break;
		case "89a":
			version = format_gif_Version.GIF89a;
			break;
		default:
			version = format_gif_Version.Unknown(gifVer);
		}
		var width = this.i.readUInt16();
		var height = this.i.readUInt16();
		var packedField = this.i.readByte();
		var bgIndex = this.i.readByte();
		var pixelAspectRatio = this.i.readByte();
		if(pixelAspectRatio != 0) {
			pixelAspectRatio = (pixelAspectRatio + 15) / 64;
		} else {
			pixelAspectRatio = 1;
		}
		var lsd = { width : width, height : height, hasGlobalColorTable : (packedField & 128) == 128, colorResolution : (packedField & 112) >>> 4, sorted : (packedField & 8) == 8, globalColorTableSize : 2 << (packedField & 7), backgroundColorIndex : bgIndex, pixelAspectRatio : pixelAspectRatio};
		var gct = null;
		if(lsd.hasGlobalColorTable) {
			gct = this.readColorTable(lsd.globalColorTableSize);
		}
		var blocks = new haxe_ds_List();
		while(true) {
			var b = this.readBlock();
			blocks.add(b);
			if(b == format_gif_Block.BEOF) {
				break;
			}
		}
		return { version : version, logicalScreenDescriptor : lsd, globalColorTable : gct, blocks : blocks};
	}
	,readBlock: function() {
		var blockID = this.i.readByte();
		switch(blockID) {
		case 33:
			return this.readExtension();
		case 44:
			return this.readImage();
		case 59:
			return format_gif_Block.BEOF;
		}
		return format_gif_Block.BEOF;
	}
	,readImage: function() {
		var x = this.i.readUInt16();
		var y = this.i.readUInt16();
		var width = this.i.readUInt16();
		var height = this.i.readUInt16();
		var packed = this.i.readByte();
		var localColorTable = (packed & 128) == 128;
		var interlaced = (packed & 64) == 64;
		var sorted = (packed & 32) == 32;
		var localColorTableSize = 2 << (packed & 7);
		var lct = null;
		if(localColorTable) {
			lct = this.readColorTable(localColorTableSize);
		}
		return format_gif_Block.BFrame({ x : x, y : y, width : width, height : height, localColorTable : localColorTable, interlaced : interlaced, sorted : sorted, localColorTableSize : localColorTableSize, pixels : this.readPixels(width,height,interlaced), colorTable : lct});
	}
	,readPixels: function(width,height,interlaced) {
		var input = this.i;
		var pixelsCount = width * height;
		var pixels = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
		var minCodeSize = input.readByte();
		var blockSize = input.readByte() - 1;
		var bits = input.readByte();
		var bitsCount = 8;
		var clearCode = 1 << minCodeSize;
		var eoiCode = clearCode + 1;
		var codeSize = minCodeSize + 1;
		var codeSizeLimit = 1 << codeSize;
		var codeMask = codeSizeLimit - 1;
		var baseDict = [];
		var _g = 0;
		var _g1 = clearCode;
		while(_g < _g1) {
			var i = _g++;
			baseDict[i] = [i];
		}
		var dict = [];
		var dictLen = clearCode + 2;
		var newRecord;
		var i = 0;
		var code = 0;
		var last;
		while(i < pixelsCount) {
			last = code;
			while(bitsCount < codeSize) {
				if(blockSize == 0) {
					break;
				}
				bits |= input.readByte() << bitsCount;
				bitsCount += 8;
				--blockSize;
				if(blockSize == 0) {
					blockSize = input.readByte();
				}
			}
			code = bits & codeMask;
			bits >>= codeSize;
			bitsCount -= codeSize;
			if(code == clearCode) {
				dict = baseDict.slice();
				dictLen = clearCode + 2;
				codeSize = minCodeSize + 1;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
				continue;
			}
			if(code == eoiCode) {
				break;
			}
			if(code < dictLen) {
				if(last != clearCode) {
					newRecord = dict[last].slice();
					newRecord.push(dict[code][0]);
					dict[dictLen++] = newRecord;
				}
			} else {
				if(code != dictLen) {
					throw haxe_Exception.thrown("Invalid LZW code. Excepted: " + dictLen + ", got: " + code);
				}
				newRecord = dict[last].slice();
				newRecord.push(newRecord[0]);
				dict[dictLen++] = newRecord;
			}
			newRecord = dict[code];
			var _g = 0;
			while(_g < newRecord.length) {
				var item = newRecord[_g];
				++_g;
				pixels.b[i++] = item;
			}
			if(dictLen == codeSizeLimit && codeSize < 12) {
				++codeSize;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
			}
		}
		while(blockSize > 0) {
			input.readByte();
			--blockSize;
			if(blockSize == 0) {
				blockSize = input.readByte();
			}
		}
		while(i < pixelsCount) pixels.b[i++] = 0;
		if(interlaced) {
			var buffer = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
			var offset = this.deinterlace(pixels,buffer,8,0,0,width,height);
			offset = this.deinterlace(pixels,buffer,8,4,offset,width,height);
			offset = this.deinterlace(pixels,buffer,4,2,offset,width,height);
			this.deinterlace(pixels,buffer,2,1,offset,width,height);
			pixels = buffer;
		}
		return pixels;
	}
	,deinterlace: function(input,output,step,y,offset,width,height) {
		while(y < height) {
			output.blit(y * width,input,offset,width);
			offset += width;
			y += step;
		}
		return offset;
	}
	,readExtension: function() {
		var subId = this.i.readByte();
		switch(subId) {
		case 1:
			if(this.i.readByte() != 12) {
				throw haxe_Exception.thrown("Incorrect size of Plain Text Extension introducer block.");
			}
			var tmp = this.i.readUInt16();
			var tmp1 = this.i.readUInt16();
			var tmp2 = this.i.readUInt16();
			var tmp3 = this.i.readUInt16();
			var tmp4 = this.i.readByte();
			var tmp5 = this.i.readByte();
			var tmp6 = this.i.readByte();
			var tmp7 = this.i.readByte();
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EText({ textGridX : tmp, textGridY : tmp1, textGridWidth : tmp2, textGridHeight : tmp3, charCellWidth : tmp4, charCellHeight : tmp5, textForegroundColorIndex : tmp6, textBackgroundColorIndex : tmp7, text : bytes.toString()}));
		case 249:
			if(this.i.readByte() != 4) {
				throw haxe_Exception.thrown("Incorrect Graphic Control Extension block size!");
			}
			var packed = this.i.readByte();
			var disposalMethod;
			switch((packed & 28) >> 2) {
			case 0:
				disposalMethod = format_gif_DisposalMethod.UNSPECIFIED;
				break;
			case 1:
				disposalMethod = format_gif_DisposalMethod.NO_ACTION;
				break;
			case 2:
				disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND;
				break;
			case 3:
				disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS;
				break;
			default:
				disposalMethod = format_gif_DisposalMethod.UNDEFINED((packed & 28) >> 2);
			}
			var b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl({ disposalMethod : disposalMethod, userInput : (packed & 2) == 2, hasTransparentColor : (packed & 1) == 1, delay : this.i.readUInt16(), transparentIndex : this.i.readByte()}));
			this.i.readByte();
			return b;
		case 254:
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EComment(bytes.toString()));
		case 255:
			return this.readApplicationExtension();
		default:
			var buffer = new haxe_io_BytesOutput();
			var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			var len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,bytes));
		}
	}
	,readApplicationExtension: function() {
		if(this.i.readByte() != 11) {
			throw haxe_Exception.thrown("Incorrect size of Application Extension introducer block.");
		}
		var name = this.i.readString(8);
		var version = this.i.readString(3);
		var buffer = new haxe_io_BytesOutput();
		var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
		var len = this.i.readByte();
		while(len != 0) {
			this.i.readBytes(bytes,0,len);
			buffer.writeBytes(bytes,0,len);
			len = this.i.readByte();
		}
		buffer.flush();
		bytes = buffer.getBytes();
		buffer.close();
		var data = bytes;
		if(name == "NETSCAPE" && version == "2.0" && data.b[0] == 1) {
			return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping(data.b[1] | data.b[2] << 8)));
		}
		return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)));
	}
	,readBlocks: function() {
		var buffer = new haxe_io_BytesOutput();
		var bytes = new haxe_io_Bytes(new ArrayBuffer(255));
		var len = this.i.readByte();
		while(len != 0) {
			this.i.readBytes(bytes,0,len);
			buffer.writeBytes(bytes,0,len);
			len = this.i.readByte();
		}
		buffer.flush();
		bytes = buffer.getBytes();
		buffer.close();
		return bytes;
	}
	,readColorTable: function(size) {
		size *= 3;
		var output = new haxe_io_Bytes(new ArrayBuffer(size));
		var c = 0;
		while(c < size) {
			var v = this.i.readByte();
			output.b[c] = v;
			var v1 = this.i.readByte();
			output.b[c + 1] = v1;
			var v2 = this.i.readByte();
			output.b[c + 2] = v2;
			c += 3;
		}
		return output;
	}
	,__class__: format_gif_Reader
};
var format_gif_Tools = function() { };
$hxClasses["format.gif.Tools"] = format_gif_Tools;
format_gif_Tools.__name__ = "format.gif.Tools";
format_gif_Tools.framesCount = function(data) {
	var frames = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		if(block._hx_index == 0) {
			var _g = block.frame;
			++frames;
		}
	}
	return frames;
};
format_gif_Tools.frame = function(data,frameIndex) {
	var counter = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		if(block._hx_index == 0) {
			var frame = block.frame;
			if(counter == frameIndex) {
				return frame;
			}
			++counter;
		}
	}
	return null;
};
format_gif_Tools.graphicControl = function(data,frameIndex) {
	var counter = 0;
	var gce = null;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			if(counter == frameIndex) {
				return gce;
			}
			gce = null;
			++counter;
			break;
		case 1:
			var _g = block.extension;
			if(_g._hx_index == 0) {
				var g = _g.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return null;
};
format_gif_Tools.extractBGRA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			if(frameCaret == frameIndex) {
				var bytes = new haxe_io_Bytes(new ArrayBuffer(frame.width * frame.height * 4));
				var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
				if(ct == null) {
					throw haxe_Exception.thrown("Frame does not have a color table!");
				}
				var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
				var writeCaret = 0;
				var _g = 0;
				var _g1 = frame.pixels.length;
				while(_g < _g1) {
					var i = _g++;
					var index = frame.pixels.b[i] * 3;
					bytes.b[writeCaret] = ct.b[index + 2];
					bytes.b[writeCaret + 1] = ct.b[index + 1];
					bytes.b[writeCaret + 2] = ct.b[index];
					if(transparentIndex == index) {
						bytes.b[writeCaret + 3] = 0;
					} else {
						bytes.b[writeCaret + 3] = 255;
					}
					writeCaret += 4;
				}
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return null;
};
format_gif_Tools.extractRGBA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			if(frameCaret == frameIndex) {
				var bytes = new haxe_io_Bytes(new ArrayBuffer(frame.width * frame.height * 4));
				var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
				if(ct == null) {
					throw haxe_Exception.thrown("Frame does not have a color table!");
				}
				var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
				var writeCaret = 0;
				var _g = 0;
				var _g1 = frame.pixels.length;
				while(_g < _g1) {
					var i = _g++;
					var index = frame.pixels.b[i] * 3;
					bytes.b[writeCaret] = ct.b[index];
					bytes.b[writeCaret + 1] = ct.b[index + 1];
					bytes.b[writeCaret + 2] = ct.b[index + 2];
					if(transparentIndex == index) {
						bytes.b[writeCaret + 3] = 0;
					} else {
						bytes.b[writeCaret + 3] = 255;
					}
					writeCaret += 4;
				}
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return null;
};
format_gif_Tools.extractFullBGRA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
			if(ct == null) {
				throw haxe_Exception.thrown("Frame does not have a color table!");
			}
			var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
			var pixels = frame.pixels;
			var x = 0;
			var writeCaret = (frame.y * data.logicalScreenDescriptor.width + frame.x) * 4;
			var lineSkip = (data.logicalScreenDescriptor.width - frame.width) * 4 + 4;
			var disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
			switch(disposalMethod._hx_index) {
			case 2:
				var _g = 0;
				var _g1 = pixels.length;
				while(_g < _g1) {
					var i = _g++;
					bytes.b[writeCaret] = 0;
					bytes.b[writeCaret + 1] = 0;
					bytes.b[writeCaret + 2] = 0;
					bytes.b[writeCaret + 3] = 0;
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
				break;
			case 3:
				break;
			default:
				var _g2 = 0;
				var _g3 = pixels.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var index = pixels.b[i1] * 3;
					if(transparentIndex != index) {
						bytes.b[writeCaret] = ct.b[index + 2];
						bytes.b[writeCaret + 1] = ct.b[index + 1];
						bytes.b[writeCaret + 2] = ct.b[index];
						bytes.b[writeCaret + 3] = 255;
					}
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
			}
			if(frameCaret == frameIndex) {
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return bytes;
};
format_gif_Tools.extractFullRGBA = function(data,frameIndex) {
	var gce = null;
	var frameCaret = 0;
	var bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		switch(block._hx_index) {
		case 0:
			var frame = block.frame;
			var ct = frame.localColorTable ? frame.colorTable : data.globalColorTable;
			if(ct == null) {
				throw haxe_Exception.thrown("Frame does not have a color table!");
			}
			var transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
			var pixels = frame.pixels;
			var x = 0;
			var writeCaret = (frame.y * data.logicalScreenDescriptor.width + frame.x) * 4;
			var lineSkip = (data.logicalScreenDescriptor.width - frame.width) * 4 + 4;
			var disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
			switch(disposalMethod._hx_index) {
			case 2:
				var _g = 0;
				var _g1 = pixels.length;
				while(_g < _g1) {
					var i = _g++;
					bytes.b[writeCaret] = 0;
					bytes.b[writeCaret + 1] = 0;
					bytes.b[writeCaret + 2] = 0;
					bytes.b[writeCaret + 3] = 0;
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
				break;
			case 3:
				break;
			default:
				var _g2 = 0;
				var _g3 = pixels.length;
				while(_g2 < _g3) {
					var i1 = _g2++;
					var index = pixels.b[i1] * 3;
					if(transparentIndex != index) {
						bytes.b[writeCaret] = ct.b[index];
						bytes.b[writeCaret + 1] = ct.b[index + 1];
						bytes.b[writeCaret + 2] = ct.b[index + 2];
						bytes.b[writeCaret + 3] = 255;
					}
					if(++x == frame.width) {
						x = 0;
						writeCaret += lineSkip;
					} else {
						writeCaret += 4;
					}
				}
			}
			if(frameCaret == frameIndex) {
				return bytes;
			}
			++frameCaret;
			gce = null;
			break;
		case 1:
			var ext = block.extension;
			if(ext._hx_index == 0) {
				var g = ext.gce;
				gce = g;
			}
			break;
		default:
		}
	}
	return bytes;
};
format_gif_Tools.loopCount = function(data) {
	var _g_head = data.blocks.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var block = val;
		if(block._hx_index == 1) {
			var _g = block.extension;
			if(_g._hx_index == 3) {
				var _g1 = _g.ext;
				if(_g1._hx_index == 0) {
					var loops = _g1.loops;
					return loops;
				}
			}
		}
	}
	return 1;
};
format_gif_Tools.log2 = function(val) {
	return Math.log(val) / format_gif_Tools.LN2;
};
var format_mp3_SamplingRate = $hxEnums["format.mp3.SamplingRate"] = { __ename__:"format.mp3.SamplingRate",__constructs__:null
	,SR_8000: {_hx_name:"SR_8000",_hx_index:0,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_11025: {_hx_name:"SR_11025",_hx_index:1,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_12000: {_hx_name:"SR_12000",_hx_index:2,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_22050: {_hx_name:"SR_22050",_hx_index:3,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_24000: {_hx_name:"SR_24000",_hx_index:4,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_32000: {_hx_name:"SR_32000",_hx_index:5,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_44100: {_hx_name:"SR_44100",_hx_index:6,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_48000: {_hx_name:"SR_48000",_hx_index:7,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_Bad: {_hx_name:"SR_Bad",_hx_index:8,__enum__:"format.mp3.SamplingRate",toString:$estr}
};
format_mp3_SamplingRate.__constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
format_mp3_SamplingRate.__empty_constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
var format_mp3_Bitrate = $hxEnums["format.mp3.Bitrate"] = { __ename__:"format.mp3.Bitrate",__constructs__:null
	,BR_8: {_hx_name:"BR_8",_hx_index:0,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_16: {_hx_name:"BR_16",_hx_index:1,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_24: {_hx_name:"BR_24",_hx_index:2,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_32: {_hx_name:"BR_32",_hx_index:3,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_40: {_hx_name:"BR_40",_hx_index:4,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_48: {_hx_name:"BR_48",_hx_index:5,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_56: {_hx_name:"BR_56",_hx_index:6,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_64: {_hx_name:"BR_64",_hx_index:7,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_80: {_hx_name:"BR_80",_hx_index:8,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_96: {_hx_name:"BR_96",_hx_index:9,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_112: {_hx_name:"BR_112",_hx_index:10,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_128: {_hx_name:"BR_128",_hx_index:11,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_144: {_hx_name:"BR_144",_hx_index:12,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_160: {_hx_name:"BR_160",_hx_index:13,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_176: {_hx_name:"BR_176",_hx_index:14,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_192: {_hx_name:"BR_192",_hx_index:15,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_224: {_hx_name:"BR_224",_hx_index:16,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_256: {_hx_name:"BR_256",_hx_index:17,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_288: {_hx_name:"BR_288",_hx_index:18,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_320: {_hx_name:"BR_320",_hx_index:19,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_352: {_hx_name:"BR_352",_hx_index:20,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_384: {_hx_name:"BR_384",_hx_index:21,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_416: {_hx_name:"BR_416",_hx_index:22,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_448: {_hx_name:"BR_448",_hx_index:23,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Free: {_hx_name:"BR_Free",_hx_index:24,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Bad: {_hx_name:"BR_Bad",_hx_index:25,__enum__:"format.mp3.Bitrate",toString:$estr}
};
format_mp3_Bitrate.__constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
format_mp3_Bitrate.__empty_constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
var format_mp3_MPEG = function() { };
$hxClasses["format.mp3.MPEG"] = format_mp3_MPEG;
format_mp3_MPEG.__name__ = "format.mp3.MPEG";
format_mp3_MPEG.enum2Num = function(m) {
	switch(m._hx_index) {
	case 0:
		return 3;
	case 1:
		return 2;
	case 2:
		return 0;
	case 3:
		return format_mp3_MPEG.Reserved;
	}
};
format_mp3_MPEG.num2Enum = function(m) {
	switch(m) {
	case 0:
		return format_mp3_MPEGVersion.MPEG_V25;
	case 2:
		return format_mp3_MPEGVersion.MPEG_V2;
	case 3:
		return format_mp3_MPEGVersion.MPEG_V1;
	default:
		return format_mp3_MPEGVersion.MPEG_Reserved;
	}
};
format_mp3_MPEG.srNum2Enum = function(sr) {
	switch(sr) {
	case 8000:
		return format_mp3_SamplingRate.SR_8000;
	case 11025:
		return format_mp3_SamplingRate.SR_11025;
	case 12000:
		return format_mp3_SamplingRate.SR_12000;
	case 22050:
		return format_mp3_SamplingRate.SR_22050;
	case 24000:
		return format_mp3_SamplingRate.SR_24000;
	case 32000:
		return format_mp3_SamplingRate.SR_32000;
	case 44100:
		return format_mp3_SamplingRate.SR_44100;
	case 48000:
		return format_mp3_SamplingRate.SR_48000;
	default:
		return format_mp3_SamplingRate.SR_Bad;
	}
};
format_mp3_MPEG.srEnum2Num = function(sr) {
	switch(sr._hx_index) {
	case 0:
		return 8000;
	case 1:
		return 11025;
	case 2:
		return 12000;
	case 3:
		return 22050;
	case 4:
		return 24000;
	case 5:
		return 32000;
	case 6:
		return 44100;
	case 7:
		return 48000;
	case 8:
		return -1;
	}
};
format_mp3_MPEG.getBitrateIdx = function(br,mpeg,layer) {
	var arr = (mpeg == format_mp3_MPEGVersion.MPEG_V1 ? format_mp3_MPEG.V1_Bitrates : format_mp3_MPEG.V2_Bitrates)[format_mp3_CLayer.enum2Num(layer)];
	if(arr[0] == br) {
		return 0;
	}
	if(arr[1] == br) {
		return 1;
	}
	if(arr[2] == br) {
		return 2;
	}
	if(arr[3] == br) {
		return 3;
	}
	if(arr[4] == br) {
		return 4;
	}
	if(arr[5] == br) {
		return 5;
	}
	if(arr[6] == br) {
		return 6;
	}
	if(arr[7] == br) {
		return 7;
	}
	if(arr[8] == br) {
		return 8;
	}
	if(arr[9] == br) {
		return 9;
	}
	if(arr[10] == br) {
		return 10;
	}
	if(arr[11] == br) {
		return 11;
	}
	if(arr[12] == br) {
		return 12;
	}
	if(arr[13] == br) {
		return 13;
	}
	if(arr[14] == br) {
		return 14;
	}
	if(arr[15] == br) {
		return 15;
	}
	throw haxe_Exception.thrown("Bitrate index not found");
};
format_mp3_MPEG.getSamplingRateIdx = function(sr,mpeg) {
	var arr = format_mp3_MPEG.SamplingRates[format_mp3_MPEG.enum2Num(mpeg)];
	if(arr[0] == sr) {
		return 0;
	}
	if(arr[1] == sr) {
		return 1;
	}
	if(arr[2] == sr) {
		return 2;
	}
	if(arr[3] == sr) {
		return 3;
	}
	throw haxe_Exception.thrown("Sampling rate index not found");
};
format_mp3_MPEG.bitrateEnum2Num = function(br) {
	switch(br._hx_index) {
	case 0:
		return 8;
	case 1:
		return 16;
	case 2:
		return 24;
	case 3:
		return 32;
	case 4:
		return 40;
	case 5:
		return 48;
	case 6:
		return 56;
	case 7:
		return 64;
	case 8:
		return 80;
	case 9:
		return 96;
	case 10:
		return 112;
	case 11:
		return 128;
	case 12:
		return 144;
	case 13:
		return 160;
	case 14:
		return 176;
	case 15:
		return 192;
	case 16:
		return 224;
	case 17:
		return 256;
	case 18:
		return 288;
	case 19:
		return 320;
	case 20:
		return 352;
	case 21:
		return 384;
	case 22:
		return 416;
	case 23:
		return 448;
	case 24:
		return 0;
	case 25:
		return -1;
	}
};
format_mp3_MPEG.bitrateNum2Enum = function(br) {
	switch(br) {
	case 0:
		return format_mp3_Bitrate.BR_Free;
	case 8:
		return format_mp3_Bitrate.BR_8;
	case 16:
		return format_mp3_Bitrate.BR_16;
	case 24:
		return format_mp3_Bitrate.BR_24;
	case 32:
		return format_mp3_Bitrate.BR_32;
	case 40:
		return format_mp3_Bitrate.BR_40;
	case 48:
		return format_mp3_Bitrate.BR_48;
	case 56:
		return format_mp3_Bitrate.BR_56;
	case 64:
		return format_mp3_Bitrate.BR_64;
	case 80:
		return format_mp3_Bitrate.BR_80;
	case 96:
		return format_mp3_Bitrate.BR_96;
	case 112:
		return format_mp3_Bitrate.BR_112;
	case 128:
		return format_mp3_Bitrate.BR_128;
	case 144:
		return format_mp3_Bitrate.BR_144;
	case 160:
		return format_mp3_Bitrate.BR_160;
	case 176:
		return format_mp3_Bitrate.BR_176;
	case 192:
		return format_mp3_Bitrate.BR_192;
	case 224:
		return format_mp3_Bitrate.BR_224;
	case 256:
		return format_mp3_Bitrate.BR_256;
	case 288:
		return format_mp3_Bitrate.BR_288;
	case 320:
		return format_mp3_Bitrate.BR_320;
	case 352:
		return format_mp3_Bitrate.BR_352;
	case 384:
		return format_mp3_Bitrate.BR_384;
	case 416:
		return format_mp3_Bitrate.BR_416;
	case 448:
		return format_mp3_Bitrate.BR_448;
	default:
		return format_mp3_Bitrate.BR_Bad;
	}
};
var format_mp3_CLayer = function() { };
$hxClasses["format.mp3.CLayer"] = format_mp3_CLayer;
format_mp3_CLayer.__name__ = "format.mp3.CLayer";
format_mp3_CLayer.enum2Num = function(l) {
	switch(l._hx_index) {
	case 0:
		return format_mp3_CLayer.LReserved;
	case 1:
		return format_mp3_CLayer.LLayer3;
	case 2:
		return format_mp3_CLayer.LLayer2;
	case 3:
		return format_mp3_CLayer.LLayer1;
	}
};
format_mp3_CLayer.num2Enum = function(l) {
	switch(l) {
	case 1:
		return format_mp3_Layer.Layer3;
	case 2:
		return format_mp3_Layer.Layer2;
	case 3:
		return format_mp3_Layer.Layer1;
	default:
		return format_mp3_Layer.LayerReserved;
	}
};
var format_mp3_CChannelMode = function() { };
$hxClasses["format.mp3.CChannelMode"] = format_mp3_CChannelMode;
format_mp3_CChannelMode.__name__ = "format.mp3.CChannelMode";
format_mp3_CChannelMode.enum2Num = function(c) {
	switch(c._hx_index) {
	case 0:
		return 0;
	case 1:
		return 1;
	case 2:
		return 2;
	case 3:
		return 3;
	}
};
format_mp3_CChannelMode.num2Enum = function(c) {
	switch(c) {
	case 0:
		return format_mp3_ChannelMode.Stereo;
	case 1:
		return format_mp3_ChannelMode.JointStereo;
	case 2:
		return format_mp3_ChannelMode.DualChannel;
	case 3:
		return format_mp3_ChannelMode.Mono;
	default:
		throw haxe_Exception.thrown("assert");
	}
};
var format_mp3_CEmphasis = function() { };
$hxClasses["format.mp3.CEmphasis"] = format_mp3_CEmphasis;
format_mp3_CEmphasis.__name__ = "format.mp3.CEmphasis";
format_mp3_CEmphasis.enum2Num = function(c) {
	switch(c._hx_index) {
	case 0:
		return 0;
	case 1:
		return 1;
	case 2:
		return 3;
	case 3:
		return 2;
	}
};
format_mp3_CEmphasis.num2Enum = function(c) {
	switch(c) {
	case 0:
		return format_mp3_Emphasis.NoEmphasis;
	case 1:
		return format_mp3_Emphasis.Ms50_15;
	case 2:
		return format_mp3_Emphasis.InvalidEmphasis;
	case 3:
		return format_mp3_Emphasis.CCIT_J17;
	default:
		throw haxe_Exception.thrown("assert");
	}
};
var format_mp3_MPEGVersion = $hxEnums["format.mp3.MPEGVersion"] = { __ename__:"format.mp3.MPEGVersion",__constructs__:null
	,MPEG_V1: {_hx_name:"MPEG_V1",_hx_index:0,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V2: {_hx_name:"MPEG_V2",_hx_index:1,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V25: {_hx_name:"MPEG_V25",_hx_index:2,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_Reserved: {_hx_name:"MPEG_Reserved",_hx_index:3,__enum__:"format.mp3.MPEGVersion",toString:$estr}
};
format_mp3_MPEGVersion.__constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
format_mp3_MPEGVersion.__empty_constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
var format_mp3_Layer = $hxEnums["format.mp3.Layer"] = { __ename__:"format.mp3.Layer",__constructs__:null
	,LayerReserved: {_hx_name:"LayerReserved",_hx_index:0,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer3: {_hx_name:"Layer3",_hx_index:1,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer2: {_hx_name:"Layer2",_hx_index:2,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer1: {_hx_name:"Layer1",_hx_index:3,__enum__:"format.mp3.Layer",toString:$estr}
};
format_mp3_Layer.__constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
format_mp3_Layer.__empty_constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
var format_mp3_ChannelMode = $hxEnums["format.mp3.ChannelMode"] = { __ename__:"format.mp3.ChannelMode",__constructs__:null
	,Stereo: {_hx_name:"Stereo",_hx_index:0,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,JointStereo: {_hx_name:"JointStereo",_hx_index:1,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,DualChannel: {_hx_name:"DualChannel",_hx_index:2,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,Mono: {_hx_name:"Mono",_hx_index:3,__enum__:"format.mp3.ChannelMode",toString:$estr}
};
format_mp3_ChannelMode.__constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
format_mp3_ChannelMode.__empty_constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
var format_mp3_Emphasis = $hxEnums["format.mp3.Emphasis"] = { __ename__:"format.mp3.Emphasis",__constructs__:null
	,NoEmphasis: {_hx_name:"NoEmphasis",_hx_index:0,__enum__:"format.mp3.Emphasis",toString:$estr}
	,Ms50_15: {_hx_name:"Ms50_15",_hx_index:1,__enum__:"format.mp3.Emphasis",toString:$estr}
	,CCIT_J17: {_hx_name:"CCIT_J17",_hx_index:2,__enum__:"format.mp3.Emphasis",toString:$estr}
	,InvalidEmphasis: {_hx_name:"InvalidEmphasis",_hx_index:3,__enum__:"format.mp3.Emphasis",toString:$estr}
};
format_mp3_Emphasis.__constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
format_mp3_Emphasis.__empty_constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
var format_mp3_FrameType = $hxEnums["format.mp3.FrameType"] = { __ename__:"format.mp3.FrameType",__constructs__:null
	,FT_MP3: {_hx_name:"FT_MP3",_hx_index:0,__enum__:"format.mp3.FrameType",toString:$estr}
	,FT_NONE: {_hx_name:"FT_NONE",_hx_index:1,__enum__:"format.mp3.FrameType",toString:$estr}
};
format_mp3_FrameType.__constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
format_mp3_FrameType.__empty_constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
var format_mp3_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.bits = new format_tools_BitsInput(i);
	this.samples = 0;
	this.sampleSize = 0;
	this.any_read = false;
};
$hxClasses["format.mp3.Reader"] = format_mp3_Reader;
format_mp3_Reader.__name__ = "format.mp3.Reader";
format_mp3_Reader.prototype = {
	skipID3v2: function() {
		this.id3v2_version = this.i.readUInt16();
		this.id3v2_flags = this.i.readByte();
		var size = this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		this.id3v2_data = this.i.read(size);
	}
	,seekFrame: function() {
		var found = false;
		try {
			var b;
			while(true) {
				b = this.i.readByte();
				if(!this.any_read) {
					this.any_read = true;
					if(b == 73) {
						b = this.i.readByte();
						if(b == 68) {
							b = this.i.readByte();
							if(b == 51) {
								this.skipID3v2();
							}
						}
					}
				}
				if(b == 255) {
					this.bits.nbits = 0;
					b = this.bits.readBits(3);
					if(b == 7) {
						return format_mp3_FrameType.FT_MP3;
					}
				}
			}
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return format_mp3_FrameType.FT_NONE;
			} else {
				throw _g;
			}
		}
	}
	,readFrames: function() {
		var frames = [];
		var ft;
		while(true) {
			ft = this.seekFrame();
			if(!(ft != format_mp3_FrameType.FT_NONE)) {
				break;
			}
			switch(ft._hx_index) {
			case 0:
				var f = this.readFrame();
				if(f != null) {
					frames.push(f);
				}
				break;
			case 1:
				break;
			}
		}
		return frames;
	}
	,readFrameHeader: function() {
		var version = this.bits.readBits(2);
		var layer = this.bits.readBits(2);
		var hasCrc = !this.bits.readBit();
		if(version == format_mp3_MPEG.Reserved || layer == format_mp3_CLayer.LReserved) {
			return null;
		}
		var bitrateIdx = this.bits.readBits(4);
		var bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx);
		var samplingRateIdx = this.bits.readBits(2);
		var samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx);
		var isPadded = this.bits.readBit();
		var privateBit = this.bits.readBit();
		if(bitrate == format_mp3_Bitrate.BR_Bad || bitrate == format_mp3_Bitrate.BR_Free || samplingRate == format_mp3_SamplingRate.SR_Bad) {
			return null;
		}
		var channelMode = this.bits.readBits(2);
		var isIntensityStereo = this.bits.readBit();
		var isMSStereo = this.bits.readBit();
		var isCopyrighted = this.bits.readBit();
		var isOriginal = this.bits.readBit();
		var emphasis = this.bits.readBits(2);
		var crc16 = 0;
		if(hasCrc) {
			crc16 = this.i.readUInt16();
		}
		return { version : format_mp3_MPEG.num2Enum(version), layer : format_mp3_CLayer.num2Enum(layer), hasCrc : hasCrc, crc16 : crc16, bitrate : bitrate, samplingRate : samplingRate, isPadded : isPadded, privateBit : privateBit, channelMode : format_mp3_CChannelMode.num2Enum(channelMode), isIntensityStereo : isIntensityStereo, isMSStereo : isMSStereo, isCopyrighted : isCopyrighted, isOriginal : isOriginal, emphasis : format_mp3_CEmphasis.num2Enum(emphasis)};
	}
	,readFrame: function() {
		var header = this.readFrameHeader();
		if(header == null || format_mp3_Tools.isInvalidFrameHeader(header)) {
			return null;
		}
		try {
			var data = this.i.read(format_mp3_Tools.getSampleDataSizeHdr(header));
			this.samples += format_mp3_Tools.getSampleCountHdr(header);
			this.sampleSize += data.length;
			return { header : header, data : data};
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	,read: function() {
		var fs = this.readFrames();
		return { frames : fs, sampleCount : this.samples, sampleSize : this.sampleSize, id3v2 : this.id3v2_data == null ? null : { versionBytes : this.id3v2_version, flagByte : this.id3v2_flags, data : this.id3v2_data}};
	}
	,__class__: format_mp3_Reader
};
var format_mp3_Tools = function() { };
$hxClasses["format.mp3.Tools"] = format_mp3_Tools;
format_mp3_Tools.__name__ = "format.mp3.Tools";
format_mp3_Tools.getBitrate = function(mpegVersion,layerIdx,bitrateIdx) {
	if(mpegVersion == format_mp3_MPEG.Reserved || layerIdx == format_mp3_CLayer.LReserved) {
		return format_mp3_Bitrate.BR_Bad;
	}
	return (mpegVersion == 3 ? format_mp3_MPEG.V1_Bitrates : format_mp3_MPEG.V2_Bitrates)[layerIdx][bitrateIdx];
};
format_mp3_Tools.getSamplingRate = function(mpegVersion,samplingRateIdx) {
	return format_mp3_MPEG.SamplingRates[mpegVersion][samplingRateIdx];
};
format_mp3_Tools.isInvalidFrameHeader = function(hdr) {
	if(!(hdr.version == format_mp3_MPEGVersion.MPEG_Reserved || hdr.layer == format_mp3_Layer.LayerReserved || hdr.bitrate == format_mp3_Bitrate.BR_Bad || hdr.bitrate == format_mp3_Bitrate.BR_Free)) {
		return hdr.samplingRate == format_mp3_SamplingRate.SR_Bad;
	} else {
		return true;
	}
};
format_mp3_Tools.getSampleDataSize = function(mpegVersion,bitrate,samplingRate,isPadded,hasCrc) {
	return ((mpegVersion == 3 ? 144 : 72) * bitrate * 1000 / samplingRate | 0) + (isPadded ? 1 : 0) - (hasCrc ? 2 : 0) - 4;
};
format_mp3_Tools.getSampleDataSizeHdr = function(hdr) {
	return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc);
};
format_mp3_Tools.getSampleCount = function(mpegVersion) {
	if(mpegVersion == 3) {
		return 1152;
	} else {
		return 576;
	}
};
format_mp3_Tools.getSampleCountHdr = function(hdr) {
	return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version));
};
format_mp3_Tools.getFrameInfo = function(fr) {
	return Std.string(fr.header.version) + ", " + Std.string(fr.header.layer) + ", " + Std.string(fr.header.channelMode) + ", " + Std.string(fr.header.samplingRate) + " Hz, " + Std.string(fr.header.bitrate) + " kbps " + "Emphasis: " + Std.string(fr.header.emphasis) + ", " + (fr.header.hasCrc ? "(CRC) " : "") + (fr.header.isPadded ? "(Padded) " : "") + (fr.header.isIntensityStereo ? "(Intensity Stereo) " : "") + (fr.header.isMSStereo ? "(MS Stereo) " : "") + (fr.header.isCopyrighted ? "(Copyrighted) " : "") + (fr.header.isOriginal ? "(Original) " : "");
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__:"format.png.Color",__constructs__:null
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColGrey",$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColTrue",$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_name:"ColIndexed",_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
format_png_Color.__constructs__ = [format_png_Color.ColGrey,format_png_Color.ColTrue,format_png_Color.ColIndexed];
format_png_Color.__empty_constructs__ = [format_png_Color.ColIndexed];
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__:"format.png.Chunk",__constructs__:null
	,CEnd: {_hx_name:"CEnd",_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CHeader",$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CData",$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CPalette",$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CUnknown",$_.__params__ = ["id","data"],$_)
};
format_png_Chunk.__constructs__ = [format_png_Chunk.CEnd,format_png_Chunk.CHeader,format_png_Chunk.CData,format_png_Chunk.CPalette,format_png_Chunk.CUnknown];
format_png_Chunk.__empty_constructs__ = [format_png_Chunk.CEnd];
var format_png_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.checkCRC = true;
};
$hxClasses["format.png.Reader"] = format_png_Reader;
format_png_Reader.__name__ = "format.png.Reader";
format_png_Reader.prototype = {
	read: function() {
		var b = 137;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 80;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 78;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 71;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 13;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 10;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 26;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var b = 10;
		if(this.i.readByte() != b) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var l = new haxe_ds_List();
		while(true) {
			var c = this.readChunk();
			l.add(c);
			if(c == format_png_Chunk.CEnd) {
				break;
			}
		}
		return l;
	}
	,readHeader: function(i) {
		i.set_bigEndian(true);
		var width = i.readInt32();
		var height = i.readInt32();
		var colbits = i.readByte();
		var color = i.readByte();
		var color1;
		switch(color) {
		case 0:
			color1 = format_png_Color.ColGrey(false);
			break;
		case 2:
			color1 = format_png_Color.ColTrue(false);
			break;
		case 3:
			color1 = format_png_Color.ColIndexed;
			break;
		case 4:
			color1 = format_png_Color.ColGrey(true);
			break;
		case 6:
			color1 = format_png_Color.ColTrue(true);
			break;
		default:
			throw haxe_Exception.thrown("Unknown color model " + color + ":" + colbits);
		}
		var compress = i.readByte();
		var filter = i.readByte();
		if(compress != 0 || filter != 0) {
			throw haxe_Exception.thrown("Invalid header");
		}
		var interlace = i.readByte();
		if(interlace != 0 && interlace != 1) {
			throw haxe_Exception.thrown("Invalid header");
		}
		return { width : width, height : height, colbits : colbits, color : color1, interlaced : interlace == 1};
	}
	,readChunk: function() {
		var dataLen = this.i.readInt32();
		var id = this.i.readString(4);
		var data = this.i.read(dataLen);
		var crc = this.i.readInt32();
		if(this.checkCRC) {
			var c_crc = -1;
			var tmp = (c_crc ^ HxOverrides.cca(id,0)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,1)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,2)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp = (c_crc ^ HxOverrides.cca(id,3)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var b = data.b.bufferValue;
			var _g = 0;
			var _g1 = data.length;
			while(_g < _g1) {
				var i = _g++;
				var tmp = (c_crc ^ b.bytes[i]) & 255;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				c_crc = c_crc >>> 8 ^ tmp;
			}
			if((c_crc ^ -1) != crc) {
				throw haxe_Exception.thrown("CRC check failure");
			}
		}
		switch(id) {
		case "IDAT":
			return format_png_Chunk.CData(data);
		case "IEND":
			return format_png_Chunk.CEnd;
		case "IHDR":
			return format_png_Chunk.CHeader(this.readHeader(new haxe_io_BytesInput(data)));
		case "PLTE":
			return format_png_Chunk.CPalette(data);
		default:
			return format_png_Chunk.CUnknown(id,data);
		}
	}
	,__class__: format_png_Reader
};
var format_png_Tools = function() { };
$hxClasses["format.png.Tools"] = format_png_Tools;
format_png_Tools.__name__ = "format.png.Tools";
format_png_Tools.getHeader = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 1) {
			var h = c.h;
			return h;
		}
	}
	throw haxe_Exception.thrown("Header not found");
};
format_png_Tools.getPalette = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 3) {
			var b = c.b;
			return b;
		}
	}
	return null;
};
format_png_Tools.filter = function(data,x,y,stride,prev,p,numChannels) {
	if(numChannels == null) {
		numChannels = 4;
	}
	var b = y == 0 ? 0 : data.b[p - stride];
	var c = x == 0 || y == 0 ? 0 : data.b[p - stride - numChannels];
	var k = prev + b - c;
	var pa = k - prev;
	if(pa < 0) {
		pa = -pa;
	}
	var pb = k - b;
	if(pb < 0) {
		pb = -pb;
	}
	var pc = k - c;
	if(pc < 0) {
		pc = -pc;
	}
	if(pa <= pb && pa <= pc) {
		return prev;
	} else if(pb <= pc) {
		return b;
	} else {
		return c;
	}
};
format_png_Tools.reverseBytes = function(b) {
	var p = 0;
	var _g = 0;
	var _g1 = b.length >> 2;
	while(_g < _g1) {
		var i = _g++;
		var b1 = b.b[p];
		var g = b.b[p + 1];
		var r = b.b[p + 2];
		var a = b.b[p + 3];
		b.b[p++] = a;
		b.b[p++] = r;
		b.b[p++] = g;
		b.b[p++] = b1;
	}
};
format_png_Tools.extractGrey = function(d) {
	var h = format_png_Tools.getHeader(d);
	var grey = new haxe_io_Bytes(new ArrayBuffer(h.width * h.height));
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var _g = h.color;
	if(_g._hx_index == 0) {
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var rinc = alpha ? 2 : 1;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				var _g2 = 0;
				var _g3 = width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = data.b[r];
					r += rinc;
					grey.b[w++] = v;
				}
				break;
			case 1:
				var cv = 0;
				var _g4 = 0;
				var _g5 = width;
				while(_g4 < _g5) {
					var x1 = _g4++;
					cv += data.b[r];
					r += rinc;
					grey.b[w++] = cv;
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width;
				var _g6 = 0;
				var _g7 = width;
				while(_g6 < _g7) {
					var x2 = _g6++;
					var v1 = data.b[r] + grey.b[w - stride];
					r += rinc;
					grey.b[w++] = v1;
				}
				break;
			case 3:
				var cv1 = 0;
				var stride1 = y == 0 ? 0 : width;
				var _g8 = 0;
				var _g9 = width;
				while(_g8 < _g9) {
					var x3 = _g8++;
					cv1 = data.b[r] + (cv1 + grey.b[w - stride1] >> 1) & 255;
					r += rinc;
					grey.b[w++] = cv1;
				}
				break;
			case 4:
				var stride2 = width;
				var cv2 = 0;
				var _g10 = 0;
				var _g11 = width;
				while(_g10 < _g11) {
					var x4 = _g10++;
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b = y == 0 ? 0 : grey.b[w - stride2];
					var c = x4 == 0 || y == 0 ? 0 : grey.b[w - stride2 - numChannels];
					var k = cv2 + b - c;
					var pa = k - cv2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c;
					if(pc < 0) {
						pc = -pc;
					}
					cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[r] & 255;
					r += rinc;
					grey.b[w++] = cv2;
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
		}
	} else {
		throw haxe_Exception.thrown("Unsupported color mode");
	}
	return grey;
};
format_png_Tools.extract32 = function(d,bytes,flipY) {
	var h = format_png_Tools.getHeader(d);
	var bgra = bytes == null ? new haxe_io_Bytes(new ArrayBuffer(h.width * h.height * 4)) : bytes;
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var lineDelta = 0;
	if(flipY) {
		lineDelta = -h.width * 8;
		w = (h.height - 1) * (h.width * 4);
	}
	var flipY1 = flipY ? -1 : 1;
	var _g = h.color;
	switch(_g._hx_index) {
	case 0:
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var alphvaIdx = -1;
		if(!alpha) {
			var _g_head = d.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var t = val;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 2) {
							alphvaIdx = data1.b[1];
						}
						break;
					}
				}
			}
		}
		var _g1 = 0;
		var _g2 = h.height;
		while(_g1 < _g2) {
			var y = _g1++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g3 = 0;
					var _g4 = width;
					while(_g3 < _g4) {
						var x = _g3++;
						var v = data.b[r++];
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = data.b[r++];
					}
				} else {
					var _g5 = 0;
					var _g6 = width;
					while(_g5 < _g6) {
						var x1 = _g5++;
						var v1 = data.b[r++];
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 1:
				var cv = 0;
				var ca = 0;
				if(alpha) {
					var _g7 = 0;
					var _g8 = width;
					while(_g7 < _g8) {
						var x2 = _g7++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						ca += data.b[r++];
						bgra.b[w++] = ca;
					}
				} else {
					var _g9 = 0;
					var _g10 = width;
					while(_g9 < _g10) {
						var x3 = _g9++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g11 = 0;
					var _g12 = width;
					while(_g11 < _g12) {
						var x4 = _g11++;
						var v2 = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						var va = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = va;
					}
				} else {
					var _g13 = 0;
					var _g14 = width;
					while(_g13 < _g14) {
						var x5 = _g13++;
						var v3 = data.b[r++] + bgra.b[w - stride];
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 3:
				var cv1 = 0;
				var ca1 = 0;
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g15 = 0;
					var _g16 = width;
					while(_g15 < _g16) {
						var x6 = _g15++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						ca1 = data.b[r++] + (ca1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = ca1;
					}
				} else {
					var _g17 = 0;
					var _g18 = width;
					while(_g17 < _g18) {
						var x7 = _g17++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 4:
				var stride2 = width * 4 * flipY1;
				var cv2 = 0;
				var ca2 = 0;
				if(alpha) {
					var _g19 = 0;
					var _g20 = width;
					while(_g19 < _g20) {
						var x8 = _g19++;
						var b = y == 0 ? 0 : bgra.b[w - stride2];
						var c = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k = cv2 + b - c;
						var pa = k - cv2;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						var pos = r++;
						cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[pos] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						var b1 = y == 0 ? 0 : bgra.b[w - stride2];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k1 = ca2 + b1 - c1;
						var pa1 = k1 - ca2;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b1;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c1;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						var pos1 = r++;
						ca2 = (pa1 <= pb1 && pa1 <= pc1 ? ca2 : pb1 <= pc1 ? b1 : c1) + data.b[pos1] & 255;
						bgra.b[w++] = ca2;
					}
				} else {
					var _g21 = 0;
					var _g22 = width;
					while(_g21 < _g22) {
						var x9 = _g21++;
						var b2 = y == 0 ? 0 : bgra.b[w - stride2];
						var c2 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k2 = cv2 + b2 - c2;
						var pa2 = k2 - cv2;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b2;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c2;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						var pos2 = r++;
						cv2 = (pa2 <= pb2 && pa2 <= pc2 ? cv2 : pb2 <= pc2 ? b2 : c2) + data.b[pos2] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 1:
		var alpha = _g.alpha;
		if(h.colbits != 8) {
			throw haxe_Exception.thrown("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 4 : 3) * width + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var alphaRed = -1;
		var alphaGreen = -1;
		var alphaBlue = -1;
		if(!alpha) {
			var _g_head = d.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var t = val;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 6) {
							alphaRed = data1.b[1];
							alphaGreen = data1.b[3];
							alphaBlue = data1.b[5];
						}
						break;
					}
				}
			}
		}
		var cr = 0;
		var cg = 0;
		var cb = 0;
		var ca = 0;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g2 = 0;
					var _g3 = width;
					while(_g2 < _g3) {
						var x = _g2++;
						bgra.b[w++] = data.b[r + 2];
						bgra.b[w++] = data.b[r + 1];
						bgra.b[w++] = data.b[r];
						bgra.b[w++] = data.b[r + 3];
						r += 4;
					}
				} else {
					var _g4 = 0;
					var _g5 = width;
					while(_g4 < _g5) {
						var x1 = _g4++;
						cb = data.b[r + 2];
						bgra.b[w++] = cb;
						cg = data.b[r + 1];
						bgra.b[w++] = cg;
						cr = data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 1:
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				if(alpha) {
					var _g6 = 0;
					var _g7 = width;
					while(_g6 < _g7) {
						var x2 = _g6++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						ca += data.b[r + 3];
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g8 = 0;
					var _g9 = width;
					while(_g8 < _g9) {
						var x3 = _g8++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g10 = 0;
					var _g11 = width;
					while(_g10 < _g11) {
						var x4 = _g10++;
						bgra.b[w] = data.b[r + 2] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r + 1] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r] + bgra.b[w - stride];
						++w;
						bgra.b[w] = data.b[r + 3] + bgra.b[w - stride];
						++w;
						r += 4;
					}
				} else {
					var _g12 = 0;
					var _g13 = width;
					while(_g12 < _g13) {
						var x5 = _g12++;
						cb = data.b[r + 2] + bgra.b[w - stride];
						bgra.b[w] = cb;
						++w;
						cg = data.b[r + 1] + bgra.b[w - stride];
						bgra.b[w] = cg;
						++w;
						cr = data.b[r] + bgra.b[w - stride];
						bgra.b[w] = cr;
						++w;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 3:
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g14 = 0;
					var _g15 = width;
					while(_g14 < _g15) {
						var x6 = _g14++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cr;
						ca = data.b[r + 3] + (ca + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g16 = 0;
					var _g17 = width;
					while(_g16 < _g17) {
						var x7 = _g16++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 4:
				var stride2 = width * 4 * flipY1;
				ca = 0;
				cb = ca;
				cg = cb;
				cr = cg;
				if(alpha) {
					var _g18 = 0;
					var _g19 = width;
					while(_g18 < _g19) {
						var x8 = _g18++;
						var b = y == 0 ? 0 : bgra.b[w - stride2];
						var c = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k = cb + b - c;
						var pa = k - cb;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						cb = (pa <= pb && pa <= pc ? cb : pb <= pc ? b : c) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b1 = y == 0 ? 0 : bgra.b[w - stride2];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k1 = cg + b1 - c1;
						var pa1 = k1 - cg;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b1;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c1;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						cg = (pa1 <= pb1 && pa1 <= pc1 ? cg : pb1 <= pc1 ? b1 : c1) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b2 = y == 0 ? 0 : bgra.b[w - stride2];
						var c2 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k2 = cr + b2 - c2;
						var pa2 = k2 - cr;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b2;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c2;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						cr = (pa2 <= pb2 && pa2 <= pc2 ? cr : pb2 <= pc2 ? b2 : c2) + data.b[r] & 255;
						bgra.b[w++] = cr;
						var b3 = y == 0 ? 0 : bgra.b[w - stride2];
						var c3 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k3 = ca + b3 - c3;
						var pa3 = k3 - ca;
						if(pa3 < 0) {
							pa3 = -pa3;
						}
						var pb3 = k3 - b3;
						if(pb3 < 0) {
							pb3 = -pb3;
						}
						var pc3 = k3 - c3;
						if(pc3 < 0) {
							pc3 = -pc3;
						}
						ca = (pa3 <= pb3 && pa3 <= pc3 ? ca : pb3 <= pc3 ? b3 : c3) + data.b[r + 3] & 255;
						bgra.b[w++] = ca;
						r += 4;
					}
				} else {
					var _g20 = 0;
					var _g21 = width;
					while(_g20 < _g21) {
						var x9 = _g20++;
						var b4 = y == 0 ? 0 : bgra.b[w - stride2];
						var c4 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k4 = cb + b4 - c4;
						var pa4 = k4 - cb;
						if(pa4 < 0) {
							pa4 = -pa4;
						}
						var pb4 = k4 - b4;
						if(pb4 < 0) {
							pb4 = -pb4;
						}
						var pc4 = k4 - c4;
						if(pc4 < 0) {
							pc4 = -pc4;
						}
						cb = (pa4 <= pb4 && pa4 <= pc4 ? cb : pb4 <= pc4 ? b4 : c4) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b5 = y == 0 ? 0 : bgra.b[w - stride2];
						var c5 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k5 = cg + b5 - c5;
						var pa5 = k5 - cg;
						if(pa5 < 0) {
							pa5 = -pa5;
						}
						var pb5 = k5 - b5;
						if(pb5 < 0) {
							pb5 = -pb5;
						}
						var pc5 = k5 - c5;
						if(pc5 < 0) {
							pc5 = -pc5;
						}
						cg = (pa5 <= pb5 && pa5 <= pc5 ? cg : pb5 <= pc5 ? b5 : c5) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b6 = y == 0 ? 0 : bgra.b[w - stride2];
						var c6 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
						var k6 = cr + b6 - c6;
						var pa6 = k6 - cr;
						if(pa6 < 0) {
							pa6 = -pa6;
						}
						var pb6 = k6 - b6;
						if(pb6 < 0) {
							pb6 = -pb6;
						}
						var pc6 = k6 - c6;
						if(pc6 < 0) {
							pc6 = -pc6;
						}
						cr = (pa6 <= pb6 && pa6 <= pc6 ? cr : pb6 <= pc6 ? b6 : c6) + data.b[r] & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 2:
		var pal = format_png_Tools.getPalette(d);
		if(pal == null) {
			throw haxe_Exception.thrown("PNG Palette is missing");
		}
		var alpha = null;
		var _g_head = d.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var t = val;
			if(t._hx_index == 4) {
				if(t.id == "tRNS") {
					var data1 = t.data;
					alpha = data1;
					break;
				}
			}
		}
		if(alpha != null && alpha.length < 1 << h.colbits) {
			var alpha2 = new haxe_io_Bytes(new ArrayBuffer(1 << h.colbits));
			alpha2.blit(0,alpha,0,alpha.length);
			alpha2.fill(alpha.length,alpha2.length - alpha.length,255);
			alpha = alpha2;
		}
		var width = h.width;
		var stride = Math.ceil(width * h.colbits / 8) + 1;
		if(data.length < h.height * stride) {
			throw haxe_Exception.thrown("Not enough data");
		}
		var rline = stride - 1;
		var _g = 0;
		var _g1 = h.height;
		while(_g < _g1) {
			var y = _g++;
			var f = data.b[r++];
			if(f == 0) {
				r += rline;
				continue;
			}
			switch(f) {
			case 1:
				var c = 0;
				var _g2 = 0;
				var _g3 = width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = data.b[r];
					c += v;
					data.b[r++] = c & 255;
				}
				break;
			case 2:
				var stride = y == 0 ? 0 : rline + 1;
				var _g4 = 0;
				var _g5 = width;
				while(_g4 < _g5) {
					var x1 = _g4++;
					var v1 = data.b[r];
					data.b[r] = v1 + data.b[r - stride];
					++r;
				}
				break;
			case 3:
				var c1 = 0;
				var stride1 = y == 0 ? 0 : rline + 1;
				var _g6 = 0;
				var _g7 = width;
				while(_g6 < _g7) {
					var x2 = _g6++;
					var v2 = data.b[r];
					c1 = v2 + (c1 + data.b[r - stride1] >> 1) & 255;
					data.b[r++] = c1;
				}
				break;
			case 4:
				var stride2 = rline + 1;
				var c2 = 0;
				var _g8 = 0;
				var _g9 = width;
				while(_g8 < _g9) {
					var x3 = _g8++;
					var v3 = data.b[r];
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b = y == 0 ? 0 : data.b[r - stride2];
					var c3 = x3 == 0 || y == 0 ? 0 : data.b[r - stride2 - numChannels];
					var k = c2 + b - c3;
					var pa = k - c2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c3;
					if(pc < 0) {
						pc = -pc;
					}
					c2 = (pa <= pb && pa <= pc ? c2 : pb <= pc ? b : c3) + v3 & 255;
					data.b[r++] = c2;
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid filter " + f);
			}
		}
		var r = 0;
		if(h.colbits == 8) {
			var _g = 0;
			var _g1 = h.height;
			while(_g < _g1) {
				var y = _g++;
				++r;
				var _g2 = 0;
				var _g3 = h.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var c = data.b[r++];
					bgra.b[w++] = pal.b[c * 3 + 2];
					bgra.b[w++] = pal.b[c * 3 + 1];
					bgra.b[w++] = pal.b[c * 3];
					bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
				}
				w += lineDelta;
			}
		} else if(h.colbits < 8) {
			var req = h.colbits;
			var mask = (1 << req) - 1;
			var _g = 0;
			var _g1 = h.height;
			while(_g < _g1) {
				var y = _g++;
				++r;
				var bits = 0;
				var nbits = 0;
				var _g2 = 0;
				var _g3 = h.width;
				while(_g2 < _g3) {
					var x = _g2++;
					if(nbits < req) {
						bits = bits << 8 | data.b[r++];
						nbits += 8;
					}
					var c = bits >>> nbits - req & mask;
					nbits -= req;
					bgra.b[w++] = pal.b[c * 3 + 2];
					bgra.b[w++] = pal.b[c * 3 + 1];
					bgra.b[w++] = pal.b[c * 3];
					bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
				}
				w += lineDelta;
			}
		} else {
			throw haxe_Exception.thrown(h.colbits + " indexed bits per pixel not supported");
		}
		break;
	}
	return bgra;
};
format_png_Tools.extract = function(d,output,expandAlpha) {
	if(expandAlpha == null) {
		expandAlpha = false;
	}
	var h = format_png_Tools.getHeader(d);
	var hasAlpha = false;
	var channels;
	var _g = h.color;
	switch(_g._hx_index) {
	case 0:
		var alpha = _g.alpha;
		hasAlpha = alpha;
		channels = alpha ? 2 : 1;
		break;
	case 1:
		var alpha = _g.alpha;
		hasAlpha = alpha;
		channels = alpha ? 4 : 3;
		break;
	case 2:
		throw haxe_Exception.thrown("assert");
	}
	if(expandAlpha && hasAlpha) {
		expandAlpha = false;
	}
	var bpp = h.colbits >> 3;
	var outChannels = expandAlpha ? channels + 1 : channels;
	if(output == null) {
		output = new haxe_io_Bytes(new ArrayBuffer(outChannels * bpp * h.width * h.height));
	}
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw haxe_Exception.thrown("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var width = h.width;
	var ncomps = channels * bpp;
	var upperLine = outChannels * bpp * width;
	var leftPixel = outChannels * bpp;
	if(data.length < h.height * (ncomps * width + 1)) {
		throw haxe_Exception.thrown("Not enough data");
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = ncomps;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(0);
	}
	var tmp = _g;
	var _g = 0;
	var _g1 = h.height;
	while(_g < _g1) {
		var y = _g++;
		var f = data.b[r++];
		if(f != 0 && f != 2) {
			var _g2 = 0;
			var _g3 = ncomps;
			while(_g2 < _g3) {
				var i = _g2++;
				tmp[i] = 0;
			}
		}
		switch(f) {
		case 0:
			var _g4 = 0;
			var _g5 = width;
			while(_g4 < _g5) {
				var x = _g4++;
				var _g6 = 0;
				var _g7 = ncomps;
				while(_g6 < _g7) {
					var i1 = _g6++;
					output.b[w++] = data.b[r++];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 1:
			var _g8 = 0;
			var _g9 = width;
			while(_g8 < _g9) {
				var x1 = _g8++;
				var _g10 = 0;
				var _g11 = ncomps;
				while(_g10 < _g11) {
					var i2 = _g10++;
					tmp[i2] += data.b[r++];
					output.b[w++] = tmp[i2];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 2:
			var stride = y == 0 ? 0 : upperLine;
			var _g12 = 0;
			var _g13 = width;
			while(_g12 < _g13) {
				var x2 = _g12++;
				var _g14 = 0;
				var _g15 = ncomps;
				while(_g14 < _g15) {
					var i3 = _g14++;
					var v = data.b[r++] + output.b[w - stride];
					output.b[w++] = v;
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 3:
			var stride1 = y == 0 ? 0 : upperLine;
			var _g16 = 0;
			var _g17 = width;
			while(_g16 < _g17) {
				var x3 = _g16++;
				var _g18 = 0;
				var _g19 = ncomps;
				while(_g18 < _g19) {
					var i4 = _g18++;
					tmp[i4] = data.b[r++] + (tmp[i4] + output.b[w - stride1] >> 1) & 255;
					output.b[w++] = tmp[i4];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		case 4:
			var _g20 = 0;
			var _g21 = width;
			while(_g20 < _g21) {
				var x4 = _g20++;
				var _g22 = 0;
				var _g23 = ncomps;
				while(_g22 < _g23) {
					var i5 = _g22++;
					var prev = tmp[i5];
					var b = y == 0 ? 0 : output.b[w - upperLine];
					var c = x4 == 0 || y == 0 ? 0 : output.b[w - upperLine - leftPixel];
					var k = prev + b - c;
					var pa = k - prev;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c;
					if(pc < 0) {
						pc = -pc;
					}
					var pos = r++;
					tmp[i5] = (pa <= pb && pa <= pc ? prev : pb <= pc ? b : c) + data.b[pos] & 255;
					output.b[w++] = tmp[i5];
				}
				if(expandAlpha) {
					output.b[w++] = 255;
					if(bpp == 2) {
						output.b[w++] = 255;
					}
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("Invalid filter " + f);
		}
	}
	if(h.colbits == 16) {
		var w = 0;
		var _g = 0;
		var _g1 = h.height * width * outChannels;
		while(_g < _g1) {
			var x = _g++;
			var a = output.b[w];
			var b = output.b[w + 1];
			output.b[w++] = b;
			output.b[w++] = a;
		}
	}
	return output;
};
format_png_Tools.buildGrey = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColGrey(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildIndexed = function(width,height,data,palette,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColIndexed, interlaced : false}));
	l.add(format_png_Chunk.CPalette(palette));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildRGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height * 3 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgb.b[w++] = data.b[r + 2];
			rgb.b[w++] = data.b[r + 1];
			rgb.b[w++] = data.b[r];
			r += 3;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32ARGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 3];
			rgba.b[w++] = data.b[r];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32BGRA = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g3 = width;
		while(_g2 < _g3) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r];
			rgba.b[w++] = data.b[r + 3];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
var format_png_Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
};
$hxClasses["format.png.Writer"] = format_png_Writer;
format_png_Writer.__name__ = "format.png.Writer";
format_png_Writer.prototype = {
	write: function(png) {
		var b = 137;
		this.o.writeByte(b);
		var b = 80;
		this.o.writeByte(b);
		var b = 78;
		this.o.writeByte(b);
		var b = 71;
		this.o.writeByte(b);
		var b = 13;
		this.o.writeByte(b);
		var b = 10;
		this.o.writeByte(b);
		var b = 26;
		this.o.writeByte(b);
		var b = 10;
		this.o.writeByte(b);
		var _g_head = png.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var c = val;
			switch(c._hx_index) {
			case 0:
				this.writeChunk("IEND",new haxe_io_Bytes(new ArrayBuffer(0)));
				break;
			case 1:
				var h = c.h;
				var b = new haxe_io_BytesOutput();
				b.set_bigEndian(true);
				b.writeInt32(h.width);
				b.writeInt32(h.height);
				b.writeByte(h.colbits);
				var _g = h.color;
				var tmp;
				switch(_g._hx_index) {
				case 0:
					var alpha = _g.alpha;
					tmp = alpha ? 4 : 0;
					break;
				case 1:
					var alpha1 = _g.alpha;
					tmp = alpha1 ? 6 : 2;
					break;
				case 2:
					tmp = 3;
					break;
				}
				b.writeByte(tmp);
				b.writeByte(0);
				b.writeByte(0);
				b.writeByte(h.interlaced ? 1 : 0);
				this.writeChunk("IHDR",b.getBytes());
				break;
			case 2:
				var d = c.b;
				this.writeChunk("IDAT",d);
				break;
			case 3:
				var b1 = c.b;
				this.writeChunk("PLTE",b1);
				break;
			case 4:
				var id = c.id;
				var data = c.data;
				this.writeChunk(id,data);
				break;
			}
		}
	}
	,writeChunk: function(id,data) {
		this.o.writeInt32(data.length);
		this.o.writeString(id);
		this.o.write(data);
		var crc_crc = -1;
		var tmp = (crc_crc ^ HxOverrides.cca(id,0)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp = (crc_crc ^ HxOverrides.cca(id,1)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp = (crc_crc ^ HxOverrides.cca(id,2)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp = (crc_crc ^ HxOverrides.cca(id,3)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var b = data.b.bufferValue;
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			var tmp = (crc_crc ^ b.bytes[i]) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			crc_crc = crc_crc >>> 8 ^ tmp;
		}
		this.o.writeInt32(crc_crc ^ -1);
	}
	,__class__: format_png_Writer
};
var format_tga_ImageOrigin = $hxEnums["format.tga.ImageOrigin"] = { __ename__:"format.tga.ImageOrigin",__constructs__:null
	,BottomLeft: {_hx_name:"BottomLeft",_hx_index:0,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,BottomRight: {_hx_name:"BottomRight",_hx_index:1,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopLeft: {_hx_name:"TopLeft",_hx_index:2,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopRight: {_hx_name:"TopRight",_hx_index:3,__enum__:"format.tga.ImageOrigin",toString:$estr}
};
format_tga_ImageOrigin.__constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
format_tga_ImageOrigin.__empty_constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
var format_tga_ImageType = $hxEnums["format.tga.ImageType"] = { __ename__:"format.tga.ImageType",__constructs__:null
	,NoImage: {_hx_name:"NoImage",_hx_index:0,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedColorMapped: {_hx_name:"UncompressedColorMapped",_hx_index:1,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedTrueColor: {_hx_name:"UncompressedTrueColor",_hx_index:2,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedBlackAndWhite: {_hx_name:"UncompressedBlackAndWhite",_hx_index:3,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthColorMapped: {_hx_name:"RunLengthColorMapped",_hx_index:4,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthTrueColor: {_hx_name:"RunLengthTrueColor",_hx_index:5,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthBlackAndWhite: {_hx_name:"RunLengthBlackAndWhite",_hx_index:6,__enum__:"format.tga.ImageType",toString:$estr}
	,Unknown: ($_=function(type) { return {_hx_index:7,type:type,__enum__:"format.tga.ImageType",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["type"],$_)
};
format_tga_ImageType.__constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite,format_tga_ImageType.Unknown];
format_tga_ImageType.__empty_constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite];
var format_tga_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.tga.Reader"] = format_tga_Reader;
format_tga_Reader.__name__ = "format.tga.Reader";
format_tga_Reader.prototype = {
	read: function() {
		var idLength = this.i.readByte();
		var header = this.readHeader();
		var id = idLength == 0 ? "" : this.i.readString(idLength);
		var colorMap = this.readColorMapData(header);
		return { header : header, imageId : id, colorMapData : colorMap, imageData : this.readImageData(header,colorMap), developerData : null};
	}
	,readHeader: function() {
		var colorMapType = this.i.readByte();
		var dataType;
		var dataId = this.i.readByte();
		switch(dataId) {
		case 0:
			dataType = format_tga_ImageType.NoImage;
			break;
		case 1:
			dataType = format_tga_ImageType.UncompressedColorMapped;
			break;
		case 2:
			dataType = format_tga_ImageType.UncompressedTrueColor;
			break;
		case 3:
			dataType = format_tga_ImageType.UncompressedBlackAndWhite;
			break;
		case 9:
			dataType = format_tga_ImageType.RunLengthColorMapped;
			break;
		case 10:
			dataType = format_tga_ImageType.RunLengthTrueColor;
			break;
		case 11:
			dataType = format_tga_ImageType.RunLengthBlackAndWhite;
			break;
		default:
			dataType = format_tga_ImageType.Unknown(dataId);
		}
		var colorMapOrigin = this.i.readInt16();
		var colorMapLength = this.i.readInt16();
		var colorMapDepth = this.i.readByte();
		var xOrigin = this.i.readInt16();
		var yOrigin = this.i.readInt16();
		var width = this.i.readInt16();
		var height = this.i.readInt16();
		var depth = this.i.readByte();
		var descriptor = this.i.readByte();
		var origin;
		switch(descriptor & 48) {
		case 16:
			origin = format_tga_ImageOrigin.BottomRight;
			break;
		case 32:
			origin = format_tga_ImageOrigin.TopLeft;
			break;
		case 48:
			origin = format_tga_ImageOrigin.TopRight;
			break;
		default:
			origin = format_tga_ImageOrigin.BottomLeft;
		}
		return { colorMapType : colorMapType, imageType : dataType, colorMapFirstIndex : colorMapOrigin, colorMapLength : colorMapLength, colorMapEntrySize : colorMapDepth, xOrigin : xOrigin, yOrigin : yOrigin, width : width, height : height, bitsPerPixel : depth, alphaChannelBits : descriptor & 15, imageOrigin : origin};
	}
	,readColorMapData: function(header) {
		if(header.colorMapType == 0) {
			return null;
		}
		return this.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,false);
	}
	,readImageData: function(header,colorMap) {
		switch(header.imageType._hx_index) {
		case 0:
			return null;
		case 1:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,false);
		case 2:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 3:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 4:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,true);
		case 5:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		case 6:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		default:
			throw haxe_Exception.thrown("Unsupported image data type!");
		}
	}
	,readPixels: function(bitsPerPixel,amount,alphaChannelBits,rle) {
		var list = new Array(amount);
		var alpha = alphaChannelBits != 0;
		var bitFieldSize = bitsPerPixel / 3 | 0;
		if(bitFieldSize > 8) {
			bitFieldSize = 8;
		}
		var parsePixel;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixel2);
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			parsePixel = $bind(this,this.parsePixel3);
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			parsePixel = $bind(this,this.parsePixel4);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var rleChunk;
			var i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	,readMono: function(bitsPerPixel,amount,alphaChannelBits,rle) {
		var list = new Array(amount);
		var alpha = alphaChannelBits != 0;
		var parsePixel;
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixelGreyAlpha);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var rleChunk;
			var i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	,readIndexes: function(bitsPerPixel,amount,colorMap,offset,rle) {
		var list = new Array(amount);
		var readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			var i = 0;
			var rleChunk;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					var pixel = colorMap[offset + readEntry()];
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = colorMap[offset + readEntry()];
						--rleChunk;
					}
				}
			}
		} else {
			var _g = 0;
			var _g1 = amount;
			while(_g < _g1) {
				var i = _g++;
				list[i] = colorMap[offset + readEntry()];
			}
		}
		return list;
	}
	,parsePixel1: function(value,alpha) {
		return value << 16 | value << 8 | value;
	}
	,parsePixelGreyAlpha: function(value,alpha) {
		return (alpha ? (value & 65280) << 16 : 0) | this.parsePixel1(value & 255,false);
	}
	,parsePixel2: function(value,alpha) {
		return (alpha ? (value & 32768) == 1 ? -16777216 : 0 : 0) | (((value & 31744) >> 10) / 31 * 255 | 0) << 16 | (((value & 992) >> 5) / 31 * 255 | 0) << 8 | ((value & 31) / 31 * 255 | 0);
	}
	,parsePixel3: function(value,alpha) {
		return value;
	}
	,parsePixel4: function(value,alpha) {
		return value;
	}
	,__class__: format_tga_Reader
};
var format_tools_BitsInput = function(i) {
	this.i = i;
	this.nbits = 0;
	this.bits = 0;
};
$hxClasses["format.tools.BitsInput"] = format_tools_BitsInput;
format_tools_BitsInput.__name__ = "format.tools.BitsInput";
format_tools_BitsInput.prototype = {
	readBits: function(n) {
		if(this.nbits >= n) {
			var c = this.nbits - n;
			var k = this.bits >>> c & (1 << n) - 1;
			this.nbits = c;
			return k;
		}
		var k = this.i.readByte();
		if(this.nbits >= 24) {
			if(n > 31) {
				throw haxe_Exception.thrown("Bits error");
			}
			var c = 8 + this.nbits - n;
			var d = this.bits & (1 << this.nbits) - 1;
			d = d << 8 - c | k << c;
			this.bits = k;
			this.nbits = c;
			return d;
		}
		this.bits = this.bits << 8 | k;
		this.nbits += 8;
		return this.readBits(n);
	}
	,readBit: function() {
		if(this.nbits == 0) {
			this.bits = this.i.readByte();
			this.nbits = 8;
		}
		this.nbits--;
		return (this.bits >>> this.nbits & 1) == 1;
	}
	,reset: function() {
		this.nbits = 0;
	}
	,__class__: format_tools_BitsInput
};
var format_tools_Deflate = function() { };
$hxClasses["format.tools.Deflate"] = format_tools_Deflate;
format_tools_Deflate.__name__ = "format.tools.Deflate";
format_tools_Deflate.run = function(b,level) {
	if(level == null) {
		level = 9;
	}
	return haxe_zip_Compress.run(b,level);
};
var format_tools_Inflate = function() { };
$hxClasses["format.tools.Inflate"] = format_tools_Inflate;
format_tools_Inflate.__name__ = "format.tools.Inflate";
format_tools_Inflate.run = function(bytes) {
	return haxe_zip_Uncompress.run(bytes);
};
var format_wav_WAVEFormat = $hxEnums["format.wav.WAVEFormat"] = { __ename__:"format.wav.WAVEFormat",__constructs__:null
	,WF_PCM: {_hx_name:"WF_PCM",_hx_index:0,__enum__:"format.wav.WAVEFormat",toString:$estr}
};
format_wav_WAVEFormat.__constructs__ = [format_wav_WAVEFormat.WF_PCM];
format_wav_WAVEFormat.__empty_constructs__ = [format_wav_WAVEFormat.WF_PCM];
var format_wav_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(false);
};
$hxClasses["format.wav.Reader"] = format_wav_Reader;
format_wav_Reader.__name__ = "format.wav.Reader";
format_wav_Reader.prototype = {
	readInt: function() {
		return this.i.readInt32();
	}
	,read: function() {
		if(this.i.readString(4) != "RIFF") {
			throw haxe_Exception.thrown("RIFF header expected");
		}
		var len = this.i.readInt32();
		if(this.i.readString(4) != "WAVE") {
			throw haxe_Exception.thrown("WAVE signature not found");
		}
		var fmt = this.i.readString(4);
		_hx_loop1: while(fmt != "fmt ") switch(fmt) {
		case "JUNK":
			var junkLen = this.i.readInt32();
			this.i.read(junkLen);
			fmt = this.i.readString(4);
			break;
		case "bext":
			var bextLen = this.i.readInt32();
			this.i.read(bextLen);
			fmt = this.i.readString(4);
			break;
		default:
			break _hx_loop1;
		}
		if(fmt != "fmt ") {
			throw haxe_Exception.thrown("unsupported wave chunk " + fmt);
		}
		var fmtlen = this.i.readInt32();
		var format;
		switch(this.i.readUInt16()) {
		case 1:case 3:
			format = format_wav_WAVEFormat.WF_PCM;
			break;
		default:
			throw haxe_Exception.thrown("only PCM (uncompressed) WAV files are supported");
		}
		var channels = this.i.readUInt16();
		var samplingRate = this.i.readInt32();
		var byteRate = this.i.readInt32();
		var blockAlign = this.i.readUInt16();
		var bitsPerSample = this.i.readUInt16();
		if(fmtlen > 16) {
			this.i.read(fmtlen - 16);
		}
		var nextChunk = this.i.readString(4);
		while(nextChunk != "data") {
			this.i.read(this.i.readInt32());
			nextChunk = this.i.readString(4);
		}
		if(nextChunk != "data") {
			throw haxe_Exception.thrown("expected data subchunk");
		}
		var datalen = this.i.readInt32();
		var data;
		try {
			data = this.i.read(datalen);
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw haxe_Exception.thrown("Invalid chunk data length");
			} else {
				throw _g;
			}
		}
		var cuePoints = [];
		try {
			while(true) {
				var nextChunk = this.i.readString(4);
				if(nextChunk == "cue ") {
					this.i.readInt32();
					var nbCuePoints = this.i.readInt32();
					var _g = 0;
					var _g1 = nbCuePoints;
					while(_g < _g1) {
						var _ = _g++;
						var cueId = this.i.readInt32();
						this.i.readInt32();
						this.i.readString(4);
						this.i.readInt32();
						this.i.readInt32();
						var cueSampleOffset = this.i.readInt32();
						cuePoints.push({ id : cueId, sampleOffset : cueSampleOffset});
					}
				} else {
					var n = this.i.readInt32();
					if(n < 0) {
						break;
					}
					this.i.read(n);
				}
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return { header : { format : format, channels : channels, samplingRate : samplingRate, byteRate : byteRate, blockAlign : blockAlign, bitsPerSample : bitsPerSample}, data : data, cuePoints : cuePoints};
	}
	,__class__: format_wav_Reader
};
var fx_Alpha = function(mc,tsc,spc) {
	if(spc == null) {
		spc = 0.1;
	}
	if(tsc == null) {
		tsc = 1.0;
	}
	Fx.call(this);
	this.root = mc;
	this.spc = spc;
	this.tsc = tsc;
	this.bsc = mc.alpha;
};
$hxClasses["fx.Alpha"] = fx_Alpha;
fx_Alpha.__name__ = "fx.Alpha";
fx_Alpha.__super__ = Fx;
fx_Alpha.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		var c = this.curve(this.coef);
		this.root.alpha = this.bsc * (1 - c) + this.tsc * c;
		if(this.coef == 1) {
			this.kill();
		}
	}
	,__class__: fx_Alpha
});
var fx_Call = function(func,lim,onFinish) {
	Fx.call(this);
	this.func = func;
	this.limit = lim;
	this.onFinish = onFinish;
};
$hxClasses["fx.Call"] = fx_Call;
fx_Call.__name__ = "fx.Call";
fx_Call.__super__ = Fx;
fx_Call.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		this.func(this);
		if(this.limit != null && this.timer >= this.limit) {
			this.kill();
		}
	}
	,__class__: fx_Call
});
var fx_Part = function(mc) {
	Fx.call(this);
	this.root = mc;
	this.fitPix = Fx.FIT_PIX;
	this.x = this.root.x;
	this.y = this.root.y;
	this.vx = 0;
	this.vy = 0;
	this.weight = 0;
	this.vr = 0;
	this.sfr = null;
	this.rfr = 1;
	this.frict = 1;
	this.rfr = 1;
	this.scale = 1;
	this.alpha = 1;
	this.life = -1;
	this.fadeLimit = 10;
	this.fadeType = 0;
};
$hxClasses["fx.Part"] = fx_Part;
fx_Part.__name__ = "fx.Part";
fx_Part.__super__ = Fx;
fx_Part.prototype = $extend(Fx.prototype,{
	setScale: function(sc) {
		this.scale = sc;
		var _this = this.root;
		_this.posChanged = true;
		_this.scaleX = sc;
		var _this = this.root;
		_this.posChanged = true;
		_this.scaleY = sc;
	}
	,setAlpha: function(a) {
		this.alpha = a;
		this.root.alpha = a;
	}
	,update: function() {
		this.timer++;
		this.vy += this.weight;
		this.vx *= this.frict;
		this.vy *= this.frict;
		this.x += this.vx;
		this.y += this.vy;
		this.vr *= this.rfr;
		var fh = this.root;
		fh.posChanged = true;
		fh.rotation += this.vr;
		if(this.sfr != null) {
			this.scale *= this.sfr;
			this.setScale(this.scale);
		}
		if(this.ground != null) {
			if(this.y > this.ground.y) {
				this.y = this.ground.y;
				this.vx *= this.ground.frx;
				this.vy *= -this.ground.fry;
				if(this.onBounceGround != null) {
					this.onBounceGround();
				}
			}
		}
		if(this.fadeInData != null) {
			this.fadeInData.timer++;
			var c = this.fadeInData.timer / this.fadeInData.limit;
			switch(this.fadeType) {
			case 0:
				break;
			case 1:
				this.root.alpha = c * this.alpha;
				break;
			case 2:
				var _this = this.root;
				var _this1 = this.root;
				_this1.posChanged = true;
				_this.posChanged = true;
				_this.scaleX = _this1.scaleY = c * this.scale;
				break;
			case 3:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleX = c * this.scale;
				break;
			case 4:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleY = c * this.scale;
				break;
			case 5:
				this.root.set_visible(this.timer % 4 < 2);
				break;
			}
			if(c == 1) {
				this.fadeInData = null;
			}
		}
		this.life--;
		if(this.life < this.fadeLimit && this.life >= 0) {
			var c = this.life / this.fadeLimit;
			switch(this.fadeType) {
			case 0:
				if(this.fadeFunc != null) {
					this.fadeFunc(c);
				}
				break;
			case 1:
				this.root.alpha = c * this.alpha;
				break;
			case 2:
				var _this = this.root;
				var _this1 = this.root;
				_this1.posChanged = true;
				_this.posChanged = true;
				_this.scaleX = _this1.scaleY = c * this.scale;
				break;
			case 3:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleX = c * this.scale;
				break;
			case 4:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleY = c * this.scale;
				break;
			case 5:
				this.root.set_visible(this.timer % 4 < 2);
				break;
			}
		}
		if(this.life == 0) {
			this.kill();
		}
		this.updatePos();
	}
	,setPos: function(nx,ny) {
		this.x = nx;
		this.y = ny;
		this.updatePos();
	}
	,updatePos: function() {
		var _this = this.root;
		_this.posChanged = true;
		_this.x = this.x;
		var _this = this.root;
		_this.posChanged = true;
		_this.y = this.y;
		if(this.fitPix) {
			var _this = this.root;
			_this.posChanged = true;
			_this.x = this.root.x | 0;
			var _this = this.root;
			_this.posChanged = true;
			_this.y = this.root.y | 0;
		}
	}
	,frameKill: function() {
		var dyn = this.root;
		dyn.kill = $bind(this,this.kill);
	}
	,fadeIn: function(n) {
		this.fadeInData = { timer : 0, limit : n};
		var _this = this.root;
		var _this1 = this.root;
		_this1.posChanged = true;
		_this.posChanged = true;
		_this.scaleX = _this1.scaleY = 0;
	}
	,setGround: function(y,frx,fry,life) {
		if(life == null) {
			life = -1;
		}
		var _gthis = this;
		this.ground = { y : y, frx : frx, fry : fry};
		if(life >= 0) {
			var me = this;
			this.onBounceGround = function() {
				if(me.life > life) {
					me.life = life;
				}
				_gthis.onBounceGround = null;
			};
		}
	}
	,twist: function(n,fr) {
		if(fr != null) {
			this.rfr = fr;
		}
		var _this = this.root;
		var v = Math.random() * 360;
		_this.posChanged = true;
		_this.rotation = v;
		this.vr = (Math.random() * 2 - 1) * n;
	}
	,shortrun: function(n) {
		this.x += this.vx * n;
		this.y += this.vy * n;
		this.updatePos();
	}
	,impulse: function(an,speed,short) {
		if(short == null) {
			short = 0.0;
		}
		this.vx += Math.cos(an) * speed;
		this.vy += Math.sin(an) * speed;
		if(short > 0) {
			this.shortrun(short);
		}
	}
	,kill: function() {
		if(this.root.parent != null) {
			this.root.parent.removeChild(this.root);
		}
		Fx.prototype.kill.call(this);
	}
	,__class__: fx_Part
});
var fx_Drunk = function() {
	var bub = new h2d_Element();
	bub.goto(Std.random(4),"bubbles");
	Game.me.dm.add(bub,GameDepth.DP_FX);
	fx_Part.call(this,bub);
	this.dex = Math.random() * 6.28;
	this.vy -= 0.2 + Math.random() * 0.5;
	this.life = 80 + Std.random(60);
	var sm = Game.me.snowman;
	this.setPos(sm.x + sm.head.x + Math.random() * 32 - 16,sm.y + sm.head.y + Math.random() * 6 - 16);
};
$hxClasses["fx.Drunk"] = fx_Drunk;
fx_Drunk.__name__ = "fx.Drunk";
fx_Drunk.__super__ = fx_Part;
fx_Drunk.prototype = $extend(fx_Part.prototype,{
	update: function() {
		fx_Part.prototype.update.call(this);
		this.dex = (this.dex + 13) % 6.28;
		this.vx += Math.cos(this.dex) * 0.1;
	}
	,__class__: fx_Drunk
});
var fx_Glow = function(mc,spc) {
	if(spc == null) {
		spc = 0.1;
	}
	Fx.call(this);
	this.root = mc;
};
$hxClasses["fx.Glow"] = fx_Glow;
fx_Glow.__name__ = "fx.Glow";
fx_Glow.__super__ = Fx;
fx_Glow.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		var c = this.curve(1 - this.coef);
		this.root.set_filter(null);
		this.root.set_filter(new h2d_filter_Glow(16777215,1,c * 16,c,1,true));
		if(this.coef == 1) {
			this.kill();
		}
	}
	,__class__: fx_Glow
});
var fx_GotoHand = function(b,h,check,spc) {
	if(spc == null) {
		spc = 0.1;
	}
	Fx.call(this);
	this.check = check;
	this.hand = h;
	this.ball = b;
	b.dummy = true;
	var x = this.ball.skin.x;
	var y = this.ball.skin.y;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.start = new h2d_col_PointImpl(x,y);
	this.spc = spc;
};
$hxClasses["fx.GotoHand"] = fx_GotoHand;
fx_GotoHand.__name__ = "fx.GotoHand";
fx_GotoHand.__super__ = Fx;
fx_GotoHand.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		if(!this.ball.alive) {
			this.kill();
			return;
		}
		var sm = Game.me.snowman;
		var c = this.curve(this.coef);
		var dx = sm.x + this.hand.x - this.start.x;
		var dy = sm.y + this.hand.y - 9 - this.start.y;
		var nx = this.start.x + dx * c;
		var ny = this.start.y + dy * c - Math.sin(c * 3.14) * 40;
		this.ball.vx = nx - this.ball.x;
		this.ball.vy = ny - this.ball.y;
		this.ball.setPos(nx,ny);
		if(this.coef == 1) {
			this.kill();
			if(this.ball.alive) {
				this.ball.dummy = false;
				this.hand.grab(this.ball,this.check);
			}
		}
	}
	,__class__: fx_GotoHand
});
var fx_Move = function(mc,ex,ey,sp,sx,sy) {
	if(sp == null) {
		sp = 0.1;
	}
	Fx.call(this);
	this.fitPix = Fx.FIT_PIX;
	this.root = mc;
	this.spc = sp;
	if(sx == null) {
		sx = this.root.x;
	}
	if(sy == null) {
		sy = this.root.y;
	}
	this.tw = new Tween(sx,sy,ex,ey);
	this.f = ($_=this.tw,$bind($_,$_.getPos));
};
$hxClasses["fx.Move"] = fx_Move;
fx_Move.__name__ = "fx.Move";
fx_Move.__super__ = Fx;
fx_Move.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		var c = this.curve(this.coef);
		var p = this.f(c);
		if(this.sin != null) {
			var cc = Math.sin(c * 3.14);
			p.x += this.sin.dx * cc;
			p.y += this.sin.dy * cc;
		}
		var _this = this.root;
		_this.posChanged = true;
		_this.x = p.x;
		var _this = this.root;
		_this.posChanged = true;
		_this.y = p.y;
		if(this.fitPix) {
			var _this = this.root;
			_this.posChanged = true;
			_this.x = this.root.x | 0;
			var _this = this.root;
			_this.posChanged = true;
			_this.y = this.root.y | 0;
		}
		if(this.coef == 1) {
			this.kill();
		}
	}
	,setSin: function(pow,a) {
		if(a == null) {
			a = -1.57;
		}
		this.sin = { dx : Math.cos(a) * pow, dy : Math.sin(a) * pow};
	}
	,setPixPerFrame: function(pix) {
		var dist = this.tw.getDist();
		if(this.sin != null) {
			var all = Math.sqrt(this.sin.dx * this.sin.dx + this.sin.dy * this.sin.dy) * 2 + dist;
			dist = all * Math.PI / 4;
		}
		this.spc = pix / dist;
	}
	,endPixFit: function() {
		var me = this;
		this.onFinish = function() {
			var _this = me.root;
			var v = me.root.x | 0;
			_this.posChanged = true;
			_this.x = v;
			var _this = me.root;
			var v = me.root.y | 0;
			_this.posChanged = true;
			_this.y = v;
		};
	}
	,__class__: fx_Move
});
var fx_Pass = function(b) {
	Fx.call(this);
	this.ball = b;
	var x = this.ball.skin.x;
	var y = this.ball.skin.y;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.start = new h2d_col_PointImpl(x,y);
};
$hxClasses["fx.Pass"] = fx_Pass;
fx_Pass.__name__ = "fx.Pass";
fx_Pass.__super__ = Fx;
fx_Pass.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		if(!this.ball.alive) {
			this.kill();
			return;
		}
		var h = Game.me.snowman.hands[0];
		var c = this.curve(this.coef);
		var dx = h.x - this.start.x;
		var dy = h.y - 9 - this.start.y;
		var nx = this.start.x + dx * c;
		var ny = this.start.y + dy * c - Math.sin(c * 3.14) * 20;
		this.ball.vx = nx - this.ball.x;
		this.ball.vy = ny - this.ball.y;
		this.ball.setPos(nx,ny);
		if(this.coef == 1) {
			this.kill();
			Game.me.snowman.endPass(this.ball);
		}
	}
	,__class__: fx_Pass
});
var fx_Scale = function(mc,tsc,spc) {
	if(spc == null) {
		spc = 0.1;
	}
	if(tsc == null) {
		tsc = 1.0;
	}
	Fx.call(this);
	this.scaleX = true;
	this.scaleY = true;
	this.root = mc;
	this.spc = spc;
	this.tsc = tsc;
	this.bsc = mc.scaleX;
};
$hxClasses["fx.Scale"] = fx_Scale;
fx_Scale.__name__ = "fx.Scale";
fx_Scale.__super__ = Fx;
fx_Scale.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		var c = this.curve(this.coef);
		var sc = this.bsc * (1 - c) + this.tsc * c;
		if(this.scaleX) {
			var _this = this.root;
			_this.posChanged = true;
			_this.scaleX = sc;
		}
		if(this.scaleY) {
			var _this = this.root;
			_this.posChanged = true;
			_this.scaleY = sc;
		}
		if(this.coef == 1) {
			this.kill();
		}
	}
	,__class__: fx_Scale
});
var fx_Snow = function() {
	Fx.call(this);
	this.el = new h2d_Element();
	this.el.goto(3,"part_snow");
	Game.me.dm.add(this.el,GameDepth.DP_FX);
	this.dex = Math.random() * 6.28;
	this.spx = 1 + Math.random() * 5;
	this.ecx = 0.5 + Math.random();
	this.we = 0.3 + Math.random() * 0.3;
	var _this = this.el;
	var v = Math.random() * Main.WIDTH;
	_this.posChanged = true;
	_this.x = v;
	var _this = this.el;
	_this.posChanged = true;
	_this.y = this.y = -4;
	this.gy = Main.HEIGHT - Math.random() * 32;
};
$hxClasses["fx.Snow"] = fx_Snow;
fx_Snow.__name__ = "fx.Snow";
fx_Snow.__super__ = Fx;
fx_Snow.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		this.dex = (this.dex + this.spc * 0.01) % 6.28;
		var fh = this.el;
		var v = fh.x + (Math.cos(this.dex) * this.ecx + Game.me.wind);
		fh.posChanged = true;
		fh.x = v;
		this.y += this.we;
		var _this = this.el;
		_this.posChanged = true;
		_this.y = this.y;
		var _this = this.el;
		var v = h2d_MAll.fmod(this.el.x,Main.WIDTH);
		_this.posChanged = true;
		_this.x = v;
		if(this.el.y > this.gy) {
			this.kill();
			this.el.kill();
		}
	}
	,__class__: fx_Snow
});
var fx_Wait = function(time,func) {
	Fx.call(this);
	this.lim = time;
	this.onFinish = func;
	if(this.lim == 0) {
		this.kill();
	}
};
$hxClasses["fx.Wait"] = fx_Wait;
fx_Wait.__name__ = "fx.Wait";
fx_Wait.__super__ = Fx;
fx_Wait.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		if(this.timer >= this.lim) {
			this.kill();
		}
	}
	,__class__: fx_Wait
});
var fx_h2d_Blink = function(mc,lim,func) {
	if(lim == null) {
		lim = 16;
	}
	this.vanish = false;
	Fx.call(this);
	this.mc = mc;
	this.limit = lim;
	this.onFinish = func;
	this.on = 2;
	this.off = 2;
};
$hxClasses["fx.h2d.Blink"] = fx_h2d_Blink;
fx_h2d_Blink.__name__ = "fx.h2d.Blink";
fx_h2d_Blink.__super__ = Fx;
fx_h2d_Blink.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		this.mc.set_visible(this.timer % (this.on + this.off) < this.on);
		if(this.alt != null) {
			this.alt.set_visible(!this.mc.visible);
		}
		if(this.timer == this.limit) {
			this.kill();
		}
	}
	,kill: function() {
		this.mc.set_visible(!this.vanish);
		if(this.alt != null) {
			this.alt.set_visible(true);
		}
		Fx.prototype.kill.call(this);
	}
	,__class__: fx_h2d_Blink
});
var fx_h2d_Fade = function(mc,color,spc) {
	if(spc == null) {
		spc = 0.1;
	}
	if(color == null) {
		color = 0;
	}
	Fx.call(this);
	this.mc = mc;
	this.spc = spc;
	this.alphaCoef = 1;
	this.alpha = false;
	this.color = color;
	this.maj();
};
$hxClasses["fx.h2d.Fade"] = fx_h2d_Fade;
fx_h2d_Fade.__name__ = "fx.h2d.Fade";
fx_h2d_Fade.__super__ = Fx;
fx_h2d_Fade.prototype = $extend(Fx.prototype,{
	reverse: function() {
		Fx.prototype.reverse.call(this);
		this.maj();
	}
	,update: function() {
		Fx.prototype.update.call(this);
		this.maj();
		if(this.coef == 1) {
			this.kill();
		}
	}
	,maj: function() {
		var c = this.curve(this.coef);
		if(this.color > -1) {
			h2d_MAll.setColor(this.mc,this.color,c * this.alphaCoef);
		}
		if(this.alpha) {
			this.mc.alpha = 1 - c;
		}
	}
	,__class__: fx_h2d_Fade
});
var fx_h2d_Flash = function(mc,color,spc,sens) {
	if(sens == null) {
		sens = 1;
	}
	if(spc == null) {
		spc = 0.1;
	}
	if(color == null) {
		color = 16777215;
	}
	Fx.call(this);
	this.mc = mc;
	this.sens = sens;
	this.spc = spc;
	var o = Col.colToObj(color);
	this.r = o.r / 255;
	this.g = o.g / 255;
	this.b = o.b / 255;
	this.startInc = this.endInc = 0;
	this.maj();
};
$hxClasses["fx.h2d.Flash"] = fx_h2d_Flash;
fx_h2d_Flash.__name__ = "fx.h2d.Flash";
fx_h2d_Flash.__super__ = Fx;
fx_h2d_Flash.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		this.maj();
		if(this.coef == 1) {
			this.kill();
		}
	}
	,maj: function() {
		var c = 1 - this.curve(this.coef);
		var n = this.startInc * c;
		var k = this.endInc * (1 - c);
		var x = (n + k + this.r * c) * this.sens;
		var y = (n + k + this.g * c) * this.sens;
		var z = (n + k + this.b * c) * this.sens;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.mc.set_colorAdd(new h3d_VectorImpl(x,y,z));
	}
	,__class__: fx_h2d_Flash
});
var fx_h2d_Part = function(mc) {
	Fx.call(this);
	this.root = mc;
	this.fitPix = Fx.FIT_PIX;
	this.x = this.root.x;
	this.y = this.root.y;
	this.vx = 0;
	this.vy = 0;
	this.weight = 0;
	this.vr = 0;
	this.sfr = null;
	this.rfr = 1;
	this.frict = 1;
	this.rfr = 1;
	this.scale = 1;
	this.alpha = 1;
	this.life = -1;
	this.fadeLimit = 10;
	this.fadeType = 0;
};
$hxClasses["fx.h2d.Part"] = fx_h2d_Part;
fx_h2d_Part.__name__ = "fx.h2d.Part";
fx_h2d_Part.__super__ = Fx;
fx_h2d_Part.prototype = $extend(Fx.prototype,{
	setScale: function(sc) {
		this.scale = sc;
		var _this = this.root;
		_this.posChanged = true;
		_this.scaleX = sc;
		var _this = this.root;
		_this.posChanged = true;
		_this.scaleY = sc;
	}
	,setAlpha: function(a) {
		this.alpha = a;
		this.root.alpha = a;
	}
	,update: function() {
		this.timer++;
		this.vy += this.weight;
		this.vx *= this.frict;
		this.vy *= this.frict;
		this.x += this.vx;
		this.y += this.vy;
		this.vr *= this.rfr;
		var fh = this.root;
		fh.posChanged = true;
		fh.rotation += this.vr;
		if(this.sfr != null) {
			this.scale *= this.sfr;
			this.setScale(this.scale);
		}
		if(this.ground != null) {
			if(this.y > this.ground.y && this.vy > 0) {
				this.y = this.ground.y;
				this.vx *= this.ground.frx;
				this.vy *= -this.ground.fry;
				if(this.onBounceGround != null) {
					this.onBounceGround();
				}
			}
		}
		if(this.fadeInData != null) {
			this.fadeInData.timer++;
			var c = this.fadeInData.timer / this.fadeInData.limit;
			switch(this.fadeType) {
			case 0:
				break;
			case 1:
				this.root.alpha = c * this.alpha;
				break;
			case 2:
				var _this = this.root;
				var _this1 = this.root;
				_this1.posChanged = true;
				_this.posChanged = true;
				_this.scaleX = _this1.scaleY = c * this.scale;
				break;
			case 3:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleX = c * this.scale;
				break;
			case 4:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleY = c * this.scale;
				break;
			case 5:
				this.root.set_visible(this.timer % 4 < 2);
				break;
			}
			if(c == 1) {
				this.fadeInData = null;
			}
		}
		if(this.life > 0) {
			this.life--;
		}
		if(this.life < this.fadeLimit && this.life >= 0) {
			var c = this.life / this.fadeLimit;
			switch(this.fadeType) {
			case 0:
				if(this.fadeFunc != null) {
					this.fadeFunc(c);
				}
				break;
			case 1:
				this.root.alpha = c * this.alpha;
				break;
			case 2:
				var _this = this.root;
				var _this1 = this.root;
				_this1.posChanged = true;
				_this.posChanged = true;
				_this.scaleX = _this1.scaleY = c * this.scale;
				break;
			case 3:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleX = c * this.scale;
				break;
			case 4:
				var _this = this.root;
				_this.posChanged = true;
				_this.scaleY = c * this.scale;
				break;
			case 5:
				this.root.set_visible(this.timer % 4 < 2);
				break;
			}
		}
		if(this.life == 0) {
			this.kill();
		}
		this.updatePos();
	}
	,setPos: function(nx,ny) {
		this.x = nx;
		this.y = ny;
		this.updatePos();
	}
	,updatePos: function() {
		var _this = this.root;
		_this.posChanged = true;
		_this.x = this.x;
		var _this = this.root;
		_this.posChanged = true;
		_this.y = this.y;
		if(this.fitPix) {
			var _this = this.root;
			_this.posChanged = true;
			_this.x = this.root.x | 0;
			var _this = this.root;
			_this.posChanged = true;
			_this.y = this.root.y | 0;
		}
	}
	,frameKill: function() {
		var dyn = this.root;
		dyn.kill = $bind(this,this.kill);
	}
	,fadeIn: function(n) {
		this.fadeInData = { timer : 0, limit : n};
		var _this = this.root;
		var _this1 = this.root;
		_this1.posChanged = true;
		_this.posChanged = true;
		_this.scaleX = _this1.scaleY = 0;
	}
	,setGround: function(y,frx,fry,life) {
		if(life == null) {
			life = -1;
		}
		this.ground = { y : y, frx : frx, fry : fry};
		if(life >= 0) {
			var me = this;
			this.onBounceGround = function() {
				if(me.life > life || me.life == -1) {
					me.life = life;
				}
				me.onBounceGround = null;
			};
		}
	}
	,twist: function(n,fr) {
		if(fr != null) {
			this.rfr = fr;
		}
		var _this = this.root;
		var v = Math.random() * 6.28;
		_this.posChanged = true;
		_this.rotation = v;
		this.vr = (Math.random() * 2 - 1) * n;
	}
	,shortrun: function(n) {
		this.x += this.vx * n;
		this.y += this.vy * n;
		this.updatePos();
	}
	,impulse: function(an,speed,short) {
		if(short == null) {
			short = 0.0;
		}
		this.vx += Math.cos(an) * speed;
		this.vy += Math.sin(an) * speed;
		if(short > 0) {
			this.shortrun(short);
		}
	}
	,kill: function() {
		if(this.root.parent != null) {
			this.root.parent.removeChild(this.root);
		}
		Fx.prototype.kill.call(this);
	}
	,__class__: fx_h2d_Part
});
var fx_h2d_Shake = function(base,shakeX,shakeY,fr,rythm) {
	if(rythm == null) {
		rythm = 2;
	}
	if(fr == null) {
		fr = 0.7;
	}
	if(shakeY == null) {
		shakeY = 0.0;
	}
	if(shakeX == null) {
		shakeX = 0.0;
	}
	this.chaotic = false;
	Fx.call(this);
	this.base = base;
	this.dx = shakeX;
	this.dy = shakeY;
	this.frict = fr;
	this.cycle = rythm;
	this.fitPix = true;
	this.bx = base.x;
	this.by = base.y;
};
$hxClasses["fx.h2d.Shake"] = fx_h2d_Shake;
fx_h2d_Shake.__name__ = "fx.h2d.Shake";
fx_h2d_Shake.__super__ = Fx;
fx_h2d_Shake.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		if(this.timer % this.cycle != 0) {
			return;
		}
		this.dx *= -this.frict;
		this.dy *= -this.frict;
		var _this = this.base;
		_this.posChanged = true;
		_this.x = this.bx + this.dx;
		var _this = this.base;
		_this.posChanged = true;
		_this.y = this.by + this.dy;
		if(this.chaotic) {
			var _this = this.base;
			var v = this.bx + Math.random() * this.dx * 2 - this.dx;
			_this.posChanged = true;
			_this.x = v;
			var _this = this.base;
			var v = this.by + Math.random() * this.dy * 2 - this.dy;
			_this.posChanged = true;
			_this.y = v;
		}
		if(Math.abs(this.dx) + Math.abs(this.dy) < 0.5) {
			var _this = this.base;
			_this.posChanged = true;
			_this.x = this.bx;
			var _this = this.base;
			_this.posChanged = true;
			_this.y = this.by;
			this.kill();
		}
		if(this.fitPix) {
			var _this = this.base;
			_this.posChanged = true;
			_this.x = this.base.x | 0;
			var _this = this.base;
			_this.posChanged = true;
			_this.y = this.base.y | 0;
		}
	}
	,__class__: fx_h2d_Shake
});
var h2d_Animator = function() {
	this.timeline = [0];
	this.cursor = 0;
	this.playSpeed = 1;
	this.loop = true;
	this.onFinish = function() {
	};
};
$hxClasses["h2d.Animator"] = h2d_Animator;
h2d_Animator.__name__ = "h2d.Animator";
h2d_Animator.prototype = {
	update: function() {
		this.cursor += this.playSpeed;
		if(this.cursor >= this.timeline.length) {
			if(this.loop) {
				this.cursor -= this.timeline.length;
			} else {
				this.cursor = this.timeline.length - 1;
				this.playSpeed = 0;
			}
			this.onFinish();
		}
		if(this.cursor < 0) {
			if(this.loop) {
				this.cursor += this.timeline.length;
			} else {
				this.cursor = 0;
				this.playSpeed = 0;
			}
			this.onFinish();
		}
	}
	,play: function(speed) {
		if(speed == null) {
			speed = 1.0;
		}
		this.playSpeed = speed;
	}
	,stop: function() {
		this.play(0);
	}
	,goto: function(n) {
		this.cursor = n;
	}
	,gotoRandom: function() {
		this.cursor = Std.random(this.timeline.length);
	}
	,getCurrentFrame: function() {
		return this.timeline[this.cursor | 0];
	}
	,reverse: function() {
		this.playSpeed = -this.playSpeed;
		this.cursor = this.timeline.length - (1 + this.cursor);
	}
	,__class__: h2d_Animator
};
var h2d_Bitmap = function(tile,parent) {
	h2d_Drawable.call(this,parent);
	this.set_tile(tile);
};
$hxClasses["h2d.Bitmap"] = h2d_Bitmap;
h2d_Bitmap.__name__ = "h2d.Bitmap";
h2d_Bitmap.__super__ = h2d_Drawable;
h2d_Bitmap.prototype = $extend(h2d_Drawable.prototype,{
	getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.tile != null) {
			if(this.width == null && this.height == null) {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.tile.width,this.tile.height);
			} else {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.width != null ? this.width : this.tile.width * this.height / this.tile.height,this.height != null ? this.height : this.tile.height * this.width / this.tile.width);
			}
		}
	}
	,set_width: function(w) {
		if(this.width == w) {
			return w;
		}
		this.width = w;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return w;
	}
	,set_height: function(h) {
		if(this.height == h) {
			return h;
		}
		this.height = h;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return h;
	}
	,set_tile: function(t) {
		if(this.tile == t) {
			return t;
		}
		this.tile = t;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t;
	}
	,draw: function(ctx) {
		if(this.width == null && this.height == null) {
			this.emitTile(ctx,this.tile);
			return;
		}
		if(this.tile == null) {
			this.set_tile(h2d_Tile.fromColor(16711935));
		}
		var ow = this.tile.width;
		var oh = this.tile.height;
		this.tile.width = this.width != null ? this.width : ow * this.height / oh;
		this.tile.height = this.height != null ? this.height : oh * this.width / ow;
		this.emitTile(ctx,this.tile);
		this.tile.width = ow;
		this.tile.height = oh;
	}
	,__class__: h2d_Bitmap
});
var h2d_BlendMode = $hxEnums["h2d.BlendMode"] = { __ename__:"h2d.BlendMode",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h2d.BlendMode",toString:$estr}
	,Alpha: {_hx_name:"Alpha",_hx_index:1,__enum__:"h2d.BlendMode",toString:$estr}
	,Add: {_hx_name:"Add",_hx_index:2,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaAdd: {_hx_name:"AlphaAdd",_hx_index:3,__enum__:"h2d.BlendMode",toString:$estr}
	,SoftAdd: {_hx_name:"SoftAdd",_hx_index:4,__enum__:"h2d.BlendMode",toString:$estr}
	,Multiply: {_hx_name:"Multiply",_hx_index:5,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaMultiply: {_hx_name:"AlphaMultiply",_hx_index:6,__enum__:"h2d.BlendMode",toString:$estr}
	,Erase: {_hx_name:"Erase",_hx_index:7,__enum__:"h2d.BlendMode",toString:$estr}
	,Screen: {_hx_name:"Screen",_hx_index:8,__enum__:"h2d.BlendMode",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:9,__enum__:"h2d.BlendMode",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:10,__enum__:"h2d.BlendMode",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:11,__enum__:"h2d.BlendMode",toString:$estr}
};
h2d_BlendMode.__constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
h2d_BlendMode.__empty_constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
var h2d_Camera = function(scene) {
	this.followRotation = false;
	this.posChanged = true;
	this.x = 0;
	this.posChanged = true;
	this.y = 0;
	this.posChanged = true;
	this.scaleX = 1;
	this.posChanged = true;
	this.scaleY = 1;
	this.posChanged = true;
	this.rotation = 0;
	this.posChanged = true;
	this.anchorX = 0;
	this.posChanged = true;
	this.anchorY = 0;
	this.viewX = 0;
	this.viewY = 0;
	this.viewW = 1;
	this.viewH = 1;
	this.visible = true;
	if(scene != null) {
		scene.addCamera(this);
	}
};
$hxClasses["h2d.Camera"] = h2d_Camera;
h2d_Camera.__name__ = "h2d.Camera";
h2d_Camera.prototype = {
	remove: function() {
		if(this.scene != null) {
			this.scene.removeCamera(this);
		}
	}
	,layerVisible: function(layer) {
		return true;
	}
	,enter: function(ctx) {
		ctx.pushCamera(this);
		if(this.clipViewport) {
			var old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.pushRenderZone(this.viewX * this.scene.width,this.viewY * this.scene.height,this.viewW * this.scene.width,this.viewH * this.scene.height);
			ctx.inFilter = old;
		}
	}
	,exit: function(ctx) {
		if(this.clipViewport) {
			var old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.popRenderZone();
			ctx.inFilter = old;
		}
		ctx.popCamera();
	}
	,sync: function(ctx,force) {
		if(force == null) {
			force = false;
		}
		if(this.scene == null) {
			return;
		}
		if(this.follow != null) {
			this.posChanged = true;
			this.x = this.follow.absX;
			this.posChanged = true;
			this.y = this.follow.absY;
			if(this.followRotation) {
				this.posChanged = true;
				this.rotation = -this.follow.rotation;
			}
		}
		if(this.posChanged || force) {
			if(this.rotation == 0) {
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				var cr = Math.cos(this.rotation);
				var sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = Math.round(-(this.x * this.matA + this.y * this.matC) + this.scene.width * this.anchorX * this.viewW + this.scene.width * this.viewX);
			this.absY = Math.round(-(this.x * this.matB + this.y * this.matD) + this.scene.height * this.anchorY * this.viewH + this.scene.height * this.viewY);
			this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
			this.posChanged = false;
		}
	}
	,setScale: function(x,y) {
		this.posChanged = true;
		this.scaleX = x;
		this.posChanged = true;
		this.scaleY = y;
	}
	,scale: function(x,y) {
		this.posChanged = true;
		this.scaleX *= x;
		this.posChanged = true;
		this.scaleY *= y;
	}
	,setPosition: function(x,y) {
		this.posChanged = true;
		this.x = x;
		this.posChanged = true;
		this.y = y;
	}
	,move: function(dx,dy) {
		this.posChanged = true;
		this.x += dx;
		this.posChanged = true;
		this.y += dy;
	}
	,rotate: function(angle) {
		this.posChanged = true;
		this.rotation += angle;
	}
	,setAnchor: function(x,y) {
		this.posChanged = true;
		this.anchorX = x;
		this.posChanged = true;
		this.anchorY = y;
	}
	,setViewport: function(x,y,w,h) {
		if(h == null) {
			h = 0;
		}
		if(w == null) {
			w = 0;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewX = Math.floor(x) / this.scene.width;
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewY = Math.floor(y) / this.scene.height;
		var v = w == 0 ? this.scene.width : w;
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewW = Math.ceil(v) / this.scene.width;
		var v = h == 0 ? this.scene.height : h;
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewH = Math.ceil(v) / this.scene.height;
	}
	,setRawViewport: function(x,y,w,h) {
		if(h == null) {
			h = 1;
		}
		if(w == null) {
			w = 1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		this.viewX = x;
		this.viewY = y;
		this.viewW = w;
		this.viewH = h;
		this.posChanged = true;
	}
	,screenXToCamera: function(mx,my) {
		return (((mx - this.scene.offsetX) / this.scene.viewportScaleX - this.absX) * this.matD - ((my - this.scene.offsetY) / this.scene.viewportScaleY - this.absY) * this.matC) * this.invDet;
	}
	,screenYToCamera: function(mx,my) {
		return (-((mx - this.scene.offsetX) / this.scene.viewportScaleX - this.absX) * this.matB + ((my - this.scene.offsetY) / this.scene.viewportScaleY - this.absY) * this.matA) * this.invDet;
	}
	,cameraXToScreen: function(mx,my) {
		return (mx * this.matA + my * this.matC + this.absX) * this.scene.viewportScaleX + this.scene.offsetX;
	}
	,cameraYToScreen: function(mx,my) {
		return (mx * this.matB + my * this.matD + this.absY) * this.scene.viewportScaleY + this.scene.offsetY;
	}
	,sceneXToCamera: function(mx,my) {
		return ((mx - this.absX) * this.matD - (my - this.absY) * this.matC) * this.invDet;
	}
	,sceneYToCamera: function(mx,my) {
		return (-(mx - this.absX) * this.matB + (my - this.absY) * this.matA) * this.invDet;
	}
	,cameraXToScene: function(mx,my) {
		return mx * this.matA + my * this.matC + this.absX;
	}
	,cameraYToScene: function(mx,my) {
		return mx * this.matB + my * this.matD + this.absY;
	}
	,eventToCamera: function(e) {
		var x = (e.relX - this.scene.offsetX) / this.scene.viewportScaleX - this.absX;
		var y = (e.relY - this.scene.offsetY) / this.scene.viewportScaleY - this.absY;
		e.relX = (x * this.matD - y * this.matC) * this.invDet;
		e.relY = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,screenToCamera: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = (pt.x - this.scene.offsetX) / this.scene.viewportScaleX - this.absX;
		var y = (pt.y - this.scene.offsetY) / this.scene.viewportScaleY - this.absY;
		pt.x = (x * this.matD - y * this.matC) * this.invDet;
		pt.y = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,cameraToScreen: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = pt.x;
		var y = pt.y;
		pt.x = (x * this.matA + y * this.matC + this.absX) * this.scene.viewportScaleX + this.scene.offsetX;
		pt.y = (x * this.matB + y * this.matD + this.absY) * this.scene.viewportScaleY + this.scene.offsetY;
	}
	,sceneToCamera: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = pt.x - this.absX;
		var y = pt.y - this.absY;
		pt.x = (x * this.matD - y * this.matC) * this.invDet;
		pt.y = (-x * this.matB + y * this.matA) * this.invDet;
	}
	,cameraToScene: function(pt) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		var x = pt.x;
		var y = pt.y;
		pt.x = x * this.matA + y * this.matC + this.absX;
		pt.y = x * this.matB + y * this.matD + this.absY;
	}
	,checkScene: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
	}
	,set_x: function(v) {
		this.posChanged = true;
		return this.x = v;
	}
	,set_y: function(v) {
		this.posChanged = true;
		return this.y = v;
	}
	,set_scaleX: function(v) {
		this.posChanged = true;
		return this.scaleX = v;
	}
	,set_scaleY: function(v) {
		this.posChanged = true;
		return this.scaleY = v;
	}
	,set_rotation: function(v) {
		this.posChanged = true;
		return this.rotation = v;
	}
	,get_viewportX: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewX * this.scene.width;
	}
	,set_viewportX: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewX = Math.floor(v) / this.scene.width;
		return v;
	}
	,get_viewportY: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewY * this.scene.height;
	}
	,set_viewportY: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewY = Math.floor(v) / this.scene.height;
		return v;
	}
	,get_viewportWidth: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewW * this.scene.width;
	}
	,set_viewportWidth: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewW = Math.ceil(v) / this.scene.width;
		return v;
	}
	,get_viewportHeight: function() {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		return this.viewH * this.scene.height;
	}
	,set_viewportHeight: function(v) {
		if(this.scene == null) {
			throw haxe_Exception.thrown("This method requires Camera to be added to the Scene");
		}
		this.posChanged = true;
		this.viewH = Math.ceil(v) / this.scene.height;
		return v;
	}
	,set_anchorX: function(v) {
		this.posChanged = true;
		return this.anchorX = v;
	}
	,set_anchorY: function(v) {
		this.posChanged = true;
		return this.anchorY = v;
	}
	,__class__: h2d_Camera
};
var h2d_DepthManager = function(base,e) {
	this.root = base;
	var max = e.__empty_constructs__.slice().length;
	this.layers = [];
	var _g = 0;
	var _g1 = max;
	while(_g < _g1) {
		var i = _g++;
		var layer = new h2d_Drawable(base);
		this.layers.push(layer);
	}
};
$hxClasses["h2d.DepthManager"] = h2d_DepthManager;
h2d_DepthManager.__name__ = "h2d.DepthManager";
h2d_DepthManager.prototype = {
	add: function(mc,en) {
		this.layers[en._hx_index].addChild(mc);
	}
	,getBox: function(en) {
		return this.layers[en._hx_index];
	}
	,cleanDepth: function(en) {
		var base = this.layers[en._hx_index];
		while(true) {
			var mc = base.getChildAt(0);
			if(mc == null) {
				break;
			}
			base.removeChild(mc);
		}
	}
	,__class__: h2d_DepthManager
};
var h2d_Kerning = function(c,o) {
	this.prevChar = c;
	this.offset = o;
};
$hxClasses["h2d.Kerning"] = h2d_Kerning;
h2d_Kerning.__name__ = "h2d.Kerning";
h2d_Kerning.prototype = {
	__class__: h2d_Kerning
};
var h2d_FontChar = function(t,w) {
	this.t = t;
	this.width = w;
};
$hxClasses["h2d.FontChar"] = h2d_FontChar;
h2d_FontChar.__name__ = "h2d.FontChar";
h2d_FontChar.prototype = {
	addKerning: function(prevChar,offset) {
		var k = new h2d_Kerning(prevChar,offset);
		k.next = this.kerning;
		this.kerning = k;
	}
	,getKerningOffset: function(prevChar) {
		var k = this.kerning;
		while(k != null) {
			if(k.prevChar == prevChar) {
				return k.offset;
			}
			k = k.next;
		}
		return 0;
	}
	,clone: function() {
		var c = new h2d_FontChar(this.t.clone(),this.width);
		var k = this.kerning;
		if(k != null) {
			var kc = new h2d_Kerning(k.prevChar,k.offset);
			c.kerning = kc;
			k = k.next;
			while(k != null) {
				var kn = new h2d_Kerning(k.prevChar,k.offset);
				kc = kc.next = kn;
				k = k.next;
			}
		}
		return c;
	}
	,__class__: h2d_FontChar
};
var h2d_FontType = $hxEnums["h2d.FontType"] = { __ename__:"h2d.FontType",__constructs__:null
	,BitmapFont: {_hx_name:"BitmapFont",_hx_index:0,__enum__:"h2d.FontType",toString:$estr}
	,SignedDistanceField: ($_=function(channel,alphaCutoff,smoothing) { return {_hx_index:1,channel:channel,alphaCutoff:alphaCutoff,smoothing:smoothing,__enum__:"h2d.FontType",toString:$estr}; },$_._hx_name="SignedDistanceField",$_.__params__ = ["channel","alphaCutoff","smoothing"],$_)
};
h2d_FontType.__constructs__ = [h2d_FontType.BitmapFont,h2d_FontType.SignedDistanceField];
h2d_FontType.__empty_constructs__ = [h2d_FontType.BitmapFont];
var h2d_Font = function(name,size,type) {
	this.offsetY = 0;
	this.offsetX = 0;
	this.name = name;
	this.size = size;
	this.initSize = size;
	this.glyphs = new haxe_ds_IntMap();
	this.defaultChar = this.nullChar = new h2d_FontChar(new h2d_Tile(null,0,0,0,0),0);
	this.charset = hxd_Charset.getDefault();
	if(name != null) {
		this.tilePath = haxe_io_Path.withExtension(name,"png");
	}
	if(type == null) {
		this.type = h2d_FontType.BitmapFont;
	} else {
		this.type = type;
	}
};
$hxClasses["h2d.Font"] = h2d_Font;
h2d_Font.__name__ = "h2d.Font";
h2d_Font.prototype = {
	getChar: function(code) {
		var c = this.glyphs.h[code];
		if(c == null) {
			c = this.charset.resolveChar(code,this.glyphs);
			if(c == null) {
				c = code == 13 || code == 10 ? this.nullChar : this.defaultChar;
			}
		}
		return c;
	}
	,setOffset: function(x,y) {
		var dx = x - this.offsetX;
		var dy = y - this.offsetY;
		if(dx == 0 && dy == 0) {
			return;
		}
		var g = this.glyphs.iterator();
		while(g.hasNext()) {
			var g1 = g.next();
			g1.t.dx += dx;
			g1.t.dy += dy;
		}
		this.offsetX += dx;
		this.offsetY += dy;
	}
	,clone: function() {
		var f = new h2d_Font(this.name,this.size);
		f.baseLine = this.baseLine;
		f.lineHeight = this.lineHeight;
		f.tile = this.tile.clone();
		f.charset = this.charset;
		f.defaultChar = this.defaultChar.clone();
		f.type = this.type;
		f.offsetX = this.offsetX;
		f.offsetY = this.offsetY;
		var g = this.glyphs.keys();
		while(g.hasNext()) {
			var g1 = g.next();
			var c = this.glyphs.h[g1];
			var c2 = c.clone();
			if(c == this.defaultChar) {
				f.defaultChar = c2;
			}
			f.glyphs.h[g1] = c2;
		}
		return f;
	}
	,resizeTo: function(size) {
		var ratio = size / this.initSize;
		var c = this.glyphs.iterator();
		while(c.hasNext()) {
			var c1 = c.next();
			c1.width *= ratio;
			c1.t.scaleToSize(c1.t.width * ratio,c1.t.height * ratio);
			c1.t.dx *= ratio;
			c1.t.dy *= ratio;
			var k = c1.kerning;
			while(k != null) {
				k.offset *= ratio;
				k = k.next;
			}
		}
		this.lineHeight = Math.ceil(this.lineHeight * ratio);
		this.baseLine = Math.ceil(this.baseLine * ratio);
		this.size = size;
	}
	,hasChar: function(code) {
		return this.glyphs.h[code] != null;
	}
	,dispose: function() {
		this.tile.dispose();
	}
	,calcBaseLine: function() {
		var padding = 0;
		var space = this.glyphs.h[32];
		if(space != null) {
			padding = space.t.height * .5;
		}
		var a = this.glyphs.h[65];
		if(a == null) {
			a = this.glyphs.h[97];
		}
		if(a == null) {
			a = this.glyphs.h[48];
		}
		if(a == null) {
			return this.lineHeight - 2 - padding;
		}
		return a.t.dy + a.t.height - padding;
	}
	,__class__: h2d_Font
};
var h2d_GPoint = function() {
};
$hxClasses["h2d.GPoint"] = h2d_GPoint;
h2d_GPoint.__name__ = "h2d.GPoint";
h2d_GPoint.prototype = {
	load: function(x,y,r,g,b,a) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
	,__class__: h2d_GPoint
};
var h3d_prim_Primitive = function() {
	this.refCount = 0;
};
$hxClasses["h3d.prim.Primitive"] = h3d_prim_Primitive;
h3d_prim_Primitive.__name__ = "h3d.prim.Primitive";
h3d_prim_Primitive.prototype = {
	triCount: function() {
		if(this.indexes != null) {
			return this.indexes.vertices / 3 | 0;
		} else if(this.buffer == null) {
			return 0;
		} else {
			return this.buffer.vertices / 3 | 0;
		}
	}
	,vertexCount: function() {
		return 0;
	}
	,getCollider: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,getBounds: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,incref: function() {
		this.refCount++;
	}
	,decref: function() {
		this.refCount--;
		if(this.refCount <= 0) {
			this.refCount = 0;
			this.dispose();
		}
	}
	,alloc: function(engine) {
		throw haxe_Exception.thrown("not implemented");
	}
	,selectMaterial: function(material) {
	}
	,getMaterialIndexes: function(material) {
		return { start : 0, count : this.indexes == null ? this.triCount() * 3 : this.indexes.vertices};
	}
	,buildNormalsDisplay: function() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	,render: function(engine) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		if(this.indexes == null) {
			var b = this.buffer;
			engine.renderBuffer(b,engine.mem.getTriIndexes(b.vertices),3,0,-1);
		} else {
			engine.renderIndexed(this.buffer,this.indexes);
		}
	}
	,dispose: function() {
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
		if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__.split(".").pop();
	}
	,__class__: h3d_prim_Primitive
};
var h2d__$Graphics_GraphicsContent = function() {
	h3d_prim_Primitive.call(this);
	this.buffers = [];
	this.state = new h2d_impl_BatchDrawState();
};
$hxClasses["h2d._Graphics.GraphicsContent"] = h2d__$Graphics_GraphicsContent;
h2d__$Graphics_GraphicsContent.__name__ = "h2d._Graphics.GraphicsContent";
h2d__$Graphics_GraphicsContent.__super__ = h3d_prim_Primitive;
h2d__$Graphics_GraphicsContent.prototype = $extend(h3d_prim_Primitive.prototype,{
	addIndex: function(i) {
		this.index.push(i);
		var _this = this.state;
		_this.tail.count += 1;
		_this.totalCount += 1;
		this.indexDirty = true;
	}
	,add: function(x,y,u,v,r,g,b,a) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = u;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		this.bufferDirty = true;
	}
	,setTile: function(tile) {
		if(tile != null) {
			this.state.setTexture(tile.innerTex);
		}
	}
	,next: function() {
		var nvect = this.tmp.pos >> 3;
		if(nvect < 32768) {
			return false;
		}
		this.buffers.push({ buf : this.tmp, idx : this.index, vbuf : null, ibuf : null, state : this.state});
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		var tex = this.state.tail.texture;
		this.state = new h2d_impl_BatchDrawState();
		this.state.setTexture(tex);
		h3d_prim_Primitive.prototype.dispose.call(this);
		return true;
	}
	,alloc: function(engine) {
		if(this.index.length <= 0) {
			return;
		}
		var alloc = hxd_impl_Allocator.get();
		this.buffer = alloc.ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA());
		this.indexes = alloc.ofIndexes(this.index);
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.vbuf == null || b.vbuf.vbuf == null) {
				b.vbuf = alloc.ofFloats(b.buf,hxd_BufferFormat.get_XY_UV_RGBA());
			}
			if(b.ibuf == null || b.ibuf.vbuf == null) {
				b.ibuf = alloc.ofIndexes(b.idx);
			}
		}
		this.bufferDirty = false;
		this.indexDirty = false;
	}
	,doRender: function(ctx) {
		if(this.index.length == 0) {
			return;
		}
		this.flush();
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.state.drawIndexed(ctx,b.vbuf,b.ibuf);
		}
		this.state.drawIndexed(ctx,this.buffer,this.indexes);
	}
	,flush: function() {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(h3d_Engine.CURRENT);
		} else {
			var allocator = hxd_impl_Allocator.get();
			if(this.bufferDirty) {
				allocator.disposeBuffer(this.buffer);
				this.buffer = allocator.ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA());
				this.bufferDirty = false;
			}
			if(this.indexDirty) {
				allocator.disposeIndexBuffer(this.indexes);
				this.indexes = allocator.ofIndexes(this.index);
				this.indexDirty = false;
			}
		}
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.vbuf != null) {
				hxd_impl_Allocator.get().disposeBuffer(b.vbuf);
			}
			if(b.ibuf != null) {
				hxd_impl_Allocator.get().disposeIndexBuffer(b.ibuf);
			}
			b.vbuf = null;
			b.ibuf = null;
			b.state.clear();
		}
		if(this.buffer != null) {
			hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			this.buffer = null;
		}
		if(this.indexes != null) {
			hxd_impl_Allocator.get().disposeIndexBuffer(this.indexes);
			this.indexes = null;
		}
		this.state.clear();
		h3d_prim_Primitive.prototype.dispose.call(this);
	}
	,clear: function() {
		this.dispose();
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		this.buffers = [];
	}
	,__class__: h2d__$Graphics_GraphicsContent
});
var h2d_Graphics = function(parent) {
	this.bevel = 0.25;
	this.my = 0.;
	this.mx = 0.;
	this.md = 1.;
	this.mc = 0.;
	this.mb = 0.;
	this.ma = 1.;
	h2d_Drawable.call(this,parent);
	this.content = new h2d__$Graphics_GraphicsContent();
	this.tile = h2d_Tile.fromColor(16777215);
	this.clear();
};
$hxClasses["h2d.Graphics"] = h2d_Graphics;
h2d_Graphics.__name__ = "h2d.Graphics";
h2d_Graphics.__super__ = h2d_Drawable;
h2d_Graphics.prototype = $extend(h2d_Drawable.prototype,{
	onRemove: function() {
		h2d_Drawable.prototype.onRemove.call(this);
		this.clear();
	}
	,clear: function() {
		this.content.clear();
		this.tmpPoints = [];
		this.pindex = 0;
		this.lineSize = 0;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.yMax = -Infinity;
		this.xMax = -Infinity;
		this.xMinSize = Infinity;
		this.yMinSize = Infinity;
		this.yMaxSize = -Infinity;
		this.xMaxSize = -Infinity;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.tile != null) {
			if(forSize) {
				this.addBounds(relativeTo,out,this.xMinSize,this.yMinSize,this.xMaxSize - this.xMinSize,this.yMaxSize - this.yMinSize);
			} else {
				this.addBounds(relativeTo,out,this.xMin,this.yMin,this.xMax - this.xMin,this.yMax - this.yMin);
			}
		}
	}
	,isConvex: function(points) {
		var first = true;
		var sign = false;
		var _g = 0;
		var _g1 = points.length;
		while(_g < _g1) {
			var i = _g++;
			var p1 = points[i];
			var p2 = points[(i + 1) % points.length];
			var p3 = points[(i + 2) % points.length];
			var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
			if(first) {
				first = false;
				sign = s;
			} else if(sign != s) {
				return false;
			}
		}
		return true;
	}
	,flushLine: function(start) {
		var pts = this.tmpPoints;
		var last = pts.length - 1;
		var prev = pts[last];
		var p = pts[0];
		this.content.setTile(h2d_Tile.fromColor(16777215));
		var closed = p.x == prev.x && p.y == prev.y;
		var count = pts.length;
		if(!closed) {
			var prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			var gp = new h2d_GPoint();
			gp.load(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,0,0,0,0);
			pts.push(gp);
			var pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			var gp = new h2d_GPoint();
			gp.load(p.x * 2 - pNext.x,p.y * 2 - pNext.y,0,0,0,0);
			prev = gp;
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			var next = pts[(i + 1) % pts.length];
			var nx1 = prev.y - p.y;
			var ny1 = p.x - prev.x;
			var ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			var nx2 = p.y - next.y;
			var ny2 = next.x - p.x;
			var ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			var nx = nx1 * ns1 + nx2 * ns2;
			var ny = ny1 * ns1 + ny2 * ns2;
			var ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			var size = nx * nx1 * ns1 + ny * ny1 * ns1;
			if(size < 0.1) {
				size = 0.1;
			}
			var d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			if(size > this.bevel) {
				var _this = this.content;
				var x = p.x + nx;
				var y = p.y + ny;
				var r = p.r;
				var g = p.g;
				var b = p.b;
				var a = p.a;
				var this1 = _this.tmp;
				if(this1.pos == this1.array.length) {
					var newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = x;
				var this2 = _this.tmp;
				if(this2.pos == this2.array.length) {
					var newSize1 = this2.array.length << 1;
					if(newSize1 < 128) {
						newSize1 = 128;
					}
					var newArray1 = new Float32Array(newSize1);
					newArray1.set(this2.array);
					this2.array = newArray1;
				}
				this2.array[this2.pos++] = y;
				var this3 = _this.tmp;
				if(this3.pos == this3.array.length) {
					var newSize2 = this3.array.length << 1;
					if(newSize2 < 128) {
						newSize2 = 128;
					}
					var newArray2 = new Float32Array(newSize2);
					newArray2.set(this3.array);
					this3.array = newArray2;
				}
				this3.array[this3.pos++] = 0;
				var this4 = _this.tmp;
				if(this4.pos == this4.array.length) {
					var newSize3 = this4.array.length << 1;
					if(newSize3 < 128) {
						newSize3 = 128;
					}
					var newArray3 = new Float32Array(newSize3);
					newArray3.set(this4.array);
					this4.array = newArray3;
				}
				this4.array[this4.pos++] = 0;
				var this5 = _this.tmp;
				if(this5.pos == this5.array.length) {
					var newSize4 = this5.array.length << 1;
					if(newSize4 < 128) {
						newSize4 = 128;
					}
					var newArray4 = new Float32Array(newSize4);
					newArray4.set(this5.array);
					this5.array = newArray4;
				}
				this5.array[this5.pos++] = r;
				var this6 = _this.tmp;
				if(this6.pos == this6.array.length) {
					var newSize5 = this6.array.length << 1;
					if(newSize5 < 128) {
						newSize5 = 128;
					}
					var newArray5 = new Float32Array(newSize5);
					newArray5.set(this6.array);
					this6.array = newArray5;
				}
				this6.array[this6.pos++] = g;
				var this7 = _this.tmp;
				if(this7.pos == this7.array.length) {
					var newSize6 = this7.array.length << 1;
					if(newSize6 < 128) {
						newSize6 = 128;
					}
					var newArray6 = new Float32Array(newSize6);
					newArray6.set(this7.array);
					this7.array = newArray6;
				}
				this7.array[this7.pos++] = b;
				var this8 = _this.tmp;
				if(this8.pos == this8.array.length) {
					var newSize7 = this8.array.length << 1;
					if(newSize7 < 128) {
						newSize7 = 128;
					}
					var newArray7 = new Float32Array(newSize7);
					newArray7.set(this8.array);
					this8.array = newArray7;
				}
				this8.array[this8.pos++] = a;
				_this.bufferDirty = true;
				var _this1 = this.content;
				var x1 = p.x - nx;
				var y1 = p.y - ny;
				var r1 = p.r;
				var g1 = p.g;
				var b1 = p.b;
				var a1 = p.a;
				var this9 = _this1.tmp;
				if(this9.pos == this9.array.length) {
					var newSize8 = this9.array.length << 1;
					if(newSize8 < 128) {
						newSize8 = 128;
					}
					var newArray8 = new Float32Array(newSize8);
					newArray8.set(this9.array);
					this9.array = newArray8;
				}
				this9.array[this9.pos++] = x1;
				var this10 = _this1.tmp;
				if(this10.pos == this10.array.length) {
					var newSize9 = this10.array.length << 1;
					if(newSize9 < 128) {
						newSize9 = 128;
					}
					var newArray9 = new Float32Array(newSize9);
					newArray9.set(this10.array);
					this10.array = newArray9;
				}
				this10.array[this10.pos++] = y1;
				var this11 = _this1.tmp;
				if(this11.pos == this11.array.length) {
					var newSize10 = this11.array.length << 1;
					if(newSize10 < 128) {
						newSize10 = 128;
					}
					var newArray10 = new Float32Array(newSize10);
					newArray10.set(this11.array);
					this11.array = newArray10;
				}
				this11.array[this11.pos++] = 0;
				var this12 = _this1.tmp;
				if(this12.pos == this12.array.length) {
					var newSize11 = this12.array.length << 1;
					if(newSize11 < 128) {
						newSize11 = 128;
					}
					var newArray11 = new Float32Array(newSize11);
					newArray11.set(this12.array);
					this12.array = newArray11;
				}
				this12.array[this12.pos++] = 0;
				var this13 = _this1.tmp;
				if(this13.pos == this13.array.length) {
					var newSize12 = this13.array.length << 1;
					if(newSize12 < 128) {
						newSize12 = 128;
					}
					var newArray12 = new Float32Array(newSize12);
					newArray12.set(this13.array);
					this13.array = newArray12;
				}
				this13.array[this13.pos++] = r1;
				var this14 = _this1.tmp;
				if(this14.pos == this14.array.length) {
					var newSize13 = this14.array.length << 1;
					if(newSize13 < 128) {
						newSize13 = 128;
					}
					var newArray13 = new Float32Array(newSize13);
					newArray13.set(this14.array);
					this14.array = newArray13;
				}
				this14.array[this14.pos++] = g1;
				var this15 = _this1.tmp;
				if(this15.pos == this15.array.length) {
					var newSize14 = this15.array.length << 1;
					if(newSize14 < 128) {
						newSize14 = 128;
					}
					var newArray14 = new Float32Array(newSize14);
					newArray14.set(this15.array);
					this15.array = newArray14;
				}
				this15.array[this15.pos++] = b1;
				var this16 = _this1.tmp;
				if(this16.pos == this16.array.length) {
					var newSize15 = this16.array.length << 1;
					if(newSize15 < 128) {
						newSize15 = 128;
					}
					var newArray15 = new Float32Array(newSize15);
					newArray15.set(this16.array);
					this16.array = newArray15;
				}
				this16.array[this16.pos++] = a1;
				_this1.bufferDirty = true;
				var pnext = i == last ? start : this.pindex + 2;
				if(i < count - 1 || closed) {
					var _this2 = this.content;
					_this2.index.push(this.pindex);
					var _this3 = _this2.state;
					_this3.tail.count += 1;
					_this3.totalCount += 1;
					_this2.indexDirty = true;
					var _this4 = this.content;
					_this4.index.push(this.pindex + 1);
					var _this5 = _this4.state;
					_this5.tail.count += 1;
					_this5.totalCount += 1;
					_this4.indexDirty = true;
					var _this6 = this.content;
					_this6.index.push(pnext);
					var _this7 = _this6.state;
					_this7.tail.count += 1;
					_this7.totalCount += 1;
					_this6.indexDirty = true;
					var _this8 = this.content;
					_this8.index.push(this.pindex + 1);
					var _this9 = _this8.state;
					_this9.tail.count += 1;
					_this9.totalCount += 1;
					_this8.indexDirty = true;
					var _this10 = this.content;
					_this10.index.push(pnext);
					var _this11 = _this10.state;
					_this11.tail.count += 1;
					_this11.totalCount += 1;
					_this10.indexDirty = true;
					var _this12 = this.content;
					_this12.index.push(pnext + 1);
					var _this13 = _this12.state;
					_this13.tail.count += 1;
					_this13.totalCount += 1;
					_this12.indexDirty = true;
				}
				this.pindex += 2;
			} else {
				var n0x = next.x - p.x;
				var n0y = next.y - p.y;
				var sign = n0x * nx + n0y * ny;
				var nnx = -ny;
				var nny = nx;
				var size1 = nnx * nx1 * ns1 + nny * ny1 * ns1;
				var d1 = this.lineSize * 0.5 / size1;
				nnx *= d1;
				nny *= d1;
				var pnext1 = i == last ? start : this.pindex + 3;
				if(sign > 0) {
					var _this14 = this.content;
					var x2 = p.x + nx;
					var y2 = p.y + ny;
					var r2 = p.r;
					var g2 = p.g;
					var b2 = p.b;
					var a2 = p.a;
					var this17 = _this14.tmp;
					if(this17.pos == this17.array.length) {
						var newSize16 = this17.array.length << 1;
						if(newSize16 < 128) {
							newSize16 = 128;
						}
						var newArray16 = new Float32Array(newSize16);
						newArray16.set(this17.array);
						this17.array = newArray16;
					}
					this17.array[this17.pos++] = x2;
					var this18 = _this14.tmp;
					if(this18.pos == this18.array.length) {
						var newSize17 = this18.array.length << 1;
						if(newSize17 < 128) {
							newSize17 = 128;
						}
						var newArray17 = new Float32Array(newSize17);
						newArray17.set(this18.array);
						this18.array = newArray17;
					}
					this18.array[this18.pos++] = y2;
					var this19 = _this14.tmp;
					if(this19.pos == this19.array.length) {
						var newSize18 = this19.array.length << 1;
						if(newSize18 < 128) {
							newSize18 = 128;
						}
						var newArray18 = new Float32Array(newSize18);
						newArray18.set(this19.array);
						this19.array = newArray18;
					}
					this19.array[this19.pos++] = 0;
					var this20 = _this14.tmp;
					if(this20.pos == this20.array.length) {
						var newSize19 = this20.array.length << 1;
						if(newSize19 < 128) {
							newSize19 = 128;
						}
						var newArray19 = new Float32Array(newSize19);
						newArray19.set(this20.array);
						this20.array = newArray19;
					}
					this20.array[this20.pos++] = 0;
					var this21 = _this14.tmp;
					if(this21.pos == this21.array.length) {
						var newSize20 = this21.array.length << 1;
						if(newSize20 < 128) {
							newSize20 = 128;
						}
						var newArray20 = new Float32Array(newSize20);
						newArray20.set(this21.array);
						this21.array = newArray20;
					}
					this21.array[this21.pos++] = r2;
					var this22 = _this14.tmp;
					if(this22.pos == this22.array.length) {
						var newSize21 = this22.array.length << 1;
						if(newSize21 < 128) {
							newSize21 = 128;
						}
						var newArray21 = new Float32Array(newSize21);
						newArray21.set(this22.array);
						this22.array = newArray21;
					}
					this22.array[this22.pos++] = g2;
					var this23 = _this14.tmp;
					if(this23.pos == this23.array.length) {
						var newSize22 = this23.array.length << 1;
						if(newSize22 < 128) {
							newSize22 = 128;
						}
						var newArray22 = new Float32Array(newSize22);
						newArray22.set(this23.array);
						this23.array = newArray22;
					}
					this23.array[this23.pos++] = b2;
					var this24 = _this14.tmp;
					if(this24.pos == this24.array.length) {
						var newSize23 = this24.array.length << 1;
						if(newSize23 < 128) {
							newSize23 = 128;
						}
						var newArray23 = new Float32Array(newSize23);
						newArray23.set(this24.array);
						this24.array = newArray23;
					}
					this24.array[this24.pos++] = a2;
					_this14.bufferDirty = true;
					var _this15 = this.content;
					var x3 = p.x - nnx;
					var y3 = p.y - nny;
					var r3 = p.r;
					var g3 = p.g;
					var b3 = p.b;
					var a3 = p.a;
					var this25 = _this15.tmp;
					if(this25.pos == this25.array.length) {
						var newSize24 = this25.array.length << 1;
						if(newSize24 < 128) {
							newSize24 = 128;
						}
						var newArray24 = new Float32Array(newSize24);
						newArray24.set(this25.array);
						this25.array = newArray24;
					}
					this25.array[this25.pos++] = x3;
					var this26 = _this15.tmp;
					if(this26.pos == this26.array.length) {
						var newSize25 = this26.array.length << 1;
						if(newSize25 < 128) {
							newSize25 = 128;
						}
						var newArray25 = new Float32Array(newSize25);
						newArray25.set(this26.array);
						this26.array = newArray25;
					}
					this26.array[this26.pos++] = y3;
					var this27 = _this15.tmp;
					if(this27.pos == this27.array.length) {
						var newSize26 = this27.array.length << 1;
						if(newSize26 < 128) {
							newSize26 = 128;
						}
						var newArray26 = new Float32Array(newSize26);
						newArray26.set(this27.array);
						this27.array = newArray26;
					}
					this27.array[this27.pos++] = 0;
					var this28 = _this15.tmp;
					if(this28.pos == this28.array.length) {
						var newSize27 = this28.array.length << 1;
						if(newSize27 < 128) {
							newSize27 = 128;
						}
						var newArray27 = new Float32Array(newSize27);
						newArray27.set(this28.array);
						this28.array = newArray27;
					}
					this28.array[this28.pos++] = 0;
					var this29 = _this15.tmp;
					if(this29.pos == this29.array.length) {
						var newSize28 = this29.array.length << 1;
						if(newSize28 < 128) {
							newSize28 = 128;
						}
						var newArray28 = new Float32Array(newSize28);
						newArray28.set(this29.array);
						this29.array = newArray28;
					}
					this29.array[this29.pos++] = r3;
					var this30 = _this15.tmp;
					if(this30.pos == this30.array.length) {
						var newSize29 = this30.array.length << 1;
						if(newSize29 < 128) {
							newSize29 = 128;
						}
						var newArray29 = new Float32Array(newSize29);
						newArray29.set(this30.array);
						this30.array = newArray29;
					}
					this30.array[this30.pos++] = g3;
					var this31 = _this15.tmp;
					if(this31.pos == this31.array.length) {
						var newSize30 = this31.array.length << 1;
						if(newSize30 < 128) {
							newSize30 = 128;
						}
						var newArray30 = new Float32Array(newSize30);
						newArray30.set(this31.array);
						this31.array = newArray30;
					}
					this31.array[this31.pos++] = b3;
					var this32 = _this15.tmp;
					if(this32.pos == this32.array.length) {
						var newSize31 = this32.array.length << 1;
						if(newSize31 < 128) {
							newSize31 = 128;
						}
						var newArray31 = new Float32Array(newSize31);
						newArray31.set(this32.array);
						this32.array = newArray31;
					}
					this32.array[this32.pos++] = a3;
					_this15.bufferDirty = true;
					var _this16 = this.content;
					var x4 = p.x + nnx;
					var y4 = p.y + nny;
					var r4 = p.r;
					var g4 = p.g;
					var b4 = p.b;
					var a4 = p.a;
					var this33 = _this16.tmp;
					if(this33.pos == this33.array.length) {
						var newSize32 = this33.array.length << 1;
						if(newSize32 < 128) {
							newSize32 = 128;
						}
						var newArray32 = new Float32Array(newSize32);
						newArray32.set(this33.array);
						this33.array = newArray32;
					}
					this33.array[this33.pos++] = x4;
					var this34 = _this16.tmp;
					if(this34.pos == this34.array.length) {
						var newSize33 = this34.array.length << 1;
						if(newSize33 < 128) {
							newSize33 = 128;
						}
						var newArray33 = new Float32Array(newSize33);
						newArray33.set(this34.array);
						this34.array = newArray33;
					}
					this34.array[this34.pos++] = y4;
					var this35 = _this16.tmp;
					if(this35.pos == this35.array.length) {
						var newSize34 = this35.array.length << 1;
						if(newSize34 < 128) {
							newSize34 = 128;
						}
						var newArray34 = new Float32Array(newSize34);
						newArray34.set(this35.array);
						this35.array = newArray34;
					}
					this35.array[this35.pos++] = 0;
					var this36 = _this16.tmp;
					if(this36.pos == this36.array.length) {
						var newSize35 = this36.array.length << 1;
						if(newSize35 < 128) {
							newSize35 = 128;
						}
						var newArray35 = new Float32Array(newSize35);
						newArray35.set(this36.array);
						this36.array = newArray35;
					}
					this36.array[this36.pos++] = 0;
					var this37 = _this16.tmp;
					if(this37.pos == this37.array.length) {
						var newSize36 = this37.array.length << 1;
						if(newSize36 < 128) {
							newSize36 = 128;
						}
						var newArray36 = new Float32Array(newSize36);
						newArray36.set(this37.array);
						this37.array = newArray36;
					}
					this37.array[this37.pos++] = r4;
					var this38 = _this16.tmp;
					if(this38.pos == this38.array.length) {
						var newSize37 = this38.array.length << 1;
						if(newSize37 < 128) {
							newSize37 = 128;
						}
						var newArray37 = new Float32Array(newSize37);
						newArray37.set(this38.array);
						this38.array = newArray37;
					}
					this38.array[this38.pos++] = g4;
					var this39 = _this16.tmp;
					if(this39.pos == this39.array.length) {
						var newSize38 = this39.array.length << 1;
						if(newSize38 < 128) {
							newSize38 = 128;
						}
						var newArray38 = new Float32Array(newSize38);
						newArray38.set(this39.array);
						this39.array = newArray38;
					}
					this39.array[this39.pos++] = b4;
					var this40 = _this16.tmp;
					if(this40.pos == this40.array.length) {
						var newSize39 = this40.array.length << 1;
						if(newSize39 < 128) {
							newSize39 = 128;
						}
						var newArray39 = new Float32Array(newSize39);
						newArray39.set(this40.array);
						this40.array = newArray39;
					}
					this40.array[this40.pos++] = a4;
					_this16.bufferDirty = true;
					var _this17 = this.content;
					_this17.index.push(this.pindex);
					var _this18 = _this17.state;
					_this18.tail.count += 1;
					_this18.totalCount += 1;
					_this17.indexDirty = true;
					var _this19 = this.content;
					_this19.index.push(pnext1);
					var _this20 = _this19.state;
					_this20.tail.count += 1;
					_this20.totalCount += 1;
					_this19.indexDirty = true;
					var _this21 = this.content;
					_this21.index.push(this.pindex + 2);
					var _this22 = _this21.state;
					_this22.tail.count += 1;
					_this22.totalCount += 1;
					_this21.indexDirty = true;
					var _this23 = this.content;
					_this23.index.push(this.pindex + 2);
					var _this24 = _this23.state;
					_this24.tail.count += 1;
					_this24.totalCount += 1;
					_this23.indexDirty = true;
					var _this25 = this.content;
					_this25.index.push(pnext1);
					var _this26 = _this25.state;
					_this26.tail.count += 1;
					_this26.totalCount += 1;
					_this25.indexDirty = true;
					var _this27 = this.content;
					_this27.index.push(pnext1 + 1);
					var _this28 = _this27.state;
					_this28.tail.count += 1;
					_this28.totalCount += 1;
					_this27.indexDirty = true;
				} else {
					var _this29 = this.content;
					var x5 = p.x + nnx;
					var y5 = p.y + nny;
					var r5 = p.r;
					var g5 = p.g;
					var b5 = p.b;
					var a5 = p.a;
					var this41 = _this29.tmp;
					if(this41.pos == this41.array.length) {
						var newSize40 = this41.array.length << 1;
						if(newSize40 < 128) {
							newSize40 = 128;
						}
						var newArray40 = new Float32Array(newSize40);
						newArray40.set(this41.array);
						this41.array = newArray40;
					}
					this41.array[this41.pos++] = x5;
					var this42 = _this29.tmp;
					if(this42.pos == this42.array.length) {
						var newSize41 = this42.array.length << 1;
						if(newSize41 < 128) {
							newSize41 = 128;
						}
						var newArray41 = new Float32Array(newSize41);
						newArray41.set(this42.array);
						this42.array = newArray41;
					}
					this42.array[this42.pos++] = y5;
					var this43 = _this29.tmp;
					if(this43.pos == this43.array.length) {
						var newSize42 = this43.array.length << 1;
						if(newSize42 < 128) {
							newSize42 = 128;
						}
						var newArray42 = new Float32Array(newSize42);
						newArray42.set(this43.array);
						this43.array = newArray42;
					}
					this43.array[this43.pos++] = 0;
					var this44 = _this29.tmp;
					if(this44.pos == this44.array.length) {
						var newSize43 = this44.array.length << 1;
						if(newSize43 < 128) {
							newSize43 = 128;
						}
						var newArray43 = new Float32Array(newSize43);
						newArray43.set(this44.array);
						this44.array = newArray43;
					}
					this44.array[this44.pos++] = 0;
					var this45 = _this29.tmp;
					if(this45.pos == this45.array.length) {
						var newSize44 = this45.array.length << 1;
						if(newSize44 < 128) {
							newSize44 = 128;
						}
						var newArray44 = new Float32Array(newSize44);
						newArray44.set(this45.array);
						this45.array = newArray44;
					}
					this45.array[this45.pos++] = r5;
					var this46 = _this29.tmp;
					if(this46.pos == this46.array.length) {
						var newSize45 = this46.array.length << 1;
						if(newSize45 < 128) {
							newSize45 = 128;
						}
						var newArray45 = new Float32Array(newSize45);
						newArray45.set(this46.array);
						this46.array = newArray45;
					}
					this46.array[this46.pos++] = g5;
					var this47 = _this29.tmp;
					if(this47.pos == this47.array.length) {
						var newSize46 = this47.array.length << 1;
						if(newSize46 < 128) {
							newSize46 = 128;
						}
						var newArray46 = new Float32Array(newSize46);
						newArray46.set(this47.array);
						this47.array = newArray46;
					}
					this47.array[this47.pos++] = b5;
					var this48 = _this29.tmp;
					if(this48.pos == this48.array.length) {
						var newSize47 = this48.array.length << 1;
						if(newSize47 < 128) {
							newSize47 = 128;
						}
						var newArray47 = new Float32Array(newSize47);
						newArray47.set(this48.array);
						this48.array = newArray47;
					}
					this48.array[this48.pos++] = a5;
					_this29.bufferDirty = true;
					var _this30 = this.content;
					var x6 = p.x - nx;
					var y6 = p.y - ny;
					var r6 = p.r;
					var g6 = p.g;
					var b6 = p.b;
					var a6 = p.a;
					var this49 = _this30.tmp;
					if(this49.pos == this49.array.length) {
						var newSize48 = this49.array.length << 1;
						if(newSize48 < 128) {
							newSize48 = 128;
						}
						var newArray48 = new Float32Array(newSize48);
						newArray48.set(this49.array);
						this49.array = newArray48;
					}
					this49.array[this49.pos++] = x6;
					var this50 = _this30.tmp;
					if(this50.pos == this50.array.length) {
						var newSize49 = this50.array.length << 1;
						if(newSize49 < 128) {
							newSize49 = 128;
						}
						var newArray49 = new Float32Array(newSize49);
						newArray49.set(this50.array);
						this50.array = newArray49;
					}
					this50.array[this50.pos++] = y6;
					var this51 = _this30.tmp;
					if(this51.pos == this51.array.length) {
						var newSize50 = this51.array.length << 1;
						if(newSize50 < 128) {
							newSize50 = 128;
						}
						var newArray50 = new Float32Array(newSize50);
						newArray50.set(this51.array);
						this51.array = newArray50;
					}
					this51.array[this51.pos++] = 0;
					var this52 = _this30.tmp;
					if(this52.pos == this52.array.length) {
						var newSize51 = this52.array.length << 1;
						if(newSize51 < 128) {
							newSize51 = 128;
						}
						var newArray51 = new Float32Array(newSize51);
						newArray51.set(this52.array);
						this52.array = newArray51;
					}
					this52.array[this52.pos++] = 0;
					var this53 = _this30.tmp;
					if(this53.pos == this53.array.length) {
						var newSize52 = this53.array.length << 1;
						if(newSize52 < 128) {
							newSize52 = 128;
						}
						var newArray52 = new Float32Array(newSize52);
						newArray52.set(this53.array);
						this53.array = newArray52;
					}
					this53.array[this53.pos++] = r6;
					var this54 = _this30.tmp;
					if(this54.pos == this54.array.length) {
						var newSize53 = this54.array.length << 1;
						if(newSize53 < 128) {
							newSize53 = 128;
						}
						var newArray53 = new Float32Array(newSize53);
						newArray53.set(this54.array);
						this54.array = newArray53;
					}
					this54.array[this54.pos++] = g6;
					var this55 = _this30.tmp;
					if(this55.pos == this55.array.length) {
						var newSize54 = this55.array.length << 1;
						if(newSize54 < 128) {
							newSize54 = 128;
						}
						var newArray54 = new Float32Array(newSize54);
						newArray54.set(this55.array);
						this55.array = newArray54;
					}
					this55.array[this55.pos++] = b6;
					var this56 = _this30.tmp;
					if(this56.pos == this56.array.length) {
						var newSize55 = this56.array.length << 1;
						if(newSize55 < 128) {
							newSize55 = 128;
						}
						var newArray55 = new Float32Array(newSize55);
						newArray55.set(this56.array);
						this56.array = newArray55;
					}
					this56.array[this56.pos++] = a6;
					_this30.bufferDirty = true;
					var _this31 = this.content;
					var x7 = p.x - nnx;
					var y7 = p.y - nny;
					var r7 = p.r;
					var g7 = p.g;
					var b7 = p.b;
					var a7 = p.a;
					var this57 = _this31.tmp;
					if(this57.pos == this57.array.length) {
						var newSize56 = this57.array.length << 1;
						if(newSize56 < 128) {
							newSize56 = 128;
						}
						var newArray56 = new Float32Array(newSize56);
						newArray56.set(this57.array);
						this57.array = newArray56;
					}
					this57.array[this57.pos++] = x7;
					var this58 = _this31.tmp;
					if(this58.pos == this58.array.length) {
						var newSize57 = this58.array.length << 1;
						if(newSize57 < 128) {
							newSize57 = 128;
						}
						var newArray57 = new Float32Array(newSize57);
						newArray57.set(this58.array);
						this58.array = newArray57;
					}
					this58.array[this58.pos++] = y7;
					var this59 = _this31.tmp;
					if(this59.pos == this59.array.length) {
						var newSize58 = this59.array.length << 1;
						if(newSize58 < 128) {
							newSize58 = 128;
						}
						var newArray58 = new Float32Array(newSize58);
						newArray58.set(this59.array);
						this59.array = newArray58;
					}
					this59.array[this59.pos++] = 0;
					var this60 = _this31.tmp;
					if(this60.pos == this60.array.length) {
						var newSize59 = this60.array.length << 1;
						if(newSize59 < 128) {
							newSize59 = 128;
						}
						var newArray59 = new Float32Array(newSize59);
						newArray59.set(this60.array);
						this60.array = newArray59;
					}
					this60.array[this60.pos++] = 0;
					var this61 = _this31.tmp;
					if(this61.pos == this61.array.length) {
						var newSize60 = this61.array.length << 1;
						if(newSize60 < 128) {
							newSize60 = 128;
						}
						var newArray60 = new Float32Array(newSize60);
						newArray60.set(this61.array);
						this61.array = newArray60;
					}
					this61.array[this61.pos++] = r7;
					var this62 = _this31.tmp;
					if(this62.pos == this62.array.length) {
						var newSize61 = this62.array.length << 1;
						if(newSize61 < 128) {
							newSize61 = 128;
						}
						var newArray61 = new Float32Array(newSize61);
						newArray61.set(this62.array);
						this62.array = newArray61;
					}
					this62.array[this62.pos++] = g7;
					var this63 = _this31.tmp;
					if(this63.pos == this63.array.length) {
						var newSize62 = this63.array.length << 1;
						if(newSize62 < 128) {
							newSize62 = 128;
						}
						var newArray62 = new Float32Array(newSize62);
						newArray62.set(this63.array);
						this63.array = newArray62;
					}
					this63.array[this63.pos++] = b7;
					var this64 = _this31.tmp;
					if(this64.pos == this64.array.length) {
						var newSize63 = this64.array.length << 1;
						if(newSize63 < 128) {
							newSize63 = 128;
						}
						var newArray63 = new Float32Array(newSize63);
						newArray63.set(this64.array);
						this64.array = newArray63;
					}
					this64.array[this64.pos++] = a7;
					_this31.bufferDirty = true;
					var _this32 = this.content;
					_this32.index.push(this.pindex + 1);
					var _this33 = _this32.state;
					_this33.tail.count += 1;
					_this33.totalCount += 1;
					_this32.indexDirty = true;
					var _this34 = this.content;
					_this34.index.push(pnext1);
					var _this35 = _this34.state;
					_this35.tail.count += 1;
					_this35.totalCount += 1;
					_this34.indexDirty = true;
					var _this36 = this.content;
					_this36.index.push(this.pindex + 2);
					var _this37 = _this36.state;
					_this37.tail.count += 1;
					_this37.totalCount += 1;
					_this36.indexDirty = true;
					var _this38 = this.content;
					_this38.index.push(this.pindex + 1);
					var _this39 = _this38.state;
					_this39.tail.count += 1;
					_this39.totalCount += 1;
					_this38.indexDirty = true;
					var _this40 = this.content;
					_this40.index.push(pnext1);
					var _this41 = _this40.state;
					_this41.tail.count += 1;
					_this41.totalCount += 1;
					_this40.indexDirty = true;
					var _this42 = this.content;
					_this42.index.push(pnext1 + 1);
					var _this43 = _this42.state;
					_this43.tail.count += 1;
					_this43.totalCount += 1;
					_this42.indexDirty = true;
				}
				var _this44 = this.content;
				_this44.index.push(this.pindex);
				var _this45 = _this44.state;
				_this45.tail.count += 1;
				_this45.totalCount += 1;
				_this44.indexDirty = true;
				var _this46 = this.content;
				_this46.index.push(this.pindex + 1);
				var _this47 = _this46.state;
				_this47.tail.count += 1;
				_this47.totalCount += 1;
				_this46.indexDirty = true;
				var _this48 = this.content;
				_this48.index.push(this.pindex + 2);
				var _this49 = _this48.state;
				_this49.tail.count += 1;
				_this49.totalCount += 1;
				_this48.indexDirty = true;
				this.pindex += 3;
			}
			prev = p;
			p = next;
		}
		this.content.setTile(this.tile);
	}
	,flushFill: function(i0) {
		if(this.tmpPoints.length < 3) {
			return;
		}
		var pts = this.tmpPoints;
		var p0 = pts[0];
		var p1 = pts[pts.length - 1];
		var last = null;
		var tmp;
		var f = p0.x - p1.x;
		if((f < 0 ? -f : f) < 1e-9) {
			var f = p0.y - p1.y;
			tmp = (f < 0 ? -f : f) < 1e-9;
		} else {
			tmp = false;
		}
		if(tmp) {
			last = pts.pop();
		}
		if(this.isConvex(pts)) {
			var _g = 1;
			var _g1 = pts.length - 1;
			while(_g < _g1) {
				var i = _g++;
				var _this = this.content;
				_this.index.push(i0);
				var _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				var _this2 = this.content;
				_this2.index.push(i0 + i);
				var _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				var _this4 = this.content;
				_this4.index.push(i0 + i + 1);
				var _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
			}
		} else {
			var ear = h2d_Graphics.EARCUT;
			if(ear == null) {
				ear = new hxd_earcut_Earcut();
				h2d_Graphics.EARCUT = ear;
			}
			var _g = 0;
			var _g1 = ear.triangulate_h2d_GPoint(pts);
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				var _this = this.content;
				_this.index.push(i + i0);
				var _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
			}
		}
		if(last != null) {
			pts.push(last);
		}
	}
	,flush: function() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.doFill) {
			this.flushFill(this.pindex);
			this.pindex += this.tmpPoints.length;
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		if(this.lineSize > 0) {
			this.flushLine(this.pindex);
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		this.tmpPoints = [];
	}
	,beginFill: function(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		this.flush();
		this.tile = h2d_Tile.fromColor(16777215);
		this.content.setTile(this.tile);
		var alpha1 = alpha;
		if(alpha1 == null) {
			alpha1 = 1.;
		}
		this.curA = alpha1;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
		this.doFill = true;
	}
	,beginTileFill: function(dx,dy,scaleX,scaleY,tile) {
		if(tile == null) {
			tile = this.tile;
		}
		if(tile == null) {
			throw haxe_Exception.thrown("Tile not specified");
		}
		this.flush();
		this.tile = tile;
		this.content.setTile(tile);
		this.curA = 1.;
		this.curR = 1.;
		this.curG = 1.;
		this.curB = 1.;
		this.doFill = true;
		if(dx == null) {
			dx = 0;
		}
		if(dy == null) {
			dy = 0;
		}
		if(scaleX == null) {
			scaleX = 1;
		}
		if(scaleY == null) {
			scaleY = 1;
		}
		dx -= tile.x;
		dy -= tile.y;
		var tex = tile.innerTex;
		var pixWidth = 1 / tex.width;
		var pixHeight = 1 / tex.height;
		this.ma = pixWidth / scaleX;
		this.mb = 0;
		this.mc = 0;
		this.md = pixHeight / scaleY;
		this.mx = -dx * this.ma;
		this.my = -dy * this.md;
	}
	,drawTile: function(x,y,tile) {
		this.beginTileFill(x,y,null,null,tile);
		this.drawRect(x,y,tile.width,tile.height);
		this.endFill();
	}
	,lineStyle: function(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0;
		}
		this.flush();
		this.lineSize = size;
		this.lineA = alpha;
		this.lineR = (color >> 16 & 255) / 255.;
		this.lineG = (color >> 8 & 255) / 255.;
		this.lineB = (color & 255) / 255.;
	}
	,moveTo: function(x,y) {
		this.flush();
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
	}
	,endFill: function() {
		this.flush();
		this.doFill = false;
	}
	,setColor: function(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.curA = alpha;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
	}
	,drawRect: function(x,y,w,h) {
		this.flush();
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var x1 = x + w;
		this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		var x1 = x + w;
		var y1 = y + h;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var y1 = y + h;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var e = 0.01;
		this.tmpPoints[0].x += e;
		this.tmpPoints[0].y += e;
		this.tmpPoints[1].y += e;
		this.tmpPoints[3].x += e;
		this.tmpPoints[4].x += e;
		this.tmpPoints[4].y += e;
		this.flush();
	}
	,drawRoundedRect: function(x,y,w,h,radius,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		var _gthis = this;
		if(radius <= 0) {
			this.drawRect(x,y,w,h);
			return;
		}
		x += radius;
		y += radius;
		w -= radius * 2;
		h -= radius * 2;
		this.flush();
		if(nsegments == 0) {
			var f = radius * 1.57079632679489656 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = 1.57079632679489656 / (nsegments - 1);
		var y1 = y - radius;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		var x1 = x + w;
		var y1 = y - radius;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var x1 = x + w;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + 4.71238898038469;
			var x2 = x1 + Math.cos(a) * radius;
			var y1 = y + Math.sin(a) * radius;
			_gthis.addVertex(x2,y1,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x2 * _gthis.ma + y1 * _gthis.mc + _gthis.mx,x2 * _gthis.mb + y1 * _gthis.md + _gthis.my);
		}
		var x1 = x + w + radius;
		var y1 = y + h;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		var x1 = x + w;
		var y1 = y + h;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			var x2 = x1 + Math.cos(a) * radius;
			var y2 = y1 + Math.sin(a) * radius;
			_gthis.addVertex(x2,y2,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x2 * _gthis.ma + y2 * _gthis.mc + _gthis.mx,x2 * _gthis.mb + y2 * _gthis.md + _gthis.my);
		}
		var y1 = y + h + radius;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		var y1 = y + h;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + 1.57079632679489656;
			var x1 = x + Math.cos(a) * radius;
			var y2 = y1 + Math.sin(a) * radius;
			_gthis.addVertex(x1,y2,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x1 * _gthis.ma + y2 * _gthis.mc + _gthis.mx,x1 * _gthis.mb + y2 * _gthis.md + _gthis.my);
		}
		var x1 = x - radius;
		this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + 3.14159265358979312;
			var x1 = x + Math.cos(a) * radius;
			var y1 = y + Math.sin(a) * radius;
			_gthis.addVertex(x1,y1,_gthis.curR,_gthis.curG,_gthis.curB,_gthis.curA,x1 * _gthis.ma + y1 * _gthis.mc + _gthis.mx,x1 * _gthis.mb + y1 * _gthis.md + _gthis.my);
		}
		this.flush();
	}
	,drawCircle: function(cx,cy,radius,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		this.flush();
		if(nsegments == 0) {
			var f = radius * 3.14 * 2 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = 6.28318530717958623 / nsegments;
		var _g = 0;
		var _g1 = nsegments + 1;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			var x = cx + Math.cos(a) * radius;
			var y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	,drawEllipse: function(cx,cy,radiusX,radiusY,rotationAngle,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if(rotationAngle == null) {
			rotationAngle = 0;
		}
		this.flush();
		if(nsegments == 0) {
			var f = radiusY * 3.14 * 2 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = 6.28318530717958623 / nsegments;
		var x1;
		var y1;
		var _g = 0;
		var _g1 = nsegments + 1;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			x1 = Math.cos(a) * Math.cos(rotationAngle) * radiusX - Math.sin(a) * Math.sin(rotationAngle) * radiusY;
			y1 = Math.cos(rotationAngle) * Math.sin(a) * radiusY + Math.cos(a) * Math.sin(rotationAngle) * radiusX;
			var x = cx + x1;
			var y = cy + y1;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	,drawPie: function(cx,cy,radius,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.28318530717958623) {
			this.drawCircle(cx,cy,radius,nsegments);
			return;
		}
		this.flush();
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		if(nsegments == 0) {
			var f = radius * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = angleLength / (nsegments - 1);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + angleStart;
			var x = cx + Math.cos(a) * radius;
			var y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		this.flush();
	}
	,drawPieInner: function(cx,cy,radius,innerRadius,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		this.flush();
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.28418530717958657) {
			angleLength = 6.28418530717958657;
		}
		var cs = Math.cos(angleStart);
		var ss = Math.sin(angleStart);
		var ce = Math.cos(angleStart + angleLength);
		var se = Math.sin(angleStart + angleLength);
		var x = cx + cs * innerRadius;
		var y = cy + ss * innerRadius;
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		if(nsegments == 0) {
			var f = radius * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = angleLength / (nsegments - 1);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + angleStart;
			var x = cx + Math.cos(a) * radius;
			var y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		var x = cx + ce * innerRadius;
		var y = cy + se * innerRadius;
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = (nsegments - 1 - i) * angle + angleStart;
			var x = cx + Math.cos(a) * innerRadius;
			var y = cy + Math.sin(a) * innerRadius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	,drawRectanglePie: function(cx,cy,width,height,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.28318530717958623) {
			this.drawRect(cx - width / 2,cy - height / 2,width,height);
			return;
		}
		this.flush();
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		if(nsegments == 0) {
			var f = (width < height ? height : width) * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = angleLength / (nsegments - 1);
		var square2 = Math.sqrt(2);
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle + angleStart;
			var _width = Math.cos(a) * (width / 2 + 1) * square2;
			var _height = Math.sin(a) * (height / 2 + 1) * square2;
			if((_width < 0 ? -_width : _width) >= width / 2) {
				_width = Math.cos(a) < 0 ? width / 2 * -1 : width / 2;
			}
			if((_height < 0 ? -_height : _height) >= height / 2) {
				_height = Math.sin(a) < 0 ? height / 2 * -1 : height / 2;
			}
			var x = cx + _width;
			var y = cy + _height;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.addVertex(cx,cy,this.curR,this.curG,this.curB,this.curA,cx * this.ma + cy * this.mc + this.mx,cx * this.mb + cy * this.md + this.my);
		this.flush();
	}
	,curveTo: function(bx,by,cx,cy) {
		var ax = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].x;
		var ay = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].y;
		var t = 0.66666666666666663;
		this.cubicCurveTo(ax + t * (bx - ax),ay + t * (by - ay),cx + t * (bx - cx),cy + t * (by - cy),cx,cy);
	}
	,cubicCurveTo: function(bx,by,cx,cy,dx,dy,nsegments) {
		if(nsegments == null) {
			nsegments = 40;
		}
		var ax = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].x;
		var ay = this.tmpPoints.length == 0 ? 0 : this.tmpPoints[this.tmpPoints.length - 1].y;
		var tobx = bx - ax;
		var toby = by - ay;
		var tocx = cx - bx;
		var tocy = cy - by;
		var todx = dx - cx;
		var tody = dy - cy;
		var step = 1 / nsegments;
		var _g = 1;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var d = i * step;
			var px = ax + d * tobx;
			var py = ay + d * toby;
			var qx = bx + d * tocx;
			var qy = by + d * tocy;
			var rx = cx + d * todx;
			var ry = cy + d * tody;
			var toqx = qx - px;
			var toqy = qy - py;
			var torx = rx - qx;
			var tory = ry - qy;
			var sx = px + d * toqx;
			var sy = py + d * toqy;
			var tx = qx + d * torx;
			var ty = qy + d * tory;
			var totx = tx - sx;
			var toty = ty - sy;
			var x = sx + d * totx;
			var y = sy + d * toty;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.addVertex(dx,dy,this.curR,this.curG,this.curB,this.curA,dx * this.ma + dy * this.mc + this.mx,dx * this.mb + dy * this.md + this.my);
	}
	,lineTo: function(x,y) {
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
	}
	,addVertex: function(x,y,r,g,b,a,u,v) {
		if(v == null) {
			v = 0.;
		}
		if(u == null) {
			u = 0.;
		}
		var half = this.lineSize / 2.0;
		if(x - half < this.xMin) {
			this.xMin = x - half;
		}
		if(y - half < this.yMin) {
			this.yMin = y - half;
		}
		if(x + half > this.xMax) {
			this.xMax = x + half;
		}
		if(y + half > this.yMax) {
			this.yMax = y + half;
		}
		if(x < this.xMinSize) {
			this.xMinSize = x;
		}
		if(y < this.yMinSize) {
			this.yMinSize = y;
		}
		if(x > this.xMaxSize) {
			this.xMaxSize = x;
		}
		if(y > this.yMaxSize) {
			this.yMaxSize = y;
		}
		if(this.doFill) {
			var _this = this.content;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = x;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = y;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = u;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = v;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = r;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = g;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = b;
			var this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				var newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = a;
			_this.bufferDirty = true;
		}
		var gp = new h2d_GPoint();
		gp.load(x,y,this.lineR,this.lineG,this.lineB,this.lineA);
		this.tmpPoints.push(gp);
	}
	,draw: function(ctx) {
		if(!ctx.beginDrawBatchState(this)) {
			return;
		}
		this.content.doRender(ctx);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		this.flush();
		this.content.flush();
	}
	,__class__: h2d_Graphics
});
var h2d_LineHeightMode = $hxEnums["h2d.LineHeightMode"] = { __ename__:"h2d.LineHeightMode",__constructs__:null
	,Accurate: {_hx_name:"Accurate",_hx_index:0,__enum__:"h2d.LineHeightMode",toString:$estr}
	,TextOnly: {_hx_name:"TextOnly",_hx_index:1,__enum__:"h2d.LineHeightMode",toString:$estr}
	,Constant: {_hx_name:"Constant",_hx_index:2,__enum__:"h2d.LineHeightMode",toString:$estr}
};
h2d_LineHeightMode.__constructs__ = [h2d_LineHeightMode.Accurate,h2d_LineHeightMode.TextOnly,h2d_LineHeightMode.Constant];
h2d_LineHeightMode.__empty_constructs__ = [h2d_LineHeightMode.Accurate,h2d_LineHeightMode.TextOnly,h2d_LineHeightMode.Constant];
var h2d_ImageVerticalAlign = $hxEnums["h2d.ImageVerticalAlign"] = { __ename__:"h2d.ImageVerticalAlign",__constructs__:null
	,Top: {_hx_name:"Top",_hx_index:0,__enum__:"h2d.ImageVerticalAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:1,__enum__:"h2d.ImageVerticalAlign",toString:$estr}
	,Middle: {_hx_name:"Middle",_hx_index:2,__enum__:"h2d.ImageVerticalAlign",toString:$estr}
};
h2d_ImageVerticalAlign.__constructs__ = [h2d_ImageVerticalAlign.Top,h2d_ImageVerticalAlign.Bottom,h2d_ImageVerticalAlign.Middle];
h2d_ImageVerticalAlign.__empty_constructs__ = [h2d_ImageVerticalAlign.Top,h2d_ImageVerticalAlign.Bottom,h2d_ImageVerticalAlign.Middle];
var h2d_Text = function(font,parent) {
	this.realMaxWidth = -1;
	this.constraintWidth = -1;
	this.lineBreak = true;
	this.lineSpacing = 0;
	this.letterSpacing = 0;
	h2d_Drawable.call(this,parent);
	this.set_font(font);
	this.set_textAlign(h2d_Align.Left);
	this.set_text("");
	this.currentText = "";
	this.set_textColor(16777215);
};
$hxClasses["h2d.Text"] = h2d_Text;
h2d_Text.__name__ = "h2d.Text";
h2d_Text.__super__ = h2d_Drawable;
h2d_Text.prototype = $extend(h2d_Drawable.prototype,{
	set_font: function(font) {
		if(this.font == font) {
			return font;
		}
		this.font = font;
		if(font != null) {
			var _g = font.type;
			switch(_g._hx_index) {
			case 0:
				if(this.sdfShader != null) {
					this.removeShader(this.sdfShader);
					this.sdfShader = null;
				}
				break;
			case 1:
				var channel = _g.channel;
				var alphaCutoff = _g.alphaCutoff;
				var smoothing = _g.smoothing;
				if(this.sdfShader == null) {
					this.sdfShader = new h3d_shader_SignedDistanceField();
					this.addShader(this.sdfShader);
				}
				if(this.smooth == null) {
					this.smooth = true;
				}
				this.sdfShader.alphaCutoff__ = alphaCutoff;
				this.sdfShader.smoothing__ = smoothing;
				var _this = this.sdfShader;
				_this.constModified = true;
				_this.channel__ = channel;
				var _this = this.sdfShader;
				_this.constModified = true;
				_this.autoSmoothing__ = smoothing == -1;
				break;
			}
		}
		if(this.glyphs != null) {
			var _this = this.glyphs;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.glyphs = new h2d_TileGroup(font == null ? null : font.tile,this);
		this.glyphs.set_visible(false);
		this.rebuild();
		return font;
	}
	,set_textAlign: function(a) {
		if(this.textAlign == a) {
			return a;
		}
		this.textAlign = a;
		this.rebuild();
		return a;
	}
	,set_letterSpacing: function(s) {
		if(this.letterSpacing == s) {
			return s;
		}
		this.letterSpacing = s;
		this.rebuild();
		return s;
	}
	,set_lineSpacing: function(s) {
		if(this.lineSpacing == s) {
			return s;
		}
		this.lineSpacing = s;
		this.rebuild();
		return s;
	}
	,set_lineBreak: function(b) {
		if(this.lineBreak == b) {
			return b;
		}
		this.lineBreak = b;
		this.rebuild();
		return b;
	}
	,constraintSize: function(width,height) {
		this.constraintWidth = width;
		this.updateConstraint();
	}
	,onAdd: function() {
		h2d_Drawable.prototype.onAdd.call(this);
		this.rebuild();
	}
	,checkText: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
	}
	,draw: function(ctx) {
		if(this.glyphs == null) {
			this.emitTile(ctx,h2d_Tile.fromColor(16711935,16,16));
			return;
		}
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
		if(this.dropShadow != null) {
			var oldX = this.absX;
			var oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			var oldR = this.color.x;
			var oldG = this.color.y;
			var oldB = this.color.z;
			var oldA = this.color.w;
			var _this = this.color;
			var c = this.dropShadow.color;
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
			this.color.w = this.dropShadow.alpha * oldA;
			this.glyphs.drawWith(ctx,this);
			this.absX = oldX;
			this.absY = oldY;
			var _this = this.color;
			var x = oldR;
			var y = oldG;
			var z = oldB;
			var w = oldA;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		this.glyphs.drawWith(ctx,this);
	}
	,set_text: function(t) {
		var t1 = t == null ? "null" : t;
		if(t1 == this.text) {
			return t1;
		}
		this.text = t1;
		this.textChanged = true;
		this.validateText();
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t1;
	}
	,validateText: function() {
	}
	,rebuild: function() {
		this.calcDone = false;
		this.needsRebuild = true;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	,calcTextWidth: function(text) {
		if(this.calcDone) {
			var ow = this.calcWidth;
			var oh = this.calcHeight;
			var osh = this.calcSizeHeight;
			var ox = this.calcXMin;
			var oy = this.calcYMin;
			this.initGlyphs(text,false);
			var w = this.calcWidth;
			this.calcWidth = ow;
			this.calcHeight = oh;
			this.calcSizeHeight = osh;
			this.calcXMin = ox;
			this.calcYMin = oy;
			return w;
		} else {
			this.initGlyphs(text,false);
			this.calcDone = false;
			return this.calcWidth;
		}
	}
	,splitText: function(text) {
		return this.splitRawText(text,0,0);
	}
	,splitRawText: function(text,leftMargin,afterData,font,sizes,prevChar) {
		if(prevChar == null) {
			prevChar = -1;
		}
		if(afterData == null) {
			afterData = 0.;
		}
		if(leftMargin == null) {
			leftMargin = 0.;
		}
		var maxWidth = this.realMaxWidth;
		if(maxWidth < 0) {
			if(sizes == null) {
				return text;
			} else {
				maxWidth = Infinity;
			}
		}
		if(font == null) {
			font = this.font;
		}
		var lines = [];
		var restPos = 0;
		var x = leftMargin;
		var _g = 0;
		var _g1 = text.length;
		while(_g < _g1) {
			var i = _g++;
			var cc = HxOverrides.cca(text,i);
			var c = font.glyphs.h[cc];
			if(c == null) {
				c = font.charset.resolveChar(cc,font.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
				}
			}
			var e = c;
			var newline = cc == 10;
			var esize = e.width + e.getKerningOffset(prevChar);
			var nc = HxOverrides.cca(text,i + 1);
			if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
				if(lines.length == 0 && leftMargin > 0 && x > maxWidth) {
					lines.push("");
					if(sizes != null) {
						sizes.push(leftMargin);
					}
					x -= leftMargin;
				}
				var size = x + esize + this.letterSpacing;
				var k = i + 1;
				var max = text.length;
				var prevChar1 = prevChar;
				var breakFound = false;
				while(size <= maxWidth && k < max) {
					var cc1 = HxOverrides.cca(text,k++);
					if(this.lineBreak && (font.charset.isSpace(cc1) || cc1 == 10)) {
						breakFound = true;
						break;
					}
					var c1 = font.glyphs.h[cc1];
					if(c1 == null) {
						c1 = font.charset.resolveChar(cc1,font.glyphs);
						if(c1 == null) {
							c1 = cc1 == 13 || cc1 == 10 ? font.nullChar : font.defaultChar;
						}
					}
					var e1 = c1;
					size += e1.width + this.letterSpacing + e1.getKerningOffset(prevChar1);
					prevChar1 = cc1;
					var nc1 = HxOverrides.cca(text,k + 1);
					if(font.charset.isBreakChar(cc1) && (nc1 == null || !font.charset.isComplementChar(nc1))) {
						break;
					}
				}
				if(this.lineBreak && (size > maxWidth || !breakFound && size + afterData > maxWidth)) {
					newline = true;
					if(font.charset.isSpace(cc)) {
						lines.push(HxOverrides.substr(text,restPos,i - restPos));
						e = null;
					} else {
						lines.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
					}
					restPos = i + 1;
				}
			}
			if(e != null && cc != 10) {
				x += esize + this.letterSpacing;
			}
			if(newline) {
				if(sizes != null) {
					sizes.push(x);
				}
				x = 0;
				prevChar = -1;
			} else {
				prevChar = cc;
			}
		}
		if(restPos < text.length) {
			if(lines.length == 0 && leftMargin > 0 && x + afterData - this.letterSpacing > maxWidth) {
				lines.push("");
				if(sizes != null) {
					sizes.push(leftMargin);
				}
				x -= leftMargin;
			}
			lines.push(HxOverrides.substr(text,restPos,text.length - restPos));
			if(sizes != null) {
				sizes.push(x);
			}
		}
		return lines.join("\n");
	}
	,getTextProgress: function(text,progress) {
		if(progress >= text.length) {
			return text;
		}
		return HxOverrides.substr(text,0,progress | 0);
	}
	,initGlyphs: function(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
		}
		var x = 0.;
		var y = 0.;
		var xMax = 0.;
		var xMin = 0.;
		var yMin = 0.;
		var prevChar = -1;
		var linei = 0;
		var align = this.textAlign;
		var lines = [];
		var dl = this.font.lineHeight + this.lineSpacing;
		var t = this.splitRawText(text,0,0,null,lines);
		var _g = 0;
		while(_g < lines.length) {
			var lw = lines[_g];
			++_g;
			if(lw > x) {
				x = lw;
			}
		}
		this.calcWidth = x;
		switch(align._hx_index) {
		case 0:
			x = 0;
			break;
		case 1:case 2:case 3:case 4:
			var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.realMaxWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			var _g = 0;
			var _g1 = lines.length;
			while(_g < _g1) {
				var i = _g++;
				lines[i] = Math.floor((max - lines[i]) * k);
			}
			x = lines[0];
			xMin = x;
			break;
		}
		var _g = 0;
		var _g1 = t.length;
		while(_g < _g1) {
			var i = _g++;
			var cc = HxOverrides.cca(t,i);
			var _this = this.font;
			var c = _this.glyphs.h[cc];
			if(c == null) {
				c = _this.charset.resolveChar(cc,_this.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? _this.nullChar : _this.defaultChar;
				}
			}
			var e = c;
			var offs = e.getKerningOffset(prevChar);
			var esize = e.width + offs;
			if(cc == 10) {
				if(x > xMax) {
					xMax = x;
				}
				switch(align._hx_index) {
				case 0:
					x = 0;
					break;
				case 1:case 2:case 3:case 4:
					x = lines[++linei];
					if(x < xMin) {
						xMin = x;
					}
					break;
				}
				y += dl;
				prevChar = -1;
			} else {
				if(e != null) {
					if(rebuild) {
						var _this1 = this.glyphs;
						_this1.content.add(x + offs,y,_this1.curColor.x,_this1.curColor.y,_this1.curColor.z,_this1.curColor.w,e.t);
					}
					if(y == 0 && e.t.dy < yMin) {
						yMin = e.t.dy;
					}
					x += esize + this.letterSpacing;
				}
				prevChar = cc;
			}
		}
		if(x > xMax) {
			xMax = x;
		}
		this.calcXMin = xMin;
		this.calcYMin = yMin;
		this.calcWidth = xMax - xMin;
		this.calcHeight = y + this.font.lineHeight;
		this.calcSizeHeight = y + (this.font.baseLine > 0 ? this.font.baseLine : this.font.lineHeight);
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	,updateSize: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
	}
	,get_textHeight: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcHeight;
	}
	,get_textWidth: function() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcWidth;
	}
	,set_maxWidth: function(w) {
		if(this.maxWidth == w) {
			return w;
		}
		this.maxWidth = w;
		this.updateConstraint();
		return w;
	}
	,updateConstraint: function() {
		var old = this.realMaxWidth;
		if(this.maxWidth == null) {
			this.realMaxWidth = this.constraintWidth;
		} else if(this.constraintWidth < 0) {
			this.realMaxWidth = this.maxWidth;
		} else {
			var a = this.maxWidth;
			var b = this.constraintWidth;
			this.realMaxWidth = a > b ? b : a;
		}
		if(this.realMaxWidth != old) {
			this.rebuild();
		}
	}
	,set_textColor: function(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		var a = this.color.w;
		var _this = this.color;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this.color.w = a;
		return c;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		var x;
		var y;
		var w;
		var h;
		if(forSize) {
			x = this.calcXMin;
			y = 0.;
			w = this.calcWidth;
			h = this.calcSizeHeight;
		} else {
			x = this.calcXMin;
			y = this.calcYMin;
			w = this.calcWidth;
			h = this.calcHeight - this.calcYMin;
		}
		this.addBounds(relativeTo,out,x,y,w,h);
	}
	,__class__: h2d_Text
});
var h2d_HtmlText = function(font,parent) {
	this.elements = [];
	this.imageVerticalAlign = h2d_ImageVerticalAlign.Bottom;
	this.lineHeightMode = h2d_LineHeightMode.Accurate;
	this.imageSpacing = 1;
	this.propagateInteractiveNode = false;
	this.condenseWhite = true;
	h2d_Text.call(this,font,parent);
};
$hxClasses["h2d.HtmlText"] = h2d_HtmlText;
h2d_HtmlText.__name__ = "h2d.HtmlText";
h2d_HtmlText.defaultLoadImage = function(url) {
	return null;
};
h2d_HtmlText.defaultLoadFont = function(name) {
	return null;
};
h2d_HtmlText.defaultFormatText = function(text) {
	return text;
};
h2d_HtmlText.__super__ = h2d_Text;
h2d_HtmlText.prototype = $extend(h2d_Text.prototype,{
	draw: function(ctx) {
		if(this.dropShadow != null) {
			var oldX = this.absX;
			var oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			if(this.dropMatrix == null) {
				this.dropMatrix = new h3d_shader_ColorMatrix();
				this.addShader(this.dropMatrix);
			}
			var _this = this.dropMatrix;
			_this.constModified = true;
			_this.enabled__ = true;
			var m = this.dropMatrix.matrix__;
			m.zero();
			m._41 = (this.dropShadow.color >> 16 & 255) / 255;
			m._42 = (this.dropShadow.color >> 8 & 255) / 255;
			m._43 = (this.dropShadow.color & 255) / 255;
			m._44 = this.dropShadow.alpha;
			this.glyphs.drawWith(ctx,this);
			var _this = this.dropMatrix;
			_this.constModified = true;
			_this.enabled__ = false;
			this.absX = oldX;
			this.absY = oldY;
		} else {
			this.removeShader(this.dropMatrix);
			this.dropMatrix = null;
		}
		this.glyphs.drawWith(ctx,this);
	}
	,getShader: function(stype) {
		if(this.shaders != null) {
			var _g_l = this.shaders;
			var _g_last = null;
			while(_g_l != _g_last) {
				var s = _g_l.s;
				_g_l = _g_l.next;
				var s1 = s;
				var c = ((s1) instanceof h3d_shader_ColorMatrix) ? s1 : null;
				if(c != null && !c.enabled__) {
					continue;
				}
				var s2 = js_Boot.__downcastCheck(s1,stype) ? s1 : null;
				if(s2 != null) {
					return s2;
				}
			}
		}
		return null;
	}
	,loadImage: function(url) {
		return h2d_HtmlText.defaultLoadImage(url);
	}
	,loadFont: function(name) {
		var f = h2d_HtmlText.defaultLoadFont(name);
		if(f == null) {
			return this.font;
		} else {
			return f;
		}
	}
	,onHyperlink: function(url) {
	}
	,onOverHyperlink: function(url) {
	}
	,onOutHyperlink: function(url) {
	}
	,formatText: function(text) {
		return h2d_HtmlText.defaultFormatText(text);
	}
	,set_text: function(t) {
		h2d_Text.prototype.set_text.call(this,this.formatText(t));
		return t;
	}
	,parseText: function(text) {
		try {
			return Xml.parse(text);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("Could not parse " + text + " (" + Std.string(e) + ")");
		}
	}
	,makeLineInfo: function(width,height,baseLine) {
		return { width : width, height : height, baseLine : baseLine};
	}
	,validateText: function() {
		this.textXml = this.parseText(this.text);
		this.validateNodes(this.textXml);
	}
	,validateNodes: function(xml) {
		switch(xml.nodeType) {
		case 0:
			if(xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			var nodeName = xml.nodeName.toLowerCase();
			switch(nodeName) {
			case "b":case "bold":
				this.loadFont("bold");
				break;
			case "font":
				if(xml.exists("face")) {
					this.loadFont(xml.get("face"));
				}
				break;
			case "img":
				this.loadImage(xml.get("src"));
				break;
			case "i":case "italic":
				this.loadFont("italic");
				break;
			}
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			var _g_current = 0;
			var _g_array = xml.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.validateNodes(child);
			}
			break;
		case 6:
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			var _g_current = 0;
			var _g_array = xml.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.validateNodes(child);
			}
			break;
		default:
		}
	}
	,initGlyphs: function(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
			var _g = 0;
			var _g1 = this.elements;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				if(e != null && e.parent != null) {
					e.parent.removeChild(e);
				}
			}
			this.elements = [];
		}
		this.glyphs.setDefaultColor(this.textColor);
		var doc;
		if(this.textXml == null) {
			doc = this.parseText(text);
		} else {
			doc = this.textXml;
		}
		this.yPos = 0;
		this.xMax = 0;
		this.xMin = Infinity;
		this.sizePos = 0;
		this.calcYMin = 0;
		var metrics = [{ width : 0, height : this.font.lineHeight, baseLine : this.font.baseLine}];
		this.prevChar = -1;
		this.newLine = true;
		var splitNode = { node : null, pos : 0, font : this.font, prevChar : -1, width : 0, height : 0, baseLine : 0};
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		var _g_current = 0;
		var _g_array = doc.children;
		while(_g_current < _g_array.length) {
			var e = _g_array[_g_current++];
			this.buildSizes(e,this.font,metrics,splitNode);
		}
		var max = 0.;
		var _g = 0;
		while(_g < metrics.length) {
			var info = metrics[_g];
			++_g;
			if(info.width > max) {
				max = info.width;
			}
		}
		this.calcWidth = max;
		this.prevChar = -1;
		this.newLine = true;
		var align = this.textAlign;
		var size = metrics[0].width;
		switch(align._hx_index) {
		case 0:
			this.xPos = 0;
			if(this.xMin > 0) {
				this.xMin = 0;
			}
			break;
		case 1:case 2:case 3:case 4:
			var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			this.xPos = Math.floor((max - size) * k);
			if(this.xPos < this.xMin) {
				this.xMin = this.xPos;
			}
			break;
		}
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		var _g_current = 0;
		var _g_array = doc.children;
		while(_g_current < _g_array.length) {
			var e = _g_array[_g_current++];
			this.addNode(e,this.font,this.textAlign,rebuild,metrics);
		}
		if(this.xPos > this.xMax) {
			this.xMax = this.xPos;
		}
		this.textXml = null;
		var y = this.yPos;
		this.calcXMin = this.xMin;
		this.calcWidth = this.xMax - this.xMin;
		this.calcHeight = y + metrics[this.sizePos].height;
		this.calcSizeHeight = y + metrics[this.sizePos].baseLine;
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	,buildSizes: function(e,font,metrics,splitNode) {
		var _gthis = this;
		var wordSplit = function() {
			var fnt = splitNode.font;
			var _this = splitNode.node;
			if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
			}
			var str = _this.nodeValue;
			var info = metrics[metrics.length - 1];
			var w = info.width;
			var cc = HxOverrides.cca(str,splitNode.pos);
			info.width = splitNode.width;
			info.height = splitNode.height;
			info.baseLine = splitNode.baseLine;
			var c = fnt.glyphs.h[cc];
			if(c == null) {
				c = fnt.charset.resolveChar(cc,fnt.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? fnt.nullChar : fnt.defaultChar;
				}
			}
			var char = c;
			if(_gthis.lineBreak && fnt.charset.isSpace(cc)) {
				w -= splitNode.width + _gthis.letterSpacing + char.width + char.getKerningOffset(splitNode.prevChar);
				var _this = splitNode.node;
				var v = HxOverrides.substr(str,0,splitNode.pos) + "\n" + HxOverrides.substr(str,splitNode.pos + 1,null);
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				_this.nodeValue = v;
			} else {
				w -= splitNode.width + _gthis.letterSpacing + char.getKerningOffset(splitNode.prevChar);
				var _this = splitNode.node;
				var v = HxOverrides.substr(str,0,splitNode.pos + 1) + "\n" + HxOverrides.substr(str,splitNode.pos + 1,null);
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				_this.nodeValue = v;
			}
			splitNode.node = null;
			return w;
		};
		if(e.nodeType == Xml.Element) {
			if(e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			var nodeName = e.nodeName.toLowerCase();
			switch(nodeName) {
			case "b":case "bold":
				font = this.loadFont("bold");
				break;
			case "br":
				var fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
				metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
				splitNode.node = null;
				_gthis.newLine = true;
				_gthis.prevChar = -1;
				break;
			case "font":
				var a = e.attributes();
				while(a.hasNext()) {
					var a1 = a.next();
					var v = e.get(a1);
					if(a1.toLowerCase() == "face") {
						font = this.loadFont(v);
					}
				}
				break;
			case "img":
				var i = this.loadImage(e.get("src"));
				if(i == null) {
					i = h2d_Tile.fromColor(16711935,8,8);
				}
				var size = metrics[metrics.length - 1].width + i.width + this.imageSpacing;
				if(this.realMaxWidth >= 0 && size > this.realMaxWidth && metrics[metrics.length - 1].width > 0) {
					if(splitNode.node != null) {
						size = wordSplit() + i.width + this.imageSpacing;
						var info = metrics[metrics.length - 1];
						if(this.lineHeightMode._hx_index == 0) {
							var grow = i.height - i.dy - info.baseLine;
							var h = info.height;
							var bl = info.baseLine;
							if(grow > 0) {
								h += grow;
								bl += grow;
							}
							metrics.push({ width : size, height : Math.max(h,bl + i.dy), baseLine : bl});
						} else {
							metrics.push({ width : size, height : info.height, baseLine : info.baseLine});
						}
					}
				} else {
					var info = metrics[metrics.length - 1];
					info.width = size;
					if(this.lineHeightMode == h2d_LineHeightMode.Accurate) {
						var grow = i.height - i.dy - info.baseLine;
						if(grow > 0) {
							switch(this.imageVerticalAlign._hx_index) {
							case 0:
								info.height += grow;
								break;
							case 1:
								info.baseLine += grow;
								info.height += grow;
								break;
							case 2:
								info.height += grow;
								info.baseLine += grow / 2 | 0;
								break;
							}
						}
						grow = info.baseLine + i.dy;
						if(info.height < grow) {
							info.height = grow;
						}
					}
				}
				this.newLine = false;
				this.prevChar = -1;
				break;
			case "i":case "italic":
				font = this.loadFont("italic");
				break;
			case "p":
				if(!this.newLine) {
					var fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					splitNode.node = null;
					_gthis.newLine = true;
					_gthis.prevChar = -1;
				}
				break;
			default:
			}
			if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			var _g_current = 0;
			var _g_array = e.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.buildSizes(child,font,metrics,splitNode);
			}
			if(nodeName == "p") {
				if(!this.newLine) {
					var fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					splitNode.node = null;
					_gthis.newLine = true;
					_gthis.prevChar = -1;
				}
			}
		} else {
			if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			if(e.nodeValue.length != 0) {
				this.newLine = false;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				var text = this.htmlToText(e.nodeValue);
				var fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
				var info = metrics.pop();
				var leftMargin = info.width;
				var maxWidth = this.realMaxWidth < 0 ? Infinity : this.realMaxWidth;
				var textSplit = [];
				var restPos = 0;
				var x = leftMargin;
				var breakChars = 0;
				var _g = 0;
				var _g1 = text.length;
				while(_g < _g1) {
					var i = _g++;
					var cc = HxOverrides.cca(text,i);
					var c = font.glyphs.h[cc];
					if(c == null) {
						c = font.charset.resolveChar(cc,font.glyphs);
						if(c == null) {
							c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
						}
					}
					var g = c;
					var newline = cc == 10;
					var esize = g.width + g.getKerningOffset(this.prevChar);
					var nc = HxOverrides.cca(text,i + 1);
					if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
						if(x > maxWidth && textSplit.length == 0 && splitNode.node != null) {
							metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
							x = wordSplit();
						}
						var size = x + esize + this.letterSpacing;
						var k = i + 1;
						var max = text.length;
						var prevChar = cc;
						while(size <= maxWidth && k < max) {
							var cc1 = HxOverrides.cca(text,k++);
							if(this.lineBreak && (font.charset.isSpace(cc1) || cc1 == 10)) {
								break;
							}
							var c1 = font.glyphs.h[cc1];
							if(c1 == null) {
								c1 = font.charset.resolveChar(cc1,font.glyphs);
								if(c1 == null) {
									c1 = cc1 == 13 || cc1 == 10 ? font.nullChar : font.defaultChar;
								}
							}
							var e1 = c1;
							size += e1.width + this.letterSpacing + e1.getKerningOffset(prevChar);
							prevChar = cc1;
							var nc1 = HxOverrides.cca(text,k);
							if(font.charset.isBreakChar(cc1) && (nc1 == null || !font.charset.isComplementChar(nc1))) {
								break;
							}
						}
						if(this.lineBreak && size > maxWidth && i != max - 1) {
							newline = true;
							if(font.charset.isSpace(cc)) {
								textSplit.push(HxOverrides.substr(text,restPos,i - restPos));
								g = null;
							} else {
								textSplit.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
								++breakChars;
							}
							splitNode.node = null;
							restPos = i + 1;
						} else {
							splitNode.node = e;
							splitNode.pos = i + breakChars;
							splitNode.prevChar = this.prevChar;
							splitNode.width = x;
							splitNode.height = info.height;
							splitNode.baseLine = info.baseLine;
							splitNode.font = font;
						}
					}
					if(g != null && cc != 10) {
						x += esize + this.letterSpacing;
					}
					if(newline) {
						metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
						info.height = fontInfo.lineHeight;
						info.baseLine = fontInfo.baseLine;
						x = 0;
						this.prevChar = -1;
						this.newLine = true;
					} else {
						this.prevChar = cc;
						this.newLine = false;
					}
				}
				if(restPos < text.length) {
					if(x > maxWidth) {
						if(splitNode.node != null && splitNode.node != e) {
							metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
							x = wordSplit();
						}
					}
					textSplit.push(HxOverrides.substr(text,restPos,null));
					metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
				}
				if(this.newLine || metrics.length == 0) {
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					textSplit.push("");
				}
				var v = textSplit.join("\n");
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				e.nodeValue = v;
			}
		}
	}
	,htmlToText: function(t) {
		if(this.condenseWhite) {
			t = t.replace(h2d_HtmlText.REG_SPACES.r," ");
		}
		return t;
	}
	,nextLine: function(align,size) {
		switch(align._hx_index) {
		case 0:
			this.xPos = 0;
			if(this.xMin > 0) {
				this.xMin = 0;
			}
			break;
		case 1:case 2:case 3:case 4:
			var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			this.xPos = Math.floor((max - size) * k);
			if(this.xPos < this.xMin) {
				this.xMin = this.xPos;
			}
			break;
		}
	}
	,splitText: function(text) {
		if(this.realMaxWidth < 0) {
			return text;
		}
		this.yPos = 0;
		this.xMax = 0;
		this.sizePos = 0;
		this.calcYMin = 0;
		var doc = this.parseText(text);
		var splitNode = { node : null, font : this.font, width : 0, height : 0, baseLine : 0, pos : 0, prevChar : -1};
		var metrics = [{ width : 0, height : this.font.lineHeight, baseLine : this.font.baseLine}];
		this.prevChar = -1;
		this.newLine = true;
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		var _g_current = 0;
		var _g_array = doc.children;
		while(_g_current < _g_array.length) {
			var e = _g_array[_g_current++];
			this.buildSizes(e,this.font,metrics,splitNode);
		}
		this.xMax = 0;
		var addBreaks = null;
		addBreaks = function(e) {
			if(e.nodeType == Xml.Element) {
				if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				var _g_current = 0;
				var _g_array = e.children;
				while(_g_current < _g_array.length) {
					var x = _g_array[_g_current++];
					addBreaks(x);
				}
			} else {
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				var text = e.nodeValue;
				var startI = 0;
				var index = Lambda.indexOf(e.parent,e);
				var _g = 0;
				var _g1 = text.length;
				while(_g < _g1) {
					var i = _g++;
					if(HxOverrides.cca(text,i) == 10) {
						var pre = text.substring(startI,i);
						if(pre != "") {
							e.parent.insertChild(Xml.createPCData(pre),index++);
						}
						e.parent.insertChild(Xml.createElement("br"),index++);
						startI = i + 1;
					}
				}
				if(startI < text.length) {
					var v = HxOverrides.substr(text,startI,null);
					if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
					}
					e.nodeValue = v;
				} else {
					e.parent.removeChild(e);
				}
			}
		};
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		var _g_current = 0;
		var _g_array = doc.children;
		while(_g_current < _g_array.length) {
			var d = _g_array[_g_current++];
			addBreaks(d);
		}
		return haxe_xml_Printer.print(doc);
	}
	,getTextProgress: function(text,progress) {
		var _gthis = this;
		if(progress >= text.length) {
			return text;
		}
		var doc = this.parseText(text);
		var progressRec = null;
		progressRec = function(e) {
			if(progress <= 0) {
				e.parent.removeChild(e);
				return;
			}
			if(e.nodeType == Xml.Element) {
				var _g = 0;
				var _g1 = [];
				if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				var _g_current = 0;
				var _g_array = e.children;
				while(_g_current < _g_array.length) {
					var x = _g_array[_g_current++];
					_g1.push(x);
				}
				var _g2 = _g1;
				while(_g < _g2.length) {
					var x = _g2[_g];
					++_g;
					progressRec(x);
				}
			} else {
				var _gthis1 = _gthis;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				var text = _gthis1.htmlToText(e.nodeValue);
				var len = text.length;
				if(len > progress) {
					text = HxOverrides.substr(text,0,progress | 0);
					if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
					}
					e.nodeValue = text;
				}
				progress -= len;
			}
		};
		var _g = 0;
		var _g1 = [];
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		var _g_current = 0;
		var _g_array = doc.children;
		while(_g_current < _g_array.length) {
			var x = _g_array[_g_current++];
			_g1.push(x);
		}
		var _g2 = _g1;
		while(_g < _g2.length) {
			var x = _g2[_g];
			++_g;
			progressRec(x);
		}
		return haxe_xml_Printer.print(doc);
	}
	,addNode: function(e,font,align,rebuild,metrics) {
		var _gthis = this;
		var createInteractive = function() {
			if(_gthis.aHrefs == null || _gthis.aHrefs.length == 0) {
				return;
			}
			_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].baseLine,_gthis);
			_gthis.aInteractive.propagateEvents = _gthis.propagateInteractiveNode;
			var href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
			_gthis.aInteractive.onClick = function(event) {
				_gthis.onHyperlink(href);
			};
			_gthis.aInteractive.onOver = function(event) {
				_gthis.onOverHyperlink(href);
			};
			_gthis.aInteractive.onOut = function(event) {
				_gthis.onOutHyperlink(href);
			};
			var _this = _gthis.aInteractive;
			var v = _gthis.xPos;
			_this.posChanged = true;
			_this.x = v;
			var _this = _gthis.aInteractive;
			var v = _gthis.yPos;
			_this.posChanged = true;
			_this.y = v;
			_gthis.elements.push(_gthis.aInteractive);
		};
		if(e.nodeType == Xml.Element) {
			var prevColor = null;
			var prevGlyphs = null;
			var oldAlign = align;
			if(e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			var nodeName = e.nodeName.toLowerCase();
			switch(nodeName) {
			case "a":
				if(e.exists("href")) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(this.aHrefs == null) {
						this.aHrefs = [];
					}
					this.aHrefs.push(e.get("href"));
					createInteractive();
				}
				break;
			case "b":case "bold":
				font = _gthis.loadFont("bold");
				if(prevGlyphs == null) {
					prevGlyphs = _gthis.glyphs;
				}
				var prev = _gthis.glyphs;
				_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
				if(font != null) {
					var _g = font.type;
					if(_g._hx_index == 1) {
						var channel = _g.channel;
						var alphaCutoff = _g.alphaCutoff;
						var smoothing = _g.smoothing;
						var shader = new h3d_shader_SignedDistanceField();
						shader.constModified = true;
						shader.channel__ = channel;
						shader.alphaCutoff__ = alphaCutoff;
						shader.smoothing__ = smoothing;
						shader.constModified = true;
						shader.autoSmoothing__ = smoothing == -1;
						_gthis.glyphs.smooth = _gthis.smooth;
						_gthis.glyphs.addShader(shader);
					}
				}
				var _this = _gthis.glyphs.curColor;
				var v = prev.curColor;
				_this.x = v.x;
				_this.y = v.y;
				_this.z = v.z;
				_this.w = v.w;
				_gthis.elements.push(_gthis.glyphs);
				break;
			case "br":
				if(_gthis.aInteractive != null) {
					_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
					_gthis.aInteractive = null;
				}
				if(_gthis.xPos > _gthis.xMax) {
					_gthis.xMax = _gthis.xPos;
				}
				_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
				var size = metrics[++_gthis.sizePos].width;
				switch(align._hx_index) {
				case 0:
					_gthis.xPos = 0;
					if(_gthis.xMin > 0) {
						_gthis.xMin = 0;
					}
					break;
				case 1:case 2:case 3:case 4:
					var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
					var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
					_gthis.xPos = Math.floor((max - size) * k);
					if(_gthis.xPos < _gthis.xMin) {
						_gthis.xMin = _gthis.xPos;
					}
					break;
				}
				createInteractive();
				this.newLine = true;
				this.prevChar = -1;
				break;
			case "font":
				var a = e.attributes();
				while(a.hasNext()) {
					var a1 = a.next();
					var v = e.get(a1);
					switch(a1.toLowerCase()) {
					case "color":
						if(prevColor == null) {
							var _this = this.glyphs.curColor;
							var x = _this.x;
							var y = _this.y;
							var z = _this.z;
							var w = _this.w;
							if(w == null) {
								w = 1.;
							}
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							prevColor = new h3d_Vector4Impl(x,y,z,w);
						}
						if(HxOverrides.cca(v,0) == 35 && v.length == 4) {
							v = "#" + v.charAt(1) + v.charAt(1) + v.charAt(2) + v.charAt(2) + v.charAt(3) + v.charAt(3);
						}
						this.glyphs.setDefaultColor(Std.parseInt("0x" + HxOverrides.substr(v,1,null)));
						break;
					case "face":
						font = _gthis.loadFont(v);
						if(prevGlyphs == null) {
							prevGlyphs = _gthis.glyphs;
						}
						var prev = _gthis.glyphs;
						_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
						if(font != null) {
							var _g = font.type;
							if(_g._hx_index == 1) {
								var channel = _g.channel;
								var alphaCutoff = _g.alphaCutoff;
								var smoothing = _g.smoothing;
								var shader = new h3d_shader_SignedDistanceField();
								shader.constModified = true;
								shader.channel__ = channel;
								shader.alphaCutoff__ = alphaCutoff;
								shader.smoothing__ = smoothing;
								shader.constModified = true;
								shader.autoSmoothing__ = smoothing == -1;
								_gthis.glyphs.smooth = _gthis.smooth;
								_gthis.glyphs.addShader(shader);
							}
						}
						var _this1 = _gthis.glyphs.curColor;
						var v1 = prev.curColor;
						_this1.x = v1.x;
						_this1.y = v1.y;
						_this1.z = v1.z;
						_this1.w = v1.w;
						_gthis.elements.push(_gthis.glyphs);
						break;
					case "opacity":
						if(prevColor == null) {
							var _this2 = this.glyphs.curColor;
							var x1 = _this2.x;
							var y1 = _this2.y;
							var z1 = _this2.z;
							var w1 = _this2.w;
							if(w1 == null) {
								w1 = 1.;
							}
							if(z1 == null) {
								z1 = 0.;
							}
							if(y1 == null) {
								y1 = 0.;
							}
							if(x1 == null) {
								x1 = 0.;
							}
							prevColor = new h3d_Vector4Impl(x1,y1,z1,w1);
						}
						this.glyphs.curColor.w *= parseFloat(v);
						break;
					default:
					}
				}
				break;
			case "img":
				var i = this.loadImage(e.get("src"));
				if(i == null) {
					i = h2d_Tile.fromColor(16711935,8,8);
				}
				var py = this.yPos;
				switch(this.imageVerticalAlign._hx_index) {
				case 0:
					break;
				case 1:
					py += metrics[this.sizePos].baseLine - i.height;
					break;
				case 2:
					py += metrics[this.sizePos].baseLine - i.height / 2;
					break;
				}
				if(py + i.dy < this.calcYMin) {
					this.calcYMin = py + i.dy;
				}
				if(rebuild) {
					var b = new h2d_Bitmap(i,this);
					b.posChanged = true;
					b.x = this.xPos;
					b.posChanged = true;
					b.y = py;
					this.elements.push(b);
				}
				this.newLine = false;
				this.prevChar = -1;
				this.xPos += i.width + this.imageSpacing;
				break;
			case "i":case "italic":
				font = _gthis.loadFont("italic");
				if(prevGlyphs == null) {
					prevGlyphs = _gthis.glyphs;
				}
				var prev = _gthis.glyphs;
				_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
				if(font != null) {
					var _g = font.type;
					if(_g._hx_index == 1) {
						var channel = _g.channel;
						var alphaCutoff = _g.alphaCutoff;
						var smoothing = _g.smoothing;
						var shader = new h3d_shader_SignedDistanceField();
						shader.constModified = true;
						shader.channel__ = channel;
						shader.alphaCutoff__ = alphaCutoff;
						shader.smoothing__ = smoothing;
						shader.constModified = true;
						shader.autoSmoothing__ = smoothing == -1;
						_gthis.glyphs.smooth = _gthis.smooth;
						_gthis.glyphs.addShader(shader);
					}
				}
				var _this = _gthis.glyphs.curColor;
				var v = prev.curColor;
				_this.x = v.x;
				_this.y = v.y;
				_this.z = v.z;
				_this.w = v.w;
				_gthis.elements.push(_gthis.glyphs);
				break;
			case "p":
				var a = e.attributes();
				while(a.hasNext()) {
					var a1 = a.next();
					if(a1.toLowerCase() == "align") {
						var v = e.get(a1);
						if(v != null) {
							switch(v.toLowerCase()) {
							case "center":
								align = h2d_Align.Center;
								break;
							case "left":
								align = h2d_Align.Left;
								break;
							case "multiline-center":
								align = h2d_Align.MultilineCenter;
								break;
							case "multiline-right":
								align = h2d_Align.MultilineRight;
								break;
							case "right":
								align = h2d_Align.Right;
								break;
							}
						}
					}
				}
				if(!this.newLine) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(_gthis.xPos > _gthis.xMax) {
						_gthis.xMax = _gthis.xPos;
					}
					_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
					var size = metrics[++_gthis.sizePos].width;
					switch(align._hx_index) {
					case 0:
						_gthis.xPos = 0;
						if(_gthis.xMin > 0) {
							_gthis.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
						var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						_gthis.xPos = Math.floor((max - size) * k);
						if(_gthis.xPos < _gthis.xMin) {
							_gthis.xMin = _gthis.xPos;
						}
						break;
					}
					createInteractive();
					this.newLine = true;
					this.prevChar = -1;
				} else {
					var size = metrics[this.sizePos].width;
					switch(align._hx_index) {
					case 0:
						this.xPos = 0;
						if(this.xMin > 0) {
							this.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
						var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						this.xPos = Math.floor((max - size) * k);
						if(this.xPos < this.xMin) {
							this.xMin = this.xPos;
						}
						break;
					}
				}
				break;
			default:
			}
			if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			var _g_current = 0;
			var _g_array = e.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.addNode(child,font,align,rebuild,metrics);
			}
			align = oldAlign;
			switch(nodeName) {
			case "a":
				if(this.aHrefs.length > 0) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					this.aHrefs.pop();
					createInteractive();
				}
				break;
			case "p":
				if(this.newLine) {
					var size = metrics[this.sizePos].width;
					switch(align._hx_index) {
					case 0:
						this.xPos = 0;
						if(this.xMin > 0) {
							this.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
						var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						this.xPos = Math.floor((max - size) * k);
						if(this.xPos < this.xMin) {
							this.xMin = this.xPos;
						}
						break;
					}
				} else if(this.sizePos < metrics.length - 2 || metrics[this.sizePos + 1].width != 0) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(_gthis.xPos > _gthis.xMax) {
						_gthis.xMax = _gthis.xPos;
					}
					_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
					var size = metrics[++_gthis.sizePos].width;
					switch(align._hx_index) {
					case 0:
						_gthis.xPos = 0;
						if(_gthis.xMin > 0) {
							_gthis.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
						var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						_gthis.xPos = Math.floor((max - size) * k);
						if(_gthis.xPos < _gthis.xMin) {
							_gthis.xMin = _gthis.xPos;
						}
						break;
					}
					createInteractive();
					this.newLine = true;
					this.prevChar = -1;
				}
				break;
			default:
			}
			if(prevGlyphs != null) {
				this.glyphs = prevGlyphs;
			}
			if(prevColor != null) {
				var _this = this.glyphs.curColor;
				_this.x = prevColor.x;
				_this.y = prevColor.y;
				_this.z = prevColor.z;
				_this.w = prevColor.w;
			}
		} else {
			if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			if(e.nodeValue.length != 0) {
				this.newLine = false;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				var t = e.nodeValue;
				var dy = metrics[this.sizePos].baseLine - font.baseLine;
				var _g = 0;
				var _g1 = t.length;
				while(_g < _g1) {
					var i = _g++;
					var cc = HxOverrides.cca(t,i);
					if(cc == 10) {
						if(_gthis.aInteractive != null) {
							_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
							_gthis.aInteractive = null;
						}
						if(_gthis.xPos > _gthis.xMax) {
							_gthis.xMax = _gthis.xPos;
						}
						_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
						var size = metrics[++_gthis.sizePos].width;
						switch(align._hx_index) {
						case 0:
							_gthis.xPos = 0;
							if(_gthis.xMin > 0) {
								_gthis.xMin = 0;
							}
							break;
						case 1:case 2:case 3:case 4:
							var max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
							var k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
							_gthis.xPos = Math.floor((max - size) * k);
							if(_gthis.xPos < _gthis.xMin) {
								_gthis.xMin = _gthis.xPos;
							}
							break;
						}
						createInteractive();
						dy = metrics[this.sizePos].baseLine - font.baseLine;
						this.prevChar = -1;
						continue;
					} else {
						var c = font.glyphs.h[cc];
						if(c == null) {
							c = font.charset.resolveChar(cc,font.glyphs);
							if(c == null) {
								c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
							}
						}
						var fc = c;
						if(fc != null) {
							this.xPos += fc.getKerningOffset(this.prevChar);
							if(rebuild) {
								var _this = this.glyphs;
								_this.content.add(this.xPos,this.yPos + dy,_this.curColor.x,_this.curColor.y,_this.curColor.z,_this.curColor.w,fc.t);
							}
							if(this.yPos == 0 && fc.t.dy + dy < this.calcYMin) {
								this.calcYMin = fc.t.dy + dy;
							}
							this.xPos += fc.width + this.letterSpacing;
						}
						this.prevChar = cc;
					}
				}
			}
		}
	}
	,set_imageSpacing: function(s) {
		if(this.imageSpacing == s) {
			return s;
		}
		this.imageSpacing = s;
		this.rebuild();
		return s;
	}
	,set_textColor: function(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		this.rebuild();
		return c;
	}
	,set_condenseWhite: function(value) {
		if(this.condenseWhite != value) {
			this.condenseWhite = value;
			this.rebuild();
		}
		return value;
	}
	,set_propagateInteractiveNode: function(value) {
		if(this.propagateInteractiveNode != value) {
			this.propagateInteractiveNode = value;
			this.rebuild();
		}
		return value;
	}
	,set_imageVerticalAlign: function(align) {
		if(this.imageVerticalAlign != align) {
			this.imageVerticalAlign = align;
			this.rebuild();
		}
		return align;
	}
	,set_lineHeightMode: function(v) {
		if(this.lineHeightMode != v) {
			this.lineHeightMode = v;
			this.rebuild();
		}
		return v;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		if(forSize) {
			var _g = 0;
			var _g1 = this.elements;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(((i) instanceof h2d_Bitmap) || ((i) instanceof h2d_Interactive)) {
					i.set_visible(false);
				}
			}
		}
		h2d_Text.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(forSize) {
			var _g = 0;
			var _g1 = this.elements;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				i.set_visible(true);
			}
		}
	}
	,__class__: h2d_HtmlText
});
var hxd_Interactive = function() { };
$hxClasses["hxd.Interactive"] = hxd_Interactive;
hxd_Interactive.__name__ = "hxd.Interactive";
hxd_Interactive.__isInterface__ = true;
hxd_Interactive.prototype = {
	__class__: hxd_Interactive
};
var h2d_Interactive = function(width,height,parent,shape) {
	this.shapeY = 0;
	this.shapeX = 0;
	this.lastClickFrame = -1;
	this.mouseDownButton = -1;
	this.allowMultiClick = false;
	this.enableRightButton = false;
	this.propagateEvents = false;
	this.cancelEvents = false;
	this.cursor = hxd_Cursor.Button;
	h2d_Object.call(this,parent);
	this.width = width;
	this.height = height;
	this.shape = shape;
};
$hxClasses["h2d.Interactive"] = h2d_Interactive;
h2d_Interactive.__name__ = "h2d.Interactive";
h2d_Interactive.__interfaces__ = [hxd_Interactive];
h2d_Interactive.__super__ = h2d_Object;
h2d_Interactive.prototype = $extend(h2d_Object.prototype,{
	onAdd: function() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		h2d_Object.prototype.onAdd.call(this);
	}
	,draw: function(ctx) {
		this.maskedBounds = ctx.getCurrentRenderZone(this.maskedBounds);
		if(this.backgroundColor != null) {
			this.emitTile(ctx,h2d_Tile.fromColor(this.backgroundColor,this.width | 0,this.height | 0,(this.backgroundColor >>> 24) / 255));
		}
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(this.backgroundColor != null || forSize) {
			this.addBounds(relativeTo,out,0,0,this.width | 0,this.height | 0);
		}
	}
	,onHierarchyMoved: function(parentChanged) {
		h2d_Object.prototype.onHierarchyMoved.call(this,parentChanged);
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = this.getScene();
			if(this.scene != null) {
				this.scene.addEventTarget(this);
			}
		}
	}
	,onRemove: function() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this,true);
			this.scene = null;
		}
		h2d_Object.prototype.onRemove.call(this);
	}
	,checkBounds: function(e) {
		switch(e.kind._hx_index) {
		case 4:case 6:case 7:case 10:
			return false;
		default:
			return true;
		}
	}
	,preventClick: function() {
		this.mouseDownButton = -1;
	}
	,getInteractiveScene: function() {
		return this.scene;
	}
	,handleEvent: function(e) {
		if(this.maskedBounds != null && this.checkBounds(e)) {
			var x = e.relX;
			var y = e.relY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var pt = new h2d_col_PointImpl(x,y);
			this.localToGlobal(pt);
			if(pt.x < this.maskedBounds.xMin || pt.y < this.maskedBounds.yMin || pt.x > this.maskedBounds.xMax || pt.y > this.maskedBounds.yMax) {
				e.cancel = true;
				return;
			}
		}
		if(this.shape == null && this.isEllipse && this.checkBounds(e)) {
			var cx = this.width * 0.5;
			var cy = this.height * 0.5;
			var dx = (e.relX - cx) / cx;
			var dy = (e.relY - cy) / cy;
			if(dx * dx + dy * dy > 1) {
				e.cancel = true;
				return;
			}
		}
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				var frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			e.propagate = true;
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	,calcAbsPos: function() {
		h2d_Object.prototype.calcAbsPos.call(this);
		this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
	}
	,set_cursor: function(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	,eventToLocal: function(e) {
		var i = this;
		var dx = e.relX - i.absX;
		var dy = e.relY - i.absY;
		e.relX = (dx * i.matD - dy * i.matC) * i.invDet;
		e.relY = (-dx * i.matB + dy * i.matA) * i.invDet;
	}
	,startCapture: function(callb,onCancel,touchId) {
		var _gthis = this;
		this.scene.startCapture(function(event) {
			var x = event.relX;
			var y = event.relY;
			_gthis.eventToLocal(event);
			callb(event);
			event.relX = x;
			event.relY = y;
		},onCancel,touchId);
	}
	,stopCapture: function() {
		this.scene.stopCapture();
	}
	,startDrag: function(callb,onCancel) {
		this.startCapture(callb,onCancel);
	}
	,stopDrag: function() {
		this.stopCapture();
	}
	,focus: function() {
		if(this.scene == null || this.scene.events == null) {
			return;
		}
		this.scene.events.focus(this);
	}
	,blur: function() {
		if(this.hasFocus()) {
			this.scene.events.blur();
		}
	}
	,isOver: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.overList.indexOf(this) != -1;
		} else {
			return false;
		}
	}
	,hasFocus: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.currentFocus == this;
		} else {
			return false;
		}
	}
	,onOver: function(e) {
	}
	,onOut: function(e) {
	}
	,onPush: function(e) {
	}
	,onRelease: function(e) {
	}
	,onReleaseOutside: function(e) {
	}
	,onClick: function(e) {
	}
	,onMove: function(e) {
	}
	,onWheel: function(e) {
	}
	,onFocus: function(e) {
	}
	,onFocusLost: function(e) {
	}
	,onKeyUp: function(e) {
	}
	,onKeyDown: function(e) {
	}
	,onCheck: function(e) {
	}
	,onTextInput: function(e) {
	}
	,__class__: h2d_Interactive
});
var h2d_Layers = function(parent) {
	h2d_Object.call(this,parent);
	this.layersIndexes = [];
	this.layerCount = 0;
};
$hxClasses["h2d.Layers"] = h2d_Layers;
h2d_Layers.__name__ = "h2d.Layers";
h2d_Layers.__super__ = h2d_Object;
h2d_Layers.prototype = $extend(h2d_Object.prototype,{
	addChild: function(s) {
		this.add(s,-1);
	}
	,add: function(s,layer,index) {
		if(index == null) {
			index = -1;
		}
		if(layer == null) {
			layer = -1;
		}
		if(s.parent == this) {
			var old = s.allocated;
			s.allocated = false;
			this.removeChild(s);
			s.allocated = old;
		}
		if(layer == -1) {
			layer = this.layerCount == 0 ? 0 : this.layerCount - 1;
		}
		while(layer >= this.layerCount) this.layersIndexes[this.layerCount++] = this.children.length;
		if(index != -1) {
			if(layer == 0) {
				var b = this.layersIndexes[layer];
				var b1 = index > b ? b : index;
				h2d_Object.prototype.addChildAt.call(this,s,0 < b1 ? b1 : 0);
			} else if(index < 0) {
				h2d_Object.prototype.addChildAt.call(this,s,this.layersIndexes[layer - 1]);
			} else {
				var a = this.layersIndexes[layer - 1] + index;
				var b = this.layersIndexes[layer];
				h2d_Object.prototype.addChildAt.call(this,s,a > b ? b : a);
			}
		} else {
			h2d_Object.prototype.addChildAt.call(this,s,this.layersIndexes[layer]);
		}
		var _g = layer;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			this.layersIndexes[i]++;
		}
	}
	,addChildAt: function(s,index) {
		this.add(s,-1,index);
	}
	,removeChild: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				this.children.splice(i,1);
				if(s.allocated) {
					s.onRemove();
				}
				s.parent = null;
				s.posChanged = true;
				if(s.parentContainer != null) {
					s.setParentContainer(null);
				}
				var k = this.layerCount - 1;
				while(k >= 0 && this.layersIndexes[k] > i) {
					this.layersIndexes[k]--;
					--k;
				}
				if(this.parentContainer != null) {
					this.parentContainer.contentChanged(this);
				}
				break;
			}
		}
	}
	,under: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				var pos = 0;
				var _g2 = 0;
				var _g3 = this.layersIndexes;
				while(_g2 < _g3.length) {
					var l = _g3[_g2];
					++_g2;
					if(l > i) {
						break;
					} else {
						pos = l;
					}
				}
				var p = i;
				while(p > pos) {
					this.children[p] = this.children[p - 1];
					--p;
				}
				this.children[pos] = s;
				if(s.allocated) {
					s.onHierarchyMoved(false);
				}
				return;
			}
		}
	}
	,over: function(s) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == s) {
				var _g2 = 0;
				var _g3 = this.layersIndexes;
				while(_g2 < _g3.length) {
					var l = _g3[_g2];
					++_g2;
					if(l > i) {
						var _g4 = i;
						var _g5 = l - 1;
						while(_g4 < _g5) {
							var p = _g4++;
							this.children[p] = this.children[p + 1];
						}
						this.children[l - 1] = s;
						if(s.allocated) {
							s.onHierarchyMoved(false);
						}
						return;
					}
				}
				return;
			}
		}
	}
	,getLayer: function(layer) {
		var a;
		if(layer >= this.layerCount) {
			a = [];
		} else {
			var start = layer == 0 ? 0 : this.layersIndexes[layer - 1];
			var max = this.layersIndexes[layer];
			a = this.children.slice(start,max);
		}
		return new hxd_impl_ArrayIterator_$h2d_$Object(a);
	}
	,getChildAtLayer: function(n,layer) {
		if(layer == -1) {
			layer = this.layerCount == 0 ? 0 : this.layerCount - 1;
		}
		if(layer >= this.layerCount || n < 0 || n >= this.layersIndexes[layer]) {
			return null;
		}
		if(layer == 0) {
			return this.children[n];
		}
		return this.children[this.layersIndexes[layer - 1] + n];
	}
	,getChildLayer: function(s) {
		if(s.parent != this) {
			return -1;
		}
		var index = this.children.indexOf(s);
		var _g = 0;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			if(this.layersIndexes[i] > index) {
				return i;
			}
		}
		return -1;
	}
	,getChildIndexInLayer: function(o) {
		if(o.parent != this) {
			return -1;
		}
		var index = this.children.indexOf(o);
		if(index < this.layersIndexes[0]) {
			return index;
		}
		var _g = 1;
		var _g1 = this.layerCount;
		while(_g < _g1) {
			var i = _g++;
			if(this.layersIndexes[i] > index) {
				return index - this.layersIndexes[i - 1];
			}
		}
		return -1;
	}
	,drawLayer: function(ctx,layer) {
		if(layer >= this.layerCount) {
			return;
		}
		var old = ctx.globalAlpha;
		ctx.globalAlpha *= this.alpha;
		var start = layer == 0 ? 0 : this.layersIndexes[layer - 1];
		var max = this.layersIndexes[layer];
		if(ctx.front2back) {
			var _g = start;
			var _g1 = max;
			while(_g < _g1) {
				var i = _g++;
				this.children[max - 1 - i].drawRec(ctx);
			}
		} else {
			var _g = start;
			var _g1 = max;
			while(_g < _g1) {
				var i = _g++;
				this.children[i].drawRec(ctx);
			}
		}
		ctx.globalAlpha = old;
	}
	,ysort: function(layer) {
		if(layer >= this.layerCount) {
			return;
		}
		var start = layer == 0 ? 0 : this.layersIndexes[layer - 1];
		var max = this.layersIndexes[layer];
		if(start == max) {
			return;
		}
		var pos = start;
		var ymax = this.children[pos++].y;
		while(pos < max) {
			var c = this.children[pos];
			if(c.y < ymax) {
				var p = pos - 1;
				while(p >= start) {
					var c2 = this.children[p];
					if(c.y >= c2.y) {
						break;
					}
					this.children[p + 1] = c2;
					--p;
				}
				this.children[p + 1] = c;
				if(c.allocated) {
					c.onHierarchyMoved(false);
				}
			} else {
				ymax = c.y;
			}
			++pos;
		}
	}
	,__class__: h2d_Layers
});
var h2d_MAll = function() { };
$hxClasses["h2d.MAll"] = h2d_MAll;
h2d_MAll.__name__ = "h2d.MAll";
h2d_MAll.applyOn = function(msk,trg) {
	trg.parent.addChild(msk);
	msk.addChild(trg);
	trg.posChanged = true;
	trg.x -= msk.x;
	trg.posChanged = true;
	trg.y -= msk.y;
};
h2d_MAll.release = function(msk,trg) {
	msk.parent.addChild(trg);
	trg.posChanged = true;
	trg.x += msk.x;
	trg.posChanged = true;
	trg.y += msk.y;
	if(msk != null && msk.parent != null) {
		msk.parent.removeChild(msk);
	}
};
h2d_MAll.morphColor = function(mc,c,cm,addColor,inc) {
	if(inc == null) {
		inc = 0;
	}
	if(c == null) {
		c = 1.0;
	}
	var o = { r : 0, g : 0, b : 0};
	if(addColor != null) {
		o = Col.colToObj(addColor);
	}
	var m = new h3d_MatrixImpl();
	var a = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
	if(cm == null) {
		var r = 0.35;
		var g = 0.45;
		var b = 0.2;
		cm = [r,r,r,0,g,g,g,0,b,b,b,0,(o.r + inc) / 256,(o.g + inc) / 256,(o.b + inc) / 256,1];
	}
	var res = [];
	var _g = 0;
	while(_g < 20) {
		var i = _g++;
		res[i] = a[i] * (1 - c) + cm[i] * c;
	}
	m.loadValues(res);
	mc.set_colorMatrix(m);
};
h2d_MAll.setColor = function(mc,color,c) {
	if(c == null) {
		c = 1.0;
	}
	var o = Col.colToObj(color);
	var k = 1 - c;
	var cm = [k,0,0,0,0,k,0,0,0,0,k,0,c * o.r / 256,c * o.g / 256,c * o.b / 256,1];
	h2d_MAll.morphColor(mc,c,cm,color);
};
h2d_MAll.brighten = function(mc,inc) {
	var x = inc;
	var y = inc;
	var z = inc;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	mc.set_colorAdd(new h3d_VectorImpl(x,y,z));
};
h2d_MAll.cmod = function(n,mod) {
	return n % mod / mod;
};
h2d_MAll.mod = function(n,mod) {
	while(n < 0) n += mod;
	while(n >= mod) n -= mod;
	return n;
};
h2d_MAll.clamp = function(n,min,max) {
	if(n < min) {
		return min;
	}
	if(n > max) {
		return max;
	}
	return n;
};
h2d_MAll.min = function(n,min) {
	if(n < min) {
		return min;
	}
	return n;
};
h2d_MAll.max = function(n,max) {
	if(n > max) {
		return max;
	}
	return n;
};
h2d_MAll.fcmod = function(n,mod) {
	return n % mod / mod;
};
h2d_MAll.fmod = function(n,mod) {
	while(n < 0) n += mod;
	while(n >= mod) n -= mod;
	return n;
};
h2d_MAll.fclamp = function(n,min,max) {
	if(n < min) {
		return min;
	}
	if(n > max) {
		return max;
	}
	return n;
};
h2d_MAll.cos = function(n,pow) {
	if(pow == null) {
		pow = 1;
	}
	var _g = 0;
	var _g1 = pow;
	while(_g < _g1) {
		var i = _g++;
		n = 0.5 - Math.cos(Math.PI * n) * 0.5;
	}
	return n;
};
h2d_MAll.acos = function(n,pow) {
	if(pow == null) {
		pow = 1;
	}
	var _g = 0;
	var _g1 = pow;
	while(_g < _g1) {
		var i = _g++;
		n = Math.acos(1 - 2 * n) / Math.PI;
	}
	return n;
};
h2d_MAll.color = function(str,color) {
	return "<font color='" + Col.getWeb(color) + "'>" + str + "</font>";
};
h2d_MAll.center = function(str) {
	return "<p align='center'>" + str + "</p>";
};
h2d_MAll.right = function(str) {
	return "<p align='right'>" + str + "</p>";
};
h2d_MAll.maj = function(str) {
	return HxOverrides.substr(str,0,1).toUpperCase() + HxOverrides.substr(str,1,null);
};
h2d_MAll.insert = function(a,n,b) {
	return HxOverrides.substr(a,0,n) + b + HxOverrides.substr(a,n,null);
};
h2d_MAll.rep = function(a,b,c) {
	return a.split(b).join(c);
};
h2d_MAll.fadeOut = function(s,spc) {
	if(spc == null) {
		spc = 0.1;
	}
};
h2d_MAll.last = function(a) {
	return a[a.length - 1];
};
h2d_MAll.couple = function(a,f) {
	var list = a.slice();
	var _g = 0;
	var _g1 = list.length;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = i + 1;
		var _g3 = list.length;
		while(_g2 < _g3) {
			var j = _g2++;
			f(a[i],a[j]);
		}
	}
};
h2d_MAll.upush = function(a,n) {
	var _g = 0;
	while(_g < a.length) {
		var k = a[_g];
		++_g;
		if(k == n) {
			return;
		}
	}
	a.push(n);
};
h2d_MAll.indexOf = function(a,n) {
	var id = 0;
	var _g = 0;
	while(_g < a.length) {
		var k = a[_g];
		++_g;
		if(k == n) {
			return id;
		}
		++id;
	}
	return -1;
};
h2d_MAll.shuffle = function(a,f) {
	if(f == null) {
		f = Std.random;
	}
	var b = [];
	while(a.length > 0) b.push(a.pop());
	while(b.length > 0) {
		var pos = f(a.length + 1);
		var x = b.pop();
		a.splice(pos,0,x);
	}
};
h2d_MAll.steal = function(a,f) {
	if(f == null) {
		f = Std.random;
	}
	var el = a[f(a.length)];
	HxOverrides.remove(a,el);
	return el;
};
h2d_MAll.best = function(a,f) {
	var score = 0.0;
	var best = null;
	var _g = 0;
	while(_g < a.length) {
		var k = a[_g];
		++_g;
		var sco = f(k);
		if(best == null || sco > score) {
			score = sco;
			best = k;
		}
	}
	return best;
};
h2d_MAll.rand = function(a,f) {
	if(f == null) {
		f = Std.random;
	}
	var el = a[f(a.length)];
	return el;
};
h2d_MAll.act = function(a,f,onFinish) {
	var b = a.slice();
	var next = function() {
	};
	var c = function() {
		if(b.length == 0) {
			if(onFinish != null) {
				onFinish();
			}
			return;
		}
		f(b.shift(),next);
	};
	next = c;
	next();
};
h2d_MAll.order = function(a,check) {
	var f = function(a,b) {
		var sa = check(a);
		var sb = check(b);
		if(sa > sb) {
			return -1;
		}
		if(sa < sb) {
			return 1;
		}
		return 0;
	};
	a.sort(f);
};
h2d_MAll.has = function(a,n) {
	var _g = 0;
	while(_g < a.length) {
		var k = a[_g];
		++_g;
		if(k == n) {
			return true;
		}
	}
	return false;
};
var h2d_Mask = function(width,height,parent) {
	this.scrollY = 0;
	this.scrollX = 0;
	h2d_Object.call(this,parent);
	this.width = width;
	this.height = height;
};
$hxClasses["h2d.Mask"] = h2d_Mask;
h2d_Mask.__name__ = "h2d.Mask";
h2d_Mask.maskWith = function(ctx,object,width,height,scrollX,scrollY) {
	if(scrollY == null) {
		scrollY = 0;
	}
	if(scrollX == null) {
		scrollX = 0;
	}
	var x1 = object.absX + scrollX;
	var y1 = object.absY + scrollY;
	var x2 = width * object.matA + height * object.matC + x1;
	var y2 = width * object.matB + height * object.matD + y1;
	var tmp;
	if(x1 > x2) {
		tmp = x1;
		x1 = x2;
		x2 = tmp;
	}
	if(y1 > y2) {
		tmp = y1;
		y1 = y2;
		y2 = tmp;
	}
	ctx.clipRenderZone(x1,y1,x2 - x1,y2 - y1);
};
h2d_Mask.unmask = function(ctx) {
	ctx.popRenderZone();
};
h2d_Mask.__super__ = h2d_Object;
h2d_Mask.prototype = $extend(h2d_Object.prototype,{
	scrollTo: function(x,y) {
		this.set_scrollX(x);
		this.set_scrollY(y);
	}
	,scrollBy: function(x,y) {
		this.set_scrollX(this.scrollX + x);
		this.set_scrollY(this.scrollY + y);
	}
	,set_scrollX: function(v) {
		if(this.scrollBounds != null) {
			var min = this.scrollBounds.xMin;
			var max = this.scrollBounds.xMax - this.width;
			if(max == null) {
				max = 1.;
			}
			if(min == null) {
				min = 0.;
			}
			if(v < min) {
				v = min;
			} else if(v > max) {
				v = max;
			}
		}
		this.posChanged = true;
		return this.scrollX = v;
	}
	,set_scrollY: function(v) {
		if(this.scrollBounds != null) {
			var min = this.scrollBounds.yMin;
			var max = this.scrollBounds.yMax - this.height;
			if(max == null) {
				max = 1.;
			}
			if(min == null) {
				min = 0.;
			}
			if(v < min) {
				v = min;
			} else if(v > max) {
				v = max;
			}
		}
		this.posChanged = true;
		return this.scrollY = v;
	}
	,calcAbsPos: function() {
		h2d_Object.prototype.calcAbsPos.call(this);
		this.absX -= this.scrollX;
		this.absY -= this.scrollY;
	}
	,getBoundsRec: function(relativeTo,out,forSize) {
		var xMin = out.xMin;
		var yMin = out.yMin;
		var xMax = out.xMax;
		var yMax = out.yMax;
		out.xMin = 1e20;
		out.yMin = 1e20;
		out.xMax = -1e20;
		out.yMax = -1e20;
		if(this.posChanged) {
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		this.addBounds(relativeTo,out,this.scrollX,this.scrollY,this.width,this.height);
		var bxMin = out.xMin;
		var byMin = out.yMin;
		var bxMax = out.xMax;
		var byMax = out.yMax;
		out.xMin = xMin;
		out.xMax = xMax;
		out.yMin = yMin;
		out.yMax = yMax;
		h2d_Object.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		if(out.xMin < bxMin) {
			out.xMin = xMin > bxMin ? bxMin : xMin;
		}
		if(out.yMin < byMin) {
			out.yMin = yMin > byMin ? byMin : yMin;
		}
		if(out.xMax > bxMax) {
			out.xMax = xMax < bxMax ? bxMax : xMax;
		}
		if(out.yMax > byMax) {
			out.yMax = yMax < byMax ? byMax : yMax;
		}
	}
	,drawRec: function(ctx) {
		h2d_Mask.maskWith(ctx,this,this.width,this.height,this.scrollX,this.scrollY);
		h2d_Object.prototype.drawRec.call(this,ctx);
		h2d_Mask.unmask(ctx);
	}
	,__class__: h2d_Mask
});
var h3d_impl_RenderContext = function() {
	this.engine = h3d_Engine.CURRENT;
	this.frame = 0;
	this.time = 0.;
	this.elapsedTime = 1. / hxd_System.getDefaultFrameRate();
	this.textures = new h3d_impl_TextureCache();
	this.globals = new hxsl_Globals();
};
$hxClasses["h3d.impl.RenderContext"] = h3d_impl_RenderContext;
h3d_impl_RenderContext.__name__ = "h3d.impl.RenderContext";
h3d_impl_RenderContext.get = function() {
	return h3d_impl_RenderContext.inst;
};
h3d_impl_RenderContext.getType = function(cl) {
	var value = h3d_impl_RenderContext.inst;
	if(js_Boot.__downcastCheck(value,cl)) {
		return value;
	} else {
		return null;
	}
};
h3d_impl_RenderContext.prototype = {
	setCurrent: function() {
		h3d_impl_RenderContext.inst = this;
	}
	,clearCurrent: function() {
		if(h3d_impl_RenderContext.inst == this) {
			h3d_impl_RenderContext.inst = null;
		} else {
			throw haxe_Exception.thrown("Context has changed");
		}
	}
	,dispose: function() {
		this.textures.dispose();
	}
	,fillRec: function(v,type,out,pos) {
		switch(type._hx_index) {
		case 1:
			out[pos] = v;
			return 1;
		case 3:
			out[pos] = v;
			return 1;
		case 5:
			var _g = type.size;
			var _g1 = type.t;
			if(_g == 4) {
				var v1 = v;
				out[pos++] = v1.x;
				out[pos++] = v1.y;
				out[pos++] = v1.z;
				out[pos++] = v1.w;
				return 4;
			} else {
				var n = _g;
				var v1 = v;
				out[pos++] = v1.x;
				out[pos++] = v1.y;
				if(n == 3) {
					out[pos++] = v1.z;
				}
				return n;
			}
			break;
		case 6:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = 0;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = 0;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = 0;
			return 12;
		case 7:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = m._41;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = m._42;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = m._43;
			out[pos++] = m._14;
			out[pos++] = m._24;
			out[pos++] = m._34;
			out[pos++] = m._44;
			return 16;
		case 8:
			var m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = m._41;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = m._42;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = m._43;
			return 12;
		case 13:
			var vl = type.vl;
			var tot = 0;
			var _g = 0;
			while(_g < vl.length) {
				var vv = vl[_g];
				++_g;
				tot += this.fillRec(Reflect.field(v,vv.name),vv.type,out,pos + tot);
			}
			return tot;
		case 15:
			var _g = type.t;
			var _g1 = type.size;
			switch(_g._hx_index) {
			case 3:
				if(_g1._hx_index == 0) {
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var count = v1.length < len ? v1.length : len;
					var _g2 = 0;
					var _g3 = count;
					while(_g2 < _g3) {
						var i = _g2++;
						out[pos++] = v1[i];
					}
					return len;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 5:
				if(_g.size == 4) {
					if(_g.t._hx_index == 1) {
						if(_g1._hx_index == 0) {
							var len = _g1.v;
							var v1 = v;
							var _g2 = 0;
							var _g3 = len;
							while(_g2 < _g3) {
								var i = _g2++;
								var n = v1[i];
								if(n == null) {
									break;
								}
								out[pos++] = n.x;
								out[pos++] = n.y;
								out[pos++] = n.z;
								out[pos++] = n.w;
							}
							return len * 4;
						} else {
							throw haxe_Exception.thrown("assert " + Std.string(type));
						}
					} else if(_g1._hx_index == 0) {
						var t = _g;
						var len = _g1.v;
						var v1 = v;
						var size = 0;
						var _g2 = 0;
						var _g3 = len;
						while(_g2 < _g3) {
							var i = _g2++;
							var n = v1[i];
							if(n == null) {
								break;
							}
							size = this.fillRec(n,t,out,pos);
							pos += size;
						}
						return len * size;
					} else {
						throw haxe_Exception.thrown("assert " + Std.string(type));
					}
				} else if(_g1._hx_index == 0) {
					var t = _g;
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var _g2 = 0;
					var _g3 = len;
					while(_g2 < _g3) {
						var i = _g2++;
						var n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,t,out,pos);
						pos += size;
					}
					return len * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 8:
				if(_g1._hx_index == 0) {
					var len = _g1.v;
					var v1 = v;
					var _g2 = 0;
					var _g3 = len;
					while(_g2 < _g3) {
						var i = _g2++;
						var m = v1[i];
						if(m == null) {
							break;
						}
						out[pos++] = m._11;
						out[pos++] = m._21;
						out[pos++] = m._31;
						out[pos++] = m._41;
						out[pos++] = m._12;
						out[pos++] = m._22;
						out[pos++] = m._32;
						out[pos++] = m._42;
						out[pos++] = m._13;
						out[pos++] = m._23;
						out[pos++] = m._33;
						out[pos++] = m._43;
					}
					return len * 12;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			default:
				if(_g1._hx_index == 0) {
					var t = _g;
					var len = _g1.v;
					var v1 = v;
					var size = 0;
					var _g = 0;
					var _g1 = len;
					while(_g < _g1) {
						var i = _g++;
						var n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,t,out,pos);
						pos += size;
					}
					return len * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("assert " + Std.string(type));
		}
	}
	,shaderInfo: function(shaders,path) {
		var name = path.split(".").pop();
		while(shaders != null) {
			var inst = shaders.s.instance;
			var _g = 0;
			var _g1 = inst.shader.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				if(v.name == name) {
					return shaders.s.toString();
				}
			}
			shaders = shaders.next;
		}
		return "(not found)";
	}
	,getPtr: function(data) {
		return data;
	}
	,getParamValue: function(p,shaders,opt) {
		if(opt == null) {
			opt = false;
		}
		if(p.perObjectGlobal != null) {
			var v = this.globals.map.h[p.perObjectGlobal.gid];
			if(v == null) {
				throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p.perObjectGlobal.path));
			}
			var _g = p.type;
			var tmp;
			if(_g._hx_index == 17) {
				var _g1 = _g.size;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				return v.texture;
			}
			return v;
		}
		var si = shaders;
		var n = p.instance;
		while(--n > 0) si = si.next;
		var v = si.s.getParamValue(p.index);
		if(v == null && !opt) {
			throw haxe_Exception.thrown("Missing param value " + Std.string(si.s) + "." + p.name);
		}
		return v;
	}
	,fillGlobals: function(buf,s) {
		var _gthis = this;
		var g = s.vertex.globals;
		var ptr = buf.vertex.globals;
		while(g != null) {
			var v = _gthis.globals.map.h[g.gid];
			if(v == null) {
				throw haxe_Exception.thrown("Missing global value " + g.path);
			}
			_gthis.fillRec(v,g.type,ptr,g.pos);
			g = g.next;
		}
		var g = s.fragment.globals;
		var ptr = buf.fragment.globals;
		while(g != null) {
			var v = _gthis.globals.map.h[g.gid];
			if(v == null) {
				throw haxe_Exception.thrown("Missing global value " + g.path);
			}
			_gthis.fillRec(v,g.type,ptr,g.pos);
			g = g.next;
		}
	}
	,fillParams: function(buf,s,shaders) {
		var _gthis = this;
		var curInstance = -1;
		var curInstanceValue = null;
		var buf1 = buf.vertex;
		var s1 = s.vertex;
		var p = s1.params;
		var ptr = buf1.params;
		while(p != null) {
			var v;
			if(p.perObjectGlobal == null) {
				if(p.type == hxsl_Type.TFloat) {
					var index = p.instance;
					var i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr[p.pos] = i.getParamFloatValue(p.index);
					p = p.next;
					continue;
				}
				var index1 = p.instance;
				var v1;
				if(curInstance == index1) {
					v1 = curInstanceValue;
				} else {
					var si1 = shaders;
					curInstance = index1;
					while(--index1 > 0) si1 = si1.next;
					curInstanceValue = si1.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
				}
			} else if(p.perObjectGlobal != null) {
				var v2 = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var v3;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					v3 = true;
				} else {
					v3 = false;
				}
				v = v3 ? v2.texture : v2;
			} else {
				var index2 = p.instance;
				var v4;
				if(curInstance == index2) {
					v4 = curInstanceValue;
				} else {
					var si2 = shaders;
					curInstance = index2;
					while(--index2 > 0) si2 = si2.next;
					curInstanceValue = si2.s;
					v4 = curInstanceValue;
				}
				var v5 = v4.getParamValue(p.index);
				if(v5 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				v = v5;
			}
			_gthis.fillRec(v,p.type,ptr,p.pos);
			p = p.next;
		}
		var tid = 0;
		var p = s1.textures;
		while(p != null) {
			var opt = !h3d_impl_RenderContext.STRICT;
			if(opt == null) {
				opt = false;
			}
			var t;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var t1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					t1 = true;
				} else {
					t1 = false;
				}
				t = t1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				t = v2;
			}
			if(p.pos < 0) {
				var arr = t;
				var _g2 = 0;
				var _g3 = -p.pos;
				while(_g2 < _g3) {
					var i = _g2++;
					buf1.tex[tid++] = arr[i];
				}
			} else {
				buf1.tex[tid++] = t;
			}
			p = p.next;
		}
		var p = s1.buffers;
		var bid = 0;
		while(p != null) {
			var opt = !h3d_impl_RenderContext.STRICT;
			if(opt == null) {
				opt = false;
			}
			var b;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var b1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					b1 = true;
				} else {
					b1 = false;
				}
				b = b1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				b = v2;
			}
			buf1.buffers[bid++] = b;
			p = p.next;
		}
		var buf1 = buf.fragment;
		var s1 = s.fragment;
		var p = s1.params;
		var ptr = buf1.params;
		while(p != null) {
			var v;
			if(p.perObjectGlobal == null) {
				if(p.type == hxsl_Type.TFloat) {
					var index = p.instance;
					var i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						var si = shaders;
						curInstance = index;
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr[p.pos] = i.getParamFloatValue(p.index);
					p = p.next;
					continue;
				}
				var index1 = p.instance;
				var v1;
				if(curInstance == index1) {
					v1 = curInstanceValue;
				} else {
					var si1 = shaders;
					curInstance = index1;
					while(--index1 > 0) si1 = si1.next;
					curInstanceValue = si1.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
				}
			} else if(p.perObjectGlobal != null) {
				var v2 = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var v3;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					v3 = true;
				} else {
					v3 = false;
				}
				v = v3 ? v2.texture : v2;
			} else {
				var index2 = p.instance;
				var v4;
				if(curInstance == index2) {
					v4 = curInstanceValue;
				} else {
					var si2 = shaders;
					curInstance = index2;
					while(--index2 > 0) si2 = si2.next;
					curInstanceValue = si2.s;
					v4 = curInstanceValue;
				}
				var v5 = v4.getParamValue(p.index);
				if(v5 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				v = v5;
			}
			_gthis.fillRec(v,p.type,ptr,p.pos);
			p = p.next;
		}
		var tid = 0;
		var p = s1.textures;
		while(p != null) {
			var opt = !h3d_impl_RenderContext.STRICT;
			if(opt == null) {
				opt = false;
			}
			var t;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var t1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					t1 = true;
				} else {
					t1 = false;
				}
				t = t1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				t = v2;
			}
			if(p.pos < 0) {
				var arr = t;
				var _g2 = 0;
				var _g3 = -p.pos;
				while(_g2 < _g3) {
					var i = _g2++;
					buf1.tex[tid++] = arr[i];
				}
			} else {
				buf1.tex[tid++] = t;
			}
			p = p.next;
		}
		var p = s1.buffers;
		var bid = 0;
		while(p != null) {
			var opt = !h3d_impl_RenderContext.STRICT;
			if(opt == null) {
				opt = false;
			}
			var b;
			if(p.perObjectGlobal != null) {
				var v = _gthis.globals.map.h[p.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + _gthis.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				var _g = p.type;
				var b1;
				if(_g._hx_index == 17) {
					var _g1 = _g.size;
					b1 = true;
				} else {
					b1 = false;
				}
				b = b1 ? v.texture : v;
			} else {
				var index = p.instance;
				var v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					var si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				var v2 = v1.getParamValue(p.index);
				if(v2 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				b = v2;
			}
			buf1.buffers[bid++] = b;
			p = p.next;
		}
	}
	,__class__: h3d_impl_RenderContext
};
var h2d_RenderContext = function(scene) {
	this.renderZoneIndex = 0;
	this.renderZoneStack = [];
	this.tmpBounds = new h2d_col_Bounds();
	this.defaultSmooth = false;
	this.globalAlpha = 1.;
	h3d_impl_RenderContext.call(this);
	this.scene = scene;
	this.bufPos = 0;
	this.output = new h3d_pass_OutputShader();
	this.pass = new h3d_mat_Pass("",null);
	this.pass.depth(true,h3d_mat_Compare.Always);
	this.pass.set_culling(h3d_mat_Face.None);
	this.baseShader = new h3d_shader_Base2d();
	this.baseShader.setPriority(100);
	this.baseShader.zValue__ = 0.;
	this.baseShaderList = new hxsl_ShaderList(this.baseShader);
	this.targetsStack = [];
	this.targetsStackIndex = 0;
	this.cameraStack = [];
	this.cameraStackIndex = 0;
	this.filterStack = [];
	this.filterStackIndex = 0;
};
$hxClasses["h2d.RenderContext"] = h2d_RenderContext;
h2d_RenderContext.__name__ = "h2d.RenderContext";
h2d_RenderContext.__super__ = h3d_impl_RenderContext;
h2d_RenderContext.prototype = $extend(h3d_impl_RenderContext.prototype,{
	dispose: function() {
		h3d_impl_RenderContext.prototype.dispose.call(this);
		if(this.fixedBuffer != null) {
			this.fixedBuffer.dispose();
		}
	}
	,hasBuffering: function() {
		return false;
	}
	,begin: function() {
		this.texture = null;
		this.currentObj = null;
		this.bufPos = 0;
		this.stride = 0;
		this.viewA = this.scene.viewportA;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = this.scene.viewportD;
		this.viewX = this.scene.viewportX;
		this.viewY = this.scene.viewportY;
		this.setCurrent();
		this.targetFlipY = this.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) ? -1 : 1;
		this.baseFlipY = this.engine.getCurrentTarget() != null ? this.targetFlipY : 1;
		this.inFilter = null;
		this.globals.set("time",this.time);
		this.globals.set("global.time",this.time);
		var _this = this.baseShader;
		_this.constModified = true;
		_this.pixelAlign__ = false;
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / this.engine.width;
		var y = 0.5 / this.engine.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _this = this.baseShader.viewportA__;
		var x = this.scene.viewportA;
		var y = 0;
		var z = this.scene.viewportX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = 0;
		var y = this.scene.viewportD * -this.baseFlipY;
		var z = this.scene.viewportY * -this.baseFlipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.filterMatrixA__;
		var x = 1;
		var y = 0;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.filterMatrixB__;
		var x = 0;
		var y = 1;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.baseShaderList.next = null;
		this.initShaders(this.baseShaderList);
		this.engine.selectMaterial(this.pass);
		this.textures.begin();
	}
	,allocTarget: function(name,filter) {
		if(filter == null) {
			filter = false;
		}
		var t = this.textures.allocTarget(name,this.scene.width,this.scene.height,false);
		t.set_filter(filter ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		return t;
	}
	,clear: function(color) {
		this.engine.clear(color);
	}
	,initShaders: function(shaders) {
		this.currentShaders = shaders;
		this.compiledShader = this.output.compileShaders(this.globals,shaders);
		if(this.buffers == null) {
			this.buffers = new h3d_shader_Buffers(this.compiledShader);
		} else {
			var _this = this.buffers;
			var s = this.compiledShader;
			_this.vertex.grow(s.vertex);
			_this.fragment.grow(s.fragment);
		}
		this.fillGlobals(this.buffers,this.compiledShader);
		this.engine.selectShader(this.compiledShader);
		this.engine.uploadShaderBuffers(this.buffers,0);
	}
	,end: function() {
		this.texture = null;
		this.currentObj = null;
		this.baseShaderList.next = null;
		this.clearCurrent();
		if(this.targetsStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popTarget()");
		}
		if(this.cameraStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popCamera()");
		}
	}
	,pushCamera: function(cam) {
		var entry = this.cameraStack[this.cameraStackIndex++];
		if(entry == null) {
			entry = { va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0};
			this.cameraStack.push(entry);
		}
		var tmpA = this.viewA;
		var tmpB = this.viewB;
		var tmpC = this.viewC;
		var tmpD = this.viewD;
		entry.va = tmpA;
		entry.vb = tmpB;
		entry.vc = tmpC;
		entry.vd = tmpD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		this.viewA = cam.matA * tmpA + cam.matB * tmpC;
		this.viewB = cam.matA * tmpB + cam.matB * tmpD;
		this.viewC = cam.matC * tmpA + cam.matD * tmpC;
		this.viewD = cam.matC * tmpB + cam.matD * tmpD;
		this.viewX = cam.absX * tmpA + cam.absY * tmpC + this.viewX;
		this.viewY = cam.absX * tmpB + cam.absY * tmpD + this.viewY;
		var flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,popCamera: function() {
		if(this.cameraStackIndex == 0) {
			throw haxe_Exception.thrown("Too many popCamera()");
		}
		var inf = this.cameraStack[--this.cameraStackIndex];
		this.viewA = inf.va;
		this.viewB = inf.vb;
		this.viewC = inf.vc;
		this.viewD = inf.vd;
		this.viewX = inf.vx;
		this.viewY = inf.vy;
		var flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,pushFilter: function(spr) {
		if(this.filterStack.length == 0 && this.onEnterFilter != null) {
			if(!this.onEnterFilter(spr)) {
				return false;
			}
		}
		this.inFilter = this.filterStack[this.filterStackIndex++];
		if(this.inFilter == null) {
			this.inFilter = { spr : null, scaleX : 1, scaleY : 1};
			this.filterStack.push(this.inFilter);
		}
		this.inFilter.spr = spr;
		this.inFilter.scaleX = 1;
		this.inFilter.scaleY = 1;
		return true;
	}
	,setFilterScale: function(scaleX,scaleY) {
		if(this.inFilter != null) {
			this.inFilter.scaleX = scaleX;
			this.inFilter.scaleY = scaleY;
		}
	}
	,getFilterScale: function(into) {
		if(into == null) {
			into = new h2d_col_PointImpl(0.,0.);
		}
		if(this.inFilter != null) {
			var _this = into;
			var x = this.inFilter.scaleX;
			var y = this.inFilter.scaleY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		} else {
			var _this = into;
			var x = 1;
			var y = 1;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
		}
		return into;
	}
	,popFilter: function() {
		this.inFilter.spr = null;
		this.filterStackIndex--;
		if(this.filterStackIndex > 0) {
			this.inFilter = this.filterStack[this.filterStackIndex - 1];
		} else {
			this.inFilter = null;
			if(this.onLeaveFilter != null) {
				this.onLeaveFilter(this.filterStack[this.filterStackIndex].spr);
			}
		}
	}
	,pushTarget: function(t,startX,startY,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(startY == null) {
			startY = 0;
		}
		if(startX == null) {
			startX = 0;
		}
		this.engine.pushTarget(t);
		this.initShaders(this.baseShaderList);
		var entry = this.targetsStack[this.targetsStackIndex++];
		if(entry == null) {
			entry = { t : null, va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0, hasRZ : false, rzX : 0, rzY : 0, rzW : 0, rzH : 0};
			this.targetsStack.push(entry);
		}
		entry.t = this.curTarget;
		entry.va = this.viewA;
		entry.vb = this.viewB;
		entry.vc = this.viewC;
		entry.vd = this.viewD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		entry.hasRZ = this.hasRenderZone;
		entry.rzX = this.renderX;
		entry.rzY = this.renderY;
		entry.rzW = this.renderW;
		entry.rzH = this.renderH;
		if(width < 0) {
			width = t == null ? this.scene.width : t.width;
		}
		if(height < 0) {
			height = t == null ? this.scene.height : t.height;
		}
		this.viewA = 2 / width;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = 2 / height;
		this.viewX = -1 - startX * this.viewA;
		this.viewY = -1 - startY * this.viewD;
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / (t == null ? this.engine.width : t.width);
		var y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * -this.targetFlipY;
		var y = this.viewD * -this.targetFlipY;
		var z = this.viewY * -this.targetFlipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.curTarget = t;
		this.currentBlend = null;
		if(this.hasRenderZone) {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	,pushTargets: function(texs) {
		this.pushTarget(texs[0]);
		if(texs.length > 1) {
			this.engine.popTarget();
			this.engine.pushTargets(texs);
		}
	}
	,popTarget: function() {
		if(this.targetsStackIndex <= 0) {
			throw haxe_Exception.thrown("Too many popTarget()");
		}
		this.engine.popTarget();
		var tinf = this.targetsStack[--this.targetsStackIndex];
		var t = this.curTarget = tinf.t;
		this.viewA = tinf.va;
		this.viewB = tinf.vb;
		this.viewC = tinf.vc;
		this.viewD = tinf.vd;
		this.viewX = tinf.vx;
		this.viewY = tinf.vy;
		var flipY = t == null ? -this.baseFlipY : -this.targetFlipY;
		this.initShaders(this.baseShaderList);
		var _this = this.baseShader.halfPixelInverse__;
		var x = 0.5 / (t == null ? this.engine.width : t.width);
		var y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _this = this.baseShader.viewportA__;
		var x = this.viewA;
		var y = this.viewC;
		var z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.viewportB__;
		var x = this.viewB * flipY;
		var y = this.viewD * flipY;
		var z = this.viewY * flipY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		if(tinf.hasRZ) {
			this.setRZ(tinf.rzX,tinf.rzY,tinf.rzW,tinf.rzH);
		}
	}
	,pushRenderZone: function(x,y,w,h) {
		var inf = this.renderZoneStack[this.renderZoneIndex++];
		if(inf == null) {
			inf = { hasRZ : this.hasRenderZone, x : this.renderX, y : this.renderY, w : this.renderW, h : this.renderH};
			this.renderZoneStack[this.renderZoneIndex - 1] = inf;
		} else if(this.hasRenderZone) {
			inf.hasRZ = true;
			inf.x = this.renderX;
			inf.y = this.renderY;
			inf.w = this.renderW;
			inf.h = this.renderH;
		} else {
			inf.hasRZ = false;
		}
		this.setRZ(x,y,w,h);
	}
	,popRenderZone: function() {
		if(this.renderZoneIndex == 0) {
			throw haxe_Exception.thrown("Too many popRenderZone()");
		}
		var inf = this.renderZoneStack[--this.renderZoneIndex];
		if(inf.hasRZ) {
			this.setRZ(inf.x,inf.y,inf.w,inf.h);
		} else {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	,getCurrentRenderZone: function(bounds) {
		if(!this.hasRenderZone) {
			return null;
		}
		if(bounds == null) {
			bounds = new h2d_col_Bounds();
		}
		var x = this.renderX;
		var y = this.renderY;
		bounds.xMin = x;
		bounds.yMin = y;
		bounds.xMax = x + this.renderW;
		bounds.yMax = y + this.renderH;
		return bounds;
	}
	,clipRenderZone: function(x,y,w,h) {
		if(!this.hasRenderZone) {
			this.pushRenderZone(x,y,w,h);
			return;
		}
		var x2 = Math.min(x + w,this.renderX + this.renderW);
		var y2 = Math.min(y + h,this.renderY + this.renderH);
		x = Math.max(x,this.renderX);
		y = Math.max(y,this.renderY);
		if(x2 < x) {
			x2 = x;
		}
		if(y2 < y) {
			y2 = y;
		}
		this.pushRenderZone(x,y,x2 - x,y2 - y);
	}
	,setRZ: function(x,y,w,h) {
		this.hasRenderZone = true;
		this.renderX = x;
		this.renderY = y;
		this.renderW = w;
		this.renderH = h;
		var scaleX = this.scene.viewportA * this.engine.width / 2;
		var scaleY = this.scene.viewportD * this.engine.height / 2;
		if(this.inFilter != null) {
			var fa = this.baseShader.filterMatrixA__;
			var fb = this.baseShader.filterMatrixB__;
			var x2 = x + w;
			var y2 = y + h;
			var rx1 = x * fa.x + y * fa.y + fa.z;
			var ry1 = x * fb.x + y * fb.y + fb.z;
			var rx2 = x2 * fa.x + y2 * fa.y + fa.z;
			var ry2 = x2 * fb.x + y2 * fb.y + fb.z;
			x = rx1;
			y = ry1;
			w = rx2 - rx1;
			h = ry2 - ry1;
		}
		this.engine.setRenderZone(x * scaleX + (this.scene.viewportX + 1) * (this.engine.width / 2) + 1e-10 | 0,y * scaleY + (this.scene.viewportY + 1) * (this.engine.height / 2) + 1e-10 | 0,w * scaleX + 1e-10 | 0,h * scaleY + 1e-10 | 0);
	}
	,clearRZ: function() {
		this.hasRenderZone = false;
		this.engine.setRenderZone();
	}
	,setRenderZone: function(x,y,w,h) {
		this.pushRenderZone(x,y,w,h);
	}
	,clearRenderZone: function() {
		this.popRenderZone();
	}
	,drawLayer: function(layer) {
		this.scene.drawLayer(this,layer);
	}
	,drawScene: function() {
		this.scene.drawRec(this);
	}
	,flush: function() {
	}
	,_flush: function() {
		if(this.bufPos == 0) {
			return;
		}
		this.beforeDraw();
		var nverts = this.bufPos / this.stride | 0;
		var tmp = new h3d_Buffer(nverts,hxd_BufferFormat.get_XY_UV_RGBA(),[h3d_BufferFlag.Dynamic]);
		tmp.uploadFloats(this.buffer,0,nverts);
		var _this = this.engine;
		_this.renderBuffer(tmp,_this.mem.getQuadIndexes(tmp.vertices),2,0,-1);
		tmp.dispose();
		this.bufPos = 0;
		this.texture = null;
	}
	,beforeDraw: function() {
		if(this.texture == null) {
			this.texture = h3d_mat_Texture.fromColor(16711935);
		}
		this.baseShader.texture__ = this.texture;
		this.texture.set_filter((this.currentObj.smooth == null ? this.defaultSmooth : this.currentObj.smooth) ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		this.texture.set_wrap(this.currentObj.tileWrap && (this.currentObj.filter == null || this.inFilter != null) ? h3d_mat_Wrap.Repeat : h3d_mat_Wrap.Clamp);
		var blend = this.currentObj.blendMode;
		if(this.inFilter != null && this.inFilter.spr == this.currentObj && blend == h2d_BlendMode.Erase) {
			blend = h2d_BlendMode.Add;
		}
		if(this.inFilterBlend != null) {
			blend = this.inFilterBlend;
		}
		if(blend != this.currentBlend) {
			this.currentBlend = blend;
			this.pass.setBlendMode(blend);
			if(blend == h2d_BlendMode.Alpha || blend == h2d_BlendMode.Add) {
				this.pass.set_blendAlphaSrc(h3d_mat_Blend.One);
				if(this.inFilterBlend != null) {
					this.pass.set_blendSrc(h3d_mat_Blend.One);
				}
			}
		}
		this.fillParams(this.buffers,this.compiledShader,this.currentShaders);
		this.engine.selectMaterial(this.pass);
		this.engine.uploadShaderBuffers(this.buffers,1);
		this.engine.uploadShaderBuffers(this.buffers,2);
		this.engine.uploadShaderBuffers(this.buffers,3);
	}
	,setupColor: function(obj) {
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
	}
	,beginDrawBatchState: function(obj) {
		if(!this.beginDraw(obj,null,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = obj.matA;
		var y = obj.matC;
		var z = obj.absX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = obj.matB;
		var y = obj.matD;
		var z = obj.absY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		return true;
	}
	,swapTexture: function(texture) {
		this.texture = texture;
		this.beforeDraw();
	}
	,beginDrawObject: function(obj,texture) {
		if(!this.beginDraw(obj,texture,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = obj.matA;
		var y = obj.matC;
		var z = obj.absX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = obj.matB;
		var y = obj.matD;
		var z = obj.absY;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.beforeDraw();
		return true;
	}
	,beginDrawBatch: function(obj,texture) {
		return this.beginDraw(obj,texture,false);
	}
	,drawTile: function(obj,tile) {
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(this.inFilter != null) {
			var f1 = this.baseShader.filterMatrixA__;
			var f2 = this.baseShader.filterMatrixB__;
			var tmpA = obj.matA * f1.x + obj.matB * f1.y;
			var tmpB = obj.matA * f2.x + obj.matB * f2.y;
			var tmpC = obj.matC * f1.x + obj.matD * f1.y;
			var tmpD = obj.matC * f2.x + obj.matD * f2.y;
			var tmpX = obj.absX * f1.x + obj.absY * f1.y + f1.z;
			var tmpY = obj.absX * f2.x + obj.absY * f2.y + f2.z;
			matA = tmpA * this.viewA + tmpB * this.viewC;
			matB = tmpA * this.viewB + tmpB * this.viewD;
			matC = tmpC * this.viewA + tmpD * this.viewC;
			matD = tmpC * this.viewB + tmpD * this.viewD;
			absX = tmpX * this.viewA + tmpY * this.viewC + this.viewX;
			absY = tmpX * this.viewB + tmpY * this.viewD + this.viewY;
		} else {
			matA = obj.matA * this.viewA + obj.matB * this.viewC;
			matB = obj.matA * this.viewB + obj.matB * this.viewD;
			matC = obj.matC * this.viewA + obj.matD * this.viewC;
			matD = obj.matC * this.viewB + obj.matD * this.viewD;
			absX = obj.absX * this.viewA + obj.absY * this.viewC + this.viewX;
			absY = obj.absX * this.viewB + obj.absY * this.viewD + this.viewY;
		}
		if(matB == 0 && matC == 0) {
			var tx = tile.dx + tile.width * 0.5;
			var ty = tile.dy + tile.height * 0.5;
			var a = matA < 0 ? -matA : matA;
			var b = matD < 0 ? -matD : matD;
			var tr = (tile.width > tile.height ? tile.width : tile.height) * 1.5 * (a < b ? b : a);
			var cx = absX + tx * matA;
			var cy = absY + ty * matD;
			if(cx + tr < -1 || cx - tr > 1 || cy + tr < -1 || cy - tr > 1) {
				return false;
			}
		} else {
			var xMin = 1e20;
			var yMin = 1e20;
			var xMax = -1e20;
			var yMax = -1e20;
			var hw = tile.width * 0.5;
			var hh = tile.height * 0.5;
			var px = tile.dx * matA + tile.dy * matC;
			var py = tile.dx * matB + tile.dy * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var x = tile.width;
			var px = (x + tile.dx) * matA + tile.dy * matC;
			var py = (x + tile.dx) * matB + tile.dy * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var y = tile.height;
			var px = tile.dx * matA + (y + tile.dy) * matC;
			var py = tile.dx * matB + (y + tile.dy) * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			var x = tile.width;
			var y = tile.height;
			var px = (x + tile.dx) * matA + (y + tile.dy) * matC;
			var py = (x + tile.dx) * matB + (y + tile.dy) * matD;
			if(px < xMin) {
				xMin = px;
			}
			if(px > xMax) {
				xMax = px;
			}
			if(py < yMin) {
				yMin = py;
			}
			if(py > yMax) {
				yMax = py;
			}
			if(absX + xMax < -1 || absY + yMax < -1 || absX + xMin > 1 || absY + yMin > 1) {
				return false;
			}
		}
		if(!this.beginDraw(obj,tile.innerTex,true,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			var _this = this.baseShader.color__;
			var x = this.globalAlpha;
			var y = this.globalAlpha;
			var z = this.globalAlpha;
			var w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			var _this = this.baseShader.color__;
			var x = obj.color.x;
			var y = obj.color.y;
			var z = obj.color.z;
			var w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		var _this = this.baseShader.absoluteMatrixA__;
		var x = tile.width * obj.matA;
		var y = tile.height * obj.matC;
		var z = obj.absX + tile.dx * obj.matA + tile.dy * obj.matC;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.absoluteMatrixB__;
		var x = tile.width * obj.matB;
		var y = tile.height * obj.matD;
		var z = obj.absY + tile.dx * obj.matB + tile.dy * obj.matD;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.baseShader.uvPos__;
		var x = tile.u;
		var y = tile.v;
		var z = tile.u2 - tile.u;
		var w = tile.v2 - tile.v;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = w;
		this.beforeDraw();
		if(this.fixedBuffer == null || this.fixedBuffer.vbuf == null) {
			this.fixedBuffer = new h3d_Buffer(4,hxd_BufferFormat.get_XY_UV_RGBA());
			var k = hxd__$FloatBuffer_Float32Expand._new(0);
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 0;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			var v = 1;
			if(k.pos == k.array.length) {
				var newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = v;
			this.fixedBuffer.uploadFloats(k,0,4);
		}
		var _this = this.engine;
		var b = this.fixedBuffer;
		_this.renderBuffer(b,_this.mem.getQuadIndexes(b.vertices),2,0,-1);
		return true;
	}
	,beginDraw: function(obj,texture,isRelative,hasUVPos) {
		if(hasUVPos == null) {
			hasUVPos = false;
		}
		if(this.onBeginDraw != null && !this.onBeginDraw(obj)) {
			return false;
		}
		var stride = 8;
		var shaderChanged = false;
		var paramsChanged = false;
		var objShaders = obj.shaders;
		var curShaders = this.currentShaders.next;
		while(objShaders != null && curShaders != null) {
			var s = objShaders.s;
			var t = curShaders.s;
			objShaders = objShaders.next;
			curShaders = curShaders.next;
			var prevInst = t.instance;
			if(s != t) {
				paramsChanged = true;
			}
			s.updateConstants(this.globals);
			if(s.instance != prevInst) {
				shaderChanged = true;
			}
		}
		if(objShaders != null || curShaders != null || this.baseShader.isRelative__ != isRelative || this.baseShader.hasUVPos__ != hasUVPos || this.baseShader.killAlpha__ != this.killAlpha) {
			shaderChanged = true;
		}
		if(shaderChanged) {
			var _this = this.baseShader;
			_this.constModified = true;
			_this.hasUVPos__ = hasUVPos;
			var _this = this.baseShader;
			_this.constModified = true;
			_this.isRelative__ = isRelative;
			var _this = this.baseShader;
			_this.constModified = true;
			_this.killAlpha__ = this.killAlpha;
			this.baseShader.updateConstants(this.globals);
			this.baseShaderList.next = obj.shaders;
			this.initShaders(this.baseShaderList);
		} else if(paramsChanged) {
			if(this.currentShaders != this.baseShaderList) {
				throw haxe_Exception.thrown("!");
			}
			this.currentShaders.next = obj.shaders;
		}
		this.texture = texture;
		this.stride = stride;
		this.currentObj = obj;
		return true;
	}
	,__class__: h2d_RenderContext
});
var h2d_ScaleModeAlign = $hxEnums["h2d.ScaleModeAlign"] = { __ename__:"h2d.ScaleModeAlign",__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Top: {_hx_name:"Top",_hx_index:3,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:4,__enum__:"h2d.ScaleModeAlign",toString:$estr}
};
h2d_ScaleModeAlign.__constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
h2d_ScaleModeAlign.__empty_constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
var h2d_ScaleMode = $hxEnums["h2d.ScaleMode"] = { __ename__:"h2d.ScaleMode",__constructs__:null
	,Resize: {_hx_name:"Resize",_hx_index:0,__enum__:"h2d.ScaleMode",toString:$estr}
	,Stretch: ($_=function(width,height) { return {_hx_index:1,width:width,height:height,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Stretch",$_.__params__ = ["width","height"],$_)
	,LetterBox: ($_=function(width,height,integerScale,horizontalAlign,verticalAlign) { return {_hx_index:2,width:width,height:height,integerScale:integerScale,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="LetterBox",$_.__params__ = ["width","height","integerScale","horizontalAlign","verticalAlign"],$_)
	,Fixed: ($_=function(width,height,zoom,horizontalAlign,verticalAlign) { return {_hx_index:3,width:width,height:height,zoom:zoom,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Fixed",$_.__params__ = ["width","height","zoom","horizontalAlign","verticalAlign"],$_)
	,Zoom: ($_=function(level) { return {_hx_index:4,level:level,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Zoom",$_.__params__ = ["level"],$_)
	,AutoZoom: ($_=function(minWidth,minHeight,integerScaling) { return {_hx_index:5,minWidth:minWidth,minHeight:minHeight,integerScaling:integerScaling,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="AutoZoom",$_.__params__ = ["minWidth","minHeight","integerScaling"],$_)
};
h2d_ScaleMode.__constructs__ = [h2d_ScaleMode.Resize,h2d_ScaleMode.Stretch,h2d_ScaleMode.LetterBox,h2d_ScaleMode.Fixed,h2d_ScaleMode.Zoom,h2d_ScaleMode.AutoZoom];
h2d_ScaleMode.__empty_constructs__ = [h2d_ScaleMode.Resize];
var hxd_InteractiveScene = function() { };
$hxClasses["hxd.InteractiveScene"] = hxd_InteractiveScene;
hxd_InteractiveScene.__name__ = "hxd.InteractiveScene";
hxd_InteractiveScene.__isInterface__ = true;
hxd_InteractiveScene.prototype = {
	__class__: hxd_InteractiveScene
};
var h2d_Scene = function() {
	this.scaleMode = h2d_ScaleMode.Resize;
	h2d_Layers.call(this,null);
	var e = h3d_Engine.CURRENT;
	this.ctx = new h2d_RenderContext(this);
	this._cameras = [];
	new h2d_Camera(this);
	this.set_interactiveCamera(this._cameras[0]);
	this.width = e.width;
	this.height = e.height;
	this.viewportA = 2 / e.width;
	this.viewportD = 2 / e.height;
	this.viewportX = -1;
	this.viewportY = -1;
	this.viewportScaleX = 1;
	this.viewportScaleY = 1;
	this.offsetX = 0;
	this.offsetY = 0;
	this.interactive = [];
	this.eventListeners = [];
	this.shapePoint = new h2d_col_PointImpl(0.,0.);
	this.window = hxd_Window.getInstance();
	this.posChanged = true;
};
$hxClasses["h2d.Scene"] = h2d_Scene;
h2d_Scene.__name__ = "h2d.Scene";
h2d_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h2d_Scene.__super__ = h2d_Layers;
h2d_Scene.prototype = $extend(h2d_Layers.prototype,{
	get_defaultSmooth: function() {
		return this.ctx.defaultSmooth;
	}
	,set_defaultSmooth: function(v) {
		return this.ctx.defaultSmooth = v;
	}
	,setEvents: function(events) {
		this.events = events;
	}
	,get_zoom: function() {
		var _g = this.scaleMode;
		if(_g._hx_index == 4) {
			var level = _g.level;
			return level | 0;
		} else {
			return 0;
		}
	}
	,set_zoom: function(v) {
		this.set_scaleMode(h2d_ScaleMode.Zoom(v));
		return v;
	}
	,set_scaleMode: function(v) {
		this.scaleMode = v;
		this.checkResize();
		return v;
	}
	,get_renderer: function() {
		return this.ctx;
	}
	,set_renderer: function(v) {
		this.ctx = v;
		return v;
	}
	,get_camera: function() {
		return this._cameras[0];
	}
	,get_cameras: function() {
		return this._cameras;
	}
	,set_interactiveCamera: function(cam) {
		if(cam == null) {
			throw haxe_Exception.thrown("Interactive cammera cannot be null!");
		}
		if(cam.scene != this) {
			this.addCamera(cam);
		}
		return this.interactiveCamera = cam;
	}
	,addCamera: function(cam,pos) {
		if(cam.scene != null) {
			cam.scene.removeCamera(cam);
		}
		cam.scene = this;
		cam.posChanged = true;
		if(pos != null) {
			this._cameras.splice(pos,0,cam);
		} else {
			this._cameras.push(cam);
		}
	}
	,removeCamera: function(cam) {
		if(cam == this.interactiveCamera) {
			throw haxe_Exception.thrown("Current interactive Camera cannot be removed from camera list!");
		}
		cam.scene = null;
		HxOverrides.remove(this._cameras,cam);
	}
	,setFixedSize: function(w,h) {
		this.set_scaleMode(h2d_ScaleMode.Stretch(w,h));
	}
	,checkResize: function() {
		var _gthis = this;
		var engine = h3d_Engine.CURRENT;
		if(engine == null) {
			return;
		}
		var _g = this.scaleMode;
		switch(_g._hx_index) {
		case 0:
			var w = engine.width;
			var h = engine.height;
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = 1;
			_gthis.viewportScaleY = 1;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 1:
			var _width = _g.width;
			var _height = _g.height;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = engine.width / _width;
			_gthis.viewportScaleY = engine.height / _height;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 2:
			var _width = _g.width;
			var _height = _g.height;
			var integerScale = _g.integerScale;
			var horizontalAlign = _g.horizontalAlign;
			var verticalAlign = _g.verticalAlign;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			var a = engine.width / _width;
			var b = engine.height / _height;
			var zoom = a > b ? b : a;
			if(integerScale) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			var horizontal = horizontalAlign;
			var vertical = verticalAlign;
			_gthis.viewportA = zoom * 2 / engine.width;
			_gthis.viewportD = zoom * 2 / engine.height;
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			if(horizontal == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				_gthis.viewportX = -1;
				_gthis.offsetX = 0;
				break;
			case 1:
				_gthis.viewportX = 1 - _gthis.width * _gthis.viewportA;
				_gthis.offsetX = engine.width - _gthis.width * zoom;
				break;
			default:
				_gthis.viewportX = Math.floor((engine.width - _gthis.width * zoom) / (zoom * 2)) * _gthis.viewportA - 1.;
				_gthis.offsetX = Math.floor((engine.width - _gthis.width * zoom) / 2);
			}
			if(vertical == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				_gthis.viewportY = -1;
				_gthis.offsetY = 0;
				break;
			case 4:
				_gthis.viewportY = 1 - _gthis.height * _gthis.viewportD;
				_gthis.offsetY = engine.height - _gthis.height * zoom;
				break;
			default:
				_gthis.viewportY = Math.floor((engine.height - _gthis.height * zoom) / (zoom * 2)) * _gthis.viewportD - 1.;
				_gthis.offsetY = Math.floor((engine.height - _gthis.height * zoom) / 2);
			}
			break;
		case 3:
			var _width = _g.width;
			var _height = _g.height;
			var zoom = _g.zoom;
			var horizontalAlign = _g.horizontalAlign;
			var verticalAlign = _g.verticalAlign;
			if(_width != _gthis.width || _height != _gthis.height) {
				_gthis.width = _width;
				_gthis.height = _height;
				_gthis.posChanged = true;
			}
			var horizontal = horizontalAlign;
			var vertical = verticalAlign;
			_gthis.viewportA = zoom * 2 / engine.width;
			_gthis.viewportD = zoom * 2 / engine.height;
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			if(horizontal == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				_gthis.viewportX = -1;
				_gthis.offsetX = 0;
				break;
			case 1:
				_gthis.viewportX = 1 - _gthis.width * _gthis.viewportA;
				_gthis.offsetX = engine.width - _gthis.width * zoom;
				break;
			default:
				_gthis.viewportX = Math.floor((engine.width - _gthis.width * zoom) / (zoom * 2)) * _gthis.viewportA - 1.;
				_gthis.offsetX = Math.floor((engine.width - _gthis.width * zoom) / 2);
			}
			if(vertical == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				_gthis.viewportY = -1;
				_gthis.offsetY = 0;
				break;
			case 4:
				_gthis.viewportY = 1 - _gthis.height * _gthis.viewportD;
				_gthis.offsetY = engine.height - _gthis.height * zoom;
				break;
			default:
				_gthis.viewportY = Math.floor((engine.height - _gthis.height * zoom) / (zoom * 2)) * _gthis.viewportD - 1.;
				_gthis.offsetY = Math.floor((engine.height - _gthis.height * zoom) / 2);
			}
			break;
		case 4:
			var level = _g.level;
			var w = Math.ceil(engine.width / level);
			var h = Math.ceil(engine.height / level);
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = level;
			_gthis.viewportScaleY = level;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		case 5:
			var minWidth = _g.minWidth;
			var minHeight = _g.minHeight;
			var integerScaling = _g.integerScaling;
			var a = engine.width / minWidth;
			var b = engine.height / minHeight;
			var zoom = a > b ? b : a;
			if(integerScaling) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			var w = Math.ceil(engine.width / zoom);
			var h = Math.ceil(engine.height / zoom);
			if(w != _gthis.width || h != _gthis.height) {
				_gthis.width = w;
				_gthis.height = h;
				_gthis.posChanged = true;
			}
			_gthis.viewportScaleX = zoom;
			_gthis.viewportScaleY = zoom;
			_gthis.viewportA = 2 / _gthis.width;
			_gthis.viewportD = 2 / _gthis.height;
			_gthis.viewportX = -1;
			_gthis.viewportY = -1;
			break;
		}
	}
	,screenXToViewport: function(mx) {
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		return (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet;
	}
	,screenYToViewport: function(my) {
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		return (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet;
	}
	,get_mouseX: function() {
		this.syncPos();
		var mx = this.window.get_mouseX();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		if(this.matC == 0) {
			return dx / this.matA;
		}
		var my = this.window.get_mouseY();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		return (dx * this.matD - dy * this.matC) / (this.matA * this.matD - this.matB * this.matC);
	}
	,get_mouseY: function() {
		this.syncPos();
		var my = this.window.get_mouseY();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		if(this.matB == 0) {
			return dy / this.matD;
		}
		var mx = this.window.get_mouseX();
		var _this = this.interactiveCamera;
		var mx = this.window.get_mouseX();
		var my = this.window.get_mouseY();
		var dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		return (dy * this.matA - dx * this.matB) / (this.matA * this.matD - this.matB * this.matC);
	}
	,dispatchListeners: function(event) {
		this.screenToViewport(event);
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	,isInteractiveVisible: function(i) {
		var s = i;
		while(s != this) {
			if(s == null || !s.visible) {
				return false;
			}
			s = s.parent;
		}
		return true;
	}
	,getInteractive: function(x,y) {
		var pt = this.shapePoint;
		var _g = 0;
		var _g1 = this.interactive;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.posChanged) {
				i.syncPos();
			}
			var dx = x - i.absX;
			var dy = y - i.absY;
			var rx = (dx * i.matD - dy * i.matC) * i.invDet;
			var ry = (dy * i.matA - dx * i.matB) * i.invDet;
			if(i.shape != null) {
				var _this = pt;
				var x1 = rx + i.shapeX;
				var y1 = ry + i.shapeY;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				_this.x = x1;
				_this.y = y1;
				if(!i.shape.contains(pt)) {
					continue;
				}
			} else if(ry < 0 || rx < 0 || rx >= i.width || ry >= i.height) {
				continue;
			}
			var visible = true;
			var p = i;
			while(p != null) {
				if(!p.visible) {
					visible = false;
					break;
				}
				p = p.parent;
			}
			if(!visible) {
				continue;
			}
			return i;
		}
		return null;
	}
	,screenToViewport: function(e) {
		this.interactiveCamera.eventToCamera(e);
	}
	,dispatchEvent: function(event,to) {
		var i = to;
		this.screenToViewport(event);
		var dx = event.relX - i.absX;
		var dy = event.relY - i.absY;
		var rx = (dx * i.matD - dy * i.matC) * i.invDet;
		var ry = (dy * i.matA - dx * i.matB) * i.invDet;
		event.relX = rx;
		event.relY = ry;
		i.handleEvent(event);
	}
	,handleEvent: function(event,last) {
		this.screenToViewport(event);
		var ex = event.relX;
		var ey = event.relY;
		var index = last == null ? 0 : this.interactive.indexOf(last) + 1;
		var pt = this.shapePoint;
		var _g = index;
		var _g1 = this.interactive.length;
		while(_g < _g1) {
			var idx = _g++;
			var i = this.interactive[idx];
			if(i == null) {
				break;
			}
			if(i.invDet == 0) {
				continue;
			}
			var dx = ex - i.absX;
			var dy = ey - i.absY;
			var rx = (dx * i.matD - dy * i.matC) * i.invDet;
			var ry = (dy * i.matA - dx * i.matB) * i.invDet;
			if(i.shape != null) {
				var _this = pt;
				var x = rx + i.shapeX;
				var y = ry + i.shapeY;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				if(!i.shape.contains(pt)) {
					continue;
				}
			} else if(ry < 0 || rx < 0 || rx >= i.width || ry >= i.height) {
				continue;
			}
			var visible = true;
			var p = i;
			while(p != null) {
				if(!p.visible) {
					visible = false;
					break;
				}
				p = p.parent;
			}
			if(!visible) {
				continue;
			}
			event.relX = rx;
			event.relY = ry;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			return i;
		}
		return null;
	}
	,addEventListener: function(f) {
		this.eventListeners.push(f);
	}
	,removeEventListener: function(f) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e == f) {
				HxOverrides.remove(this.eventListeners,e);
				return true;
			}
		}
		return false;
	}
	,startCapture: function(onEvent,onCancel,touchId) {
		var _gthis = this;
		this.events.startCapture(function(e) {
			_gthis.screenToViewport(e);
			onEvent(e);
		},onCancel,touchId);
	}
	,stopCapture: function() {
		this.events.stopCapture();
	}
	,startDrag: function(onEvent,onCancel,refEvent) {
		this.startCapture(onEvent,onCancel,refEvent != null ? refEvent.touchId : null);
	}
	,stopDrag: function() {
		this.stopCapture();
	}
	,getFocus: function() {
		if(this.events == null) {
			return null;
		}
		var f = this.events.getFocus();
		if(f == null) {
			return null;
		}
		var i = ((f) instanceof h2d_Interactive) ? f : null;
		if(i == null) {
			return null;
		}
		return this.interactive[this.interactive.indexOf(i)];
	}
	,addEventTarget: function(i) {
		var i1 = i;
		var lv = 0;
		while(i1 != null) {
			i1 = i1.parent;
			++lv;
		}
		var level = lv;
		var _g = 0;
		var _g1 = this.interactive.length;
		while(_g < _g1) {
			var index = _g++;
			var i1 = i;
			var i2 = this.interactive[index];
			var lv1 = level;
			var i3 = i2;
			var lv = 0;
			while(i3 != null) {
				i3 = i3.parent;
				++lv;
			}
			var lv2 = lv;
			var p1 = i1;
			var p2 = i2;
			while(lv1 > lv2) {
				i1 = p1;
				p1 = p1.parent;
				--lv1;
			}
			while(lv2 > lv1) {
				i2 = p2;
				p2 = p2.parent;
				--lv2;
			}
			while(p1 != p2) {
				i1 = p1;
				p1 = p1.parent;
				i2 = p2;
				p2 = p2.parent;
			}
			var id = -1;
			var _g2 = 0;
			var _g3 = p1.children.length;
			while(_g2 < _g3) {
				var k = _g2++;
				if(p1.children[k] == i1) {
					id = k;
					break;
				}
			}
			var tmp = id;
			var id1 = -1;
			var _g4 = 0;
			var _g5 = p2.children.length;
			while(_g4 < _g5) {
				var k1 = _g4++;
				if(p2.children[k1] == i2) {
					id1 = k1;
					break;
				}
			}
			if(tmp > id1) {
				this.interactive.splice(index,0,i);
				return;
			}
		}
		this.interactive.push(i);
	}
	,removeEventTarget: function(i,notify) {
		if(notify == null) {
			notify = false;
		}
		HxOverrides.remove(this.interactive,i);
		if(notify && this.events != null) {
			this.events.onRemove(i);
		}
	}
	,dispose: function() {
		if(this.allocated) {
			this.onRemove();
		}
		this.ctx.dispose();
	}
	,setElapsedTime: function(v) {
		this.ctx.elapsedTime = v;
	}
	,drawImplTo: function(s,texs,outputs) {
		var _g = 0;
		while(_g < texs.length) {
			var t = texs[_g];
			++_g;
			if((t.flags & 1 << h3d_mat_TextureFlags.Target._hx_index) == 0) {
				throw haxe_Exception.thrown("Can only draw to texture created with Target flag");
			}
		}
		this.ctx.engine = h3d_Engine.CURRENT;
		var oldBG = this.ctx.engine.backgroundColor;
		var inRender = this.ctx.engine.inRender;
		this.ctx.engine.backgroundColor = null;
		this.ctx.globalAlpha = this.alpha;
		var prevCtx = h3d_impl_RenderContext.get();
		if(!inRender) {
			this.ctx.engine.begin();
			this.ctx.begin();
		} else if(this.ctx.targetFlipY == 0) {
			this.ctx.begin();
		}
		this.ctx.pushTargets(texs);
		if(outputs != null) {
			this.ctx.output.setOutput(outputs);
		}
		s.drawRec(this.ctx);
		if(outputs != null) {
			this.ctx.output.setOutput();
		}
		this.ctx.popTarget();
		this.ctx.engine.backgroundColor = oldBG;
		if(!inRender) {
			this.ctx.end();
			this.ctx.engine.end();
		}
		if(prevCtx != null) {
			prevCtx.setCurrent();
		}
	}
	,syncOnly: function(et) {
		var engine = h3d_Engine.CURRENT;
		this.setElapsedTime(et);
		this.ctx.engine = engine;
		this.ctx.frame++;
		this.ctx.time += this.ctx.elapsedTime;
		this.ctx.globalAlpha = this.alpha;
		this.sync(this.ctx);
	}
	,render: function(engine) {
		this.ctx.engine = engine;
		this.ctx.frame++;
		this.ctx.time += this.ctx.elapsedTime;
		this.ctx.globalAlpha = this.alpha;
		this.sync(this.ctx);
		if(this.children.length == 0) {
			return;
		}
		this.ctx.begin();
		this.ctx.drawScene();
		this.ctx.end();
	}
	,sync: function(ctx) {
		var forceCamSync = this.posChanged;
		if(!this.allocated) {
			this.onAdd();
		}
		h2d_Layers.prototype.sync.call(this,ctx);
		var _g = 0;
		var _g1 = this._cameras;
		while(_g < _g1.length) {
			var cam = _g1[_g];
			++_g;
			cam.sync(ctx,forceCamSync);
		}
	}
	,clipBounds: function(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		var matA;
		var matB;
		var matC;
		var matD;
		var absX;
		var absY;
		if(ctx.inFilter != null) {
			var f1 = ctx.baseShader.filterMatrixA__;
			var f2 = ctx.baseShader.filterMatrixB__;
			var tmpA = this.matA * f1.x + this.matB * f1.y;
			var tmpB = this.matA * f2.x + this.matB * f2.y;
			var tmpC = this.matC * f1.x + this.matD * f1.y;
			var tmpD = this.matC * f2.x + this.matD * f2.y;
			var tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			var tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		var invDet = 1 / (matA * matD - matB * matC);
		bounds.xMin = ((-1 - absX) * matD + (absY + 1) * matC) * invDet;
		bounds.yMin = ((absX + 1) * matB + (-1 - absY) * matA) * invDet;
		bounds.xMax = ((1 - absX) * matD + (absY - 1) * matC) * invDet;
		bounds.yMax = ((absX - 1) * matB + (1 - absY) * matA) * invDet;
	}
	,drawContent: function(ctx) {
		if(ctx.front2back) {
			var _g = 0;
			var _g1 = this._cameras;
			while(_g < _g1.length) {
				var cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				var i = this.children.length;
				var l = this.layerCount;
				cam.enter(ctx);
				while(l-- > 0) {
					var top = l == 0 ? 0 : this.layersIndexes[l - 1];
					if(cam.layerVisible(l)) {
						while(i >= top) this.children[i--].drawRec(ctx);
					} else {
						i = top - 1;
					}
				}
				cam.exit(ctx);
			}
			this.draw(ctx);
		} else {
			this.draw(ctx);
			var _g = 0;
			var _g1 = this._cameras;
			while(_g < _g1.length) {
				var cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				var i = 0;
				var l = 0;
				cam.enter(ctx);
				while(l < this.layerCount) {
					var top = this.layersIndexes[l++];
					if(cam.layerVisible(l - 1)) {
						while(i < top) this.children[i++].drawRec(ctx);
					} else {
						i = top;
					}
				}
				cam.exit(ctx);
			}
		}
	}
	,onAdd: function() {
		this.checkResize();
		h2d_Layers.prototype.onAdd.call(this);
		this.window.addResizeEvent($bind(this,this.checkResize));
	}
	,onRemove: function() {
		h2d_Layers.prototype.onRemove.call(this);
		this.window.removeResizeEvent($bind(this,this.checkResize));
	}
	,captureBitmap: function(target) {
		var engine = h3d_Engine.CURRENT;
		if(target == null) {
			var tex = new h3d_mat_Texture(this.width,this.height,[h3d_mat_TextureFlags.Target]);
			target = new h2d_Tile(tex,0,0,this.width,this.height);
		}
		engine.begin();
		engine.setRenderZone(target.x | 0,target.y | 0,Math.ceil(target.width),Math.ceil(target.height));
		var tex = target.innerTex;
		engine.pushTarget(tex);
		var ow = this.width;
		var oh = this.height;
		var ova = this.viewportA;
		var ovd = this.viewportD;
		var ovx = this.viewportX;
		var ovy = this.viewportY;
		this.width = tex.width;
		this.height = tex.height;
		this.viewportA = 2 / this.width;
		this.viewportD = 2 / this.height;
		this.viewportX = -1;
		this.viewportY = -1;
		this.posChanged = true;
		this.render(engine);
		engine.popTarget();
		this.width = ow;
		this.height = oh;
		this.viewportA = ova;
		this.viewportD = ovd;
		this.viewportX = ovx;
		this.viewportY = ovy;
		this.posChanged = true;
		engine.setRenderZone();
		engine.end();
		return new h2d_Bitmap(target);
	}
	,__class__: h2d_Scene
});
var h2d_TileCenter = $hxEnums["h2d.TileCenter"] = { __ename__:"h2d.TileCenter",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h2d.TileCenter",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:1,__enum__:"h2d.TileCenter",toString:$estr}
	,XCenter: {_hx_name:"XCenter",_hx_index:2,__enum__:"h2d.TileCenter",toString:$estr}
	,YCenter: {_hx_name:"YCenter",_hx_index:3,__enum__:"h2d.TileCenter",toString:$estr}
};
h2d_TileCenter.__constructs__ = [h2d_TileCenter.None,h2d_TileCenter.Center,h2d_TileCenter.XCenter,h2d_TileCenter.YCenter];
h2d_TileCenter.__empty_constructs__ = [h2d_TileCenter.None,h2d_TileCenter.Center,h2d_TileCenter.XCenter,h2d_TileCenter.YCenter];
var h2d_Store = function() {
	this.frameAlignY = 0.0;
	this.frameAlignX = 0.0;
	this.textures = [];
	this.lastIndex = 0;
	this.tiles = [];
	this.index = new haxe_ds_StringMap();
	this.timelines = new haxe_ds_StringMap();
};
$hxClasses["h2d.Store"] = h2d_Store;
h2d_Store.__name__ = "h2d.Store";
h2d_Store.prototype = {
	setImg: function(img,t,transpColor) {
		if(t != null) {
			this.tile = t;
		}
		if(transpColor != null) {
			var bmp = img.toBitmap();
			var _g = 0;
			var _g1 = bmp.ctx.canvas.width;
			while(_g < _g1) {
				var x = _g++;
				var _g2 = 0;
				var _g3 = bmp.ctx.canvas.height;
				while(_g2 < _g3) {
					var y = _g2++;
					var n = bmp.getPixel(x,y);
					if(n == transpColor) {
						bmp.setPixel(x,y,0);
					}
				}
			}
			this.tile = h2d_Tile.fromBitmap(bmp);
		}
		if(this.tile == null) {
			this.tile = img.toTile();
		}
		this.textures.push(this.tile);
	}
	,addIndex: function(str) {
		this.index.h[str] = this.tiles.length;
		this.lastIndex = this.tiles.length;
	}
	,slice: function(name,centerMode,dx,dy,ww,hh,xmax,ymax,crop1) {
		if(crop1 == null) {
			crop1 = false;
		}
		if(ymax == null) {
			ymax = 1;
		}
		if(xmax == null) {
			xmax = 1;
		}
		if(centerMode == null) {
			centerMode = h2d_TileCenter.None;
		}
		if(name != null) {
			this.addIndex(name);
		}
		var ow = ww;
		var oh = hh;
		if(crop1) {
			++dx;
			++dy;
			ww -= 2;
			hh -= 2;
		}
		var _g = 0;
		var _g1 = ymax;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = xmax;
			while(_g2 < _g3) {
				var x = _g2++;
				var t = this.tile.sub(dx + x * ow,dy + y * oh,ww,hh);
				t.dx = -(ww * this.frameAlignX | 0);
				t.dy = -(hh * this.frameAlignY | 0);
				switch(centerMode._hx_index) {
				case 0:
					break;
				case 1:
					t = t.center();
					break;
				case 2:
					var px = 0.5;
					var py = 0.0;
					if(py == null) {
						py = 0.5;
					}
					if(px == null) {
						px = 0.5;
					}
					t.dx = -(px * t.width);
					t.dy = -(py * t.height);
					break;
				case 3:
					var px1 = 0.0;
					var py1 = 0.5;
					if(py1 == null) {
						py1 = 0.5;
					}
					if(px1 == null) {
						px1 = 0.5;
					}
					t.dx = -(px1 * t.width);
					t.dy = -(py1 * t.height);
					break;
				}
				this.tiles.push(t);
			}
		}
	}
	,addAnim: function(str,frames,rythm,multi) {
		if(multi == null) {
			multi = 1;
		}
		var a = [];
		var id = 0;
		var _g = 0;
		while(_g < frames.length) {
			var n = frames[_g];
			++_g;
			var max = 1;
			if(rythm != null) {
				if(id < rythm.length) {
					max = rythm[id];
				} else {
					max = rythm[rythm.length - 1];
				}
			}
			var _g1 = 0;
			var _g2 = max;
			while(_g1 < _g2) {
				var i = _g1++;
				a.push(n + this.lastIndex);
			}
			++id;
		}
		if(multi > 1) {
			var _g = 0;
			var _g1 = multi;
			while(_g < _g1) {
				var k = _g++;
				var b = [];
				var inc = k * a.length;
				var _g2 = 0;
				while(_g2 < a.length) {
					var n = a[_g2];
					++_g2;
					b.push(n + inc);
				}
				this.timelines.h[str + "_" + k] = a;
			}
		} else {
			this.timelines.h[str] = a;
		}
	}
	,get: function(id,str) {
		if(id == null) {
			id = 0;
		}
		if(str != null) {
			id += this.index.h[str];
		}
		return this.tiles[id];
	}
	,getTimeline: function(str) {
		return this.timelines.h[str];
	}
	,setAlign: function(ax,ay) {
		if(ay == null) {
			ay = ax;
		}
		this.frameAlignX = ax;
		this.frameAlignY = ay;
	}
	,__class__: h2d_Store
};
var h2d_Align = $hxEnums["h2d.Align"] = { __ename__:"h2d.Align",__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.Align",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.Align",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.Align",toString:$estr}
	,MultilineRight: {_hx_name:"MultilineRight",_hx_index:3,__enum__:"h2d.Align",toString:$estr}
	,MultilineCenter: {_hx_name:"MultilineCenter",_hx_index:4,__enum__:"h2d.Align",toString:$estr}
};
h2d_Align.__constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
h2d_Align.__empty_constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
var h2d_Tile = function(tex,x,y,w,h,dx,dy) {
	if(dy == null) {
		dy = 0;
	}
	if(dx == null) {
		dx = 0;
	}
	this.innerTex = tex;
	this.x = x;
	this.y = y;
	this.width = w;
	this.height = h;
	this.dx = dx;
	this.dy = dy;
	if(tex != null) {
		this.setTexture(tex);
	}
};
$hxClasses["h2d.Tile"] = h2d_Tile;
h2d_Tile.__name__ = "h2d.Tile";
h2d_Tile.fromColor = function(color,width,height,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	if(height == null) {
		height = 1;
	}
	if(width == null) {
		width = 1;
	}
	var t = new h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1);
	t.width = width;
	t.height = height;
	return t;
};
h2d_Tile.fromBitmap = function(bmp) {
	var tex = h3d_mat_Texture.fromBitmap(bmp);
	return new h2d_Tile(tex,0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height);
};
h2d_Tile.autoCut = function(bmp,width,height) {
	bmp.lock();
	if(height == null) {
		height = width;
	}
	var colorBG = bmp.getPixel(bmp.ctx.canvas.width - 1,bmp.ctx.canvas.height - 1);
	var tl = [];
	var w = 1;
	var h = 1;
	while(w < bmp.ctx.canvas.width) w <<= 1;
	while(h < bmp.ctx.canvas.height) h <<= 1;
	var tex = new h3d_mat_Texture(w,h);
	var _g = 0;
	var _g1 = bmp.ctx.canvas.height / height | 0;
	while(_g < _g1) {
		var y = _g++;
		var a = [];
		tl[y] = a;
		var _g2 = 0;
		var _g3 = bmp.ctx.canvas.width / width | 0;
		while(_g2 < _g3) {
			var x = _g2++;
			var sz = h2d_Tile.isEmpty(bmp,x * width,y * height,width,height,colorBG);
			if(sz == null) {
				break;
			}
			a.push(new h2d_Tile(tex,x * width + sz.dx,y * height + sz.dy,sz.w,sz.h,sz.dx,sz.dy));
		}
	}
	bmp.unlock();
	var main = new h2d_Tile(tex,0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height);
	main.upload(bmp);
	return { main : main, tiles : tl};
};
h2d_Tile.fromTexture = function(t) {
	return new h2d_Tile(t,0,0,t.width,t.height);
};
h2d_Tile.fromPixels = function(pixels) {
	var pix2 = pixels.makeSquare(true);
	var t = h3d_mat_Texture.fromPixels(pix2,h3d_mat_Texture.nativeFormat);
	if(pix2 != pixels) {
		pix2.dispose();
	}
	return new h2d_Tile(t,0,0,pixels.width,pixels.height);
};
h2d_Tile.isEmpty = function(b,px,py,width,height,bg) {
	var empty = true;
	var xmin = width;
	var ymin = height;
	var xmax = 0;
	var ymax = 0;
	var _g = 0;
	var _g1 = width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = height;
		while(_g2 < _g3) {
			var y = _g2++;
			var color = b.getPixel(x + px,y + py);
			if((color & -16777216) == 0) {
				if(color != 0) {
					b.setPixel(x + px,y + py,0);
				}
				continue;
			}
			if(color != bg) {
				empty = false;
				if(x < xmin) {
					xmin = x;
				}
				if(y < ymin) {
					ymin = y;
				}
				if(x > xmax) {
					xmax = x;
				}
				if(y > ymax) {
					ymax = y;
				}
			}
			if(color == bg && color != 0) {
				b.setPixel(x + px,y + py,0);
			}
		}
	}
	if(empty) {
		return null;
	} else {
		return { dx : xmin, dy : ymin, w : xmax - xmin + 1, h : ymax - ymin + 1};
	}
};
h2d_Tile.prototype = {
	get_ix: function() {
		return Math.floor(this.x);
	}
	,get_iy: function() {
		return Math.floor(this.y);
	}
	,get_iwidth: function() {
		return Math.ceil(this.width + this.x) - Math.floor(this.x);
	}
	,get_iheight: function() {
		return Math.ceil(this.height + this.y) - Math.floor(this.y);
	}
	,getTexture: function() {
		return this.innerTex;
	}
	,isDisposed: function() {
		if(this.innerTex != null) {
			var _this = this.innerTex;
			if(_this.isDepth()) {
				return _this.t == null;
			} else if(_this.t == null) {
				return _this.realloc == null;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,setTexture: function(tex) {
		this.innerTex = tex;
		if(tex != null) {
			this.u = this.x / tex.width;
			this.v = this.y / tex.height;
			this.u2 = (this.x + this.width) / tex.width;
			this.v2 = (this.y + this.height) / tex.height;
		}
	}
	,switchTexture: function(t) {
		this.setTexture(t.innerTex);
	}
	,sub: function(x,y,w,h,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		return new h2d_Tile(this.innerTex,this.x + x,this.y + y,w,h,dx,dy);
	}
	,center: function() {
		return this.sub(0,0,this.width,this.height,-(this.width * .5),-(this.height * .5));
	}
	,setCenterRatio: function(px,py) {
		if(py == null) {
			py = 0.5;
		}
		if(px == null) {
			px = 0.5;
		}
		this.dx = -(px * this.width);
		this.dy = -(py * this.height);
	}
	,flipX: function() {
		var tmp = this.u;
		this.u = this.u2;
		this.u2 = tmp;
		this.dx = -this.dx - this.width;
	}
	,flipY: function() {
		var tmp = this.v;
		this.v = this.v2;
		this.v2 = tmp;
		this.dy = -this.dy - this.height;
	}
	,setPosition: function(x,y) {
		this.x = x;
		this.y = y;
		var tex = this.innerTex;
		if(tex != null) {
			this.u = x / tex.width;
			this.v = y / tex.height;
			this.u2 = (x + this.width) / tex.width;
			this.v2 = (y + this.height) / tex.height;
		}
	}
	,setSize: function(w,h) {
		this.width = w;
		this.height = h;
		var tex = this.innerTex;
		if(tex != null) {
			this.u2 = (this.x + w) / tex.width;
			this.v2 = (this.y + h) / tex.height;
		}
	}
	,scaleToSize: function(w,h) {
		this.width = w;
		this.height = h;
	}
	,scrollDiscrete: function(dx,dy) {
		var tex = this.innerTex;
		this.u += dx / tex.width;
		this.v -= dy / tex.height;
		this.u2 += dx / tex.width;
		this.v2 -= dy / tex.height;
		this.x = this.u * tex.width;
		this.y = this.v * tex.height;
	}
	,dispose: function() {
		if(this.innerTex != null) {
			this.innerTex.dispose();
		}
		this.innerTex = null;
	}
	,clone: function() {
		var t = new h2d_Tile(null,this.x,this.y,this.width,this.height,this.dx,this.dy);
		t.innerTex = this.innerTex;
		t.u = this.u;
		t.u2 = this.u2;
		t.v = this.v;
		t.v2 = this.v2;
		return t;
	}
	,get_xFlip: function() {
		return this.u2 < this.u;
	}
	,get_yFlip: function() {
		return this.v2 < this.v;
	}
	,set_xFlip: function(v) {
		if(v != this.get_xFlip()) {
			this.flipX();
		}
		return v;
	}
	,set_yFlip: function(v) {
		if(v != this.get_yFlip()) {
			this.flipY();
		}
		return v;
	}
	,split: function(frames,vertical,subpixel) {
		if(subpixel == null) {
			subpixel = false;
		}
		if(vertical == null) {
			vertical = false;
		}
		if(frames == null) {
			frames = 0;
		}
		var tl = [];
		if(vertical) {
			if(frames == 0) {
				frames = this.height / this.width | 0;
			}
			var stride = subpixel ? this.height / frames : this.height / frames | 0;
			var _g = 0;
			var _g1 = frames;
			while(_g < _g1) {
				var i = _g++;
				tl.push(this.sub(0,i * stride,this.width,stride));
			}
		} else {
			if(frames == 0) {
				frames = this.width / this.height | 0;
			}
			var stride = subpixel ? this.width / frames : this.width / frames | 0;
			var _g = 0;
			var _g1 = frames;
			while(_g < _g1) {
				var i = _g++;
				tl.push(this.sub(i * stride,0,stride,this.height));
			}
		}
		return tl;
	}
	,gridFlatten: function(size,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.height / size | 0;
		while(_g1 < _g2) {
			var y = _g1++;
			var _g3 = 0;
			var _g4 = this.width / size | 0;
			while(_g3 < _g4) {
				var x = _g3++;
				_g.push(this.sub(x * size,y * size,size,size,dx,dy));
			}
		}
		return _g;
	}
	,grid: function(size,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.width / size | 0;
		while(_g1 < _g2) {
			var x = _g1++;
			var _g3 = [];
			var _g4 = 0;
			var _g5 = this.height / size | 0;
			while(_g4 < _g5) {
				var y = _g4++;
				_g3.push(this.sub(x * size,y * size,size,size,dx,dy));
			}
			_g.push(_g3);
		}
		return _g;
	}
	,toString: function() {
		return "Tile(" + this.x + "," + this.y + "," + this.width + "x" + this.height + (this.dx != 0 || this.dy != 0 ? "," + this.dx + ":" + this.dy : "") + ")";
	}
	,upload: function(bmp) {
		var w = this.innerTex.width;
		var h = this.innerTex.height;
		this.innerTex.uploadBitmap(bmp);
	}
	,__class__: h2d_Tile
};
var h2d_TileLayerContent = function() {
	this.useAllocatorLimit = 1024;
	h3d_prim_Primitive.call(this);
	this.state = new h2d_impl_BatchDrawState();
	this.clear();
};
$hxClasses["h2d.TileLayerContent"] = h2d_TileLayerContent;
h2d_TileLayerContent.__name__ = "h2d.TileLayerContent";
h2d_TileLayerContent.__super__ = h3d_prim_Primitive;
h2d_TileLayerContent.prototype = $extend(h3d_prim_Primitive.prototype,{
	clear: function() {
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
		}
		this.buffer = null;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.xMax = -Infinity;
		this.yMax = -Infinity;
		this.state.clear();
	}
	,isEmpty: function() {
		return this.triCount() == 0;
	}
	,triCount: function() {
		if(this.buffer == null) {
			return this.tmp.pos >> 4;
		} else {
			return this.buffer.vertices >> 1;
		}
	}
	,addColor: function(x,y,color,t) {
		this.add(x,y,color.x,color.y,color.z,color.w,t);
	}
	,add: function(x,y,r,g,b,a,t) {
		var sx = x + t.dx;
		var sy = y + t.dy;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sy;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		var v = sx + t.width;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sy;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		var this1 = this.tmp;
		var v = sy + t.height;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var this1 = this.tmp;
		var v = sx + t.width;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = sy + t.height;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = r;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = g;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = b;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = a;
		var x1 = x + t.dx;
		var y1 = y + t.dy;
		if(x1 < this.xMin) {
			this.xMin = x1;
		}
		if(y1 < this.yMin) {
			this.yMin = y1;
		}
		x1 += t.width;
		y1 += t.height;
		if(x1 > this.xMax) {
			this.xMax = x1;
		}
		if(y1 > this.yMax) {
			this.yMax = y1;
		}
		if(t != null) {
			this.state.setTexture(t.innerTex);
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,addTransform: function(x,y,sx,sy,r,c,t) {
		var _gthis = this;
		var ca = Math.cos(r);
		var sa = Math.sin(r);
		var hx = t.width;
		var hy = t.height;
		var dx = t.dx * sx;
		var dy = t.dy * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		var dx = (t.dx + hx) * sx;
		var dy = t.dy * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		var dx = t.dx * sx;
		var dy = (t.dy + hy) * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		var dx = (t.dx + hx) * sx;
		var dy = (t.dy + hy) * sy;
		var px = dx * ca - dy * sa + x;
		var py = dy * ca + dx * sa + y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = px;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = py;
		var this1 = this.tmp;
		var v = t.u2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = t.v2;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.x;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.y;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.z;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		var this1 = this.tmp;
		var v = c.w;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = v;
		if(px < _gthis.xMin) {
			_gthis.xMin = px;
		}
		if(py < _gthis.yMin) {
			_gthis.yMin = py;
		}
		if(px > _gthis.xMax) {
			_gthis.xMax = px;
		}
		if(py > _gthis.yMax) {
			_gthis.yMax = py;
		}
		if(t != null) {
			this.state.setTexture(t.innerTex);
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,addPoint: function(x,y,color) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,insertColor: function(c) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (c >>> 24) / 255.;
	}
	,rectColor: function(x,y,w,h,color) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (color >>> 24) / 255.;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		x += w;
		y += h;
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,rectGradient: function(x,y,w,h,ctl,ctr,cbl,cbr) {
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctl >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (ctr >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbl >>> 24) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = x + w;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = y + h;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 1;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr >> 16 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr >> 8 & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr & 255) / 255.;
		var this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = (cbr >>> 24) / 255.;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		x += w;
		y += h;
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	,fillArc: function(x,y,ray,c,start,end) {
		if(end <= start) {
			return;
		}
		var arcLength = end - start;
		var nsegments = Math.ceil(ray * 3.14 * 2 / 4);
		if(nsegments < 4) {
			nsegments = 4;
		}
		var angle = arcLength / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var _x = 0.;
		var _y = 0.;
		var i = 0;
		var count = 0;
		while(i < nsegments) {
			var a = start + i * angle;
			_x = x + Math.cos(a) * ray;
			_y = y + Math.sin(a) * ray;
			if(prevX != -Infinity) {
				this.addPoint(x,y,c);
				this.addPoint(_x,_y,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(prevX,prevY,c);
				count += 4;
			}
			prevX = _x;
			prevY = _y;
			++i;
		}
		var a = end;
		_x = x + Math.cos(a) * ray;
		_y = y + Math.sin(a) * ray;
		this.addPoint(x,y,c);
		this.addPoint(_x,_y,c);
		this.addPoint(prevX,prevY,c);
		this.addPoint(prevX,prevY,c);
		var _this = this.state;
		var count1 = count + 4;
		_this.tail.count += count1;
		_this.totalCount += count1;
	}
	,fillCircle: function(x,y,radius,c) {
		var nsegments = Math.ceil(radius * 3.14 * 2 / 2);
		if(nsegments < 3) {
			nsegments = 3;
		}
		var angle = Math.PI * 2 / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var firstX = -Infinity;
		var firstY = -Infinity;
		var curX = 0.;
		var curY = 0.;
		var count = 0;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			curX = x + Math.cos(a) * radius;
			curY = y + Math.sin(a) * radius;
			if(prevX != -Infinity) {
				this.addPoint(x,y,c);
				this.addPoint(curX,curY,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(x,y,c);
				count += 4;
			}
			if(firstX == -Infinity) {
				firstX = curX;
				firstY = curY;
			}
			prevX = curX;
			prevY = curY;
		}
		this.addPoint(x,y,c);
		this.addPoint(curX,curY,c);
		this.addPoint(firstX,firstY,c);
		this.addPoint(x,y,c);
		var _this = this.state;
		var count1 = count + 4;
		_this.tail.count += count1;
		_this.totalCount += count1;
	}
	,circle: function(x,y,ray,size,c) {
		if(size > ray) {
			return;
		}
		var nsegments = Math.ceil(ray * 3.14 * 2 / 2);
		if(nsegments < 3) {
			nsegments = 3;
		}
		var ray1 = ray - size;
		var angle = Math.PI * 2 / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var prevX1 = -Infinity;
		var prevY1 = -Infinity;
		var count = 0;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = i * angle;
			var _x = x + Math.cos(a) * ray;
			var _y = y + Math.sin(a) * ray;
			var _x1 = x + Math.cos(a) * ray1;
			var _y1 = y + Math.sin(a) * ray1;
			if(prevX != -Infinity) {
				this.addPoint(_x,_y,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(_x1,_y1,c);
				this.addPoint(prevX1,prevY1,c);
				count += 4;
			}
			prevX = _x;
			prevY = _y;
			prevX1 = _x1;
			prevY1 = _y1;
		}
		var _this = this.state;
		_this.tail.count += count;
		_this.totalCount += count;
	}
	,arc: function(x,y,ray,size,start,end,c) {
		if(size > ray) {
			return;
		}
		if(end <= start) {
			return;
		}
		var arcLength = end - start;
		var nsegments = Math.ceil(ray * 3.14 * 2 / 4);
		if(nsegments < 3) {
			nsegments = 3;
		}
		var ray1 = ray - size;
		var angle = arcLength / nsegments;
		var prevX = -Infinity;
		var prevY = -Infinity;
		var prevX1 = -Infinity;
		var prevY1 = -Infinity;
		var _x = 0.;
		var _y = 0.;
		var _x1 = 0.;
		var _y1 = 0.;
		var count = 0;
		var _g = 0;
		var _g1 = nsegments;
		while(_g < _g1) {
			var i = _g++;
			var a = start + i * angle;
			_x = x + Math.cos(a) * ray;
			_y = y + Math.sin(a) * ray;
			_x1 = x + Math.cos(a) * ray1;
			_y1 = y + Math.sin(a) * ray1;
			if(prevX != -Infinity) {
				this.addPoint(_x,_y,c);
				this.addPoint(prevX,prevY,c);
				this.addPoint(_x1,_y1,c);
				this.addPoint(prevX1,prevY1,c);
				count += 4;
			}
			prevX = _x;
			prevY = _y;
			prevX1 = _x1;
			prevY1 = _y1;
		}
		var a = end;
		_x = x + Math.cos(a) * ray;
		_y = y + Math.sin(a) * ray;
		_x1 = x + Math.cos(a) * ray1;
		_y1 = y + Math.sin(a) * ray1;
		this.addPoint(_x,_y,c);
		this.addPoint(prevX,prevY,c);
		this.addPoint(_x1,_y1,c);
		this.addPoint(prevX1,prevY1,c);
		var _this = this.state;
		var count1 = count + 4;
		_this.tail.count += count1;
		_this.totalCount += count1;
	}
	,alloc: function(engine) {
		if(this.tmp == null) {
			this.clear();
		}
		if(this.tmp.pos > 0) {
			this.buffer = this.tmp.pos < this.useAllocatorLimit ? hxd_impl_Allocator.get().ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA()) : h3d_Buffer.ofFloats(this.tmp,hxd_BufferFormat.get_XY_UV_RGBA());
		}
	}
	,dispose: function() {
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
			this.buffer = null;
		}
		h3d_prim_Primitive.prototype.dispose.call(this);
	}
	,flush: function() {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(h3d_Engine.CURRENT);
		}
	}
	,doRender: function(ctx,min,len) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(h3d_Engine.CURRENT);
		}
		this.state.drawQuads(ctx,this.buffer,min,len);
	}
	,__class__: h2d_TileLayerContent
});
var h2d_TileGroup = function(t,parent) {
	h2d_Drawable.call(this,parent);
	this.tile = t;
	this.rangeMin = this.rangeMax = -1;
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.curColor = new h3d_Vector4Impl(x,y,z,w);
	this.content = new h2d_TileLayerContent();
};
$hxClasses["h2d.TileGroup"] = h2d_TileGroup;
h2d_TileGroup.__name__ = "h2d.TileGroup";
h2d_TileGroup.__super__ = h2d_Drawable;
h2d_TileGroup.prototype = $extend(h2d_Drawable.prototype,{
	getBoundsRec: function(relativeTo,out,forSize) {
		h2d_Drawable.prototype.getBoundsRec.call(this,relativeTo,out,forSize);
		this.addBounds(relativeTo,out,this.content.xMin,this.content.yMin,this.content.xMax - this.content.xMin,this.content.yMax - this.content.yMin);
	}
	,clear: function() {
		this.content.clear();
	}
	,invalidate: function() {
		this.content.dispose();
	}
	,count: function() {
		return this.content.triCount() >> 1;
	}
	,onRemove: function() {
		this.content.dispose();
		h2d_Drawable.prototype.onRemove.call(this);
	}
	,setDefaultColor: function(rgb,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		this.curColor.x = (rgb >> 16 & 255) / 255;
		this.curColor.y = (rgb >> 8 & 255) / 255;
		this.curColor.z = (rgb & 255) / 255;
		this.curColor.w = alpha;
	}
	,add: function(x,y,t) {
		this.content.add(x,y,this.curColor.x,this.curColor.y,this.curColor.z,this.curColor.w,t);
	}
	,addColor: function(x,y,r,g,b,a,t) {
		this.content.add(x,y,r,g,b,a,t);
	}
	,addAlpha: function(x,y,a,t) {
		this.content.add(x,y,this.curColor.x,this.curColor.y,this.curColor.z,a,t);
	}
	,addTransform: function(x,y,sx,sy,r,t) {
		this.content.addTransform(x,y,sx,sy,r,this.curColor,t);
	}
	,draw: function(ctx) {
		this.drawWith(ctx,this);
	}
	,sync: function(ctx) {
		h2d_Drawable.prototype.sync.call(this,ctx);
		if(this.visible) {
			var _this = this.content;
			if(_this.buffer == null || _this.buffer.vbuf == null) {
				_this.alloc(h3d_Engine.CURRENT);
			}
		}
	}
	,drawWith: function(ctx,obj) {
		var max = this.content.triCount();
		if(max == 0) {
			return;
		}
		if(!ctx.beginDrawBatchState(obj)) {
			return;
		}
		var min = this.rangeMin < 0 ? 0 : this.rangeMin * 2;
		if(this.rangeMax > 0 && this.rangeMax < max * 2) {
			max = this.rangeMax * 2;
		}
		var _this = this.content;
		if(_this.buffer == null || _this.buffer.vbuf == null) {
			_this.alloc(h3d_Engine.CURRENT);
		}
		_this.state.drawQuads(ctx,_this.buffer,min,max - min);
	}
	,__class__: h2d_TileGroup
});
var h2d_col_Collider = function() { };
$hxClasses["h2d.col.Collider"] = h2d_col_Collider;
h2d_col_Collider.__name__ = "h2d.col.Collider";
h2d_col_Collider.prototype = {
	__class__: h2d_col_Collider
};
var h2d_col_Bounds = function() {
	this.xMin = 1e20;
	this.yMin = 1e20;
	this.xMax = -1e20;
	this.yMax = -1e20;
};
$hxClasses["h2d.col.Bounds"] = h2d_col_Bounds;
h2d_col_Bounds.__name__ = "h2d.col.Bounds";
h2d_col_Bounds.fromValues = function(x0,y0,width,height) {
	var b = new h2d_col_Bounds();
	b.xMin = x0;
	b.yMin = y0;
	b.xMax = x0 + width;
	b.yMax = y0 + height;
	return b;
};
h2d_col_Bounds.fromPoints = function(min,max) {
	var b = new h2d_col_Bounds();
	b.xMin = min.x;
	b.yMin = min.y;
	b.xMax = max.x;
	b.yMax = max.y;
	return b;
};
h2d_col_Bounds.__super__ = h2d_col_Collider;
h2d_col_Bounds.prototype = $extend(h2d_col_Collider.prototype,{
	toIBounds: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		var ix = Math.floor(this.xMin * scale);
		var iy = Math.floor(this.yMin * scale);
		var width = Math.ceil(this.xMax * scale) - ix;
		var height = Math.ceil(this.yMax * scale) - iy;
		var b = new h2d_col_IBounds();
		b.xMin = ix;
		b.yMin = iy;
		b.xMax = ix + width;
		b.yMax = iy + height;
		return b;
	}
	,intersects: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.xMax < b.xMin || this.yMax < b.yMin);
	}
	,collideBounds: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.xMax < b.xMin || this.yMax < b.yMin);
	}
	,collideCircle: function(c) {
		if(c.x < this.xMin - c.ray) {
			return false;
		} else if(c.x > this.xMax + c.ray) {
			return false;
		} else if(c.y < this.yMin - c.ray) {
			return false;
		} else if(c.y > this.yMax + c.ray) {
			return false;
		} else {
			var tmp;
			if(c.x < this.xMin && c.y < this.yMin) {
				var dx = c.x - this.xMin;
				var dy = c.y - this.yMin;
				tmp = dx * dx + dy * dy > c.ray * c.ray;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			} else {
				var tmp;
				if(c.x > this.xMax && c.y < this.yMin) {
					var dx = c.x - this.xMax;
					var dy = c.y - this.yMin;
					tmp = dx * dx + dy * dy > c.ray * c.ray;
				} else {
					tmp = false;
				}
				if(tmp) {
					return false;
				} else {
					var tmp;
					if(c.x < this.xMin && c.y > this.yMax) {
						var dx = c.x - this.xMin;
						var dy = c.y - this.yMax;
						tmp = dx * dx + dy * dy > c.ray * c.ray;
					} else {
						tmp = false;
					}
					if(tmp) {
						return false;
					} else {
						var tmp;
						if(c.x > this.xMax && c.y > this.yMax) {
							var dx = c.x - this.xMax;
							var dy = c.y - this.yMax;
							tmp = dx * dx + dy * dy > c.ray * c.ray;
						} else {
							tmp = false;
						}
						if(tmp) {
							return false;
						} else {
							return true;
						}
					}
				}
			}
		}
	}
	,contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin) {
			return p.y < this.yMax;
		} else {
			return false;
		}
	}
	,rayIntersection: function(r) {
		var minTx = (this.xMin - r.px) / r.lx;
		var minTy = (this.yMin - r.py) / r.ly;
		var maxTx = (this.xMax - r.px) / r.lx;
		var maxTy = (this.yMax - r.py) / r.ly;
		var realMinTx = minTx > maxTx ? maxTx : minTx;
		var realMinTy = minTy > maxTy ? maxTy : minTy;
		var realMaxTx = minTx < maxTx ? maxTx : minTx;
		var realMaxTy = minTy < maxTy ? maxTy : minTy;
		var minmax = realMaxTx > realMaxTy ? realMaxTy : realMaxTx;
		var maxmin = realMinTx < realMinTy ? realMinTy : realMinTx;
		if(minmax < maxmin) {
			return -1;
		}
		return maxmin;
	}
	,distanceSq: function(p) {
		var dx = p.x < this.xMin ? this.xMin - p.x : p.x > this.xMax ? p.x - this.xMax : 0.;
		var dy = p.y < this.yMin ? this.yMin - p.y : p.y > this.yMax ? p.y - this.yMax : 0.;
		return dx * dx + dy * dy;
	}
	,distance: function(p) {
		var dx = p.x < this.xMin ? this.xMin - p.x : p.x > this.xMax ? p.x - this.xMax : 0.;
		var dy = p.y < this.yMin ? this.yMin - p.y : p.y > this.yMax ? p.y - this.yMax : 0.;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,addBounds: function(b) {
		if(b.xMin < this.xMin) {
			this.xMin = b.xMin;
		}
		if(b.xMax > this.xMax) {
			this.xMax = b.xMax;
		}
		if(b.yMin < this.yMin) {
			this.yMin = b.yMin;
		}
		if(b.yMax > this.yMax) {
			this.yMax = b.yMax;
		}
	}
	,addPoint: function(p) {
		if(p.x < this.xMin) {
			this.xMin = p.x;
		}
		if(p.x > this.xMax) {
			this.xMax = p.x;
		}
		if(p.y < this.yMin) {
			this.yMin = p.y;
		}
		if(p.y > this.yMax) {
			this.yMax = p.y;
		}
	}
	,addPos: function(x,y) {
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,set: function(x,y,width,height) {
		this.xMin = x;
		this.yMin = y;
		this.xMax = x + width;
		this.yMax = y + height;
	}
	,setMin: function(p) {
		this.xMin = p.x;
		this.yMin = p.y;
	}
	,setMax: function(p) {
		this.xMax = p.x;
		this.yMax = p.y;
	}
	,doIntersect: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a > b1 ? b1 : a;
	}
	,doUnion: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a < b1 ? b1 : a;
	}
	,intersection: function(b) {
		var i = new h2d_col_Bounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a > b1 ? b1 : a;
		if(i.xMax < i.xMin) {
			i.xMax = i.xMin;
		}
		if(i.yMax < i.yMin) {
			i.yMax = i.yMin;
		}
		return i;
	}
	,union: function(b) {
		var i = new h2d_col_Bounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a < b1 ? b1 : a;
		return i;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.yMin = b.yMin;
		this.xMax = b.xMax;
		this.yMax = b.yMax;
	}
	,scalePivot: function(v) {
		this.xMin *= v;
		this.yMin *= v;
		this.xMax *= v;
		this.yMax *= v;
	}
	,scaleCenter: function(v) {
		var dx = (this.xMax - this.xMin) * 0.5 * v;
		var dy = (this.yMax - this.yMin) * 0.5 * v;
		var mx = (this.xMax + this.xMin) * 0.5;
		var my = (this.yMax + this.yMin) * 0.5;
		this.xMin = mx - dx;
		this.yMin = my - dy;
		this.xMax = mx + dx;
		this.yMax = my + dy;
	}
	,rotate: function(angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		var x0 = this.xMin;
		var y0 = this.yMin;
		var x1 = this.xMax;
		var y1 = this.yMax;
		this.xMin = 1e20;
		this.yMin = 1e20;
		this.xMax = -1e20;
		this.yMax = -1e20;
		var x = x0 * cos - y0 * sin;
		var y = x0 * sin + y0 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var x = x1 * cos - y0 * sin;
		var y = x1 * sin + y0 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var x = x0 * cos - y1 * sin;
		var y = x0 * sin + y1 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		var x = x1 * cos - y1 * sin;
		var y = x1 * sin + y1 * cos;
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,offset: function(dx,dy) {
		this.xMin += dx;
		this.xMax += dx;
		this.yMin += dy;
		this.yMax += dy;
	}
	,getMin: function() {
		var x = this.xMin;
		var y = this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getCenter: function() {
		var x = (this.xMin + this.xMax) * 0.5;
		var y = (this.yMin + this.yMax) * 0.5;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getSize: function() {
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getMax: function() {
		var x = this.xMax;
		var y = this.yMax;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,isEmpty: function() {
		if(!(this.xMax <= this.xMin)) {
			return this.yMax <= this.yMin;
		} else {
			return true;
		}
	}
	,empty: function() {
		this.xMin = 1e20;
		this.yMin = 1e20;
		this.xMax = -1e20;
		this.yMax = -1e20;
	}
	,all: function() {
		this.xMin = -1e20;
		this.yMin = -1e20;
		this.xMax = 1e20;
		this.yMax = 1e20;
	}
	,clone: function() {
		var b = new h2d_col_Bounds();
		b.xMin = this.xMin;
		b.yMin = this.yMin;
		b.xMax = this.xMax;
		b.yMax = this.yMax;
		return b;
	}
	,get_x: function() {
		return this.xMin;
	}
	,get_y: function() {
		return this.yMin;
	}
	,set_x: function(x) {
		this.xMax += x - this.xMin;
		return this.xMin = x;
	}
	,set_y: function(y) {
		this.yMax += y - this.yMin;
		return this.yMin = y;
	}
	,get_width: function() {
		return this.xMax - this.xMin;
	}
	,get_height: function() {
		return this.yMax - this.yMin;
	}
	,set_width: function(w) {
		this.xMax = this.xMin + w;
		return w;
	}
	,set_height: function(h) {
		this.yMax = this.yMin + h;
		return h;
	}
	,toString: function() {
		var x = this.xMin;
		var y = this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var tmp = "{" + Std.string(new h2d_col_PointImpl(x,y)) + ",";
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return tmp + Std.string(new h2d_col_PointImpl(x,y)) + "}";
	}
	,toCircle: function() {
		var dx = this.xMax - this.xMin;
		var dy = this.yMax - this.yMin;
		return new h2d_col_Circle((this.xMin + this.xMax) * 0.5,(this.yMin + this.yMax) * 0.5,Math.sqrt(dx * dx + dy * dy) * 0.5);
	}
	,__class__: h2d_col_Bounds
});
var h2d_col_Circle = function(x,y,ray) {
	this.x = x;
	this.y = y;
	this.ray = ray;
};
$hxClasses["h2d.col.Circle"] = h2d_col_Circle;
h2d_col_Circle.__name__ = "h2d.col.Circle";
h2d_col_Circle.__super__ = h2d_col_Collider;
h2d_col_Circle.prototype = $extend(h2d_col_Collider.prototype,{
	distanceSq: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var d = dx * dx + dy * dy - this.ray * this.ray;
		if(d < 0) {
			return 0;
		} else {
			return d;
		}
	}
	,side: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		return this.ray * this.ray - (dx * dx + dy * dy);
	}
	,collideCircle: function(c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		return dx * dx + dy * dy < (this.ray + c.ray) * (this.ray + c.ray);
	}
	,collideBounds: function(b) {
		if(this.x < b.xMin - this.ray) {
			return false;
		}
		if(this.x > b.xMax + this.ray) {
			return false;
		}
		if(this.y < b.yMin - this.ray) {
			return false;
		}
		if(this.y > b.yMax + this.ray) {
			return false;
		}
		var tmp;
		if(this.x < b.xMin && this.y < b.yMin) {
			var dx = this.x - b.xMin;
			var dy = this.y - b.yMin;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		if(this.x > b.xMax && this.y < b.yMin) {
			var dx = this.x - b.xMax;
			var dy = this.y - b.yMin;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		if(this.x < b.xMin && this.y > b.yMax) {
			var dx = this.x - b.xMin;
			var dy = this.y - b.yMax;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		if(this.x > b.xMax && this.y > b.yMax) {
			var dx = this.x - b.xMax;
			var dy = this.y - b.yMax;
			tmp = dx * dx + dy * dy > this.ray * this.ray;
		} else {
			tmp = false;
		}
		if(tmp) {
			return false;
		}
		return true;
	}
	,lineIntersect: function(p1,p2) {
		var dx = p2.x - p1.x;
		var dy = p2.y - p1.y;
		var a = dx * dx + dy * dy;
		if(a < 1e-8) {
			return null;
		}
		var b = 2 * (dx * (p1.x - this.x) + dy * (p1.y - this.y));
		var dx1 = p1.x - this.x;
		var dy1 = p1.y - this.y;
		var c = dx1 * dx1 + dy1 * dy1 - this.ray * this.ray;
		var d = b * b - 4 * a * c;
		if(d < 0) {
			return null;
		}
		if(d == 0) {
			var t = -b / (2 * a);
			var x = p1.x + t * dx;
			var y = p1.y + t * dy;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return [new h2d_col_PointImpl(x,y)];
		}
		var t1 = (-b - Math.sqrt(d)) / (2 * a);
		var t2 = (-b + Math.sqrt(d)) / (2 * a);
		var x = p1.x + t1 * dx;
		var y = p1.y + t1 * dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h2d_col_PointImpl(x,y);
		var x = p1.x + t2 * dx;
		var y = p1.y + t2 * dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return [this1,new h2d_col_PointImpl(x,y)];
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.ray) + "}";
	}
	,contains: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var d = dx * dx + dy * dy - this.ray * this.ray;
		return (d < 0 ? 0 : d) == 0;
	}
	,__class__: h2d_col_Circle
});
var h2d_col_IBounds = function() {
	this.xMin = 2147483647;
	this.yMin = 2147483647;
	this.xMax = -2147483648;
	this.yMax = -2147483648;
};
$hxClasses["h2d.col.IBounds"] = h2d_col_IBounds;
h2d_col_IBounds.__name__ = "h2d.col.IBounds";
h2d_col_IBounds.fromValues = function(x0,y0,width,height) {
	var b = new h2d_col_IBounds();
	b.xMin = x0;
	b.yMin = y0;
	b.xMax = x0 + width;
	b.yMax = y0 + height;
	return b;
};
h2d_col_IBounds.fromPoints = function(min,max) {
	var b = new h2d_col_IBounds();
	b.xMin = min.x;
	b.yMin = min.y;
	b.xMax = max.x;
	b.yMax = max.y;
	return b;
};
h2d_col_IBounds.prototype = {
	toBounds: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		var x0 = this.xMin * scale;
		var y0 = this.yMin * scale;
		var width = (this.xMax - this.xMin) * scale;
		var height = (this.yMax - this.yMin) * scale;
		var b = new h2d_col_Bounds();
		b.xMin = x0;
		b.yMin = y0;
		b.xMax = x0 + width;
		b.yMax = y0 + height;
		return b;
	}
	,intersects: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.xMax < b.xMin || this.yMax < b.yMin);
	}
	,contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin) {
			return p.y < this.yMax;
		} else {
			return false;
		}
	}
	,addBounds: function(b) {
		if(b.xMin < this.xMin) {
			this.xMin = b.xMin;
		}
		if(b.xMax > this.xMax) {
			this.xMax = b.xMax;
		}
		if(b.yMin < this.yMin) {
			this.yMin = b.yMin;
		}
		if(b.yMax > this.yMax) {
			this.yMax = b.yMax;
		}
	}
	,addPoint: function(p) {
		if(p.x < this.xMin) {
			this.xMin = p.x;
		}
		if(p.x > this.xMax) {
			this.xMax = p.x;
		}
		if(p.y < this.yMin) {
			this.yMin = p.y;
		}
		if(p.y > this.yMax) {
			this.yMax = p.y;
		}
	}
	,addPos: function(x,y) {
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
	}
	,set: function(x,y,width,height) {
		this.xMin = x;
		this.yMin = y;
		this.xMax = x + width;
		this.yMax = y + height;
	}
	,setMin: function(p) {
		this.xMin = p.x;
		this.yMin = p.y;
	}
	,setMax: function(p) {
		this.xMax = p.x;
		this.yMax = p.y;
	}
	,doIntersect: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a > b1 ? b1 : a;
	}
	,doUnion: function(b) {
		var a = this.xMin;
		var b1 = b.xMin;
		this.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		this.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		this.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		this.yMax = a < b1 ? b1 : a;
	}
	,intersection: function(b) {
		var i = new h2d_col_IBounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a < b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a < b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a > b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a > b1 ? b1 : a;
		if(i.xMax < i.xMin) {
			i.xMax = i.xMin;
		}
		if(i.yMax < i.yMin) {
			i.yMax = i.yMin;
		}
		return i;
	}
	,union: function(b) {
		var i = new h2d_col_IBounds();
		var a = this.xMin;
		var b1 = b.xMin;
		i.xMin = a > b1 ? b1 : a;
		var a = this.yMin;
		var b1 = b.yMin;
		i.yMin = a > b1 ? b1 : a;
		var a = this.xMax;
		var b1 = b.xMax;
		i.xMax = a < b1 ? b1 : a;
		var a = this.yMax;
		var b1 = b.yMax;
		i.yMax = a < b1 ? b1 : a;
		return i;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.yMin = b.yMin;
		this.xMax = b.xMax;
		this.yMax = b.yMax;
	}
	,offset: function(dx,dy) {
		this.xMin += dx;
		this.xMax += dx;
		this.yMin += dy;
		this.yMax += dy;
	}
	,getMin: function() {
		return new h2d_col_IPoint(this.xMin,this.yMin);
	}
	,getCenter: function() {
		return new h2d_col_IPoint(this.xMin + this.xMax >> 1,this.yMin + this.yMax >> 1);
	}
	,getSize: function() {
		return new h2d_col_IPoint(this.xMax - this.xMin,this.yMax - this.yMin);
	}
	,getMax: function() {
		return new h2d_col_IPoint(this.xMax,this.yMax);
	}
	,isEmpty: function() {
		if(this.xMax > this.xMin) {
			return this.yMax <= this.yMin;
		} else {
			return true;
		}
	}
	,empty: function() {
		this.xMin = 2147483647;
		this.yMin = 2147483647;
		this.xMax = -2147483648;
		this.yMax = -2147483648;
	}
	,all: function() {
		this.xMin = -2147483648;
		this.yMin = -2147483648;
		this.xMax = 2147483647;
		this.yMax = 2147483647;
	}
	,clone: function() {
		var b = new h2d_col_IBounds();
		b.xMin = this.xMin;
		b.yMin = this.yMin;
		b.xMax = this.xMax;
		b.yMax = this.yMax;
		return b;
	}
	,get_x: function() {
		return this.xMin;
	}
	,get_y: function() {
		return this.yMin;
	}
	,set_x: function(x) {
		this.xMax += x - this.xMin;
		return this.xMin = x;
	}
	,set_y: function(y) {
		this.yMax += y - this.yMin;
		return this.yMin = y;
	}
	,get_width: function() {
		return this.xMax - this.xMin;
	}
	,get_height: function() {
		return this.yMax - this.yMin;
	}
	,set_width: function(w) {
		this.xMax = this.xMin + w;
		return w;
	}
	,set_height: function(h) {
		this.yMax = this.yMin + h;
		return h;
	}
	,toString: function() {
		return "{" + Std.string(new h2d_col_IPoint(this.xMin,this.yMin)) + "," + Std.string(new h2d_col_IPoint(this.xMax - this.xMin,this.yMax - this.yMin)) + "}";
	}
	,__class__: h2d_col_IBounds
};
var h2d_col_IPoint = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
$hxClasses["h2d.col.IPoint"] = h2d_col_IPoint;
h2d_col_IPoint.__name__ = "h2d.col.IPoint";
h2d_col_IPoint.prototype = {
	load: function(p) {
		this.x = p.x;
		this.y = p.y;
	}
	,scale: function(v) {
		this.x *= v;
		this.y *= v;
	}
	,scaled: function(v) {
		return new h2d_col_IPoint(this.x * v,this.y * v);
	}
	,distanceSq: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return dx * dx + dy * dy;
	}
	,distance: function(p) {
		var dx = this.x - p.x;
		var dy = this.y - p.y;
		return Math.sqrt(dx * dx + dy * dy);
	}
	,toString: function() {
		return "{" + this.x + "," + this.y + "}";
	}
	,sub: function(p) {
		return new h2d_col_IPoint(this.x - p.x,this.y - p.y);
	}
	,add: function(p) {
		return new h2d_col_IPoint(this.x + p.x,this.y + p.y);
	}
	,equals: function(other) {
		if(this.x == other.x) {
			return this.y == other.y;
		} else {
			return false;
		}
	}
	,dot: function(p) {
		return this.x * p.x + this.y * p.y;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,set: function(x,y) {
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		this.x = x;
		this.y = y;
	}
	,clone: function() {
		return new h2d_col_IPoint(this.x,this.y);
	}
	,cross: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,toPoint: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		var x = this.x * scale;
		var y = this.y * scale;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,__class__: h2d_col_IPoint
};
var h2d_col_OffsetKind = $hxEnums["h2d.col.OffsetKind"] = { __ename__:"h2d.col.OffsetKind",__constructs__:null
	,Square: {_hx_name:"Square",_hx_index:0,__enum__:"h2d.col.OffsetKind",toString:$estr}
	,Miter: {_hx_name:"Miter",_hx_index:1,__enum__:"h2d.col.OffsetKind",toString:$estr}
	,Round: ($_=function(arc) { return {_hx_index:2,arc:arc,__enum__:"h2d.col.OffsetKind",toString:$estr}; },$_._hx_name="Round",$_.__params__ = ["arc"],$_)
};
h2d_col_OffsetKind.__constructs__ = [h2d_col_OffsetKind.Square,h2d_col_OffsetKind.Miter,h2d_col_OffsetKind.Round];
h2d_col_OffsetKind.__empty_constructs__ = [h2d_col_OffsetKind.Square,h2d_col_OffsetKind.Miter];
var h2d_col_IPolygon = {};
h2d_col_IPolygon.get_length = function(this1) {
	return this1.length;
};
h2d_col_IPolygon.get_points = function(this1) {
	return this1;
};
h2d_col_IPolygon._new = function(points) {
	return points == null ? [] : points;
};
h2d_col_IPolygon.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$IPoint(this1);
};
h2d_col_IPolygon.toPolygon = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		var scale1 = scale;
		if(scale1 == null) {
			scale1 = 1.;
		}
		var x = p.x * scale1;
		var y = p.y * scale1;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_g.push(new h2d_col_PointImpl(x,y));
	}
	return _g;
};
h2d_col_IPolygon.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_IBounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p.x < b.xMin) {
			b.xMin = p.x;
		}
		if(p.x > b.xMax) {
			b.xMax = p.x;
		}
		if(p.y < b.yMin) {
			b.yMin = p.y;
		}
		if(p.y > b.yMax) {
			b.yMax = p.y;
		}
	}
	return b;
};
h2d_col_IPolygon.union = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygon(this1,hxd_clipper_PolyType.Clip);
	c.addPolygon(p,hxd_clipper_PolyType.Clip);
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygon.intersection = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygon.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles);
};
h2d_col_IPolygon.subtraction = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygon.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles);
};
h2d_col_IPolygon.offset = function(this1,delta,kind,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	var c = new hxd_clipper_ClipperOffset();
	switch(kind._hx_index) {
	case 0:
		c.addPolygon(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol);
		break;
	case 1:
		c.addPolygon(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol);
		break;
	case 2:
		var arc = kind.arc;
		c.ArcTolerance = arc;
		c.addPolygon(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol);
		break;
	}
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	return c.execute(delta);
};
h2d_col_IPolygon.clipperOp = function(this1,p,op,withHoles) {
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygon(this1,hxd_clipper_PolyType.Subject);
	c.addPolygon(p,hxd_clipper_PolyType.Clip);
	return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygon.convexHull = function(this1) {
	var len = this1.length;
	if(len < 3) {
		throw haxe_Exception.thrown("convexHull() needs at least 3 points");
	}
	var first = 0;
	var firstX = this1[first].x;
	var _g = 1;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		var px = this1[i].x;
		if(px < firstX) {
			first = i;
			firstX = px;
		}
	}
	var hull = [];
	var curr = first;
	var next = 0;
	do {
		hull.push(this1[curr]);
		next = (curr + 1) % len;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			var p1 = this1[i];
			var p2 = this1[curr];
			var t = this1[next];
			if((p2.x - p1.x) * (t.y - p1.y) - (p2.y - p1.y) * (t.x - p1.x) < 0) {
				next = i;
			}
		}
		curr = next;
	} while(curr != first);
	return hull;
};
h2d_col_IPolygon.isClockwise = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += (p2.x - p1.x) * (p2.y + p1.y);
		p1 = p2;
	}
	return sum < 0;
};
h2d_col_IPolygon.area = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += p1.x * p2.y - p2.x * p1.y;
		p1 = p2;
	}
	return (sum < 0 ? -sum : sum) * 0.5;
};
h2d_col_IPolygon.side = function(this1,p1,p2,t) {
	return (p2.x - p1.x) * (t.y - p1.y) - (p2.y - p1.y) * (t.x - p1.x);
};
h2d_col_IPolygon.isConvex = function(this1) {
	var p1 = this1[this1.length - 2];
	var p2 = this1[this1.length - 1];
	var p3 = this1[0];
	var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
	var _g = 1;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		p1 = p2;
		p2 = p3;
		p3 = this1[i];
		if((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0 != s) {
			return false;
		}
	}
	return true;
};
h2d_col_IPolygon.reverse = function(this1) {
	this1.reverse();
};
h2d_col_IPolygon.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	if(isConvex) {
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if((p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) < 0) {
				return false;
			}
			p1 = p2;
		}
		return true;
	} else {
		var w = 0;
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if(p2.y <= p.y) {
				if(p1.y > p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) > 0) {
					++w;
				}
			} else if(p1.y <= p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) < 0) {
				--w;
			}
			p1 = p2;
		}
		return w != 0;
	}
};
h2d_col_IPolygon.optimize = function(this1,epsilon) {
	var out = [];
	h2d_col_IPolygon.optimizeRec(this1,0,this1.length,out,epsilon);
	return out;
};
h2d_col_IPolygon.optimizeRec = function(points,index,len,out,epsilon) {
	var dmax = 0.;
	var pfirst = points[index];
	var plast = points[len - 1];
	var _g = index + 1;
	var _g1 = len - 1;
	while(_g < _g1) {
		var i = _g++;
		var p0 = points[i];
		var A = p0.x - pfirst.x;
		var B = p0.y - pfirst.y;
		var C = plast.x - pfirst.x;
		var D = plast.y - pfirst.y;
		var dot = A * C + B * D;
		var dist = C * C + D * D;
		var param = -1.;
		if(dist != 0) {
			param = dot / dist;
		}
		var xx;
		var yy;
		if(param < 0) {
			xx = pfirst.x;
			yy = pfirst.y;
		} else if(param > 1) {
			xx = plast.x;
			yy = plast.y;
		} else {
			xx = pfirst.x + param * C;
			yy = pfirst.y + param * D;
		}
		var dx = p0.x - xx;
		var dy = p0.y - yy;
		var d = dx * dx + dy * dy;
		if(d > dmax) {
			index = i;
			dmax = d;
		}
	}
	if(dmax >= epsilon) {
		h2d_col_IPolygon.optimizeRec(points,0,index,out,epsilon);
		out.pop();
		h2d_col_IPolygon.optimizeRec(points,index,len,out,epsilon);
	} else {
		out.push(points[index]);
		out.push(points[len - 1]);
	}
};
var h2d_col_IPolygons = {};
h2d_col_IPolygons.get_length = function(this1) {
	return this1.length;
};
h2d_col_IPolygons.get_polygons = function(this1) {
	return this1;
};
h2d_col_IPolygons._new = function(polygons) {
	return polygons == null ? [] : polygons;
};
h2d_col_IPolygons.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$IPolygon(this1);
};
h2d_col_IPolygons.toPolygons = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_IPolygon.toPolygon(p,scale));
	}
	return _g;
};
h2d_col_IPolygons.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_IBounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		h2d_col_IPolygon.getBounds(p,b);
	}
	return b;
};
h2d_col_IPolygons.union = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygons(this1,hxd_clipper_PolyType.Clip);
	if(p != null) {
		c.addPolygons(p,hxd_clipper_PolyType.Clip);
	}
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygons.intersection = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygons.clipperOp(this1,p,hxd_clipper_ClipType.Intersection,withHoles);
};
h2d_col_IPolygons.subtraction = function(this1,p,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	return h2d_col_IPolygons.clipperOp(this1,p,hxd_clipper_ClipType.Difference,withHoles);
};
h2d_col_IPolygons.offset = function(this1,delta,kind,withHoles) {
	if(withHoles == null) {
		withHoles = true;
	}
	if(this1.length == 0) {
		var polygons = null;
		return polygons == null ? [] : polygons;
	}
	var c = new hxd_clipper_ClipperOffset();
	switch(kind._hx_index) {
	case 0:
		c.addPolygons(this1,hxd_clipper_JoinType.Square,hxd_clipper_EndType.ClosedPol);
		break;
	case 1:
		c.addPolygons(this1,hxd_clipper_JoinType.Miter,hxd_clipper_EndType.ClosedPol);
		break;
	case 2:
		var arc = kind.arc;
		c.ArcTolerance = arc;
		c.addPolygons(this1,hxd_clipper_JoinType.Round,hxd_clipper_EndType.ClosedPol);
		break;
	}
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	return c.execute(delta);
};
h2d_col_IPolygons.clipperOp = function(this1,p,op,withHoles) {
	var c = new hxd_clipper_Clipper();
	if(!withHoles) {
		c.resultKind = hxd_clipper_ResultKind.NoHoles;
	}
	c.addPolygons(this1,hxd_clipper_PolyType.Subject);
	c.addPolygons(p,hxd_clipper_PolyType.Clip);
	return c.execute(op,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
h2d_col_IPolygons.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var pl = _g1[_g];
		++_g;
		if(h2d_col_IPolygon.contains(pl,p,isConvex)) {
			return true;
		}
	}
	return false;
};
h2d_col_IPolygons.optimize = function(this1,epsilon) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_IPolygon.optimize(p,epsilon));
	}
	return _g;
};
var h2d_col_Matrix = function() {
	this.a = 1;
	this.b = 0;
	this.c = 0;
	this.d = 1;
	this.x = 0;
	this.y = 0;
};
$hxClasses["h2d.col.Matrix"] = h2d_col_Matrix;
h2d_col_Matrix.__name__ = "h2d.col.Matrix";
h2d_col_Matrix.prototype = {
	identity: function() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.x = 0;
		this.y = 0;
	}
	,initTranslate: function(x,y) {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.x = x;
		this.y = y;
	}
	,initScale: function(sx,sy) {
		this.a = sx;
		this.b = 0;
		this.c = 0;
		this.d = sy;
		this.x = 0;
		this.y = 0;
	}
	,initRotate: function(angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		this.a = cos;
		this.b = sin;
		this.c = -sin;
		this.d = cos;
		this.x = 0;
		this.y = 0;
	}
	,initSkew: function(sx,sy) {
		var tanX = Math.tan(sx);
		var tanY = Math.tan(sy);
		this.a = 1;
		this.b = tanY;
		this.c = tanX;
		this.d = 1;
		this.x = 0;
		this.y = 0;
	}
	,invert: function() {
		this.inverse(this);
	}
	,getDeterminant: function() {
		return this.a * this.d - this.b * this.c;
	}
	,inverse: function(m) {
		var a = m.a;
		var b = m.b;
		var c = m.c;
		var d = m.d;
		var x = m.x;
		var y = m.y;
		var invDet = 1 / (this.a * this.d - this.b * this.c);
		this.a = d * invDet;
		this.b = -b * invDet;
		this.c = -c * invDet;
		this.d = a * invDet;
		this.x = (-x * d + c * y) * invDet;
		this.y = (x * b - a * y) * invDet;
	}
	,transform: function(pt) {
		var x = pt.x * this.a + pt.y * this.c + this.x;
		var y = pt.x * this.b + pt.y * this.d + this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,translate: function(x,y) {
		this.x += x;
		this.y += y;
	}
	,translateX: function(x) {
		this.x += x;
	}
	,translateY: function(y) {
		this.y += y;
	}
	,prependTranslate: function(x,y) {
		this.x += this.a * x + this.c * y;
		this.y += this.b * x + this.d * y;
	}
	,prependTranslateX: function(x) {
		this.x += this.a * x;
	}
	,prependTranslateY: function(y) {
		this.y += this.d * y;
	}
	,multiply: function(a,b) {
		var aa = a.a;
		var ab = a.b;
		var ac = a.c;
		var ad = a.d;
		var ax = a.x;
		var ay = a.y;
		var ba = b.a;
		var bb = b.b;
		var bc = b.c;
		var bd = b.d;
		var bx = b.x;
		var by = b.y;
		this.a = aa * ba + ab * bc;
		this.b = aa * bb + ab * bd;
		this.c = ac * ba + ad * bc;
		this.d = ac * bb + ad * bd;
		this.x = ax * ba + ay * bc + bx;
		this.y = ax * bb + ay * bd + by;
	}
	,getScale: function() {
		var p = new h2d_col_PointImpl(0.,0.);
		p.x = Math.sqrt(this.a * this.a + this.b * this.b);
		p.y = Math.sqrt(this.c * this.c + this.d * this.d);
		if(this.a * this.d - this.b * this.c < 0) {
			p.x *= -1;
			p.y *= -1;
		}
		return p;
	}
	,scale: function(sx,sy) {
		this.a *= sx;
		this.c *= sx;
		this.x *= sx;
		this.b *= sy;
		this.d *= sy;
		this.y *= sy;
	}
	,scaleX: function(sx) {
		this.a *= sx;
		this.c *= sx;
		this.x *= sx;
	}
	,scaleY: function(sy) {
		this.b *= sy;
		this.d *= sy;
		this.y *= sy;
	}
	,rotate: function(angle) {
		var _this = h2d_col_Matrix.tmp;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		_this.a = cos;
		_this.b = sin;
		_this.c = -sin;
		_this.d = cos;
		_this.x = 0;
		_this.y = 0;
		this.multiply(this,h2d_col_Matrix.tmp);
	}
	,skew: function(sx,sy) {
		var aa = this.a;
		var ab = this.b;
		var ac = this.c;
		var ad = this.d;
		var ax = this.x;
		var ay = this.y;
		var bb = Math.tan(sy);
		var bc = Math.tan(sx);
		this.a = aa + ab * bc;
		this.b = aa * bb + ab;
		this.c = ac + ad * bc;
		this.d = ac * bb + ad;
		this.x = ax + ay * bc;
		this.y = ax * bb + ay;
	}
	,skewX: function(sx) {
		var bc = Math.tan(sx);
		this.a += this.b * bc;
		this.c += this.d * bc;
		this.x += this.y * bc;
	}
	,skewY: function(sy) {
		var bb = Math.tan(sy);
		this.b = this.a * bb + this.b;
		this.d = this.c * bb + this.d;
		this.y = this.x * bb + this.y;
	}
	,clone: function() {
		var m = new h2d_col_Matrix();
		m.a = this.a;
		m.b = this.b;
		m.c = this.c;
		m.d = this.d;
		m.x = this.x;
		m.y = this.y;
		return m;
	}
	,getPosition: function(p) {
		if(p == null) {
			p = new h2d_col_PointImpl(0.,0.);
		}
		var _this = p;
		var x = this.x;
		var y = this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		return p;
	}
	,toString: function() {
		return "MAT=[\n" + "  [ " + hxd_Math.fmt(this.a) + ", " + hxd_Math.fmt(this.b) + " ]\n" + "  [ " + hxd_Math.fmt(this.c) + ", " + hxd_Math.fmt(this.d) + " ]\n" + "  [ " + hxd_Math.fmt(this.x) + ", " + hxd_Math.fmt(this.y) + " ]\n" + "]";
	}
	,__class__: h2d_col_Matrix
};
var h2d_col_Point = {};
h2d_col_Point._new = function(x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.sub = function(this1,p) {
	var x = this1.x - p.x;
	var y = this1.y - p.y;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.add = function(this1,p) {
	var x = this1.x + p.x;
	var y = this1.y + p.y;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.transform = function(this1,m) {
	var mx = m.a * this1.x + m.c * this1.y + m.x;
	var my = m.b * this1.x + m.d * this1.y + m.y;
	this1.x = mx;
	this1.y = my;
};
h2d_col_Point.transformed = function(this1,m) {
	var mx = m.a * this1.x + m.c * this1.y + m.x;
	var my = m.b * this1.x + m.d * this1.y + m.y;
	var x = mx;
	var y = my;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.scale = function(this1,v) {
	this1.x *= v;
	this1.y *= v;
};
h2d_col_Point.scaled = function(this1,v) {
	var x = this1.x * v;
	var y = this1.y * v;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Point.scaledInv = function(f,p) {
	var x = p.x * f;
	var y = p.y * f;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
var h2d_col_Polygon = {};
h2d_col_Polygon.get_length = function(this1) {
	return this1.length;
};
h2d_col_Polygon.get_points = function(this1) {
	return this1;
};
h2d_col_Polygon._new = function(points) {
	return points == null ? [] : points;
};
h2d_col_Polygon.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$Point(this1);
};
h2d_col_Polygon.fastTriangulate = function(this1) {
	return new hxd_earcut_Earcut().triangulate_anon_y_Float_x_Float(this1);
};
h2d_col_Polygon.toSegments = function(this1) {
	var segments = [];
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		var s = new h2d_col_Segment(p1,p2);
		segments.push(s);
		p1 = p2;
	}
	return segments;
};
h2d_col_Polygon.toIPolygon = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		var _this = p;
		var scale1 = scale;
		if(scale1 == null) {
			scale1 = 1.;
		}
		_g.push(new h2d_col_IPoint(Math.round(_this.x * scale1),Math.round(_this.y * scale1)));
	}
	return _g;
};
h2d_col_Polygon.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_Bounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p.x < b.xMin) {
			b.xMin = p.x;
		}
		if(p.x > b.xMax) {
			b.xMax = p.x;
		}
		if(p.y < b.yMin) {
			b.yMin = p.y;
		}
		if(p.y > b.yMax) {
			b.yMax = p.y;
		}
	}
	return b;
};
h2d_col_Polygon.getCollider = function(this1,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	return new h2d_col_PolygonCollider([this1],isConvex);
};
h2d_col_Polygon.xSort = function(this1,a,b) {
	if(a.x == b.x) {
		if(a.y < b.y) {
			return -1;
		} else {
			return 1;
		}
	}
	if(a.x < b.x) {
		return -1;
	} else {
		return 1;
	}
};
h2d_col_Polygon.convexHull = function(this1) {
	var len = this1.length;
	if(this1.length < 3) {
		return this1;
	}
	this1.sort(function(a,b) {
		if(a.x == b.x) {
			if(a.y < b.y) {
				return -1;
			} else {
				return 1;
			}
		} else if(a.x < b.x) {
			return -1;
		} else {
			return 1;
		}
	});
	var hull = [];
	var k = 0;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		while(true) {
			var tmp;
			if(k >= 2) {
				var p1 = hull[k - 2];
				var p2 = hull[k - 1];
				tmp = (p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) <= 0;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			--k;
		}
		hull[k++] = p;
	}
	var i = this1.length - 2;
	var len = k + 1;
	while(i >= 0) {
		var p = this1[i];
		while(true) {
			var tmp;
			if(k >= len) {
				var p1 = hull[k - 2];
				var p2 = hull[k - 1];
				tmp = (p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) <= 0;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			--k;
		}
		hull[k++] = p;
		--i;
	}
	while(hull.length >= k) hull.pop();
	return hull;
};
h2d_col_Polygon.isClockwise = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += (p2.x - p1.x) * (p2.y + p1.y);
		p1 = p2;
	}
	return sum < 0;
};
h2d_col_Polygon.area = function(this1) {
	var sum = 0.;
	var p1 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		sum += p2.x * p1.y - p1.x * p2.y;
		p1 = p2;
	}
	return (sum < 0 ? -sum : sum) * 0.5;
};
h2d_col_Polygon.centroid = function(this1) {
	var A = 0.;
	var cx = 0.;
	var cy = 0.;
	var p0 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		var a = p0.x * p.y - p.x * p0.y;
		cx += (p0.x + p.x) * a;
		cy += (p0.y + p.y) * a;
		A += a;
		p0 = p;
	}
	A *= 0.5;
	cx *= 1 / (6 * A);
	cy *= 1 / (6 * A);
	var x = cx;
	var y = cy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h2d_col_PointImpl(x,y);
};
h2d_col_Polygon.side = function(this1,p1,p2,t) {
	return (p2.x - p1.x) * (t.y - p1.y) - (p2.y - p1.y) * (t.x - p1.x);
};
h2d_col_Polygon.isConvex = function(this1) {
	if(this1.length < 4) {
		return true;
	}
	var p1 = this1[this1.length - 2];
	var p2 = this1[this1.length - 1];
	var p3 = this1[0];
	var s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
	var _g = 1;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		p1 = p2;
		p2 = p3;
		p3 = this1[i];
		if((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0 != s) {
			return false;
		}
	}
	return true;
};
h2d_col_Polygon.reverse = function(this1) {
	this1.reverse();
};
h2d_col_Polygon.transform = function(this1,mat) {
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var i = _g++;
		var pt = this1[i];
		var x = pt.x * mat.a + pt.y * mat.c + mat.x;
		var y = pt.x * mat.b + pt.y * mat.d + mat.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this1[i] = new h2d_col_PointImpl(x,y);
	}
};
h2d_col_Polygon.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	if(isConvex) {
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if((p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x) < 0) {
				return false;
			}
			p1 = p2;
		}
		return true;
	} else {
		var w = 0;
		var p1 = this1[this1.length - 1];
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var p2 = _g1[_g];
			++_g;
			if(p2.y <= p.y) {
				if(p1.y > p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) > 0) {
					++w;
				}
			} else if(p1.y <= p.y && (p1.x - p2.x) * (p.y - p2.y) - (p1.y - p2.y) * (p.x - p2.x) < 0) {
				--w;
			}
			p1 = p2;
		}
		return w != 0;
	}
};
h2d_col_Polygon.findClosestPoint = function(this1,pt,maxDist) {
	var closest = null;
	var minDist = maxDist * maxDist;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var cp = _g1[_g];
		++_g;
		var _this = cp;
		var dx = _this.x - pt.x;
		var dy = _this.y - pt.y;
		var sqDist = dx * dx + dy * dy;
		if(sqDist < minDist) {
			closest = cp;
			minDist = sqDist;
		}
	}
	return closest;
};
h2d_col_Polygon.projectPoint = function(this1,pt) {
	var p1 = this1[this1.length - 1];
	var closestProj = null;
	var minDistSq = 1e10;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		var p11 = p1;
		var p21 = p2;
		var _this_x = p11.x;
		var _this_y = p11.y;
		var _this_dx = p21.x - _this_x;
		var _this_dy = p21.y - _this_y;
		var _this_lenSq = _this_dx * _this_dx + _this_dy * _this_dy;
		var _this_invLenSq = 1 / _this_lenSq;
		var px = pt.x - _this_x;
		var py = pt.y - _this_y;
		var t = px * _this_dx + py * _this_dy;
		var proj;
		if(t < 0) {
			var x = _this_x;
			var y = _this_y;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			proj = new h2d_col_PointImpl(x,y);
		} else if(t > _this_lenSq) {
			var x1 = _this_x + _this_dx;
			var y1 = _this_y + _this_dy;
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			proj = new h2d_col_PointImpl(x1,y1);
		} else {
			var tl2 = t * _this_invLenSq;
			var x2 = _this_x + tl2 * _this_dx;
			var y2 = _this_y + tl2 * _this_dy;
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			proj = new h2d_col_PointImpl(x2,y2);
		}
		var _this = proj;
		var dx = _this.x - pt.x;
		var dy = _this.y - pt.y;
		var distSq = dx * dx + dy * dy;
		if(distSq < minDistSq) {
			closestProj = proj;
			minDistSq = distSq;
		}
		p1 = p2;
	}
	return closestProj;
};
h2d_col_Polygon.distance = function(this1,pt,outside) {
	return Math.sqrt(h2d_col_Polygon.distanceSq(this1,pt,outside));
};
h2d_col_Polygon.distanceSq = function(this1,pt,outside) {
	var p1 = this1[this1.length - 1];
	var minDistSq = 1e10;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p2 = _g1[_g];
		++_g;
		var p11 = p1;
		var p21 = p2;
		var s_x = p11.x;
		var s_y = p11.y;
		var s_dx = p21.x - s_x;
		var s_dy = p21.y - s_y;
		var s_lenSq = s_dx * s_dx + s_dy * s_dy;
		var s_invLenSq = 1 / s_lenSq;
		if(outside == null || s_dx * (pt.y - s_y) - s_dy * (pt.x - s_x) < 0 == outside) {
			var px = pt.x - s_x;
			var py = pt.y - s_y;
			var t = px * s_dx + py * s_dy;
			var dist;
			if(t < 0) {
				dist = px * px + py * py;
			} else if(t > s_lenSq) {
				var kx = pt.x - (s_x + s_dx);
				var ky = pt.y - (s_y + s_dy);
				dist = kx * kx + ky * ky;
			} else {
				var tl2 = t * s_invLenSq;
				var pdx = s_x + tl2 * s_dx - pt.x;
				var pdy = s_y + tl2 * s_dy - pt.y;
				dist = pdx * pdx + pdy * pdy;
			}
			if(dist < minDistSq) {
				minDistSq = dist;
			}
		}
		p1 = p2;
	}
	if(minDistSq == 1e10) {
		return 0.;
	} else {
		return minDistSq;
	}
};
h2d_col_Polygon.rayIntersection = function(this1,r,bestMatch,oriented) {
	if(oriented == null) {
		oriented = false;
	}
	var dmin = -1.;
	var p0 = this1[this1.length - 1];
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if((r.lx * (p0.y - r.py) - r.ly * (p0.x - r.px)) * (r.lx * (p.y - r.py) - r.ly * (p.x - r.px)) > 0) {
			p0 = p;
			continue;
		}
		var u = (r.lx * (p0.y - r.py) - r.ly * (p0.x - r.px)) / (r.ly * (p.x - p0.x) - r.lx * (p.y - p0.y));
		var x = p0.x + u * (p.x - p0.x);
		var y = p0.y + u * (p.y - p0.y);
		var x1 = x - r.px;
		var y1 = y - r.py;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var x2 = x1;
		var y2 = y1;
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		var v_x = x2;
		var v_y = y2;
		var tmp;
		if(!(!oriented)) {
			var x3 = r.lx;
			var y3 = r.ly;
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var x4 = x3;
			var y4 = y3;
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var _this_x = x4;
			var _this_y = y4;
			tmp = _this_x * v_x + _this_y * v_y > 0;
		} else {
			tmp = true;
		}
		if(tmp) {
			var dx = v_x;
			var dy = v_y;
			var d = dx * dx + dy * dy;
			if(d < dmin || dmin < 0) {
				if(!bestMatch) {
					return Math.sqrt(d);
				}
				dmin = d;
			}
		}
		p0 = p;
	}
	if(dmin < 0) {
		return dmin;
	} else {
		return Math.sqrt(dmin);
	}
};
h2d_col_Polygon.orientation = function(this1,p,q,r) {
	var v = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
	if(v == 0) {
		return 0;
	}
	if(v > 0) {
		return 1;
	} else {
		return -1;
	}
};
h2d_col_Polygon.onSegment = function(this1,p,q,r) {
	var a = p.x;
	var b = q.x;
	if(r.x > (a < b ? b : a)) {
		return false;
	}
	var a = p.x;
	var b = q.x;
	if(r.x < (a > b ? b : a)) {
		return false;
	}
	var a = p.y;
	var b = q.y;
	if(r.y > (a < b ? b : a)) {
		return false;
	}
	var a = p.y;
	var b = q.y;
	if(r.y < (a > b ? b : a)) {
		return false;
	}
	return true;
};
h2d_col_Polygon.intersect = function(this1,p1,q1,p2,q2) {
	var v = (q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x);
	var s1 = v == 0 ? 0 : v > 0 ? 1 : -1;
	var v = (q1.x - p1.x) * (q2.y - p1.y) - (q1.y - p1.y) * (q2.x - p1.x);
	var s2 = v == 0 ? 0 : v > 0 ? 1 : -1;
	var v = (q2.x - p2.x) * (p1.y - p2.y) - (q2.y - p2.y) * (p1.x - p2.x);
	var s3 = v == 0 ? 0 : v > 0 ? 1 : -1;
	var v = (q2.x - p2.x) * (q1.y - p2.y) - (q2.y - p2.y) * (q1.x - p2.x);
	var s4 = v == 0 ? 0 : v > 0 ? 1 : -1;
	if(s1 != s2 && s3 != s4) {
		return true;
	}
	var tmp;
	var tmp1;
	var tmp2;
	var tmp3;
	if(s1 == 0) {
		var a = p1.x;
		var b = q1.x;
		if(p2.x > (a < b ? b : a)) {
			tmp3 = false;
		} else {
			var a = p1.x;
			var b = q1.x;
			if(p2.x < (a > b ? b : a)) {
				tmp3 = false;
			} else {
				var a = p1.y;
				var b = q1.y;
				if(p2.y > (a < b ? b : a)) {
					tmp3 = false;
				} else {
					var a = p1.y;
					var b = q1.y;
					tmp3 = p2.y < (a > b ? b : a) ? false : true;
				}
			}
		}
	} else {
		tmp3 = false;
	}
	if(!tmp3) {
		if(s2 == 0) {
			var a = p1.x;
			var b = q1.x;
			if(q2.x > (a < b ? b : a)) {
				tmp2 = false;
			} else {
				var a = p1.x;
				var b = q1.x;
				if(q2.x < (a > b ? b : a)) {
					tmp2 = false;
				} else {
					var a = p1.y;
					var b = q1.y;
					if(q2.y > (a < b ? b : a)) {
						tmp2 = false;
					} else {
						var a = p1.y;
						var b = q1.y;
						tmp2 = q2.y < (a > b ? b : a) ? false : true;
					}
				}
			}
		} else {
			tmp2 = false;
		}
	} else {
		tmp2 = true;
	}
	if(!tmp2) {
		if(s3 == 0) {
			var a = p2.x;
			var b = q2.x;
			if(p1.x > (a < b ? b : a)) {
				tmp1 = false;
			} else {
				var a = p2.x;
				var b = q2.x;
				if(p1.x < (a > b ? b : a)) {
					tmp1 = false;
				} else {
					var a = p2.y;
					var b = q2.y;
					if(p1.y > (a < b ? b : a)) {
						tmp1 = false;
					} else {
						var a = p2.y;
						var b = q2.y;
						tmp1 = p1.y < (a > b ? b : a) ? false : true;
					}
				}
			}
		} else {
			tmp1 = false;
		}
	} else {
		tmp1 = true;
	}
	if(!tmp1) {
		if(s4 == 0) {
			var a = p2.x;
			var b = q2.x;
			if(q1.x > (a < b ? b : a)) {
				tmp = false;
			} else {
				var a = p2.x;
				var b = q2.x;
				if(q1.x < (a > b ? b : a)) {
					tmp = false;
				} else {
					var a = p2.y;
					var b = q2.y;
					if(q1.y > (a < b ? b : a)) {
						tmp = false;
					} else {
						var a = p2.y;
						var b = q2.y;
						tmp = q1.y < (a > b ? b : a) ? false : true;
					}
				}
			}
		} else {
			tmp = false;
		}
	} else {
		tmp = true;
	}
	if(tmp) {
		return true;
	}
	return false;
};
h2d_col_Polygon.selfIntersecting = function(this1) {
	if(this1.length < 4) {
		return false;
	}
	var _g = 0;
	var _g1 = this1.length - 2;
	while(_g < _g1) {
		var i = _g++;
		var p1 = this1[i];
		var q1 = this1[i + 1];
		var _g2 = i + 2;
		var _g3 = this1.length;
		while(_g2 < _g3) {
			var j = _g2++;
			var p2 = this1[j];
			var q2 = this1[(j + 1) % this1.length];
			if(q2 != p1 && h2d_col_Polygon.intersect(this1,p1,q1,p2,q2)) {
				return true;
			}
		}
	}
	return false;
};
h2d_col_Polygon.optimize = function(this1,epsilon) {
	var out = [];
	h2d_col_Polygon.optimizeRec(this1,0,this1.length - 1,out,epsilon);
	return out;
};
h2d_col_Polygon.optimizeRec = function(points,start,end,out,epsilon) {
	var dmax = 0.;
	var pfirst = points[start];
	var plast = points[end];
	var index = 0;
	var _g = start + 1;
	var _g1 = end;
	while(_g < _g1) {
		var i = _g++;
		var p0 = points[i];
		var A = p0.x - pfirst.x;
		var B = p0.y - pfirst.y;
		var C = plast.x - pfirst.x;
		var D = plast.y - pfirst.y;
		var dot = A * C + B * D;
		var dist = C * C + D * D;
		var param = -1.;
		if(dist != 0) {
			param = dot / dist;
		}
		var xx;
		var yy;
		if(param < 0) {
			xx = pfirst.x;
			yy = pfirst.y;
		} else if(param > 1) {
			xx = plast.x;
			yy = plast.y;
		} else {
			xx = pfirst.x + param * C;
			yy = pfirst.y + param * D;
		}
		var dx = p0.x - xx;
		var dy = p0.y - yy;
		var d = dx * dx + dy * dy;
		if(d > dmax) {
			index = i;
			dmax = d;
		}
	}
	if(dmax >= epsilon * epsilon) {
		h2d_col_Polygon.optimizeRec(points,start,index,out,epsilon);
		out.pop();
		h2d_col_Polygon.optimizeRec(points,index,end,out,epsilon);
	} else {
		out.push(points[start]);
		out.push(points[end]);
	}
};
h2d_col_Polygon.makeCircle = function(x,y,radius,npoints) {
	if(npoints == null) {
		npoints = 0;
	}
	if(npoints == 0) {
		var f = radius * 3.14 * 2 / 4;
		npoints = Math.ceil(f < 0 ? -f : f);
	}
	if(npoints < 3) {
		npoints = 3;
	}
	var angle = 6.28318530717958623 / npoints;
	var points = [];
	var _g = 0;
	var _g1 = npoints;
	while(_g < _g1) {
		var i = _g++;
		var a = i * angle;
		var x1 = Math.cos(a) * radius + x;
		var y1 = Math.sin(a) * radius + y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		points.push(new h2d_col_PointImpl(x1,y1));
	}
	return points == null ? [] : points;
};
var h2d_col_PolygonCollider = function(polygons,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	this.polygons = polygons;
	this.isConvex = isConvex;
};
$hxClasses["h2d.col.PolygonCollider"] = h2d_col_PolygonCollider;
h2d_col_PolygonCollider.__name__ = "h2d.col.PolygonCollider";
h2d_col_PolygonCollider.__super__ = h2d_col_Collider;
h2d_col_PolygonCollider.prototype = $extend(h2d_col_Collider.prototype,{
	contains: function(p) {
		if(this.polygons == null) {
			return false;
		}
		return h2d_col_Polygons.contains(this.polygons,p,this.isConvex);
	}
	,collideCircle: function(c) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,collideBounds: function(b) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: h2d_col_PolygonCollider
});
var h2d_col_Polygons = {};
h2d_col_Polygons.get_length = function(this1) {
	return this1.length;
};
h2d_col_Polygons.get_polygons = function(this1) {
	return this1;
};
h2d_col_Polygons._new = function(polygons) {
	return polygons == null ? [] : polygons;
};
h2d_col_Polygons.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$Polygon(this1);
};
h2d_col_Polygons.toIPolygons = function(this1,scale) {
	if(scale == null) {
		scale = 1.;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_Polygon.toIPolygon(p,scale));
	}
	return _g;
};
h2d_col_Polygons.getBounds = function(this1,b) {
	if(b == null) {
		b = new h2d_col_Bounds();
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		h2d_col_Polygon.getBounds(p,b);
	}
	return b;
};
h2d_col_Polygons.getCollider = function(this1,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	return new h2d_col_PolygonCollider(this1,isConvex);
};
h2d_col_Polygons.contains = function(this1,p,isConvex) {
	if(isConvex == null) {
		isConvex = false;
	}
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var pl = _g1[_g];
		++_g;
		if(h2d_col_Polygon.contains(pl,p,isConvex)) {
			return true;
		}
	}
	return false;
};
h2d_col_Polygons.optimize = function(this1,epsilon) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var p = _g2[_g1];
		++_g1;
		_g.push(h2d_col_Polygon.optimize(p,epsilon));
	}
	return _g;
};
var h2d_col_Ray = function() {
};
$hxClasses["h2d.col.Ray"] = h2d_col_Ray;
h2d_col_Ray.__name__ = "h2d.col.Ray";
h2d_col_Ray.fromPoints = function(p1,p2) {
	var r = new h2d_col_Ray();
	r.px = p1.x;
	r.py = p1.y;
	r.lx = p2.x - p1.x;
	r.ly = p2.y - p1.y;
	r.normalize();
	return r;
};
h2d_col_Ray.fromValues = function(x,y,dx,dy) {
	var r = new h2d_col_Ray();
	r.px = x;
	r.py = y;
	r.lx = dx;
	r.ly = dy;
	r.normalize();
	return r;
};
h2d_col_Ray.prototype = {
	side: function(p) {
		return this.lx * (p.y - this.py) - this.ly * (p.x - this.px);
	}
	,getPoint: function(distance) {
		var x = this.px + distance * this.lx;
		var y = this.py + distance * this.ly;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getPos: function() {
		var x = this.px;
		var y = this.py;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,getDir: function() {
		var x = this.lx;
		var y = this.ly;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,normalize: function() {
		var l = this.lx * this.lx + this.ly * this.ly;
		if(l == 1.) {
			return;
		}
		if(l < 1e-20) {
			l = 0;
		} else {
			l = 1. / Math.sqrt(l);
		}
		this.lx *= l;
		this.ly *= l;
	}
	,__class__: h2d_col_Ray
};
var h2d_col_Segment = function(p1,p2) {
	this.x = p1.x;
	this.y = p1.y;
	this.dx = p2.x - this.x;
	this.dy = p2.y - this.y;
	this.lenSq = this.dx * this.dx + this.dy * this.dy;
	this.invLenSq = 1 / this.lenSq;
};
$hxClasses["h2d.col.Segment"] = h2d_col_Segment;
h2d_col_Segment.__name__ = "h2d.col.Segment";
h2d_col_Segment.prototype = {
	setPoints: function(p1,p2) {
		this.x = p1.x;
		this.y = p1.y;
		this.dx = p2.x - this.x;
		this.dy = p2.y - this.y;
		this.lenSq = this.dx * this.dx + this.dy * this.dy;
		this.invLenSq = 1 / this.lenSq;
	}
	,side: function(p) {
		return this.dx * (p.y - this.y) - this.dy * (p.x - this.x);
	}
	,distanceSq: function(p) {
		var px = p.x - this.x;
		var py = p.y - this.y;
		var t = px * this.dx + py * this.dy;
		if(t < 0) {
			return px * px + py * py;
		} else if(t > this.lenSq) {
			var kx = p.x - (this.x + this.dx);
			var ky = p.y - (this.y + this.dy);
			return kx * kx + ky * ky;
		} else {
			var tl2 = t * this.invLenSq;
			var pdx = this.x + tl2 * this.dx - p.x;
			var pdy = this.y + tl2 * this.dy - p.y;
			return pdx * pdx + pdy * pdy;
		}
	}
	,distance: function(p) {
		var px = p.x - this.x;
		var py = p.y - this.y;
		var t = px * this.dx + py * this.dy;
		var f;
		if(t < 0) {
			f = px * px + py * py;
		} else if(t > this.lenSq) {
			var kx = p.x - (this.x + this.dx);
			var ky = p.y - (this.y + this.dy);
			f = kx * kx + ky * ky;
		} else {
			var tl2 = t * this.invLenSq;
			var pdx = this.x + tl2 * this.dx - p.x;
			var pdy = this.y + tl2 * this.dy - p.y;
			f = pdx * pdx + pdy * pdy;
		}
		return Math.sqrt(f);
	}
	,project: function(p) {
		var px = p.x - this.x;
		var py = p.y - this.y;
		var t = px * this.dx + py * this.dy;
		if(t < 0) {
			var x = this.x;
			var y = this.y;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h2d_col_PointImpl(x,y);
		} else if(t > this.lenSq) {
			var x = this.x + this.dx;
			var y = this.y + this.dy;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h2d_col_PointImpl(x,y);
		} else {
			var tl2 = t * this.invLenSq;
			var x = this.x + tl2 * this.dx;
			var y = this.y + tl2 * this.dy;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h2d_col_PointImpl(x,y);
		}
	}
	,lineIntersection: function(r,pt) {
		var x = this.x;
		var y = this.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var x = this.x + this.dx;
		var y = this.y + this.dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x1 = x1;
		var p_y1 = y1;
		if((r.lx * (p_y - r.py) - r.ly * (p_x - r.px)) * (r.lx * (p_y1 - r.py) - r.ly * (p_x1 - r.px)) > 0) {
			return null;
		}
		var u = (r.lx * (this.y - r.py) - r.ly * (this.x - r.px)) / (r.ly * this.dx - r.lx * this.dy);
		if(u < 0 || u > 1) {
			return null;
		}
		if(pt == null) {
			pt = new h2d_col_PointImpl(0.,0.);
		}
		pt.x = this.x + u * this.dx;
		pt.y = this.y + u * this.dy;
		return pt;
	}
	,__class__: h2d_col_Segment
};
var h2d_col_Segments = {};
h2d_col_Segments.get_segments = function(this1) {
	return this1;
};
h2d_col_Segments.get_length = function(this1) {
	return this1.length;
};
h2d_col_Segments.iterator = function(this1) {
	return new hxd_impl_ArrayIterator_$h2d_$col_$Segment(this1);
};
h2d_col_Segments.containsPoint = function(this1,p,isConvex) {
	if(isConvex) {
		var _g = 0;
		var _g1 = this1;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.dx * (p.y - s.y) - s.dy * (p.x - s.x) < 0) {
				return false;
			}
		}
	} else {
		throw haxe_Exception.thrown("TODO");
	}
	return true;
};
h2d_col_Segments.toPolygon = function(this1) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var s = _g2[_g1];
		++_g1;
		var x = s.x;
		var y = s.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_g.push(new h2d_col_PointImpl(x,y));
	}
	return _g;
};
h2d_col_Segments.project = function(this1,p) {
	var dmin = 1e20;
	var smin = null;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		var px = p.x - s.x;
		var py = p.y - s.y;
		var t = px * s.dx + py * s.dy;
		var d;
		if(t < 0) {
			d = px * px + py * py;
		} else if(t > s.lenSq) {
			var kx = p.x - (s.x + s.dx);
			var ky = p.y - (s.y + s.dy);
			d = kx * kx + ky * ky;
		} else {
			var tl2 = t * s.invLenSq;
			var pdx = s.x + tl2 * s.dx - p.x;
			var pdy = s.y + tl2 * s.dy - p.y;
			d = pdx * pdx + pdy * pdy;
		}
		if(d < dmin) {
			dmin = d;
			smin = s;
		}
	}
	var px = p.x - smin.x;
	var py = p.y - smin.y;
	var t = px * smin.dx + py * smin.dy;
	if(t < 0) {
		var x = smin.x;
		var y = smin.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	} else if(t > smin.lenSq) {
		var x = smin.x + smin.dx;
		var y = smin.y + smin.dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	} else {
		var tl2 = t * smin.invLenSq;
		var x = smin.x + tl2 * smin.dx;
		var y = smin.y + tl2 * smin.dy;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
};
h2d_col_Segments.distanceSq = function(this1,p) {
	var dmin = 1e20;
	var _g = 0;
	var _g1 = this1;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		var px = p.x - s.x;
		var py = p.y - s.y;
		var t = px * s.dx + py * s.dy;
		var d;
		if(t < 0) {
			d = px * px + py * py;
		} else if(t > s.lenSq) {
			var kx = p.x - (s.x + s.dx);
			var ky = p.y - (s.y + s.dy);
			d = kx * kx + ky * ky;
		} else {
			var tl2 = t * s.invLenSq;
			var pdx = s.x + tl2 * s.dx - p.x;
			var pdy = s.y + tl2 * s.dy - p.y;
			d = pdx * pdx + pdy * pdy;
		}
		if(d < dmin) {
			dmin = d;
		}
	}
	return dmin;
};
h2d_col_Segments.distance = function(this1,p) {
	return Math.sqrt(h2d_col_Segments.distanceSq(this1,p));
};
var h2d_filter_Filter = function() {
	this.useScreenResolution = h2d_filter_Filter.defaultUseScreenResolution;
	this.resolutionScale = 1;
	this.enable = true;
	this.smooth = false;
	this.boundsExtend = 0.;
	this.autoBounds = true;
};
$hxClasses["h2d.filter.Filter"] = h2d_filter_Filter;
h2d_filter_Filter.__name__ = "h2d.filter.Filter";
h2d_filter_Filter.prototype = {
	get_enable: function() {
		return this.enable;
	}
	,set_enable: function(v) {
		return this.enable = v;
	}
	,set_resolutionScale: function(v) {
		return this.resolutionScale = v;
	}
	,set_useScreenResolution: function(v) {
		return this.useScreenResolution = v;
	}
	,sync: function(ctx,s) {
	}
	,bind: function(s) {
	}
	,unbind: function(s) {
	}
	,getBounds: function(s,bounds,scale) {
		s.getBounds(s,bounds);
		bounds.xMin = bounds.xMin * scale.x - this.boundsExtend;
		bounds.xMax = bounds.xMax * scale.x + this.boundsExtend;
		bounds.yMin = bounds.yMin * scale.y - this.boundsExtend;
		bounds.yMax = bounds.yMax * scale.y + this.boundsExtend;
	}
	,draw: function(ctx,input) {
		return input;
	}
	,__class__: h2d_filter_Filter
};
var h2d_filter_Hide = function() {
	h2d_filter_Filter.call(this);
	this.boundsExtend = 1;
};
$hxClasses["h2d.filter.Hide"] = h2d_filter_Hide;
h2d_filter_Hide.__name__ = "h2d.filter.Hide";
h2d_filter_Hide.__super__ = h2d_filter_Filter;
h2d_filter_Hide.prototype = $extend(h2d_filter_Filter.prototype,{
	draw: function(ctx,input) {
		this.frame = ctx.frame;
		this.input = input;
		this.inputWidth = Math.ceil(input.width + input.x) - Math.floor(input.x);
		this.inputHeight = Math.ceil(input.height + input.y) - Math.floor(input.y);
		if(this.maskVisible) {
			return input;
		} else {
			return null;
		}
	}
	,__class__: h2d_filter_Hide
});
var h2d_filter_AbstractMask = function(mask) {
	this.bindCount = 0;
	h2d_filter_Filter.call(this);
	this.hide = new h2d_filter_Hide();
	this.set_mask(mask);
	this.maskMatrix = new h2d_col_Matrix();
	this.tmpMatrix = new h2d_col_Matrix();
};
$hxClasses["h2d.filter.AbstractMask"] = h2d_filter_AbstractMask;
h2d_filter_AbstractMask.__name__ = "h2d.filter.AbstractMask";
h2d_filter_AbstractMask.__super__ = h2d_filter_Filter;
h2d_filter_AbstractMask.prototype = $extend(h2d_filter_Filter.prototype,{
	set_maskVisible: function(b) {
		this.hide.maskVisible = b;
		return this.maskVisible = b;
	}
	,bind: function(s) {
		this.bindCount++;
		if(this.bindCount == 1) {
			this.set_mask(this.mask);
		}
	}
	,unbind: function(s) {
		this.bindCount--;
		if(this.bindCount == 0) {
			this.set_mask(this.mask);
		}
	}
	,set_mask: function(m) {
		if(this.mask != null) {
			if(this.mask.filter == this.hide) {
				this.mask.set_filter(null);
			}
		}
		this.mask = m;
		if(m != null && this.bindCount > 0) {
			if(m.filter != null) {
				if(((m.filter) instanceof h2d_filter_Hide)) {
					throw haxe_Exception.thrown("Same mask can't be part of several filters");
				}
				throw haxe_Exception.thrown("Can't set mask with filter " + Std.string(m.filter));
			}
			m.set_filter(this.hide);
		}
		this.hide.input = null;
		return m;
	}
	,getMaskTexture: function(ctx,tile) {
		var t = this.hide.input == null ? null : this.hide.input.innerTex;
		if(t == null) {
			return null;
		}
		this.mask.getMatrix(this.maskMatrix);
		var _this = this.maskMatrix;
		var x = this.hide.input.dx;
		var y = this.hide.input.dy;
		_this.x += _this.a * x + _this.c * y;
		_this.y += _this.b * x + _this.d * y;
		this.maskMatrix.invert();
		this.obj.getMatrix(this.tmpMatrix);
		var _this = this.tmpMatrix;
		var x = tile.dx;
		var y = tile.dy;
		_this.x += _this.a * x + _this.c * y;
		_this.y += _this.b * x + _this.d * y;
		this.maskMatrix.multiply(this.tmpMatrix,this.maskMatrix);
		var resolutionScale = ctx.getFilterScale(h2d_Object.tmpPoint);
		this.maskMatrix.x /= tile.width / resolutionScale.x;
		this.maskMatrix.y /= tile.height / resolutionScale.y;
		var _this = this.maskMatrix;
		var sx = tile.width / this.hide.inputWidth;
		var sy = tile.height / this.hide.inputHeight;
		_this.a *= sx;
		_this.c *= sx;
		_this.x *= sx;
		_this.b *= sy;
		_this.d *= sy;
		_this.y *= sy;
		t.set_filter(this.smooth ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		return t;
	}
	,sync: function(ctx,obj) {
		this.obj = obj;
		if(this.mask == null || this.hide.frame != ctx.frame) {
			var p = obj;
			while(p != null) {
				if(p == this.mask) {
					throw haxe_Exception.thrown("You can't mask with one of the object parents");
				}
				p = p.parent;
			}
			this.hide.input = null;
		}
	}
	,set_resolutionScale: function(v) {
		this.hide.set_resolutionScale(v);
		return h2d_filter_Filter.prototype.set_resolutionScale.call(this,v);
	}
	,set_useScreenResolution: function(v) {
		this.hide.set_useScreenResolution(v);
		return h2d_filter_Filter.prototype.set_useScreenResolution.call(this,v);
	}
	,__class__: h2d_filter_AbstractMask
});
var h2d_filter_Blur = function(radius,gain,quality,linear) {
	if(linear == null) {
		linear = 0.;
	}
	if(quality == null) {
		quality = 1.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	h2d_filter_Filter.call(this);
	this.pass = new h3d_pass_Blur(radius,gain,linear,quality);
};
$hxClasses["h2d.filter.Blur"] = h2d_filter_Blur;
h2d_filter_Blur.__name__ = "h2d.filter.Blur";
h2d_filter_Blur.__super__ = h2d_filter_Filter;
h2d_filter_Blur.prototype = $extend(h2d_filter_Filter.prototype,{
	get_quality: function() {
		return this.pass.quality;
	}
	,set_quality: function(v) {
		return this.pass.set_quality(v);
	}
	,get_radius: function() {
		return this.pass.radius;
	}
	,set_radius: function(v) {
		return this.pass.set_radius(v);
	}
	,get_gain: function() {
		return this.pass.gain;
	}
	,set_gain: function(v) {
		return this.pass.set_gain(v);
	}
	,get_linear: function() {
		return this.pass.linear;
	}
	,set_linear: function(v) {
		return this.pass.set_linear(v);
	}
	,sync: function(ctx,s) {
		this.boundsExtend = this.pass.radius * 2;
	}
	,draw: function(ctx,t) {
		var out = t.innerTex;
		var old = out.filter;
		out.set_filter(h3d_mat_Filter.Linear);
		this.pass.apply(ctx,out);
		out.set_filter(old);
		return t;
	}
	,__class__: h2d_filter_Blur
});
var h2d_filter_Glow = function(color,alpha,radius,gain,quality,smoothColor) {
	if(smoothColor == null) {
		smoothColor = false;
	}
	if(quality == null) {
		quality = 1.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	if(alpha == null) {
		alpha = 1.;
	}
	if(color == null) {
		color = 16777215;
	}
	h2d_filter_Blur.call(this,radius,gain,quality);
	this.color = color;
	this.alpha = alpha;
	this.smoothColor = smoothColor;
	var _this = this.pass.shader;
	_this.constModified = true;
	_this.hasFixedColor__ = true;
};
$hxClasses["h2d.filter.Glow"] = h2d_filter_Glow;
h2d_filter_Glow.__name__ = "h2d.filter.Glow";
h2d_filter_Glow.__super__ = h2d_filter_Blur;
h2d_filter_Glow.prototype = $extend(h2d_filter_Blur.prototype,{
	setParams: function() {
		var _this = this.pass.shader.fixedColor__;
		var c = this.color;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this.pass.shader.fixedColor__.w = this.smoothColor ? this.alpha * 1.5 : this.alpha;
		var _this = this.pass.shader;
		_this.constModified = true;
		_this.smoothFixedColor__ = this.smoothColor;
	}
	,draw: function(ctx,t) {
		this.setParams();
		var tex = t.innerTex;
		var old = tex.filter;
		var save = ctx.textures.allocTileTarget("glowSave",t);
		h3d_pass_Copy.run(tex,save,h2d_BlendMode.None);
		tex.set_filter(h3d_mat_Filter.Linear);
		this.pass.apply(ctx,tex);
		tex.set_filter(old);
		if(this.knockout) {
			h3d_pass_Copy.run(save,tex,h2d_BlendMode.Erase);
		} else {
			h3d_pass_Copy.run(save,tex,h2d_BlendMode.Alpha);
		}
		return t;
	}
	,__class__: h2d_filter_Glow
});
var hxsl_Shader = function() {
	this.priority = 0;
	this.initialize();
};
$hxClasses["hxsl.Shader"] = hxsl_Shader;
hxsl_Shader.__name__ = "hxsl.Shader";
hxsl_Shader.prototype = {
	initialize: function() {
		this.constModified = true;
		if(this.shader != null) {
			return;
		}
		var cl = js_Boot.getClass(this);
		this.shader = cl._SHADER;
		if(this.shader == null) {
			var curClass = cl;
			while(curClass != null && curClass.SRC == null) curClass = curClass.__super__;
			if(curClass == null) {
				throw haxe_Exception.thrown(cl.__name__ + " has no shader source");
			}
			this.shader = curClass._SHADER;
			if(this.shader == null) {
				this.shader = new hxsl_SharedShader(curClass.SRC);
				curClass._SHADER = this.shader;
			}
		}
	}
	,setPriority: function(v) {
		this.priority = v;
	}
	,getParamValue: function(index) {
		throw haxe_Exception.thrown("assert");
	}
	,getParamFloatValue: function(index) {
		throw haxe_Exception.thrown("assert");
	}
	,setParamIndexValue: function(index,val) {
		throw haxe_Exception.thrown("assert");
	}
	,setParamIndexFloatValue: function(index,val) {
		throw haxe_Exception.thrown("assert");
	}
	,updateConstants: function(globals) {
		throw haxe_Exception.thrown("assert");
	}
	,updateConstantsFinal: function(globals) {
		var c = this.shader.consts;
		while(c != null) {
			if(c.globalId == 0) {
				c = c.next;
				continue;
			}
			var v = globals.map.h[c.globalId];
			var _g = c.v.type;
			switch(_g._hx_index) {
			case 1:
				var v1 = v;
				if(v1 >>> c.bits != 0) {
					throw haxe_Exception.thrown("Constant " + c.v.name + " is outside range (" + v1 + " > " + ((1 << c.bits) - 1) + ")");
				}
				this.constBits |= v1 << c.pos;
				break;
			case 2:
				var v2 = v;
				if(v2) {
					this.constBits |= 1 << c.pos;
				}
				break;
			case 17:
				var count = _g.size;
				if(v == null) {
					c = c.next;
					continue;
				}
				var v3 = v;
				var sel = v3.channel;
				if(v3.texture == null) {
					sel = hxsl_Channel.Unknown;
				} else if(sel == null || sel == hxsl_Channel.Unknown) {
					switch(count) {
					case 1:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedFloat;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					case 3:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedNormal;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					default:
						throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
					}
				}
				this.constBits |= (globals.allocChannelID(v3.texture) << 3 | sel._hx_index) << c.pos;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			c = c.next;
		}
		var _this = this.shader;
		var constBits = this.constBits;
		var i = _this.instanceCache.h[constBits];
		this.instance = i == null ? _this.makeInstance(constBits) : i;
	}
	,clone: function() {
		return this;
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__;
	}
	,__class__: hxsl_Shader
};
var h3d_shader_ScreenShader = function() {
	this.flipY__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader;
h3d_shader_ScreenShader.__name__ = "h3d.shader.ScreenShader";
h3d_shader_ScreenShader.__super__ = hxsl_Shader;
h3d_shader_ScreenShader.prototype = $extend(hxsl_Shader.prototype,{
	get_flipY: function() {
		return this.flipY__;
	}
	,set_flipY: function(_v) {
		return this.flipY__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.flipY__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		if(index == 0) {
			this.flipY__ = val;
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ScreenShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		return s;
	}
	,__class__: h3d_shader_ScreenShader
});
var h2d_filter__$Mask_MaskShader = function() {
	this.maskMatB__ = new h3d_VectorImpl(0.,0.,0.);
	this.maskMatA__ = new h3d_VectorImpl(0.,0.,0.);
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h2d.filter._Mask.MaskShader"] = h2d_filter__$Mask_MaskShader;
h2d_filter__$Mask_MaskShader.__name__ = "h2d.filter._Mask.MaskShader";
h2d_filter__$Mask_MaskShader.__super__ = h3d_shader_ScreenShader;
h2d_filter__$Mask_MaskShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_mask: function() {
		return this.mask__;
	}
	,set_mask: function(_v) {
		return this.mask__ = _v;
	}
	,get_maskMatA: function() {
		return this.maskMatA__;
	}
	,set_maskMatA: function(_v) {
		return this.maskMatA__ = _v;
	}
	,get_maskMatB: function() {
		return this.maskMatB__;
	}
	,set_maskMatB: function(_v) {
		return this.maskMatB__ = _v;
	}
	,get_smoothAlpha: function() {
		return this.smoothAlpha__;
	}
	,set_smoothAlpha: function(_v) {
		this.constModified = true;
		return this.smoothAlpha__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.smoothAlpha__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.mask__;
		case 3:
			return this.maskMatA__;
		case 4:
			return this.maskMatB__;
		case 5:
			return this.smoothAlpha__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h2d_filter__$Mask_MaskShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.mask__ = this.mask__;
		s.maskMatA__ = this.maskMatA__;
		s.maskMatB__ = this.maskMatB__;
		s.smoothAlpha__ = this.smoothAlpha__;
		return s;
	}
	,__class__: h2d_filter__$Mask_MaskShader
});
var h2d_filter_Mask = function(mask,maskVisible,smoothAlpha) {
	if(smoothAlpha == null) {
		smoothAlpha = false;
	}
	if(maskVisible == null) {
		maskVisible = false;
	}
	h2d_filter_AbstractMask.call(this,mask);
	this.pass = new h3d_pass_ScreenFx(new h2d_filter__$Mask_MaskShader());
	this.set_maskVisible(maskVisible);
	this.set_smoothAlpha(smoothAlpha);
};
$hxClasses["h2d.filter.Mask"] = h2d_filter_Mask;
h2d_filter_Mask.__name__ = "h2d.filter.Mask";
h2d_filter_Mask.__super__ = h2d_filter_AbstractMask;
h2d_filter_Mask.prototype = $extend(h2d_filter_AbstractMask.prototype,{
	get_smoothAlpha: function() {
		return this.pass.shader.smoothAlpha__;
	}
	,set_smoothAlpha: function(v) {
		var _this = this.pass.shader;
		_this.constModified = true;
		return _this.smoothAlpha__ = v;
	}
	,draw: function(ctx,t) {
		var mask = this.getMaskTexture(ctx,t);
		if(mask == null) {
			if(this.mask == null) {
				throw haxe_Exception.thrown("Mask filter has no mask object");
			}
			return null;
		}
		var out = ctx.textures.allocTileTarget("maskTmp",t);
		ctx.engine.pushTarget(out);
		this.pass.shader.texture__ = t.innerTex;
		this.pass.shader.mask__ = this.getMaskTexture(ctx,t);
		var _this = this.pass.shader.maskMatA__;
		var x = this.maskMatrix.a;
		var y = this.maskMatrix.c;
		var z = this.maskMatrix.x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.pass.shader.maskMatB__;
		var x = this.maskMatrix.b;
		var y = this.maskMatrix.d;
		var z = this.maskMatrix.y;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		this.pass.render();
		ctx.engine.popTarget();
		return h2d_Tile.fromTexture(out);
	}
	,__class__: h2d_filter_Mask
});
var h2d_impl_BatchDrawState = function() {
	this.head = this.tail = new h2d_impl__$BatchDrawState_StateEntry(null);
	this.totalCount = 0;
};
$hxClasses["h2d.impl.BatchDrawState"] = h2d_impl_BatchDrawState;
h2d_impl_BatchDrawState.__name__ = "h2d.impl.BatchDrawState";
h2d_impl_BatchDrawState.prototype = {
	setTile: function(tile) {
		if(tile != null) {
			this.setTexture(tile.innerTex);
		}
	}
	,setTexture: function(texture) {
		if(texture != null) {
			if(this.tail.texture == null) {
				this.tail.texture = texture;
			} else if(this.tail.texture != texture) {
				var cur = this.tail;
				if(cur.count == 0) {
					cur.set(texture);
				} else if(cur.next == null) {
					cur.next = this.tail = new h2d_impl__$BatchDrawState_StateEntry(texture);
				} else {
					this.tail = cur.next.set(texture);
				}
			}
		}
	}
	,add: function(count) {
		this.tail.count += count;
		this.totalCount += count;
	}
	,clear: function() {
		var state = this.head;
		do {
			state.texture = null;
			state = state.next;
		} while(state != null);
		this.tail = this.head;
		this.tail.count = 0;
		this.totalCount = 0;
	}
	,drawQuads: function(ctx,buffer,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		var state = this.head;
		var last = this.tail.next;
		var engine = ctx.engine;
		var stateLen;
		if(offset == 0 && length == -1) {
			do {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count >> 1;
				var start = offset;
				var max = stateLen;
				if(max == null) {
					max = -1;
				}
				if(start == null) {
					start = 0;
				}
				engine.renderBuffer(buffer,engine.mem.getQuadIndexes(buffer.vertices),2,start,max);
				offset += stateLen;
				state = state.next;
			} while(state != last);
		} else {
			if(length == -1) {
				length = (this.totalCount >> 1) - offset;
			}
			var caret = 0;
			do {
				stateLen = state.count >> 1;
				if(caret + stateLen >= offset) {
					var stateMin = offset >= caret ? offset : caret;
					var stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					var start = stateMin;
					var max = stateLen1;
					if(max == null) {
						max = -1;
					}
					if(start == null) {
						start = 0;
					}
					engine.renderBuffer(buffer,engine.mem.getQuadIndexes(buffer.vertices),2,start,max);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
			} while(state != last);
		}
	}
	,drawIndexed: function(ctx,buffer,indices,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		var state = this.head;
		var last = this.tail.next;
		var engine = ctx.engine;
		var stateLen;
		if(offset == 0 && length == -1) {
			do {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count / 3 | 0;
				engine.renderIndexed(buffer,indices,offset,stateLen);
				offset += stateLen;
				state = state.next;
			} while(state != last);
		} else {
			if(length == -1) {
				length = this.totalCount / 3 | 0;
			}
			var caret = 0;
			do {
				stateLen = state.count / 3 | 0;
				if(caret + stateLen >= offset) {
					var stateMin = offset >= caret ? offset : caret;
					var stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					engine.renderIndexed(buffer,indices,stateMin,stateLen1);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
			} while(state != last);
		}
	}
	,get_currentTexture: function() {
		return this.tail.texture;
	}
	,__class__: h2d_impl_BatchDrawState
};
var h2d_impl__$BatchDrawState_StateEntry = function(texture) {
	this.texture = texture;
	this.count = 0;
};
$hxClasses["h2d.impl._BatchDrawState.StateEntry"] = h2d_impl__$BatchDrawState_StateEntry;
h2d_impl__$BatchDrawState_StateEntry.__name__ = "h2d.impl._BatchDrawState.StateEntry";
h2d_impl__$BatchDrawState_StateEntry.prototype = {
	set: function(texture) {
		this.texture = texture;
		this.count = 0;
		return this;
	}
	,__class__: h2d_impl__$BatchDrawState_StateEntry
};
var h3d_BufferFlag = $hxEnums["h3d.BufferFlag"] = { __ename__:"h3d.BufferFlag",__constructs__:null
	,Dynamic: {_hx_name:"Dynamic",_hx_index:0,__enum__:"h3d.BufferFlag",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:1,__enum__:"h3d.BufferFlag",toString:$estr}
	,UniformBuffer: {_hx_name:"UniformBuffer",_hx_index:2,__enum__:"h3d.BufferFlag",toString:$estr}
	,ReadWriteBuffer: {_hx_name:"ReadWriteBuffer",_hx_index:3,__enum__:"h3d.BufferFlag",toString:$estr}
	,IndexBuffer: {_hx_name:"IndexBuffer",_hx_index:4,__enum__:"h3d.BufferFlag",toString:$estr}
};
h3d_BufferFlag.__constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.ReadWriteBuffer,h3d_BufferFlag.IndexBuffer];
h3d_BufferFlag.__empty_constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.ReadWriteBuffer,h3d_BufferFlag.IndexBuffer];
var h3d_Buffer = function(vertices,format,flags) {
	this.id = h3d_Buffer.GUID++;
	this.vertices = vertices;
	this.format = format;
	this.flags = 0;
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	this.engine = h3d_Engine.CURRENT;
	if((this.flags & 1 << h3d_BufferFlag.NoAlloc._hx_index) == 0) {
		this.engine.mem.allocBuffer(this);
	}
};
$hxClasses["h3d.Buffer"] = h3d_Buffer;
h3d_Buffer.__name__ = "h3d.Buffer";
h3d_Buffer.ofFloats = function(v,format,flags) {
	var nvert = v.pos / format.stride | 0;
	var b = new h3d_Buffer(nvert,format,flags);
	b.uploadFloats(v,0,nvert);
	return b;
};
h3d_Buffer.ofSubFloats = function(v,vertices,format,flags) {
	var b = new h3d_Buffer(vertices,format,flags);
	b.uploadFloats(v,0,vertices);
	return b;
};
h3d_Buffer.prototype = {
	getMemSize: function() {
		return this.vertices * this.format.strideBytes;
	}
	,isDisposed: function() {
		return this.vbuf == null;
	}
	,dispose: function() {
		if(this.vbuf != null) {
			this.engine.mem.freeBuffer(this);
			this.vbuf = null;
		}
	}
	,uploadFloats: function(buf,bufPos,vertices,startVertice) {
		if(startVertice == null) {
			startVertice = 0;
		}
		if(startVertice < 0 || vertices < 0 || startVertice + vertices > this.vertices) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		if(this.format.hasLowPrecision) {
			throw haxe_Exception.thrown("Can't upload floats on low precision buffer");
		}
		if(vertices == 0) {
			return;
		}
		this.engine.driver.uploadBufferData(this,startVertice,vertices,buf,bufPos);
	}
	,uploadBytes: function(data,dataPos,vertices) {
		if(vertices < 0 || vertices > this.vertices) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		if(vertices == 0) {
			return;
		}
		this.engine.driver.uploadBufferBytes(this,0,vertices,data,dataPos);
	}
	,readBytes: function(bytes,bytesPosition,vertices,startVertice) {
		if(startVertice == null) {
			startVertice = 0;
		}
		if(startVertice < 0 || vertices < 0 || startVertice + vertices > this.vertices) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		this.engine.driver.readBufferBytes(this,startVertice,vertices,bytes,bytesPosition);
	}
	,__class__: h3d_Buffer
};
var h3d_Camera = function(fovY,zoom,screenRatio,zNear,zFar,rightHanded) {
	if(rightHanded == null) {
		rightHanded = false;
	}
	if(zFar == null) {
		zFar = 4000.;
	}
	if(zNear == null) {
		zNear = 0.02;
	}
	if(screenRatio == null) {
		screenRatio = 1.333333;
	}
	if(zoom == null) {
		zoom = 1.;
	}
	if(fovY == null) {
		fovY = 25.;
	}
	this.viewY = 0.;
	this.viewX = 0.;
	this.fovY = fovY;
	this.zoom = zoom;
	this.screenRatio = screenRatio;
	this.zNear = zNear;
	this.zFar = zFar;
	this.rightHanded = rightHanded;
	var x = 2;
	var y = 3;
	var z = 4;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.pos = new h3d_VectorImpl(x,y,z);
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.up = new h3d_VectorImpl(x,y,z);
	var x = 0;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.target = new h3d_VectorImpl(x,y,z);
	this.m = new h3d_MatrixImpl();
	this.mcam = new h3d_MatrixImpl();
	this.mproj = new h3d_MatrixImpl();
	this.frustum = new h3d_col_Frustum();
	this.update();
};
$hxClasses["h3d.Camera"] = h3d_Camera;
h3d_Camera.__name__ = "h3d.Camera";
h3d_Camera.prototype = {
	setFovX: function(fovX,withRatio) {
		var degToRad = Math.PI / 180;
		this.fovY = 2 * Math.atan(Math.tan(fovX * 0.5 * degToRad) / withRatio) / degToRad;
	}
	,getFovX: function() {
		var degToRad = Math.PI / 180;
		var halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
		var fovX = halfFovX * 2 / degToRad;
		return fovX;
	}
	,clone: function() {
		var c = new h3d_Camera(this.fovY,this.zoom,this.screenRatio,this.zNear,this.zFar,this.rightHanded);
		var _this = this.pos;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		c.pos = new h3d_VectorImpl(x,y,z);
		var _this = this.up;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		c.up = new h3d_VectorImpl(x,y,z);
		var _this = this.target;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		c.target = new h3d_VectorImpl(x,y,z);
		c.update();
		return c;
	}
	,getInverseViewProj: function() {
		if(this.minv == null) {
			this.minv = new h3d_MatrixImpl();
		}
		if(this.needInv) {
			this.minv.initInverse(this.m);
			this.needInv = false;
		}
		return this.minv;
	}
	,getInverseProj: function() {
		if(this.mprojInv == null) {
			this.mprojInv = new h3d_MatrixImpl();
			this.mprojInv._44 = 0;
		}
		if(this.mprojInv._44 == 0) {
			this.mprojInv.initInverse(this.mproj);
		}
		return this.mprojInv;
	}
	,getInverseView: function() {
		if(this.mcamInv == null) {
			this.mcamInv = new h3d_MatrixImpl();
			this.mcamInv._44 = 0;
		}
		if(this.mcamInv._44 == 0) {
			this.mcamInv.initInverse(this.mcam);
		}
		return this.mcamInv;
	}
	,setCubeMap: function(face,position) {
		var dx = 0;
		var dy = 0;
		var dz = 0;
		switch(face) {
		case 0:
			dx = 1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 1:
			dx = -1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 2:
			dy = 1;
			var _this = this.up;
			var x = 0;
			var y = 0;
			var z = -1;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 3:
			dy = -1;
			var _this = this.up;
			var x = 0;
			var y = 0;
			var z = 1;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 4:
			dz = 1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		case 5:
			dz = -1;
			var _this = this.up;
			var x = 0;
			var y = 1;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			break;
		}
		if(position != null) {
			var _this = this.pos;
			_this.x = position.x;
			_this.y = position.y;
			_this.z = position.z;
		}
		var _this = this.target;
		var x = this.pos.x + dx;
		var y = this.pos.y + dy;
		var z = this.pos.z + dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,unproject: function(screenX,screenY,camZ) {
		var x = screenX;
		var y = screenY;
		var z = camZ;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p = new h3d_VectorImpl(x,y,z);
		var _this = p;
		var m = this.getInverseViewProj();
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31 + m._41;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32 + m._42;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33 + m._43;
		var iw = 1 / (_this.x * m._14 + _this.y * m._24 + _this.z * m._34 + m._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		return p;
	}
	,rayFromScreen: function(pixelX,pixelY,sceneWidth,sceneHeight) {
		if(sceneHeight == null) {
			sceneHeight = -1;
		}
		if(sceneWidth == null) {
			sceneWidth = -1;
		}
		var engine = h3d_Engine.CURRENT;
		if(sceneWidth < 0) {
			sceneWidth = engine.width;
		}
		if(sceneHeight < 0) {
			sceneHeight = engine.height;
		}
		var rx = (pixelX / sceneWidth - 0.5) * 2;
		var ry = (0.5 - pixelY / sceneHeight) * 2;
		var p1 = this.unproject(rx,ry,0);
		var p2 = this.unproject(rx,ry,1);
		var r = new h3d_col_Ray();
		r.px = p1.x;
		r.py = p1.y;
		r.pz = p1.z;
		r.lx = p2.x - p1.x;
		r.ly = p2.y - p1.y;
		r.lz = p2.z - p1.z;
		r.normalize();
		return r;
	}
	,update: function() {
		if(this.follow != null) {
			var fpos = this.follow.pos.localToGlobal();
			var ftarget = this.follow.target.localToGlobal();
			var _this = this.pos;
			var x = fpos.x;
			var y = fpos.y;
			var z = fpos.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			var _this = this.target;
			var x = ftarget.x;
			var y = ftarget.y;
			var z = ftarget.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			if(this.follow.pos.name != null) {
				var p = this.follow.pos;
				while(p != null) {
					if(p.currentAnimation != null) {
						var v = p.currentAnimation.getPropValue(this.follow.pos.name,"FOVY");
						if(v != null) {
							this.fovY = v;
							break;
						}
					}
					p = p.parent;
				}
			}
		}
		this.makeCameraMatrix(this.mcam);
		this.makeFrustumMatrix(this.mproj);
		this.m.multiply(this.mcam,this.mproj);
		this.needInv = true;
		if(this.mcamInv != null) {
			this.mcamInv._44 = 0;
		}
		if(this.mprojInv != null) {
			this.mprojInv._44 = 0;
		}
		this.frustum.loadMatrix(this.m);
	}
	,getFrustumCorners: function(zMax,zMin) {
		if(zMin == null) {
			zMin = 0.;
		}
		if(zMax == null) {
			zMax = 1.;
		}
		return [this.unproject(-1,1,zMin),this.unproject(1,1,zMin),this.unproject(1,-1,zMin),this.unproject(-1,-1,zMin),this.unproject(-1,1,zMax),this.unproject(1,1,zMax),this.unproject(1,-1,zMax),this.unproject(-1,-1,zMax)];
	}
	,lostUp: function() {
		var _this = this.pos;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x *= k;
		_this_y *= k;
		_this_z *= k;
		var v = this.up;
		return Math.abs(_this_x * v.x + _this_y * v.y + _this_z * v.z) > 0.999;
	}
	,getViewDirection: function(dx,dy,dz) {
		if(dz == null) {
			dz = 0.;
		}
		var x = dx;
		var y = dy;
		var z = dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var a = new h3d_VectorImpl(x,y,z);
		var _this = a;
		var m = this.mcam;
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33;
		_this.x = px;
		_this.y = py;
		_this.z = pz;
		var _this = a;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return a;
	}
	,movePosAxis: function(dx,dy,dz) {
		if(dz == null) {
			dz = 0.;
		}
		var x = dx;
		var y = dy;
		var z = dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var m = this.mcam;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		this.pos.x += _this_x;
		this.pos.y += _this_y;
		this.pos.z += _this_z;
	}
	,moveTargetAxis: function(dx,dy,dz) {
		if(dz == null) {
			dz = 0.;
		}
		var x = dx;
		var y = dy;
		var z = dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var m = this.mcam;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		this.target.x += _this_x;
		this.target.y += _this_y;
		this.target.z += _this_z;
	}
	,forward: function(speed) {
		if(speed == null) {
			speed = 1.;
		}
		var c = 1 - 0.025 * speed;
		var _this = this.pos;
		var x = this.target.x + (this.pos.x - this.target.x) * c;
		var y = this.target.y + (this.pos.y - this.target.y) * c;
		var z = this.target.z + (this.pos.z - this.target.z) * c;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,backward: function(speed) {
		if(speed == null) {
			speed = 1.;
		}
		var c = 1 + 0.025 * speed;
		var _this = this.pos;
		var x = this.target.x + (this.pos.x - this.target.x) * c;
		var y = this.target.y + (this.pos.y - this.target.y) * c;
		var z = this.target.z + (this.pos.z - this.target.z) * c;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
	}
	,makeCameraMatrix: function(m) {
		var this1 = this.target;
		var v = this.pos;
		var x = this1.x - v.x;
		var y = this1.y - v.y;
		var z = this1.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		if(this.rightHanded) {
			_this_x *= -1;
			_this_y *= -1;
			_this_z *= -1;
		}
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x *= k;
		_this_y *= k;
		_this_z *= k;
		var _this = this.up;
		var x = _this.y * _this_z - _this.z * _this_y;
		var y = _this.z * _this_x - _this.x * _this_z;
		var z = _this.x * _this_y - _this.y * _this_x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x1 *= k;
		_this_y1 *= k;
		_this_z1 *= k;
		if(Math.sqrt(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1) == 0) {
			_this_x1 = _this_y;
			_this_y1 = _this_z;
			_this_z1 = _this_x;
		}
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		m._11 = _this_x1;
		m._12 = _this_x2;
		m._13 = _this_x;
		m._14 = 0;
		m._21 = _this_y1;
		m._22 = _this_y2;
		m._23 = _this_y;
		m._24 = 0;
		m._31 = _this_z1;
		m._32 = _this_z2;
		m._33 = _this_z;
		m._34 = 0;
		var v = this.pos;
		m._41 = -(_this_x1 * v.x + _this_y1 * v.y + _this_z1 * v.z);
		var v = this.pos;
		m._42 = -(_this_x2 * v.x + _this_y2 * v.y + _this_z2 * v.z);
		var v = this.pos;
		m._43 = -(_this_x * v.x + _this_y * v.y + _this_z * v.z);
		m._44 = 1;
	}
	,setTransform: function(m) {
		var _this = this.pos;
		var x = m._41;
		var y = m._42;
		var z = m._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.target;
		var this1 = this.pos;
		var v = m.getDirection();
		var x = this1.x + v.x;
		var y = this1.y + v.y;
		var z = this1.z + v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
	}
	,makeFrustumMatrix: function(m) {
		m.zero();
		var bounds = this.orthoBounds;
		if(bounds != null) {
			var w = 1 / (bounds.xMax - bounds.xMin);
			var h = 1 / (bounds.yMax - bounds.yMin);
			var d = 1 / (bounds.zMax - bounds.zMin);
			m._11 = 2 * w;
			m._22 = 2 * h;
			m._33 = d;
			m._41 = -(bounds.xMin + bounds.xMax) * w;
			m._42 = -(bounds.yMin + bounds.yMax) * h;
			m._43 = -bounds.zMin * d;
			m._44 = 1;
		} else {
			var degToRad = Math.PI / 180;
			var halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
			var scale = this.zoom / Math.tan(halfFovX);
			m._11 = scale;
			m._22 = scale * this.screenRatio;
			m._33 = this.zFar / (this.zFar - this.zNear);
			m._34 = 1;
			m._43 = -(this.zNear * this.zFar) / (this.zFar - this.zNear);
		}
		m._11 += this.viewX * m._14;
		m._21 += this.viewX * m._24;
		m._31 += this.viewX * m._34;
		m._41 += this.viewX * m._44;
		m._12 += this.viewY * m._14;
		m._22 += this.viewY * m._24;
		m._32 += this.viewY * m._34;
		m._42 += this.viewY * m._44;
		if(this.rightHanded) {
			m._33 *= -1;
			m._34 *= -1;
		}
	}
	,project: function(x,y,z,screenWidth,screenHeight,snapToPixel,p) {
		if(snapToPixel == null) {
			snapToPixel = true;
		}
		if(p == null) {
			p = new h3d_VectorImpl(0.,0.,0.);
		}
		var _this = p;
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this.x = x1;
		_this.y = y1;
		_this.z = z1;
		var _this = p;
		var m = this.m;
		var px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31 + m._41;
		var py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32 + m._42;
		var pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33 + m._43;
		var iw = 1 / (_this.x * m._14 + _this.y * m._24 + _this.z * m._34 + m._44);
		_this.x = px * iw;
		_this.y = py * iw;
		_this.z = pz * iw;
		p.x = (p.x + 1) * 0.5 * screenWidth;
		p.y = (-p.y + 1) * 0.5 * screenHeight;
		if(snapToPixel) {
			p.x = Math.round(p.x);
			p.y = Math.round(p.y);
		}
		return p;
	}
	,distanceToDepth: function(dist) {
		var min = this.zNear;
		var max = this.zFar;
		if(max == null) {
			max = 1.;
		}
		if(min == null) {
			min = 0.;
		}
		return ((this.zFar + this.zNear - 2.0 * this.zNear * this.zFar / (dist < min ? min : dist > max ? max : dist)) / (this.zFar - this.zNear) + 1.0) / 2.0;
	}
	,depthToDistance: function(depth) {
		var min = 0;
		var max = 1;
		if(max == null) {
			max = 1.;
		}
		if(min == null) {
			min = 0.;
		}
		return ((depth < min ? min : depth > max ? max : depth) * this.zFar - this.zNear * this.zFar) / (this.zFar - this.zNear);
	}
	,load: function(cam) {
		var _this = this.pos;
		var v = cam.pos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = this.target;
		var v = cam.target;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = this.up;
		var v = cam.up;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		if(cam.orthoBounds != null) {
			this.orthoBounds = new h3d_col_Bounds();
			this.orthoBounds.load(cam.orthoBounds);
		} else {
			this.orthoBounds = null;
		}
		this.fovY = cam.fovY;
		this.screenRatio = cam.screenRatio;
		this.zoom = cam.zoom;
		this.zNear = cam.zNear;
		this.zFar = cam.zFar;
		if(cam.follow != null) {
			this.follow = { pos : cam.follow.pos, target : cam.follow.target};
		} else {
			this.follow = null;
		}
		this.viewX = cam.viewX;
		this.viewY = cam.viewY;
		this.update();
	}
	,__class__: h3d_Camera
};
var h3d__$Engine_TargetTmp = function(t,n,l,m,db) {
	this.t = t;
	this.next = n;
	this.layer = l;
	this.mipLevel = m;
	this.depthBinding = db;
};
$hxClasses["h3d._Engine.TargetTmp"] = h3d__$Engine_TargetTmp;
h3d__$Engine_TargetTmp.__name__ = "h3d._Engine.TargetTmp";
h3d__$Engine_TargetTmp.prototype = {
	__class__: h3d__$Engine_TargetTmp
};
var h3d_DepthBinding = $hxEnums["h3d.DepthBinding"] = { __ename__:"h3d.DepthBinding",__constructs__:null
	,ReadWrite: {_hx_name:"ReadWrite",_hx_index:0,__enum__:"h3d.DepthBinding",toString:$estr}
	,ReadOnly: {_hx_name:"ReadOnly",_hx_index:1,__enum__:"h3d.DepthBinding",toString:$estr}
	,DepthOnly: {_hx_name:"DepthOnly",_hx_index:2,__enum__:"h3d.DepthBinding",toString:$estr}
	,NotBound: {_hx_name:"NotBound",_hx_index:3,__enum__:"h3d.DepthBinding",toString:$estr}
};
h3d_DepthBinding.__constructs__ = [h3d_DepthBinding.ReadWrite,h3d_DepthBinding.ReadOnly,h3d_DepthBinding.DepthOnly,h3d_DepthBinding.NotBound];
h3d_DepthBinding.__empty_constructs__ = [h3d_DepthBinding.ReadWrite,h3d_DepthBinding.ReadOnly,h3d_DepthBinding.DepthOnly,h3d_DepthBinding.NotBound];
var h3d_Engine = function() {
	this.resCache = new haxe_ds_ObjectMap();
	this.ready = false;
	this.inRender = false;
	this.textureColorCache = new haxe_ds_IntMap();
	this.tmpVector = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.backgroundColor = -16777216;
	this.hardware = !h3d_Engine.SOFTWARE_DRIVER;
	this.antiAlias = h3d_Engine.ANTIALIASING;
	this.autoResize = true;
	this.set_fullScreen(!hxd_System.getValue(hxd_SystemValue.IsWindowed));
	this.window = hxd_Window.getInstance();
	this.realFps = hxd_System.getDefaultFrameRate();
	this.lastTime = HxOverrides.now() / 1000;
	this.window.addResizeEvent($bind(this,this.onWindowResize));
	this.driver = js_Browser.get_supported() ? new h3d_impl_GlDriver(this.antiAlias) : new h3d_impl_NullDriver();
	h3d_Engine.CURRENT = this;
};
$hxClasses["h3d.Engine"] = h3d_Engine;
h3d_Engine.__name__ = "h3d.Engine";
h3d_Engine.getCurrent = function() {
	return h3d_Engine.CURRENT;
};
h3d_Engine.prototype = {
	setDriver: function(d) {
		this.driver = d;
		if(this.mem != null) {
			this.mem.driver = d;
		}
	}
	,setCurrent: function() {
		h3d_Engine.CURRENT = this;
	}
	,init: function() {
		this.driver.init($bind(this,this.onCreate),!this.hardware);
	}
	,driverName: function(details) {
		if(details == null) {
			details = false;
		}
		return this.driver.getDriverName(details);
	}
	,selectShader: function(shader) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		if(this.driver.selectShader(shader)) {
			this.shaderSwitches++;
		}
	}
	,selectMaterial: function(pass) {
		this.driver.selectMaterial(pass);
	}
	,uploadShaderBuffers: function(buffers,which) {
		this.driver.uploadShaderBuffers(buffers,which);
	}
	,selectBuffer: function(buf) {
		if(buf.vbuf == null) {
			return false;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectBuffer(buf);
		return true;
	}
	,renderTriBuffer: function(b,start,max) {
		if(max == null) {
			max = -1;
		}
		if(start == null) {
			start = 0;
		}
		this.renderBuffer(b,this.mem.getTriIndexes(b.vertices),3,start,max);
	}
	,renderQuadBuffer: function(b,start,max) {
		if(max == null) {
			max = -1;
		}
		if(start == null) {
			start = 0;
		}
		this.renderBuffer(b,this.mem.getQuadIndexes(b.vertices),2,start,max);
	}
	,renderBuffer: function(b,indexes,vertPerTri,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(indexes.vbuf == null) {
			return;
		}
		var ntri = b.vertices / vertPerTri | 0;
		if(drawTri < 0) {
			drawTri = ntri - startTri;
		}
		if(startTri < 0 || drawTri < 0 || startTri + drawTri > ntri) {
			throw haxe_Exception.thrown("Invalid vertices count");
		}
		if(drawTri > 0 && this.selectBuffer(b)) {
			this.driver.draw(indexes,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderIndexed: function(b,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(indexes.vbuf == null) {
			return;
		}
		var maxTri = indexes.vertices / 3 | 0;
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0 && this.selectBuffer(b)) {
			this.driver.draw(indexes,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderMultiBuffers: function(format,buffers,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		var maxTri = indexes.vertices / 3 | 0;
		if(maxTri <= 0) {
			return;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectMultiBuffers(format,buffers);
		if(indexes.vbuf == null) {
			return;
		}
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0) {
			this.driver.draw(indexes,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	,renderInstanced: function(indexes,commands) {
		if(indexes.vbuf == null) {
			return;
		}
		if(commands.commandCount > 0) {
			this.driver.drawInstanced(indexes,commands);
			this.drawTriangles += commands.triCount;
			this.drawCalls++;
		}
	}
	,set_debug: function(d) {
		this.debug = d;
		this.driver.setDebug(this.debug);
		return d;
	}
	,onCreate: function(disposed) {
		h3d_Engine.CURRENT = this;
		if(this.autoResize) {
			this.width = this.window.get_width();
			this.height = this.window.get_height();
		}
		if(disposed) {
			hxd_impl_Allocator.get().onContextLost();
			this.mem.onContextLost();
		} else {
			this.mem = new h3d_impl_MemoryManager(this.driver);
			this.mem.init();
			this.nullTexture = new h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc]);
		}
		this.hardware = this.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated);
		this.set_debug(this.debug);
		this.set_fullScreen(this.fullScreen);
		this.resize(this.width,this.height);
		if(disposed) {
			this.onContextLost();
		} else {
			this.onReady();
		}
		this.ready = true;
	}
	,onContextLost: function() {
	}
	,onReady: function() {
	}
	,onWindowResize: function() {
		if(this.autoResize && !this.driver.isDisposed()) {
			var w = this.window.get_width();
			var h = this.window.get_height();
			if(w != this.width || h != this.height) {
				this.resize(w,h);
			}
			this.onResized();
		}
	}
	,set_fullScreen: function(v) {
		this.fullScreen = v;
		if(this.mem != null && hxd_System.getValue(hxd_SystemValue.IsWindowed)) {
			this.window.set_displayMode(v ? hxd_DisplayMode.Borderless : hxd_DisplayMode.Windowed);
		}
		return v;
	}
	,onResized: function() {
	}
	,resize: function(width,height) {
		if(width < 32) {
			width = 32;
		}
		if(height < 32) {
			height = 32;
		}
		this.width = width;
		this.height = height;
		if(!this.driver.isDisposed()) {
			this.driver.resize(width,height);
		}
	}
	,begin: function() {
		if(this.driver.isDisposed()) {
			return false;
		}
		this.inRender = true;
		this.drawTriangles = 0;
		this.shaderSwitches = 0;
		this.drawCalls = 0;
		this.targetStack = null;
		this.needFlushTarget = this.currentTargetTex != null;
		this.driver.begin(hxd_Timer.frameCount);
		if(this.backgroundColor != null) {
			this.clear(this.backgroundColor,1,0);
		}
		return true;
	}
	,hasFeature: function(f) {
		return this.driver.hasFeature(f);
	}
	,end: function() {
		this.inRender = false;
		this.driver.end();
	}
	,getCurrentTarget: function() {
		if(this.targetStack == null) {
			return null;
		} else if(this.targetStack.t == this.nullTexture) {
			return this.targetStack.textures[0];
		} else {
			return this.targetStack.t;
		}
	}
	,pushTarget: function(tex,layer,mipLevel,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		var c = this.targetTmp;
		if(c == null) {
			c = new h3d__$Engine_TargetTmp(tex,this.targetStack,layer,mipLevel,depthBinding);
		} else {
			this.targetTmp = c.next;
			c.t = tex;
			c.next = this.targetStack;
			c.mipLevel = mipLevel;
			c.layer = layer;
			c.depthBinding = depthBinding;
		}
		this.targetStack = c;
		this.updateNeedFlush();
	}
	,updateNeedFlush: function() {
		var t = this.targetStack;
		if(t == null) {
			this.needFlushTarget = this.currentTargetTex != null;
		} else {
			this.needFlushTarget = this.currentTargetTex != t.t || this.currentTargetLayer != t.layer || this.currentTargetMip != t.mipLevel || t.textures != null || this.currentDepthBinding != t.depthBinding;
		}
	}
	,pushTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		this.pushTarget(this.nullTexture,null,null,depthBinding);
		this.targetStack.textures = textures;
		this.needFlushTarget = true;
	}
	,pushDepth: function(depthBuffer) {
		this.pushTarget(depthBuffer,null,null,h3d_DepthBinding.DepthOnly);
	}
	,popTarget: function() {
		var c = this.targetStack;
		if(c == null) {
			throw haxe_Exception.thrown("popTarget() with no matching pushTarget()");
		}
		this.targetStack = c.next;
		this.updateNeedFlush();
		c.t = null;
		c.textures = null;
		c.next = this.targetTmp;
		this.targetTmp = c;
	}
	,flushTarget: function() {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
	}
	,doFlushTarget: function() {
		var t = this.targetStack;
		if(t == null) {
			this.driver.setRenderTarget(null);
			this.currentTargetTex = null;
		} else {
			if(t.depthBinding == h3d_DepthBinding.DepthOnly) {
				this.driver.setDepth(t.t);
			} else if(t.textures != null) {
				this.driver.setRenderTargets(t.textures,t.depthBinding);
			} else {
				this.driver.setRenderTarget(t.t,t.layer,t.mipLevel,t.depthBinding);
			}
			this.currentTargetTex = t.t;
			this.currentTargetLayer = t.layer;
			this.currentTargetMip = t.mipLevel;
			this.currentDepthBinding = t.depthBinding;
		}
		this.needFlushTarget = false;
	}
	,clearF: function(color,depth,stencil) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.clear(color,depth,stencil);
	}
	,clear: function(color,depth,stencil) {
		if(color != null) {
			var _this = this.tmpVector;
			_this.x = (color >> 16 & 255) / 255;
			_this.y = (color >> 8 & 255) / 255;
			_this.z = (color & 255) / 255;
			_this.w = (color >>> 24) / 255;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.clear(color == null ? null : this.tmpVector,depth,stencil);
	}
	,setRenderZone: function(x,y,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.setRenderZone(x,y,width,height);
	}
	,render: function(obj) {
		if(!this.begin()) {
			return false;
		}
		obj.render(this);
		this.end();
		var delta = HxOverrides.now() / 1000 - this.lastTime;
		this.lastTime += delta;
		if(delta > 0) {
			var curFps = 1. / delta;
			if(curFps > this.realFps * 2) {
				curFps = this.realFps * 2;
			} else if(curFps < this.realFps * 0.5) {
				curFps = this.realFps * 0.5;
			}
			var f = delta / .5;
			if(f > 0.3) {
				f = 0.3;
			}
			this.realFps = this.realFps * (1 - f) + curFps * f;
		}
		return true;
	}
	,dispose: function() {
		this.driver.dispose();
		this.window.removeResizeEvent($bind(this,this.onWindowResize));
	}
	,get_fps: function() {
		return Math.ceil(this.realFps * 100) / 100;
	}
	,__class__: h3d_Engine
};
var h3d_Indexes = {};
h3d_Indexes._new = function(count,is32) {
	if(is32 == null) {
		is32 = false;
	}
	return new h3d_Buffer(count,is32 ? hxd_BufferFormat.get_INDEX32() : hxd_BufferFormat.get_INDEX16(),[h3d_BufferFlag.IndexBuffer]);
};
h3d_Indexes.uploadIndexes = function(this1,ibuf,bufPos,indices,startIndice) {
	if(startIndice == null) {
		startIndice = 0;
	}
	if(startIndice < 0 || indices < 0 || startIndice + indices > this1.vertices) {
		throw haxe_Exception.thrown("Invalid indices count");
	}
	if(this1.format.inputs[0].precision != 1) {
		throw haxe_Exception.thrown("Can't upload indexes on a 32-bit buffer");
	}
	if(indices == 0) {
		return;
	}
	h3d_Engine.CURRENT.driver.uploadIndexData(this1,startIndice,indices,ibuf,bufPos);
};
h3d_Indexes.get_count = function(this1) {
	return this1.vertices;
};
h3d_Indexes.alloc = function(i,startPos,length) {
	if(length == null) {
		length = -1;
	}
	if(startPos == null) {
		startPos = 0;
	}
	if(length < 0) {
		length = i.length;
	}
	var idx = h3d_Indexes._new(length);
	h3d_Indexes.uploadIndexes(idx,i,0,length);
	return idx;
};
var h3d_MatrixImpl = function() {
};
$hxClasses["h3d.MatrixImpl"] = h3d_MatrixImpl;
h3d_MatrixImpl.__name__ = "h3d.MatrixImpl";
h3d_MatrixImpl.prototype = {
	get_tx: function() {
		return this._41;
	}
	,get_ty: function() {
		return this._42;
	}
	,get_tz: function() {
		return this._43;
	}
	,set_tx: function(v) {
		return this._41 = v;
	}
	,set_ty: function(v) {
		return this._42 = v;
	}
	,set_tz: function(v) {
		return this._43 = v;
	}
	,equal: function(other) {
		if(this._11 == other._11 && this._12 == other._12 && this._13 == other._13 && this._14 == other._14 && this._21 == other._21 && this._22 == other._22 && this._23 == other._23 && this._24 == other._24 && this._31 == other._31 && this._32 == other._32 && this._33 == other._33 && this._34 == other._34 && this._41 == other._41 && this._42 == other._42 && this._43 == other._43) {
			return this._44 == other._44;
		} else {
			return false;
		}
	}
	,zero: function() {
		this._11 = 0.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 0.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 0.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 0.0;
	}
	,identity: function() {
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,isIdentity: function() {
		if(this._41 != 0 || this._42 != 0 || this._43 != 0) {
			return false;
		}
		if(this._11 != 1 || this._22 != 1 || this._33 != 1) {
			return false;
		}
		if(this._12 != 0 || this._13 != 0 || this._14 != 0) {
			return false;
		}
		if(this._21 != 0 || this._23 != 0 || this._24 != 0) {
			return false;
		}
		if(this._31 != 0 || this._32 != 0 || this._34 != 0) {
			return false;
		}
		return this._44 == 1;
	}
	,isIdentityEpsilon: function(e) {
		var tmp;
		var tmp1;
		var f = this._41;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._42;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._43;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._11 - 1;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._22 - 1;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._33 - 1;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._12;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._13;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._14;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._21;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._23;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._24;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var tmp;
		var tmp1;
		var f = this._31;
		if(!((f < 0 ? -f : f) > e)) {
			var f = this._32;
			tmp1 = (f < 0 ? -f : f) > e;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			var f = this._34;
			tmp = (f < 0 ? -f : f) > e;
		} else {
			tmp = true;
		}
		if(tmp) {
			return false;
		}
		var f = this._44 - 1;
		return (f < 0 ? -f : f) <= e;
	}
	,initRotationX: function(a) {
		var cos = Math.cos(a);
		var sin = Math.sin(a);
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = cos;
		this._23 = sin;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = -sin;
		this._33 = cos;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initRotationY: function(a) {
		var cos = Math.cos(a);
		var sin = Math.sin(a);
		this._11 = cos;
		this._12 = 0.0;
		this._13 = -sin;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = sin;
		this._32 = 0.0;
		this._33 = cos;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initRotationZ: function(a) {
		var cos = Math.cos(a);
		var sin = Math.sin(a);
		this._11 = cos;
		this._12 = sin;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = -sin;
		this._22 = cos;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initTranslation: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = x;
		this._42 = y;
		this._43 = z;
		this._44 = 1.0;
	}
	,initScale: function(x,y,z) {
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this._11 = x;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = y;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = z;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	,initRotationAxis: function(axis,angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		var cos1 = 1 - cos;
		var x = -axis.x;
		var y = -axis.y;
		var z = -axis.z;
		var xx = x * x;
		var yy = y * y;
		var zz = z * z;
		var len = 1. / Math.sqrt(xx + yy + zz);
		x *= len;
		y *= len;
		z *= len;
		var xcos1 = x * cos1;
		var zcos1 = z * cos1;
		this._11 = cos + x * xcos1;
		this._12 = y * xcos1 - z * sin;
		this._13 = x * zcos1 + y * sin;
		this._14 = 0.;
		this._21 = y * xcos1 + z * sin;
		this._22 = cos + y * y * cos1;
		this._23 = y * zcos1 - x * sin;
		this._24 = 0.;
		this._31 = x * zcos1 - y * sin;
		this._32 = y * zcos1 + x * sin;
		this._33 = cos + z * zcos1;
		this._34 = 0.;
		this._41 = 0.;
		this._42 = 0.;
		this._43 = 0.;
		this._44 = 1.;
	}
	,initRotation: function(x,y,z) {
		var cx = Math.cos(x);
		var sx = Math.sin(x);
		var cy = Math.cos(y);
		var sy = Math.sin(y);
		var cz = Math.cos(z);
		var sz = Math.sin(z);
		var cxsy = cx * sy;
		var sxsy = sx * sy;
		this._11 = cy * cz;
		this._12 = cy * sz;
		this._13 = -sy;
		this._14 = 0;
		this._21 = sxsy * cz - cx * sz;
		this._22 = sxsy * sz + cx * cz;
		this._23 = sx * cy;
		this._24 = 0;
		this._31 = cxsy * cz + sx * sz;
		this._32 = cxsy * sz - sx * cz;
		this._33 = cx * cy;
		this._34 = 0;
		this._41 = 0;
		this._42 = 0;
		this._43 = 0;
		this._44 = 1;
	}
	,translate: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this._11 += x * this._14;
		this._12 += y * this._14;
		this._13 += z * this._14;
		this._21 += x * this._24;
		this._22 += y * this._24;
		this._23 += z * this._24;
		this._31 += x * this._34;
		this._32 += y * this._34;
		this._33 += z * this._34;
		this._41 += x * this._44;
		this._42 += y * this._44;
		this._43 += z * this._44;
	}
	,scale: function(x,y,z) {
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this._11 *= x;
		this._21 *= x;
		this._31 *= x;
		this._41 *= x;
		this._12 *= y;
		this._22 *= y;
		this._32 *= y;
		this._42 *= y;
		this._13 *= z;
		this._23 *= z;
		this._33 *= z;
		this._43 *= z;
	}
	,rotate: function(x,y,z) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotation(x,y,z);
		this.multiply(this,tmp);
	}
	,rotateAxis: function(axis,angle) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotationAxis(axis,angle);
		this.multiply(this,tmp);
	}
	,getPosition: function() {
		var v = new h3d_VectorImpl(0.,0.,0.);
		var _this = v;
		var x = this._41;
		var y = this._42;
		var z = this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		return v;
	}
	,setPosition: function(v) {
		this._41 = v.x;
		this._42 = v.y;
		this._43 = v.z;
	}
	,prependTranslation: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var vx = this._11 * x + this._21 * y + this._31 * z + this._41;
		var vy = this._12 * x + this._22 * y + this._32 * z + this._42;
		var vz = this._13 * x + this._23 * y + this._33 * z + this._43;
		var vw = this._14 * x + this._24 * y + this._34 * z + this._44;
		this._41 = vx;
		this._42 = vy;
		this._43 = vz;
		this._44 = vw;
	}
	,getScale: function() {
		var v = new h3d_VectorImpl(0.,0.,0.);
		v.x = Math.sqrt(this._11 * this._11 + this._12 * this._12 + this._13 * this._13);
		v.y = Math.sqrt(this._21 * this._21 + this._22 * this._22 + this._23 * this._23);
		v.z = Math.sqrt(this._31 * this._31 + this._32 * this._32 + this._33 * this._33);
		if(this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31) < 0) {
			v.x *= -1;
			v.y *= -1;
			v.z *= -1;
		}
		return v;
	}
	,prependRotation: function(x,y,z) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotation(x,y,z);
		this.multiply(tmp,this);
	}
	,prependRotationAxis: function(axis,angle) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initRotationAxis(axis,angle);
		this.multiply(tmp,this);
	}
	,prependScale: function(sx,sy,sz) {
		if(sz == null) {
			sz = 1.;
		}
		if(sy == null) {
			sy = 1.;
		}
		if(sx == null) {
			sx = 1.;
		}
		var tmp = h3d_MatrixImpl.tmp;
		tmp.initScale(sx,sy,sz);
		this.multiply(tmp,this);
	}
	,multiply3x4: function(a,b) {
		var m11 = a._11;
		var m12 = a._12;
		var m13 = a._13;
		var m21 = a._21;
		var m22 = a._22;
		var m23 = a._23;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		this._14 = 0;
		this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		this._24 = 0;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		this._34 = 0;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		this._44 = 1;
	}
	,multiply3x4inline: function(a,b) {
		var m11 = a._11;
		var m12 = a._12;
		var m13 = a._13;
		var m21 = a._21;
		var m22 = a._22;
		var m23 = a._23;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		this._14 = 0;
		this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		this._24 = 0;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		this._34 = 0;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		this._44 = 1;
	}
	,multiply: function(a,b) {
		var a11 = a._11;
		var a12 = a._12;
		var a13 = a._13;
		var a14 = a._14;
		var a21 = a._21;
		var a22 = a._22;
		var a23 = a._23;
		var a24 = a._24;
		var a31 = a._31;
		var a32 = a._32;
		var a33 = a._33;
		var a34 = a._34;
		var a41 = a._41;
		var a42 = a._42;
		var a43 = a._43;
		var a44 = a._44;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b14 = b._14;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b24 = b._24;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b34 = b._34;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		var b44 = b._44;
		this._11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		this._12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		this._13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		this._14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		this._21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		this._22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		this._23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		this._24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		this._34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		this._44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	}
	,multiplyValue: function(v) {
		this._11 *= v;
		this._12 *= v;
		this._13 *= v;
		this._14 *= v;
		this._21 *= v;
		this._22 *= v;
		this._23 *= v;
		this._24 *= v;
		this._31 *= v;
		this._32 *= v;
		this._33 *= v;
		this._34 *= v;
		this._41 *= v;
		this._42 *= v;
		this._43 *= v;
		this._44 *= v;
	}
	,invert: function() {
		this.initInverse(this);
	}
	,getInverse: function(m) {
		if(m == null) {
			m = new h3d_MatrixImpl();
		}
		m.initInverse(this);
		return m;
	}
	,getDeterminant: function() {
		return this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31);
	}
	,inverse3x4: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		var m41 = m._41;
		var m42 = m._42;
		var m43 = m._43;
		this._11 = m22 * m33 - m23 * m32;
		this._12 = m13 * m32 - m12 * m33;
		this._13 = m12 * m23 - m13 * m22;
		this._14 = 0;
		this._21 = m23 * m31 - m21 * m33;
		this._22 = m11 * m33 - m13 * m31;
		this._23 = m13 * m21 - m11 * m23;
		this._24 = 0;
		this._31 = m21 * m32 - m22 * m31;
		this._32 = m12 * m31 - m11 * m32;
		this._33 = m11 * m22 - m12 * m21;
		this._34 = 0;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		this._44 = 1;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		var invDet = 1.0 / det;
		this._11 *= invDet;
		this._12 *= invDet;
		this._13 *= invDet;
		this._21 *= invDet;
		this._22 *= invDet;
		this._23 *= invDet;
		this._31 *= invDet;
		this._32 *= invDet;
		this._33 *= invDet;
		this._41 *= invDet;
		this._42 *= invDet;
		this._43 *= invDet;
	}
	,initInverse: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m14 = m._14;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m24 = m._24;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		var m34 = m._34;
		var m41 = m._41;
		var m42 = m._42;
		var m43 = m._43;
		var m44 = m._44;
		this._11 = m22 * m33 * m44 - m22 * m34 * m43 - m32 * m23 * m44 + m32 * m24 * m43 + m42 * m23 * m34 - m42 * m24 * m33;
		this._12 = -m12 * m33 * m44 + m12 * m34 * m43 + m32 * m13 * m44 - m32 * m14 * m43 - m42 * m13 * m34 + m42 * m14 * m33;
		this._13 = m12 * m23 * m44 - m12 * m24 * m43 - m22 * m13 * m44 + m22 * m14 * m43 + m42 * m13 * m24 - m42 * m14 * m23;
		this._14 = -m12 * m23 * m34 + m12 * m24 * m33 + m22 * m13 * m34 - m22 * m14 * m33 - m32 * m13 * m24 + m32 * m14 * m23;
		this._21 = -m21 * m33 * m44 + m21 * m34 * m43 + m31 * m23 * m44 - m31 * m24 * m43 - m41 * m23 * m34 + m41 * m24 * m33;
		this._22 = m11 * m33 * m44 - m11 * m34 * m43 - m31 * m13 * m44 + m31 * m14 * m43 + m41 * m13 * m34 - m41 * m14 * m33;
		this._23 = -m11 * m23 * m44 + m11 * m24 * m43 + m21 * m13 * m44 - m21 * m14 * m43 - m41 * m13 * m24 + m41 * m14 * m23;
		this._24 = m11 * m23 * m34 - m11 * m24 * m33 - m21 * m13 * m34 + m21 * m14 * m33 + m31 * m13 * m24 - m31 * m14 * m23;
		this._31 = m21 * m32 * m44 - m21 * m34 * m42 - m31 * m22 * m44 + m31 * m24 * m42 + m41 * m22 * m34 - m41 * m24 * m32;
		this._32 = -m11 * m32 * m44 + m11 * m34 * m42 + m31 * m12 * m44 - m31 * m14 * m42 - m41 * m12 * m34 + m41 * m14 * m32;
		this._33 = m11 * m22 * m44 - m11 * m24 * m42 - m21 * m12 * m44 + m21 * m14 * m42 + m41 * m12 * m24 - m41 * m14 * m22;
		this._34 = -m11 * m22 * m34 + m11 * m24 * m32 + m21 * m12 * m34 - m21 * m14 * m32 - m31 * m12 * m24 + m31 * m14 * m22;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31 + m14 * this._41;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		det = 1.0 / det;
		this._11 *= det;
		this._12 *= det;
		this._13 *= det;
		this._14 *= det;
		this._21 *= det;
		this._22 *= det;
		this._23 *= det;
		this._24 *= det;
		this._31 *= det;
		this._32 *= det;
		this._33 *= det;
		this._34 *= det;
		this._41 *= det;
		this._42 *= det;
		this._43 *= det;
		this._44 *= det;
	}
	,initInverse3x3: function(m) {
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var m31 = m._31;
		var m32 = m._32;
		var m33 = m._33;
		this._11 = m22 * m33 - m32 * m23;
		this._12 = -m12 * m33 + m32 * m13;
		this._13 = m12 * m23 - m22 * m13;
		this._21 = -m21 * m33 + m31 * m23;
		this._22 = m11 * m33 - m31 * m13;
		this._23 = -m11 * m23 + m21 * m13;
		this._31 = m21 * m32 - m31 * m22;
		this._32 = -m11 * m32 + m31 * m12;
		this._33 = m11 * m22 - m21 * m12;
		var det = m11 * this._11 + m12 * this._21 + m13 * this._31;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		det = 1.0 / det;
		this._11 *= det;
		this._12 *= det;
		this._13 *= det;
		this._14 = 0;
		this._21 *= det;
		this._22 *= det;
		this._23 *= det;
		this._24 = 0;
		this._31 *= det;
		this._32 *= det;
		this._33 *= det;
		this._34 = 0;
		this._41 = 0;
		this._42 = 0;
		this._43 = 0;
		this._44 = 1;
	}
	,front: function() {
		var x = this._11;
		var y = this._12;
		var z = this._13;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_VectorImpl(x,y,z);
		var _this = v;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return v;
	}
	,right: function() {
		var x = this._21;
		var y = this._22;
		var z = this._23;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_VectorImpl(x,y,z);
		var _this = v;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return v;
	}
	,up: function() {
		var x = this._31;
		var y = this._32;
		var z = this._33;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_VectorImpl(x,y,z);
		var _this = v;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		return v;
	}
	,transpose: function() {
		var tmp = this._12;
		this._12 = this._21;
		this._21 = tmp;
		tmp = this._13;
		this._13 = this._31;
		this._31 = tmp;
		tmp = this._14;
		this._14 = this._41;
		this._41 = tmp;
		tmp = this._23;
		this._23 = this._32;
		this._32 = tmp;
		tmp = this._24;
		this._24 = this._42;
		this._42 = tmp;
		tmp = this._34;
		this._34 = this._43;
		this._43 = tmp;
	}
	,clone: function() {
		var m = new h3d_MatrixImpl();
		m._11 = this._11;
		m._12 = this._12;
		m._13 = this._13;
		m._14 = this._14;
		m._21 = this._21;
		m._22 = this._22;
		m._23 = this._23;
		m._24 = this._24;
		m._31 = this._31;
		m._32 = this._32;
		m._33 = this._33;
		m._34 = this._34;
		m._41 = this._41;
		m._42 = this._42;
		m._43 = this._43;
		m._44 = this._44;
		return m;
	}
	,load: function(m) {
		this._11 = m._11;
		this._12 = m._12;
		this._13 = m._13;
		this._14 = m._14;
		this._21 = m._21;
		this._22 = m._22;
		this._23 = m._23;
		this._24 = m._24;
		this._31 = m._31;
		this._32 = m._32;
		this._33 = m._33;
		this._34 = m._34;
		this._41 = m._41;
		this._42 = m._42;
		this._43 = m._43;
		this._44 = m._44;
	}
	,loadValues: function(a) {
		this._11 = a[0];
		this._12 = a[1];
		this._13 = a[2];
		this._14 = a[3];
		this._21 = a[4];
		this._22 = a[5];
		this._23 = a[6];
		this._24 = a[7];
		this._31 = a[8];
		this._32 = a[9];
		this._33 = a[10];
		this._34 = a[11];
		this._41 = a[12];
		this._42 = a[13];
		this._43 = a[14];
		this._44 = a[15];
	}
	,getFloats: function() {
		return [this._11,this._12,this._13,this._14,this._21,this._22,this._23,this._24,this._31,this._32,this._33,this._34,this._41,this._42,this._43,this._44];
	}
	,getDirection: function() {
		var q = new h3d_Quat();
		q.initRotateMatrix(this);
		q.normalize();
		var x = 1 - 2 * (q.y * q.y + q.z * q.z);
		var y = 2 * (q.x * q.y + q.z * q.w);
		var z = 2 * (q.x * q.z - q.y * q.w);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getEulerAngles: function() {
		var m = this.clone();
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(this._11 * this._11 + this._12 * this._12 + this._13 * this._13);
		s_y = Math.sqrt(this._21 * this._21 + this._22 * this._22 + this._23 * this._23);
		s_z = Math.sqrt(this._31 * this._31 + this._32 * this._32 + this._33 * this._33);
		if(this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		m.prependScale(1.0 / s_x,1.0 / s_y,1.0 / s_z);
		var cy = Math.sqrt(m._11 * m._11 + m._12 * m._12);
		if(cy > 0.01) {
			var x = Math.atan2(m._23,m._33);
			var y = Math.atan2(-m._13,cy);
			var z = Math.atan2(m._12,m._11);
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var v1 = new h3d_VectorImpl(x,y,z);
			var x = Math.atan2(-m._23,-m._33);
			var y = Math.atan2(-m._13,-cy);
			var z = Math.atan2(-m._12,-m._11);
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var v2 = new h3d_VectorImpl(x,y,z);
			var _this = v1;
			var _this1 = v2;
			if(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z < _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z) {
				return v1;
			} else {
				return v2;
			}
		} else {
			var x = Math.atan2(-m._32,m._22);
			var y = Math.atan2(-m._13,cy);
			var z = 0.0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h3d_VectorImpl(x,y,z);
		}
	}
	,toString: function() {
		return "MAT=[\n" + "  [ " + hxd_Math.fmt(this._11) + ", " + hxd_Math.fmt(this._12) + ", " + hxd_Math.fmt(this._13) + ", " + hxd_Math.fmt(this._14) + " ]\n" + "  [ " + hxd_Math.fmt(this._21) + ", " + hxd_Math.fmt(this._22) + ", " + hxd_Math.fmt(this._23) + ", " + hxd_Math.fmt(this._24) + " ]\n" + "  [ " + hxd_Math.fmt(this._31) + ", " + hxd_Math.fmt(this._32) + ", " + hxd_Math.fmt(this._33) + ", " + hxd_Math.fmt(this._34) + " ]\n" + "  [ " + hxd_Math.fmt(this._41) + ", " + hxd_Math.fmt(this._42) + ", " + hxd_Math.fmt(this._43) + ", " + hxd_Math.fmt(this._44) + " ]\n" + "]";
	}
	,colorHue: function(hue) {
		if(hue == 0.) {
			return;
		}
		var cosA = Math.cos(-hue);
		var sinA = Math.sin(-hue);
		var ch = (1 - cosA) / 3;
		var tmp = h3d_MatrixImpl.tmp;
		tmp._11 = cosA + ch;
		tmp._12 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._13 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._21 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._22 = cosA + ch;
		tmp._23 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._31 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._32 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._33 = cosA + ch;
		tmp._34 = 0;
		tmp._41 = 0;
		tmp._42 = 0;
		tmp._43 = 0;
		this.multiply3x4(this,tmp);
	}
	,colorSaturate: function(sat) {
		++sat;
		var ins = 1 - sat;
		var r = ins * 0.212671;
		var g = ins * 0.71516;
		var b = ins * 0.072169;
		var tmp = h3d_MatrixImpl.tmp;
		tmp._11 = r + sat;
		tmp._12 = r;
		tmp._13 = r;
		tmp._21 = g;
		tmp._22 = g + sat;
		tmp._23 = g;
		tmp._31 = b;
		tmp._32 = b;
		tmp._33 = b + sat;
		tmp._41 = 0;
		tmp._42 = 0;
		tmp._43 = 0;
		this.multiply3x4(this,tmp);
	}
	,colorContrast: function(contrast) {
		var tmp = h3d_MatrixImpl.tmp;
		var v = contrast + 1;
		tmp._11 = v;
		tmp._12 = 0;
		tmp._13 = 0;
		tmp._21 = 0;
		tmp._22 = v;
		tmp._23 = 0;
		tmp._31 = 0;
		tmp._32 = 0;
		tmp._33 = v;
		tmp._41 = -contrast * 0.5;
		tmp._42 = -contrast * 0.5;
		tmp._43 = -contrast * 0.5;
		this.multiply3x4(this,tmp);
	}
	,colorLightness: function(lightness) {
		this._41 += lightness;
		this._42 += lightness;
		this._43 += lightness;
	}
	,colorGain: function(color,alpha) {
		var tmp = h3d_MatrixImpl.tmp;
		tmp._11 = 1 - alpha;
		tmp._12 = 0;
		tmp._13 = 0;
		tmp._21 = 0;
		tmp._22 = 1 - alpha;
		tmp._23 = 0;
		tmp._31 = 0;
		tmp._32 = 0;
		tmp._33 = 1 - alpha;
		tmp._41 = (color >> 16 & 255) / 255 * alpha;
		tmp._42 = (color >> 8 & 255) / 255 * alpha;
		tmp._43 = (color & 255) / 255 * alpha;
		this.multiply3x4(this,tmp);
	}
	,colorBits: function(bits,blend) {
		var t11 = 0.;
		var t12 = 0.;
		var t13 = 0.;
		var t21 = 0.;
		var t22 = 0.;
		var t23 = 0.;
		var t31 = 0.;
		var t32 = 0.;
		var t33 = 0.;
		var c = bits;
		if((c & 1) == 1) {
			t11 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t12 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t13 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t21 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t22 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t23 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t31 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t32 = 1;
		}
		c >>= 1;
		if((c & 1) == 1) {
			t33 = 1;
		}
		c >>= 1;
		var r = t11 + t21 + t31;
		var g = t12 + t22 + t32;
		var b = t13 + t23 + t33;
		if(r > 1) {
			t11 /= r;
			t21 /= r;
			t31 /= r;
		}
		if(g > 1) {
			t12 /= g;
			t22 /= g;
			t32 /= g;
		}
		if(b > 1) {
			t13 /= b;
			t23 /= b;
			t33 /= b;
		}
		var b11 = this._11 * t11 + this._12 * t21 + this._13 * t31;
		var b12 = this._11 * t12 + this._12 * t22 + this._13 * t32;
		var b13 = this._11 * t13 + this._12 * t23 + this._13 * t33;
		var b21 = this._21 * t11 + this._22 * t21 + this._23 * t31;
		var b22 = this._21 * t12 + this._22 * t22 + this._23 * t32;
		var b23 = this._21 * t13 + this._22 * t23 + this._23 * t33;
		var b31 = this._31 * t11 + this._32 * t21 + this._33 * t31;
		var b32 = this._31 * t12 + this._32 * t22 + this._33 * t32;
		var b33 = this._31 * t13 + this._32 * t23 + this._33 * t33;
		var ik = blend;
		var k = 1 - ik;
		this._11 = this._11 * k + b11 * ik;
		this._12 = this._12 * k + b12 * ik;
		this._13 = this._13 * k + b13 * ik;
		this._21 = this._21 * k + b21 * ik;
		this._22 = this._22 * k + b22 * ik;
		this._23 = this._23 * k + b23 * ik;
		this._31 = this._31 * k + b31 * ik;
		this._32 = this._32 * k + b32 * ik;
		this._33 = this._33 * k + b33 * ik;
	}
	,colorAdd: function(c) {
		this._41 += (c >> 16 & 255) / 255;
		this._42 += (c >> 8 & 255) / 255;
		this._43 += (c & 255) / 255;
	}
	,colorSet: function(c,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.zero();
		this._44 = alpha;
		this._41 += (c >> 16 & 255) / 255;
		this._42 += (c >> 8 & 255) / 255;
		this._43 += (c & 255) / 255;
	}
	,adjustColor: function(col) {
		if(col.hue != null) {
			this.colorHue(col.hue);
		}
		if(col.saturation != null) {
			this.colorSaturate(col.saturation);
		}
		if(col.contrast != null) {
			this.colorContrast(col.contrast);
		}
		if(col.lightness != null) {
			this.colorLightness(col.lightness);
		}
		if(col.gain != null) {
			this.colorGain(col.gain.color,col.gain.alpha);
		}
	}
	,toMatrix2D: function(m) {
		if(m == null) {
			m = new h2d_col_Matrix();
		}
		m.a = this._11;
		m.b = this._12;
		m.c = this._21;
		m.d = this._22;
		m.x = this._41;
		m.y = this._42;
		return m;
	}
	,__class__: h3d_MatrixImpl
};
var h3d_Matrix = {};
h3d_Matrix._new = function() {
	return new h3d_MatrixImpl();
};
h3d_Matrix.multiplied = function(this1,m) {
	var mout = new h3d_MatrixImpl();
	mout.multiply(this1,m);
	return mout;
};
h3d_Matrix.I = function() {
	var m = new h3d_MatrixImpl();
	m.identity();
	return m;
};
h3d_Matrix.L = function(a) {
	var m = new h3d_MatrixImpl();
	m.loadValues(a);
	return m;
};
h3d_Matrix.T = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var m = new h3d_MatrixImpl();
	m.initTranslation(x,y,z);
	return m;
};
h3d_Matrix.R = function(x,y,z) {
	var m = new h3d_MatrixImpl();
	m.initRotation(x,y,z);
	return m;
};
h3d_Matrix.S = function(x,y,z) {
	if(z == null) {
		z = 1.0;
	}
	if(y == null) {
		y = 1.;
	}
	if(x == null) {
		x = 1.;
	}
	var m = new h3d_MatrixImpl();
	m.initScale(x,y,z);
	return m;
};
h3d_Matrix.lookAtX = function(dir,up,m) {
	if(up == null) {
		var x = 0;
		var y = 0;
		var z = 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		up = new h3d_VectorImpl(x,y,z);
	}
	if(m == null) {
		m = new h3d_MatrixImpl();
	}
	var _this = dir;
	var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
	if(k < 1e-20) {
		k = 0;
	} else {
		k = 1. / Math.sqrt(k);
	}
	var x = _this.x * k;
	var y = _this.y * k;
	var z = _this.z * k;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	var _this = up;
	var x = _this.y * _this_z - _this.z * _this_y;
	var y = _this.z * _this_x - _this.x * _this_z;
	var z = _this.x * _this_y - _this.y * _this_x;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x1 = x1;
	var _this_y1 = y1;
	var _this_z1 = z1;
	var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
	if(k < 1e-20) {
		k = 0;
	} else {
		k = 1. / Math.sqrt(k);
	}
	var x = _this_x1 * k;
	var y = _this_y1 * k;
	var z = _this_z1 * k;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x1 = x1;
	var _this_y1 = y1;
	var _this_z1 = z1;
	if(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1 < 1e-20) {
		_this_x1 = _this_y;
		_this_y1 = _this_z;
		_this_z1 = _this_x;
	}
	var x = _this_y * _this_z1 - _this_z * _this_y1;
	var y = _this_z * _this_x1 - _this_x * _this_z1;
	var z = _this_x * _this_y1 - _this_y * _this_x1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var az_x = x1;
	var az_y = y1;
	var az_z = z1;
	m._11 = _this_x;
	m._12 = _this_y;
	m._13 = _this_z;
	m._14 = 0;
	m._21 = _this_x1;
	m._22 = _this_y1;
	m._23 = _this_z1;
	m._24 = 0;
	m._31 = az_x;
	m._32 = az_y;
	m._33 = az_z;
	m._34 = 0;
	m._41 = 0;
	m._42 = 0;
	m._43 = 0;
	m._44 = 1;
	return m;
};
var h3d_Quat = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["h3d.Quat"] = h3d_Quat;
h3d_Quat.__name__ = "h3d.Quat";
h3d_Quat.prototype = {
	set: function(x,y,z,w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	,identity: function() {
		this.x = this.y = this.z = 0;
		this.w = 1;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	,load: function(q) {
		this.x = q.x;
		this.y = q.y;
		this.z = q.z;
		this.w = q.w;
	}
	,clone: function() {
		return new h3d_Quat(this.x,this.y,this.z,this.w);
	}
	,initMoveTo: function(from,to) {
		var hx = from.x + to.x;
		var hy = from.y + to.y;
		var hz = from.z + to.z;
		var h = 1. / Math.sqrt(hx * hx + hy * hy + hz * hz);
		this.x = from.y * hz - from.z * hy;
		this.y = from.z * hx - from.x * hz;
		this.z = from.x * hy - from.y * hx;
		this.w = from.x * hx + from.y * hy + from.z * hz;
		this.normalize();
	}
	,initNormal: function(dir) {
		var _this = dir;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this.x * k;
		var y = _this.y * k;
		var z = _this.z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		if(_this_x * _this_x + _this_y * _this_y < 1e-20) {
			var x = 1;
			var y = 0;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			this.initDirection(new h3d_VectorImpl(x,y,z));
		} else {
			var x = _this_x;
			var y = _this_y;
			var z = 0;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x1 = x1;
			var _this_y1 = y1;
			var _this_z1 = z1;
			var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			var x = _this_x1 * k;
			var y = _this_y1 * k;
			var z = _this_z1 * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var ay_x = x1;
			var ay_y = y1;
			var ay_z = z1;
			var x = _this_y * ay_z - _this_z * ay_y;
			var y = _this_z * ay_x - _this_x * ay_z;
			var z = _this_x * ay_y - _this_y * ay_x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var az_x = x1;
			var az_y = y1;
			var az_z = z1;
			var x = _this_y * az_z - _this_z * az_y;
			var y = _this_z * az_x - _this_x * az_z;
			var z = _this_x * az_y - _this_y * az_x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var this_x = x1;
			var this_y = y1;
			var this_z = z1;
			var x = this_x;
			var y = this_y;
			var z = this_z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			this.initDirection(new h3d_VectorImpl(x,y,z));
		}
	}
	,initDirection: function(dir,up) {
		var _this = dir;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = _this_x * k;
		var y = _this_y * k;
		var z = _this_z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = -_this_y;
		var y = _this_x;
		var z = 0;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		if(up != null) {
			var _this = up;
			var x = _this.y * _this_z - _this.z * _this_y;
			var y = _this.z * _this_x - _this.x * _this_z;
			var z = _this.x * _this_y - _this.y * _this_x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var v_x = x1;
			var v_y = y1;
			var v_z = z1;
			_this_x1 = v_x;
			_this_y1 = v_y;
			_this_z1 = v_z;
		}
		var k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this_x1 *= k;
		_this_y1 *= k;
		_this_z1 *= k;
		if(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1 < 1e-20) {
			_this_x1 = _this_y;
			_this_y1 = _this_z;
			_this_z1 = _this_x;
		}
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var az_x = x1;
		var az_y = y1;
		var az_z = z1;
		var tr = _this_x + _this_y1 + az_z;
		if(tr > 0) {
			var s = Math.sqrt(tr + 1.0) * 2;
			var ins = 1 / s;
			this.x = (_this_z1 - az_y) * ins;
			this.y = (az_x - _this_z) * ins;
			this.z = (_this_y - _this_x1) * ins;
			this.w = 0.25 * s;
		} else if(_this_x > _this_y1 && _this_x > az_z) {
			var s = Math.sqrt(1.0 + _this_x - _this_y1 - az_z) * 2;
			var ins = 1 / s;
			this.x = 0.25 * s;
			this.y = (_this_x1 + _this_y) * ins;
			this.z = (az_x + _this_z) * ins;
			this.w = (_this_z1 - az_y) * ins;
		} else if(_this_y1 > az_z) {
			var s = Math.sqrt(1.0 + _this_y1 - _this_x - az_z) * 2;
			var ins = 1 / s;
			this.x = (_this_x1 + _this_y) * ins;
			this.y = 0.25 * s;
			this.z = (az_y + _this_z1) * ins;
			this.w = (az_x - _this_z) * ins;
		} else {
			var s = Math.sqrt(1.0 + az_z - _this_x - _this_y1) * 2;
			var ins = 1 / s;
			this.x = (az_x + _this_z) * ins;
			this.y = (az_y + _this_z1) * ins;
			this.z = 0.25 * s;
			this.w = (_this_y - _this_x1) * ins;
		}
	}
	,initRotateAxis: function(x,y,z,a) {
		var sin = Math.sin(a / 2);
		var cos = Math.cos(a / 2);
		this.x = x * sin;
		this.y = y * sin;
		this.z = z * sin;
		this.w = cos * Math.sqrt(x * x + y * y + z * z);
		this.normalize();
	}
	,initRotateMatrix: function(m) {
		var tr = m._11 + m._22 + m._33;
		if(tr > 0) {
			var s = Math.sqrt(tr + 1.0) * 2;
			var ins = 1 / s;
			this.x = (m._23 - m._32) * ins;
			this.y = (m._31 - m._13) * ins;
			this.z = (m._12 - m._21) * ins;
			this.w = 0.25 * s;
		} else if(m._11 > m._22 && m._11 > m._33) {
			var s = Math.sqrt(1.0 + m._11 - m._22 - m._33) * 2;
			var ins = 1 / s;
			this.x = 0.25 * s;
			this.y = (m._21 + m._12) * ins;
			this.z = (m._31 + m._13) * ins;
			this.w = (m._23 - m._32) * ins;
		} else if(m._22 > m._33) {
			var s = Math.sqrt(1.0 + m._22 - m._11 - m._33) * 2;
			var ins = 1 / s;
			this.x = (m._21 + m._12) * ins;
			this.y = 0.25 * s;
			this.z = (m._32 + m._23) * ins;
			this.w = (m._31 - m._13) * ins;
		} else {
			var s = Math.sqrt(1.0 + m._33 - m._11 - m._22) * 2;
			var ins = 1 / s;
			this.x = (m._31 + m._13) * ins;
			this.y = (m._32 + m._23) * ins;
			this.z = 0.25 * s;
			this.w = (m._12 - m._21) * ins;
		}
	}
	,normalize: function() {
		var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		if(len < 1e-20) {
			this.x = this.y = this.z = 0;
			this.w = 1;
		} else {
			var m = 1. / Math.sqrt(len);
			this.x *= m;
			this.y *= m;
			this.z *= m;
			this.w *= m;
		}
	}
	,initRotation: function(ax,ay,az) {
		var sinX = Math.sin(ax * 0.5);
		var cosX = Math.cos(ax * 0.5);
		var sinY = Math.sin(ay * 0.5);
		var cosY = Math.cos(ay * 0.5);
		var sinZ = Math.sin(az * 0.5);
		var cosZ = Math.cos(az * 0.5);
		var cosYZ = cosY * cosZ;
		var sinYZ = sinY * sinZ;
		this.x = sinX * cosYZ - cosX * sinYZ;
		this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
		this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
		this.w = cosX * cosYZ + sinX * sinYZ;
	}
	,multiply: function(q1,q2) {
		var x2 = q1.x * q2.w + q1.w * q2.x + q1.y * q2.z - q1.z * q2.y;
		var y2 = q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x;
		var z2 = q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w;
		var w2 = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
		this.x = x2;
		this.y = y2;
		this.z = z2;
		this.w = w2;
	}
	,toEuler: function() {
		return this.toMatrix().getEulerAngles();
	}
	,lerp: function(q1,q2,v,nearest) {
		if(nearest == null) {
			nearest = false;
		}
		var v2 = 1 - v;
		if(nearest && q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w < 0) {
			v = -v;
		}
		var x = q1.x * v2 + q2.x * v;
		var y = q1.y * v2 + q2.y * v;
		var z = q1.z * v2 + q2.z * v;
		var w = q1.w * v2 + q2.w * v;
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	,slerp: function(q1,q2,v) {
		var cosHalfTheta = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
		if((cosHalfTheta < 0 ? -cosHalfTheta : cosHalfTheta) >= 1) {
			this.x = q1.x;
			this.y = q1.y;
			this.z = q1.z;
			this.w = q1.w;
			return;
		}
		var halfTheta = Math.acos(cosHalfTheta);
		var invSinHalfTheta = 1. / Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
		if((invSinHalfTheta < 0 ? -invSinHalfTheta : invSinHalfTheta) > 1e3) {
			var v1 = 0.5;
			var nearest = true;
			if(nearest == null) {
				nearest = false;
			}
			var v2 = 1 - v1;
			if(nearest && q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w < 0) {
				v1 = -v1;
			}
			var x = q1.x * v2 + q2.x * v1;
			var y = q1.y * v2 + q2.y * v1;
			var z = q1.z * v2 + q2.z * v1;
			var w = q1.w * v2 + q2.w * v1;
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return;
		}
		var a = Math.sin((1 - v) * halfTheta) * invSinHalfTheta;
		var b = Math.sin(v * halfTheta) * invSinHalfTheta * (cosHalfTheta < 0 ? -1 : 1);
		this.x = q1.x * a + q2.x * b;
		this.y = q1.y * a + q2.y * b;
		this.z = q1.z * a + q2.z * b;
		this.w = q1.w * a + q2.w * b;
	}
	,conjugate: function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
	}
	,pow: function(v) {
		var r = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		var t = r > 1e-10 ? Math.atan2(r,this.w) / r : 0;
		this.w = 0.5 * Math.log(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
		this.x *= t;
		this.y *= t;
		this.z *= t;
		this.x *= v;
		this.y *= v;
		this.z *= v;
		this.w *= v;
		var r = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		var et = Math.exp(this.w);
		var s = r > 1e-10 ? et * Math.sin(r) / r : 0;
		this.w = et * Math.cos(r);
		this.x *= s;
		this.y *= s;
		this.z *= s;
	}
	,negate: function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
	}
	,dot: function(q) {
		return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;
	}
	,getDirection: function() {
		var x = 1 - 2 * (this.y * this.y + this.z * this.z);
		var y = 2 * (this.x * this.y + this.z * this.w);
		var z = 2 * (this.x * this.z - this.y * this.w);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getUpAxis: function() {
		var x = 2 * (this.x * this.z + this.y * this.w);
		var y = 2 * (this.y * this.z - this.x * this.w);
		var z = 1 - 2 * (this.x * this.x + this.y * this.y);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toMatrix: function(m) {
		if(m == null) {
			m = new h3d_MatrixImpl();
		}
		var xx = this.x * this.x;
		var xy = this.x * this.y;
		var xz = this.x * this.z;
		var xw = this.x * this.w;
		var yy = this.y * this.y;
		var yz = this.y * this.z;
		var yw = this.y * this.w;
		var zz = this.z * this.z;
		var zw = this.z * this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		return m;
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "," + hxd_Math.fmt(this.w) + "}";
	}
	,__class__: h3d_Quat
};
var h3d_VectorImpl = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["h3d.VectorImpl"] = h3d_VectorImpl;
h3d_VectorImpl.__name__ = "h3d.VectorImpl";
h3d_VectorImpl.prototype = {
	distance: function(v) {
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		var dz = v.z - this.z;
		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	}
	,distanceSq: function(v) {
		var dx = v.x - this.x;
		var dy = v.y - this.y;
		var dz = v.z - this.z;
		return dx * dx + dy * dy + dz * dz;
	}
	,sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		var z = this.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		var z = this.z + v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,scaled: function(v) {
		var x = this.x * v;
		var y = this.y * v;
		var z = this.z * v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,equals: function(v) {
		if(this.x == v.x && this.y == v.y) {
			return this.z == v.z;
		} else {
			return false;
		}
	}
	,cross: function(v) {
		var x = this.y * v.z - this.z * v.y;
		var y = this.z * v.x - this.x * v.z;
		var z = this.x * v.y - this.y * v.x;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,dot: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}
	,lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	,length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	,normalize: function() {
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		this.x *= k;
		this.y *= k;
		this.z *= k;
	}
	,normalized: function() {
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		var x = this.x * k;
		var y = this.y * k;
		var z = this.z * k;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,packNormal: function() {
		this.x = this.x * 0.5 + 0.5;
		this.y = this.y * 0.5 + 0.5;
		this.z = this.z * 0.5 + 0.5;
	}
	,unpackNormal: function() {
		this.x = this.x * 2.0 - 1.0;
		this.y = this.y * 2.0 - 1.0;
		this.z = this.z * 2.0 - 1.0;
	}
	,normalStrength: function(strength) {
		var k = 1.0 / strength;
		this.x *= k;
		this.y *= k;
		var k = this.x * this.x + this.y * this.y + this.z * this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		this.x *= k;
		this.y *= k;
		this.z *= k;
	}
	,set: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
	,load: function(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
	}
	,scale: function(f) {
		this.x *= f;
		this.y *= f;
		this.z *= f;
	}
	,lerp: function(v1,v2,k) {
		var a = v1.x;
		this.x = a + k * (v2.x - a);
		var a = v1.y;
		this.y = a + k * (v2.y - a);
		var a = v1.z;
		this.z = a + k * (v2.z - a);
	}
	,transform: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + m._43;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + m._43;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,transform3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,clone: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toVector4: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,1.);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "}";
	}
	,reflect: function(n) {
		var k = 2 * (this.x * n.x + this.y * n.y + this.z * n.z);
		var x = this.x - k * n.x;
		var y = this.y - k * n.y;
		var z = this.z - k * n.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,project: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + m._43;
		var iw = 1 / (this.x * m._14 + this.y * m._24 + this.z * m._34 + m._44);
		this.x = px * iw;
		this.y = py * iw;
		this.z = pz * iw;
	}
	,get_r: function() {
		return this.x;
	}
	,get_g: function() {
		return this.y;
	}
	,get_b: function() {
		return this.z;
	}
	,set_r: function(v) {
		return this.x = v;
	}
	,set_g: function(v) {
		return this.y = v;
	}
	,set_b: function(v) {
		return this.z = v;
	}
	,setColor: function(c) {
		this.x = (c >> 16 & 255) / 255;
		this.y = (c >> 8 & 255) / 255;
		this.z = (c & 255) / 255;
	}
	,makeColor: function(hue,saturation,brightness) {
		if(brightness == null) {
			brightness = 0.5;
		}
		if(saturation == null) {
			saturation = 1.;
		}
		var r = hue % 6.28318530717958623;
		hue = r >= 0 ? r : r + 6.28318530717958623;
		var f = 2 * brightness - 1;
		var c = (1 - (f < 0 ? -f : f)) * saturation;
		var f = hue * 3 / 3.14159265358979323 % 2. - 1;
		var x = c * (1 - (f < 0 ? -f : f));
		var m = brightness - c / 2;
		if(hue < 1.04719755119659763) {
			this.x = c;
			this.y = x;
			this.z = 0;
		} else if(hue < 2.09439510239319526) {
			this.x = x;
			this.y = c;
			this.z = 0;
		} else if(hue < 3.14159265358979323) {
			this.x = 0;
			this.y = c;
			this.z = x;
		} else if(hue < 4.18879020478639053) {
			this.x = 0;
			this.y = x;
			this.z = c;
		} else if(hue < 5.23598775598298882) {
			this.x = x;
			this.y = 0;
			this.z = c;
		} else {
			this.x = c;
			this.y = 0;
			this.z = x;
		}
		this.x += m;
		this.y += m;
		this.z += m;
	}
	,toColor: function() {
		var f = this.x;
		var f1 = this.y;
		var f2 = this.z;
		return -16777216 | ((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 16 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 8 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0);
	}
	,toColorHSL: function() {
		var a = this.x;
		var b = this.y;
		var a1 = a < b ? b : a;
		var b = this.z;
		var max = a1 < b ? b : a1;
		var a = this.x;
		var b = this.y;
		var a1 = a > b ? b : a;
		var b = this.z;
		var min = a1 > b ? b : a1;
		var h;
		var s;
		var l = (max + min) / 2.0;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			if(max == this.x) {
				h = (this.y - this.z) / d + (this.y < this.z ? 6.0 : 0.0);
			} else if(max == this.y) {
				h = (this.z - this.x) / d + 2.0;
			} else {
				h = (this.x - this.y) / d + 4.0;
			}
			h *= 1.04719755119659763;
		}
		var x = h;
		var y = s;
		var z = l;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,__class__: h3d_VectorImpl
};
var h3d_Vector = {};
h3d_Vector._new = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.sub = function(this1,v) {
	var x = this1.x - v.x;
	var y = this1.y - v.y;
	var z = this1.z - v.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.add = function(this1,v) {
	var x = this1.x + v.x;
	var y = this1.y + v.y;
	var z = this1.z + v.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.transform = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
	this1.x = px;
	this1.y = py;
	this1.z = pz;
};
h3d_Vector.transformed = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + m._43;
	var x = px;
	var y = py;
	var z = pz;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.toPoint = function(this1) {
	var x = this1.x;
	var y = this1.y;
	var z = this1.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.toVector = function(this1) {
	var x = this1.x;
	var y = this1.y;
	var z = this1.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.scale = function(this1,v) {
	this1.x *= v;
	this1.y *= v;
	this1.z *= v;
};
h3d_Vector.scaled = function(this1,v) {
	var x = this1.x * v;
	var y = this1.y * v;
	var z = this1.z * v;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.scaledInv = function(f,v) {
	var x = v.x * f;
	var y = v.y * f;
	var z = v.z * f;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.fromColor = function(c,scale) {
	if(scale == null) {
		scale = 1.0;
	}
	var s = scale / 255;
	var x = (c >> 16 & 255) * s;
	var y = (c >> 8 & 255) * s;
	var z = (c & 255) * s;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_VectorImpl(x,y,z);
};
h3d_Vector.fromArray = function(a) {
	var r = new h3d_VectorImpl(0.,0.,0.);
	if(a.length > 0) {
		r.x = a[0];
	}
	if(a.length > 1) {
		r.y = a[1];
	}
	if(a.length > 2) {
		r.z = a[2];
	}
	return r;
};
var h3d_Vector4Impl = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
	this.w = w;
};
$hxClasses["h3d.Vector4Impl"] = h3d_Vector4Impl;
h3d_Vector4Impl.__name__ = "h3d.Vector4Impl";
h3d_Vector4Impl.prototype = {
	dot4: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	}
	,dot3: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}
	,scale3: function(f) {
		this.x *= f;
		this.y *= f;
		this.z *= f;
	}
	,sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		var z = this.z - v.z;
		var w = this.w - v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		var z = this.z + v.z;
		var w = this.w + v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,equals: function(v) {
		if(this.x == v.x && this.y == v.y && this.z == v.z) {
			return this.w == v.w;
		} else {
			return false;
		}
	}
	,cross: function(v) {
		var x = this.y * v.z - this.z * v.y;
		var y = this.z * v.x - this.x * v.z;
		var z = this.x * v.y - this.y * v.x;
		var w = 1;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,set: function(x,y,z,w) {
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	,load: function(v) {
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = v.w;
	}
	,lerp: function(v1,v2,k) {
		var a = v1.x;
		this.x = a + k * (v2.x - a);
		var a = v1.y;
		this.y = a + k * (v2.y - a);
		var a = v1.z;
		this.z = a + k * (v2.z - a);
		var a = v1.w;
		this.w = a + k * (v2.w - a);
	}
	,transform: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var pw = this.x * m._14 + this.y * m._24 + this.z * m._34 + this.w * m._44;
		this.x = px;
		this.y = py;
		this.z = pz;
		this.w = pw;
	}
	,transformed: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var pw = this.x * m._14 + this.y * m._24 + this.z * m._34 + this.w * m._44;
		var x = px;
		var y = py;
		var z = pz;
		var w = pw;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,transform3x4: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed3x4: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,1.);
	}
	,transform3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		this.x = px;
		this.y = py;
		this.z = pz;
	}
	,transformed3x3: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33;
		var x = px;
		var y = py;
		var z = pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,1.);
	}
	,clone: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,toVector: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "," + hxd_Math.fmt(this.w) + "}";
	}
	,project: function(m) {
		var px = this.x * m._11 + this.y * m._21 + this.z * m._31 + this.w * m._41;
		var py = this.x * m._12 + this.y * m._22 + this.z * m._32 + this.w * m._42;
		var pz = this.x * m._13 + this.y * m._23 + this.z * m._33 + this.w * m._43;
		var iw = 1 / (this.x * m._14 + this.y * m._24 + this.z * m._34 + this.w * m._44);
		this.x = px * iw;
		this.y = py * iw;
		this.z = pz * iw;
		this.w = 1;
	}
	,get_r: function() {
		return this.x;
	}
	,get_g: function() {
		return this.y;
	}
	,get_b: function() {
		return this.z;
	}
	,get_a: function() {
		return this.w;
	}
	,set_r: function(v) {
		return this.x = v;
	}
	,set_g: function(v) {
		return this.y = v;
	}
	,set_b: function(v) {
		return this.z = v;
	}
	,set_a: function(v) {
		return this.w = v;
	}
	,setColor: function(c) {
		this.x = (c >> 16 & 255) / 255;
		this.y = (c >> 8 & 255) / 255;
		this.z = (c & 255) / 255;
		this.w = (c >>> 24) / 255;
	}
	,makeColor: function(hue,saturation,brightness) {
		if(brightness == null) {
			brightness = 0.5;
		}
		if(saturation == null) {
			saturation = 1.;
		}
		var r = hue % 6.28318530717958623;
		hue = r >= 0 ? r : r + 6.28318530717958623;
		var f = 2 * brightness - 1;
		var c = (1 - (f < 0 ? -f : f)) * saturation;
		var f = hue * 3 / 3.14159265358979323 % 2. - 1;
		var x = c * (1 - (f < 0 ? -f : f));
		var m = brightness - c / 2;
		if(hue < 1.04719755119659763) {
			this.x = c;
			this.y = x;
			this.z = 0;
		} else if(hue < 2.09439510239319526) {
			this.x = x;
			this.y = c;
			this.z = 0;
		} else if(hue < 3.14159265358979323) {
			this.x = 0;
			this.y = c;
			this.z = x;
		} else if(hue < 4.18879020478639053) {
			this.x = 0;
			this.y = x;
			this.z = c;
		} else if(hue < 5.23598775598298882) {
			this.x = x;
			this.y = 0;
			this.z = c;
		} else {
			this.x = c;
			this.y = 0;
			this.z = x;
		}
		this.x += m;
		this.y += m;
		this.z += m;
		this.w = 1;
	}
	,toColor: function() {
		var f = this.w;
		var f1 = this.x;
		var f2 = this.y;
		var f3 = this.z;
		return ((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 24 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 16 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0) << 8 | ((f3 < 0. ? 0. : f3 > 1. ? 1. : f3) * 255 + 0.499 | 0);
	}
	,toColorHSL: function() {
		var a = this.x;
		var b = this.y;
		var a1 = a < b ? b : a;
		var b = this.z;
		var max = a1 < b ? b : a1;
		var a = this.x;
		var b = this.y;
		var a1 = a > b ? b : a;
		var b = this.z;
		var min = a1 > b ? b : a1;
		var h;
		var s;
		var l = (max + min) / 2.0;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			if(max == this.x) {
				h = (this.y - this.z) / d + (this.y < this.z ? 6.0 : 0.0);
			} else if(max == this.y) {
				h = (this.z - this.x) / d + 2.0;
			} else {
				h = (this.x - this.y) / d + 4.0;
			}
			h *= 1.04719755119659763;
		}
		var x = h;
		var y = s;
		var z = l;
		var w = this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_Vector4Impl(x,y,z,w);
	}
	,__class__: h3d_Vector4Impl
};
var h3d_Vector4 = {};
h3d_Vector4._new = function(x,y,z,w) {
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.sub = function(this1,v) {
	var x = this1.x - v.x;
	var y = this1.y - v.y;
	var z = this1.z - v.z;
	var w = this1.w - v.w;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.add = function(this1,v) {
	var x = this1.x + v.x;
	var y = this1.y + v.y;
	var z = this1.z + v.z;
	var w = this1.w + v.w;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.transform = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + this1.w * m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + this1.w * m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + this1.w * m._43;
	var pw = this1.x * m._14 + this1.y * m._24 + this1.z * m._34 + this1.w * m._44;
	this1.x = px;
	this1.y = py;
	this1.z = pz;
	this1.w = pw;
};
h3d_Vector4.transformed = function(this1,m) {
	var px = this1.x * m._11 + this1.y * m._21 + this1.z * m._31 + this1.w * m._41;
	var py = this1.x * m._12 + this1.y * m._22 + this1.z * m._32 + this1.w * m._42;
	var pz = this1.x * m._13 + this1.y * m._23 + this1.z * m._33 + this1.w * m._43;
	var pw = this1.x * m._14 + this1.y * m._24 + this1.z * m._34 + this1.w * m._44;
	var x = px;
	var y = py;
	var z = pz;
	var w = pw;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.fromColor = function(c,scale) {
	if(scale == null) {
		scale = 1.0;
	}
	var s = scale / 255;
	var x = (c >> 16 & 255) * s;
	var y = (c >> 8 & 255) * s;
	var z = (c & 255) * s;
	var w = (c >>> 24) * s;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	return new h3d_Vector4Impl(x,y,z,w);
};
h3d_Vector4.fromArray = function(a) {
	var r = new h3d_Vector4Impl(0.,0.,0.,1.);
	if(a.length > 0) {
		r.x = a[0];
	}
	if(a.length > 1) {
		r.y = a[1];
	}
	if(a.length > 2) {
		r.z = a[2];
	}
	if(a.length > 3) {
		r.w = a[3];
	}
	return r;
};
var h3d_anim_AnimatedObject = function(name) {
	this.objectName = name;
};
$hxClasses["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject;
h3d_anim_AnimatedObject.__name__ = "h3d.anim.AnimatedObject";
h3d_anim_AnimatedObject.prototype = {
	clone: function() {
		return new h3d_anim_AnimatedObject(this.objectName);
	}
	,__class__: h3d_anim_AnimatedObject
};
var h3d_anim_Animation = function(name,frameCount,sampling) {
	this.name = name;
	this.frameCount = frameCount;
	this.sampling = sampling;
	this.objects = [];
	this.lastEvent = -1;
	this.frame = 0.;
	this.speed = 1.;
	this.loop = true;
	this.pause = false;
};
$hxClasses["h3d.anim.Animation"] = h3d_anim_Animation;
h3d_anim_Animation.__name__ = "h3d.anim.Animation";
h3d_anim_Animation.prototype = {
	getDuration: function() {
		return this.frameCount / (this.sampling * this.speed);
	}
	,frameToTime: function(f) {
		return f / (this.sampling * this.speed);
	}
	,getIFrame: function() {
		var f = this.frame | 0;
		var max = this.endFrame();
		if(f == max) {
			--f;
		}
		return f;
	}
	,unbind: function(objectName) {
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.objectName == objectName) {
				this.isSync = false;
				o.targetObject = null;
				o.targetSkin = null;
				return;
			}
		}
	}
	,setEvents: function(el) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.frameCount;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(null);
		}
		this.events = _g;
		var e = $getIterator(el);
		while(e.hasNext()) {
			var e1 = e.next();
			if(this.events[e1.frame] == null) {
				this.events[e1.frame] = [];
			}
			this.events[e1.frame].push(e1.data);
		}
	}
	,addEvent: function(frame,data) {
		if(this.events == null) {
			this.events = [];
		}
		if(this.events[frame] == null) {
			this.events[frame] = [data];
		} else {
			this.events[frame].push(data);
		}
	}
	,getEvents: function() {
		return this.events;
	}
	,getObjects: function() {
		return this.objects;
	}
	,getEventTime: function(id) {
		if(this.events == null) {
			return null;
		}
		var _g = 0;
		var _g1 = this.events.length;
		while(_g < _g1) {
			var i = _g++;
			var ev = this.events[i];
			if(ev != null && ev.indexOf(id) >= 0) {
				return i / (this.sampling * this.speed);
			}
		}
		return null;
	}
	,setFrame: function(f) {
		this.frame = f;
		this.lastEvent = -1;
		while(this.frame < 0) this.frame += this.frameCount;
		while(this.frame > this.frameCount) this.frame -= this.frameCount;
	}
	,clone: function(a) {
		if(a == null) {
			a = new h3d_anim_Animation(this.name,this.frameCount,this.sampling);
		}
		a.objects = this.objects;
		a.speed = this.speed;
		a.loop = this.loop;
		a.pause = this.pause;
		a.events = this.events;
		a.resourcePath = this.resourcePath;
		return a;
	}
	,initInstance: function() {
		this.isInstance = true;
	}
	,createInstance: function(base) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.objects;
		while(_g1 < _g2.length) {
			var a = _g2[_g1];
			++_g1;
			_g.push(a.clone());
		}
		var objects = _g;
		var a = this.clone();
		a.objects = objects;
		a.bind(base);
		a.initInstance();
		return a;
	}
	,bind: function(base) {
		var currentSkin = null;
		var _g = 0;
		var _g1 = this.objects.slice();
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(currentSkin != null) {
				var j = currentSkin.skinData.namedJoints.h[a.objectName];
				if(j != null) {
					a.targetSkin = currentSkin;
					a.targetJoint = j.index;
					continue;
				}
			}
			var obj = base.getObjectByName(a.objectName);
			if(obj == null) {
				HxOverrides.remove(this.objects,a);
				continue;
			}
			var joint = ((obj) instanceof h3d_scene_Joint) ? obj : null;
			if(joint != null) {
				currentSkin = joint.parent;
				a.targetSkin = currentSkin != null ? currentSkin : joint.skin;
				a.targetJoint = joint.index;
			} else {
				a.targetObject = obj;
			}
		}
		this.isSync = false;
	}
	,getPropValue: function(objectName,propName) {
		return null;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		throw haxe_Exception.thrown("assert");
	}
	,isPlaying: function() {
		if(!this.pause) {
			return (this.speed < 0 ? -this.speed : this.speed) > 0.000001;
		} else {
			return false;
		}
	}
	,endFrame: function() {
		return this.frameCount;
	}
	,update: function(dt) {
		if(!this.isInstance) {
			throw haxe_Exception.thrown("You must instantiate this animation first");
		}
		if(!this.isPlaying()) {
			return 0;
		}
		if(this.events != null && this.onEvent != null) {
			var f0 = this.frame | 0;
			var f1 = this.frame + dt * this.speed * this.sampling | 0;
			if(f1 >= this.frameCount) {
				f1 = this.frameCount - 1;
			}
			var _g = f0;
			var _g1 = f1 + 1;
			while(_g < _g1) {
				var f = _g++;
				if(f == this.lastEvent) {
					continue;
				}
				this.lastEvent = f;
				if(this.events[f] != null) {
					var oldF = this.frame;
					var oldDT = dt;
					dt -= (f - this.frame) / (this.speed * this.sampling);
					this.frame = f;
					var _g2 = 0;
					var _g3 = this.events[f];
					while(_g2 < _g3.length) {
						var e = _g3[_g2];
						++_g2;
						this.onEvent(e);
					}
					if(this.frame == f && f == this.frameCount - 1) {
						this.frame = oldF;
						dt = oldDT;
						break;
					} else {
						return dt;
					}
				}
			}
		}
		if(this.onAnimEnd != null) {
			var end = this.endFrame();
			var et = this.speed == 0 ? 0 : (end - this.frame) / (this.speed * this.sampling);
			if(et <= dt && et > 0) {
				this.frame = end;
				dt -= et;
				this.onAnimEnd();
				if(this.frame == end && this.isPlaying()) {
					if(this.loop) {
						this.frame = 0;
					} else {
						dt = 0;
					}
				}
				return dt;
			}
		}
		this.frame += dt * this.speed * this.sampling;
		if(this.frame >= this.frameCount) {
			if(this.loop) {
				this.frame %= this.frameCount;
			} else {
				this.frame = this.frameCount;
			}
		}
		return 0;
	}
	,initAndBind: function(obj) {
		this.bind(obj);
		this.initInstance();
		this.pause = true;
	}
	,toString: function() {
		return this.name;
	}
	,__class__: h3d_anim_Animation
};
var h3d_anim_DataLayout = $hxEnums["h3d.anim.DataLayout"] = { __ename__:"h3d.anim.DataLayout",__constructs__:null
	,Position: {_hx_name:"Position",_hx_index:0,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Rotation: {_hx_name:"Rotation",_hx_index:1,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Scale: {_hx_name:"Scale",_hx_index:2,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,UV: {_hx_name:"UV",_hx_index:3,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Alpha: {_hx_name:"Alpha",_hx_index:4,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,Property: {_hx_name:"Property",_hx_index:5,__enum__:"h3d.anim.DataLayout",toString:$estr}
	,SingleFrame: {_hx_name:"SingleFrame",_hx_index:6,__enum__:"h3d.anim.DataLayout",toString:$estr}
};
h3d_anim_DataLayout.__constructs__ = [h3d_anim_DataLayout.Position,h3d_anim_DataLayout.Rotation,h3d_anim_DataLayout.Scale,h3d_anim_DataLayout.UV,h3d_anim_DataLayout.Alpha,h3d_anim_DataLayout.Property,h3d_anim_DataLayout.SingleFrame];
h3d_anim_DataLayout.__empty_constructs__ = [h3d_anim_DataLayout.Position,h3d_anim_DataLayout.Rotation,h3d_anim_DataLayout.Scale,h3d_anim_DataLayout.UV,h3d_anim_DataLayout.Alpha,h3d_anim_DataLayout.Property,h3d_anim_DataLayout.SingleFrame];
var h3d_anim_BufferObject = function(objectName,dataOffset) {
	h3d_anim_AnimatedObject.call(this,objectName);
	this.dataOffset = dataOffset;
};
$hxClasses["h3d.anim.BufferObject"] = h3d_anim_BufferObject;
h3d_anim_BufferObject.__name__ = "h3d.anim.BufferObject";
h3d_anim_BufferObject.__super__ = h3d_anim_AnimatedObject;
h3d_anim_BufferObject.prototype = $extend(h3d_anim_AnimatedObject.prototype,{
	getStride: function() {
		var stride = 0;
		if((this.layout & 1 << h3d_anim_DataLayout.Position._hx_index) != 0) {
			stride += 3;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Rotation._hx_index) != 0) {
			stride += 3;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
			stride += 3;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.UV._hx_index) != 0) {
			stride += 2;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Alpha._hx_index) != 0) {
			++stride;
		}
		if((this.layout & 1 << h3d_anim_DataLayout.Property._hx_index) != 0) {
			++stride;
		}
		return stride;
	}
	,clone: function() {
		var o = new h3d_anim_BufferObject(this.objectName,this.dataOffset);
		o.layout = this.layout;
		o.propName = this.propName;
		return o;
	}
	,__class__: h3d_anim_BufferObject
});
var h3d_anim_BufferAnimation = function(name,frame,sampling) {
	h3d_anim_Animation.call(this,name,frame,sampling);
	this.syncFrame = -1;
};
$hxClasses["h3d.anim.BufferAnimation"] = h3d_anim_BufferAnimation;
h3d_anim_BufferAnimation.__name__ = "h3d.anim.BufferAnimation";
h3d_anim_BufferAnimation.__super__ = h3d_anim_Animation;
h3d_anim_BufferAnimation.prototype = $extend(h3d_anim_Animation.prototype,{
	setData: function(data,stride) {
		this.data = data;
		this.stride = stride;
	}
	,addObject: function(objName,offset) {
		var f = new h3d_anim_BufferObject(objName,offset);
		this.objects.push(f);
		return f;
	}
	,getPropValue: function(objName,propName) {
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.objectName == objName && o.propName == propName) {
				return o.propCurrentValue;
			}
		}
		return null;
	}
	,getFrames: function() {
		return this.objects;
	}
	,clone: function(a) {
		if(a == null) {
			a = new h3d_anim_BufferAnimation(this.name,this.frameCount,this.sampling);
		}
		h3d_anim_Animation.prototype.clone.call(this,a);
		var la = ((a) instanceof h3d_anim_BufferAnimation) ? a : null;
		la.setData(this.data,this.stride);
		return a;
	}
	,endFrame: function() {
		if(this.loop) {
			return this.frameCount;
		} else {
			return this.frameCount - 1;
		}
	}
	,initInstance: function() {
		h3d_anim_Animation.prototype.initInstance.call(this);
		var frames = this.objects;
		var _g = 0;
		while(_g < frames.length) {
			var a = frames[_g];
			++_g;
			if((a.layout & 1 << h3d_anim_DataLayout.Property._hx_index) != 0) {
				a.propCurrentValue = this.data[a.dataOffset];
			}
			var tmp;
			if((a.layout & 1 << h3d_anim_DataLayout.Alpha._hx_index) != 0) {
				if(a.targetObject != null) {
					var _this = a.targetObject;
					tmp = (((_this) instanceof h3d_scene_Mesh) ? _this : null) == null;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				throw haxe_Exception.thrown(a.objectName + " should be a mesh (for alpha animation)");
			}
			if((a.layout & 1 << h3d_anim_DataLayout.Position._hx_index) != 0 || (a.layout & 1 << h3d_anim_DataLayout.Rotation._hx_index) != 0 || (a.layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
				a.matrix = new h3d_MatrixImpl();
				a.matrix.identity();
				if((a.layout & 1 << h3d_anim_DataLayout.Position._hx_index) == 0 && a.targetSkin != null) {
					var m2 = a.targetSkin.getSkinData().allJoints[a.targetJoint].defMat;
					a.matrix._14 = m2._41;
					a.matrix._24 = m2._42;
					a.matrix._34 = m2._43;
				}
			}
		}
		frames.sort($bind(this,this.sortByFrameCountDesc));
	}
	,sortByFrameCountDesc: function(o1,o2) {
		return ((o2.layout & 1 << h3d_anim_DataLayout.SingleFrame._hx_index) != 0 ? 0 : 1) - ((o1.layout & 1 << h3d_anim_DataLayout.SingleFrame._hx_index) != 0 ? 0 : 1);
	}
	,uvLerp: function(v1,v2,k) {
		v1 %= 1.;
		v2 %= 1.;
		if(v1 < v2 - 0.5) {
			++v1;
		} else if(v1 > v2 + 0.5) {
			--v1;
		}
		return v1 * (1 - k) + v2 * k;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		var _gthis = this;
		if(this.frame == this.syncFrame && !decompose) {
			return;
		}
		var f = this.frame | 0;
		var max = this.endFrame();
		if(f == max) {
			--f;
		}
		var frame1 = f;
		var frame2 = (frame1 + 1) % this.frameCount;
		var k2 = this.frame - frame1;
		var k1 = 1 - k2;
		if(frame1 < 0) {
			frame2 = 0;
			frame1 = frame2;
		} else if(this.frame >= this.frameCount) {
			frame2 = this.frameCount - 1;
			frame1 = frame2;
		} else if(!this.loop && frame2 == 0) {
			frame2 = this.frameCount - 1;
		}
		this.syncFrame = this.frame;
		if(decompose) {
			this.isSync = false;
		}
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.targetObject == null && o.targetSkin == null) {
				continue;
			}
			var layout = o.layout;
			var offset1 = this.stride * frame1 + o.dataOffset;
			var offset2 = this.stride * frame2 + o.dataOffset;
			var frame11 = frame1;
			var frame21 = frame2;
			if((layout & 1 << h3d_anim_DataLayout.SingleFrame._hx_index) != 0) {
				if(this.isSync) {
					break;
				}
				frame21 = 0;
				frame11 = frame21;
				offset2 = o.dataOffset;
				offset1 = offset2;
			}
			var m = o.matrix;
			if(m != null) {
				if((layout & 1 << h3d_anim_DataLayout.Position._hx_index) != 0) {
					m._41 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
					m._42 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
					m._43 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
				} else {
					m._41 = m._14;
					m._42 = m._24;
					m._43 = m._34;
				}
				if((layout & 1 << h3d_anim_DataLayout.Rotation._hx_index) != 0) {
					var q1x = this.data[offset1++];
					var q1y = this.data[offset1++];
					var q1z = this.data[offset1++];
					var f = 1 - (q1x * q1x + q1y * q1y + q1z * q1z);
					var q1w = Math.sqrt(f < 0 ? -f : f);
					var q2x = this.data[offset2++];
					var q2y = this.data[offset2++];
					var q2z = this.data[offset2++];
					var f1 = 1 - (q2x * q2x + q2y * q2y + q2z * q2z);
					var q2w = Math.sqrt(f1 < 0 ? -f1 : f1);
					var dot = q1x * q2x + q1y * q2y + q1z * q2z + q1w * q2w;
					var q2 = dot < 0 ? -k2 : k2;
					var qx = q1x * k1 + q2x * q2;
					var qy = q1y * k1 + q2y * q2;
					var qz = q1z * k1 + q2z * q2;
					var qw = q1w * k1 + q2w * q2;
					var ql = 1 / Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);
					qx *= ql;
					qy *= ql;
					qz *= ql;
					qw *= ql;
					if(decompose) {
						m._12 = qx;
						m._13 = qy;
						m._21 = qz;
						m._23 = qw;
						if((layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
							m._11 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							m._22 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							m._33 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
						} else {
							m._11 = 1;
							m._22 = 1;
							m._33 = 1;
						}
					} else {
						var xx = qx * qx;
						var xy = qx * qy;
						var xz = qx * qz;
						var xw = qx * qw;
						var yy = qy * qy;
						var yz = qy * qz;
						var yw = qy * qw;
						var zz = qz * qz;
						var zw = qz * qw;
						m._11 = 1 - 2 * (yy + zz);
						m._12 = 2 * (xy + zw);
						m._13 = 2 * (xz - yw);
						m._21 = 2 * (xy - zw);
						m._22 = 1 - 2 * (xx + zz);
						m._23 = 2 * (yz + xw);
						m._31 = 2 * (xz + yw);
						m._32 = 2 * (yz - xw);
						m._33 = 1 - 2 * (xx + yy);
						if((layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
							var sx = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							var sy = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							var sz = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
							m._11 *= sx;
							m._12 *= sx;
							m._13 *= sx;
							m._21 *= sy;
							m._22 *= sy;
							m._23 *= sy;
							m._31 *= sz;
							m._32 *= sz;
							m._33 *= sz;
						}
					}
				} else {
					m._12 = 0;
					m._13 = 0;
					m._21 = 0;
					m._23 = decompose ? 1 : 0;
					if((layout & 1 << h3d_anim_DataLayout.Scale._hx_index) != 0) {
						m._11 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
						m._22 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
						m._33 = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
					} else {
						m._11 = 1;
						m._22 = 1;
						m._33 = 1;
					}
				}
				if(o.targetSkin != null) {
					o.targetSkin.currentRelPose[o.targetJoint] = m;
					o.targetSkin.jointsUpdated = true;
				} else {
					var _this = o.targetObject;
					_this.defaultTransform = m;
					var f2 = 1;
					var b = true;
					if(b) {
						_this.flags |= f2;
					} else {
						_this.flags &= ~f2;
					}
				}
			}
			if((layout & 1 << h3d_anim_DataLayout.UV._hx_index) != 0) {
				var mat = o.targetObject.toMesh().material;
				var s = mat.passes.getShader(h3d_shader_UVDelta);
				if(s == null) {
					s = mat.passes.addShader(new h3d_shader_UVDelta());
					mat.get_texture().set_wrap(h3d_mat_Wrap.Repeat);
				}
				var v1 = this.data[offset1++];
				var v2 = this.data[offset2++];
				v1 %= 1.;
				v2 %= 1.;
				if(v1 < v2 - 0.5) {
					++v1;
				} else if(v1 > v2 + 0.5) {
					--v1;
				}
				s.uvDelta__.x = v1 * (1 - k2) + v2 * k2;
				var v11 = this.data[offset1++];
				var v21 = this.data[offset2++];
				v11 %= 1.;
				v21 %= 1.;
				if(v11 < v21 - 0.5) {
					++v11;
				} else if(v11 > v21 + 0.5) {
					--v11;
				}
				s.uvDelta__.y = v11 * (1 - k2) + v21 * k2;
			}
			if((layout & 1 << h3d_anim_DataLayout.Alpha._hx_index) != 0) {
				var mat1 = o.targetObject.toMesh().material;
				if(mat1.blendMode == h2d_BlendMode.None) {
					mat1.set_blendMode(h2d_BlendMode.Alpha);
				}
				mat1.mshader.color__.w = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
			}
			if((layout & 1 << h3d_anim_DataLayout.Property._hx_index) != 0) {
				o.propCurrentValue = _gthis.data[offset1++] * k1 + _gthis.data[offset2++] * k2;
			}
		}
		if(!decompose) {
			this.isSync = true;
		}
	}
	,__class__: h3d_anim_BufferAnimation
});
var h3d_anim_LinearFrame = function() {
};
$hxClasses["h3d.anim.LinearFrame"] = h3d_anim_LinearFrame;
h3d_anim_LinearFrame.__name__ = "h3d.anim.LinearFrame";
h3d_anim_LinearFrame.prototype = {
	toMatrix: function() {
		var m = new h3d_MatrixImpl();
		new h3d_Quat(this.qx,this.qy,this.qz,this.qw).toMatrix(m);
		m.prependScale(this.sx,this.sy,this.sz);
		m.translate(this.tx,this.ty,this.tz);
		return m;
	}
	,__class__: h3d_anim_LinearFrame
};
var h3d_anim_LinearObject = function(name) {
	this.hasPosition = true;
	h3d_anim_AnimatedObject.call(this,name);
};
$hxClasses["h3d.anim.LinearObject"] = h3d_anim_LinearObject;
h3d_anim_LinearObject.__name__ = "h3d.anim.LinearObject";
h3d_anim_LinearObject.__super__ = h3d_anim_AnimatedObject;
h3d_anim_LinearObject.prototype = $extend(h3d_anim_AnimatedObject.prototype,{
	clone: function() {
		var o = new h3d_anim_LinearObject(this.objectName);
		o.hasPosition = this.hasPosition;
		o.hasRotation = this.hasRotation;
		o.hasScale = this.hasScale;
		o.frames = this.frames;
		o.alphas = this.alphas;
		o.uvs = this.uvs;
		o.propName = this.propName;
		o.propValues = this.propValues;
		return o;
	}
	,__class__: h3d_anim_LinearObject
});
var h3d_anim_LinearAnimation = function(name,frame,sampling) {
	h3d_anim_Animation.call(this,name,frame,sampling);
	this.syncFrame = -1;
};
$hxClasses["h3d.anim.LinearAnimation"] = h3d_anim_LinearAnimation;
h3d_anim_LinearAnimation.__name__ = "h3d.anim.LinearAnimation";
h3d_anim_LinearAnimation.__super__ = h3d_anim_Animation;
h3d_anim_LinearAnimation.prototype = $extend(h3d_anim_Animation.prototype,{
	addCurve: function(objName,frames,hasPos,hasRot,hasScale) {
		var f = new h3d_anim_LinearObject(objName);
		f.frames = frames;
		f.hasPosition = hasPos;
		f.hasRotation = hasRot;
		f.hasScale = hasScale;
		this.objects.push(f);
	}
	,addAlphaCurve: function(objName,alphas) {
		var f = new h3d_anim_LinearObject(objName);
		f.alphas = alphas;
		this.objects.push(f);
	}
	,addUVCurve: function(objName,uvs) {
		var f = new h3d_anim_LinearObject(objName);
		f.uvs = uvs;
		this.objects.push(f);
	}
	,addPropCurve: function(objName,propName,values) {
		var f = new h3d_anim_LinearObject(objName);
		f.propName = propName;
		f.propValues = values;
		this.objects.push(f);
	}
	,getPropValue: function(objName,propName) {
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.objectName == objName && o.propName == propName) {
				return o.propCurrentValue;
			}
		}
		return null;
	}
	,getFrames: function() {
		return this.objects;
	}
	,clone: function(a) {
		if(a == null) {
			a = new h3d_anim_LinearAnimation(this.name,this.frameCount,this.sampling);
		}
		h3d_anim_Animation.prototype.clone.call(this,a);
		return a;
	}
	,endFrame: function() {
		if(this.loop) {
			return this.frameCount;
		} else {
			return this.frameCount - 1;
		}
	}
	,initInstance: function() {
		h3d_anim_Animation.prototype.initInstance.call(this);
		var frames = this.objects;
		var _g = 0;
		while(_g < frames.length) {
			var a = frames[_g];
			++_g;
			if(a.propValues != null) {
				a.propCurrentValue = a.propValues[0];
				continue;
			}
			var tmp;
			if(a.alphas != null) {
				if(a.targetObject != null) {
					var _this = a.targetObject;
					tmp = (((_this) instanceof h3d_scene_Mesh) ? _this : null) == null;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				throw haxe_Exception.thrown(a.objectName + " should be a mesh (for alpha animation)");
			}
			if(a.uvs != null || a.alphas != null) {
				continue;
			}
			a.matrix = new h3d_MatrixImpl();
			a.matrix.identity();
		}
		frames.sort($bind(this,this.sortByFrameCountDesc));
	}
	,sortByFrameCountDesc: function(o1,o2) {
		return (o2.frames == null ? 10 : o2.frames.length) - (o1.frames == null ? 10 : o1.frames.length);
	}
	,uvLerp: function(v1,v2,k) {
		v1 %= 1.;
		v2 %= 1.;
		if(v1 < v2 - 0.5) {
			++v1;
		} else if(v1 > v2 + 0.5) {
			--v1;
		}
		return v1 * (1 - k) + v2 * k;
	}
	,sync: function(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		if(this.frame == this.syncFrame && !decompose) {
			return;
		}
		var f = this.frame | 0;
		var max = this.endFrame();
		if(f == max) {
			--f;
		}
		var frame1 = f;
		var frame2 = (frame1 + 1) % this.frameCount;
		var k2 = this.frame - frame1;
		var k1 = 1 - k2;
		if(frame1 < 0) {
			frame2 = 0;
			frame1 = frame2;
		} else if(this.frame >= this.frameCount) {
			frame2 = this.frameCount - 1;
			frame1 = frame2;
		} else if(!this.loop && frame2 == 0) {
			frame2 = this.frameCount - 1;
		}
		this.syncFrame = this.frame;
		if(decompose) {
			this.isSync = false;
		}
		var _g = 0;
		var _g1 = this.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.targetObject == null && o.targetSkin == null) {
				continue;
			}
			if(o.alphas != null) {
				var mat = o.targetObject.toMesh().material;
				if(mat.blendMode == h2d_BlendMode.None) {
					mat.set_blendMode(h2d_BlendMode.Alpha);
				}
				mat.mshader.color__.w = o.alphas[frame1] * k1 + o.alphas[frame2] * k2;
				continue;
			}
			if(o.uvs != null) {
				var mat1 = o.targetObject.toMesh().material;
				var s = mat1.passes.getShader(h3d_shader_UVDelta);
				if(s == null) {
					s = mat1.passes.addShader(new h3d_shader_UVDelta());
					mat1.get_texture().set_wrap(h3d_mat_Wrap.Repeat);
				}
				var v1 = o.uvs[frame1 << 1];
				var v2 = o.uvs[frame2 << 1];
				v1 %= 1.;
				v2 %= 1.;
				if(v1 < v2 - 0.5) {
					++v1;
				} else if(v1 > v2 + 0.5) {
					--v1;
				}
				s.uvDelta__.x = v1 * (1 - k2) + v2 * k2;
				var v11 = o.uvs[frame1 << 1 | 1];
				var v21 = o.uvs[frame2 << 1 | 1];
				v11 %= 1.;
				v21 %= 1.;
				if(v11 < v21 - 0.5) {
					++v11;
				} else if(v11 > v21 + 0.5) {
					--v11;
				}
				s.uvDelta__.y = v11 * (1 - k2) + v21 * k2;
				continue;
			}
			if(o.propValues != null) {
				o.propCurrentValue = o.propValues[frame1] * k1 + o.propValues[frame2] * k2;
				continue;
			}
			var frame11 = frame1;
			var frame21 = frame2;
			if(o.frames.length == 1) {
				if(this.isSync) {
					break;
				}
				frame21 = 0;
				frame11 = frame21;
			}
			var f1 = o.frames[frame11];
			var f2 = o.frames[frame21];
			var m = o.matrix;
			m._41 = f1.tx * k1 + f2.tx * k2;
			m._42 = f1.ty * k1 + f2.ty * k2;
			m._43 = f1.tz * k1 + f2.tz * k2;
			if(o.hasRotation) {
				var dot = f1.qx * f2.qx + f1.qy * f2.qy + f1.qz * f2.qz + f1.qw * f2.qw;
				var q2 = dot < 0 ? -k2 : k2;
				var qx = f1.qx * k1 + f2.qx * q2;
				var qy = f1.qy * k1 + f2.qy * q2;
				var qz = f1.qz * k1 + f2.qz * q2;
				var qw = f1.qw * k1 + f2.qw * q2;
				var ql = 1 / Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);
				qx *= ql;
				qy *= ql;
				qz *= ql;
				qw *= ql;
				if(decompose) {
					m._12 = qx;
					m._13 = qy;
					m._21 = qz;
					m._23 = qw;
					if(o.hasScale) {
						m._11 = f1.sx * k1 + f2.sx * k2;
						m._22 = f1.sy * k1 + f2.sy * k2;
						m._33 = f1.sz * k1 + f2.sz * k2;
					} else {
						m._11 = 1;
						m._22 = 1;
						m._33 = 1;
					}
				} else {
					var xx = qx * qx;
					var xy = qx * qy;
					var xz = qx * qz;
					var xw = qx * qw;
					var yy = qy * qy;
					var yz = qy * qz;
					var yw = qy * qw;
					var zz = qz * qz;
					var zw = qz * qw;
					m._11 = 1 - 2 * (yy + zz);
					m._12 = 2 * (xy + zw);
					m._13 = 2 * (xz - yw);
					m._21 = 2 * (xy - zw);
					m._22 = 1 - 2 * (xx + zz);
					m._23 = 2 * (yz + xw);
					m._31 = 2 * (xz + yw);
					m._32 = 2 * (yz - xw);
					m._33 = 1 - 2 * (xx + yy);
					if(o.hasScale) {
						var sx = f1.sx * k1 + f2.sx * k2;
						var sy = f1.sy * k1 + f2.sy * k2;
						var sz = f1.sz * k1 + f2.sz * k2;
						m._11 *= sx;
						m._12 *= sx;
						m._13 *= sx;
						m._21 *= sy;
						m._22 *= sy;
						m._23 *= sy;
						m._31 *= sz;
						m._32 *= sz;
						m._33 *= sz;
					}
				}
			} else {
				m._12 = 0;
				m._13 = 0;
				m._21 = 0;
				m._23 = decompose ? 1 : 0;
				if(o.hasScale) {
					m._11 = f1.sx * k1 + f2.sx * k2;
					m._22 = f1.sy * k1 + f2.sy * k2;
					m._33 = f1.sz * k1 + f2.sz * k2;
				} else {
					m._11 = 1;
					m._22 = 1;
					m._33 = 1;
				}
			}
			if(o.targetSkin != null) {
				o.targetSkin.currentRelPose[o.targetJoint] = o.matrix;
				o.targetSkin.jointsUpdated = true;
			} else {
				var _this = o.targetObject;
				var v = o.matrix;
				_this.defaultTransform = v;
				var f = 1;
				var b = true;
				if(b) {
					_this.flags |= f;
				} else {
					_this.flags &= ~f;
				}
			}
		}
		if(!decompose) {
			this.isSync = true;
		}
	}
	,__class__: h3d_anim_LinearAnimation
});
var h3d_anim_Joint = function() {
	this.bindIndex = -1;
	this.splitIndex = -1;
	this.subs = [];
};
$hxClasses["h3d.anim.Joint"] = h3d_anim_Joint;
h3d_anim_Joint.__name__ = "h3d.anim.Joint";
h3d_anim_Joint.prototype = {
	__class__: h3d_anim_Joint
};
var h3d_anim__$Skin_Permut = function() {
};
$hxClasses["h3d.anim._Skin.Permut"] = h3d_anim__$Skin_Permut;
h3d_anim__$Skin_Permut.__name__ = "h3d.anim._Skin.Permut";
h3d_anim__$Skin_Permut.prototype = {
	__class__: h3d_anim__$Skin_Permut
};
var h3d_anim__$Skin_Influence = function(j,w) {
	this.j = j;
	this.w = w;
};
$hxClasses["h3d.anim._Skin.Influence"] = h3d_anim__$Skin_Influence;
h3d_anim__$Skin_Influence.__name__ = "h3d.anim._Skin.Influence";
h3d_anim__$Skin_Influence.prototype = {
	__class__: h3d_anim__$Skin_Influence
};
var h3d_anim_Skin = function(name,vertexCount,bonesPerVertex) {
	this.name = name;
	this.vertexCount = vertexCount;
	this.bonesPerVertex = bonesPerVertex;
	if(vertexCount > 0) {
		this.vertexJoints = new Array(vertexCount * bonesPerVertex);
		this.vertexWeights = new Array(vertexCount * bonesPerVertex);
		this.envelop = [];
	}
};
$hxClasses["h3d.anim.Skin"] = h3d_anim_Skin;
h3d_anim_Skin.__name__ = "h3d.anim.Skin";
h3d_anim_Skin.prototype = {
	setJoints: function(joints,roots) {
		this.rootJoints = roots;
		this.allJoints = joints;
		this.namedJoints = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < joints.length) {
			var j = joints[_g];
			++_g;
			if(j.name != null) {
				this.namedJoints.h[j.name] = j;
			}
		}
	}
	,addInfluence: function(vid,j,w) {
		var il = this.envelop[vid];
		if(il == null) {
			il = this.envelop[vid] = [];
		}
		il.push(new h3d_anim__$Skin_Influence(j,w));
	}
	,sortInfluences: function(i1,i2) {
		if(i2.w > i1.w) {
			return 1;
		} else {
			return -1;
		}
	}
	,isSplit: function() {
		return this.splitJoints != null;
	}
	,initWeights: function() {
		this.boundJoints = [];
		var pos = 0;
		var _g = 0;
		var _g1 = this.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var il = this.envelop[i];
			if(il == null) {
				il = [];
			}
			haxe_ds_ArraySort.sort(il,$bind(this,this.sortInfluences));
			if(il.length > this.bonesPerVertex) {
				il = il.slice(0,this.bonesPerVertex);
			}
			var tw = 0.;
			var _g2 = 0;
			while(_g2 < il.length) {
				var i1 = il[_g2];
				++_g2;
				tw += i1.w;
			}
			tw = 1 / tw;
			var _g3 = 0;
			var _g4 = this.bonesPerVertex;
			while(_g3 < _g4) {
				var i2 = _g3++;
				var i3 = il[i2];
				if(i3 == null) {
					this.vertexJoints[pos] = 0;
					this.vertexWeights[pos] = 0;
				} else {
					if(i3.j.bindIndex == -1) {
						i3.j.bindIndex = this.boundJoints.length;
						this.boundJoints.push(i3.j);
					}
					this.vertexJoints[pos] = i3.j.bindIndex;
					this.vertexWeights[pos] = i3.w * tw;
				}
				++pos;
			}
		}
		this.envelop = null;
	}
	,sortByBindIndex: function(j1,j2) {
		return j1.bindIndex - j2.bindIndex;
	}
	,isSub: function(a,b) {
		var j = 0;
		var max = b.length;
		var _g = 0;
		while(_g < a.length) {
			var e = a[_g];
			++_g;
			while(e != b[j++]) if(j >= max) {
				return false;
			}
		}
		return true;
	}
	,merge: function(permuts) {
		var _g = 0;
		while(_g < permuts.length) {
			var p1 = permuts[_g];
			++_g;
			var _g1 = 0;
			while(_g1 < permuts.length) {
				var p2 = permuts[_g1];
				++_g1;
				if(p1 != p2 && p1.material == p2.material && this.isSub(p1.joints,p2.joints)) {
					var _g2 = 0;
					var _g3 = p1.triangles;
					while(_g2 < _g3.length) {
						var t = _g3[_g2];
						++_g2;
						p2.triangles.push(t);
					}
					HxOverrides.remove(permuts,p1);
					return true;
				}
			}
		}
		return false;
	}
	,jointsDiff: function(p1,p2) {
		var diff = 0;
		var i = 0;
		var j = 0;
		var imax = p1.joints.length;
		var jmax = p2.joints.length;
		while(i < imax && j < jmax) {
			var j1 = p1.joints[i];
			var j2 = p2.joints[j];
			if(j1 == j2) {
				++i;
				++j;
			} else {
				++diff;
				if(j1.bindIndex < j2.bindIndex) {
					++i;
				} else {
					++j;
				}
			}
		}
		return diff + (imax - i) + (jmax - j);
	}
	,split: function(maxBones,index,triangleMaterials) {
		if(this.splitJoints != null) {
			return true;
		}
		if(this.boundJoints.length <= maxBones) {
			return false;
		}
		this.splitJoints = [];
		this.triangleGroups = new Array(index.length / 3 | 0);
		var permuts = [];
		var _g = 0;
		var _g1 = index.length / 3 | 0;
		while(_g < _g1) {
			var tri = _g++;
			var iid = tri * 3;
			var mid = triangleMaterials == null ? 0 : triangleMaterials[tri];
			var jl = [];
			var _g2 = 0;
			while(_g2 < 3) {
				var i = _g2++;
				var vid = index[iid + i];
				var _g3 = 0;
				var _g4 = this.bonesPerVertex;
				while(_g3 < _g4) {
					var b = _g3++;
					var bidx = vid * this.bonesPerVertex + b;
					if(this.vertexWeights[bidx] == 0) {
						continue;
					}
					var j = this.boundJoints[this.vertexJoints[bidx]];
					if(j.splitIndex != iid) {
						j.splitIndex = iid;
						jl.push(j);
					}
				}
			}
			jl.sort($bind(this,this.sortByBindIndex));
			var _g5 = 0;
			while(_g5 < permuts.length) {
				var p2 = permuts[_g5];
				++_g5;
				if(p2.material == mid && this.isSub(jl,p2.joints)) {
					p2.triangles.push(tri);
					jl = null;
					break;
				}
			}
			if(jl == null) {
				continue;
			}
			var _g6 = 0;
			while(_g6 < permuts.length) {
				var p21 = permuts[_g6];
				++_g6;
				if(p21.material == mid && this.isSub(p21.joints,jl)) {
					p21.joints = jl;
					p21.triangles.push(tri);
					jl = null;
					break;
				}
			}
			if(jl == null) {
				continue;
			}
			var pr = new h3d_anim__$Skin_Permut();
			pr.joints = jl;
			pr.triangles = [tri];
			pr.material = mid;
			permuts.push(pr);
		}
		while(true) {
			while(this.merge(permuts)) {
			}
			var minDif = 100000;
			var minTot = 100000;
			var minP1 = null;
			var minP2 = null;
			var _g = 0;
			var _g1 = permuts.length;
			while(_g < _g1) {
				var i = _g++;
				var p1 = permuts[i];
				if(p1.joints.length == maxBones) {
					continue;
				}
				var _g2 = i + 1;
				var _g3 = permuts.length;
				while(_g2 < _g3) {
					var j = _g2++;
					var p2 = permuts[j];
					if(p2.joints.length == maxBones || p1.material != p2.material) {
						continue;
					}
					var count = this.jointsDiff(p1,p2);
					var tot = count + (p1.joints.length + p2.joints.length - count >> 1);
					if(tot > maxBones || tot > minTot || tot == minTot && count > minDif) {
						continue;
					}
					minDif = count;
					minTot = tot;
					minP1 = p1;
					minP2 = p2;
				}
			}
			if(minP1 == null) {
				break;
			}
			var p11 = minP1;
			var p21 = minP2;
			var _g4 = 0;
			var _g5 = p11.joints;
			while(_g4 < _g5.length) {
				var j1 = _g5[_g4];
				++_g4;
				HxOverrides.remove(p21.joints,j1);
				p21.joints.push(j1);
			}
			p21.joints.sort($bind(this,this.sortByBindIndex));
			var _g6 = 0;
			var _g7 = p11.triangles;
			while(_g6 < _g7.length) {
				var t = _g7[_g6];
				++_g6;
				p21.triangles.push(t);
			}
			HxOverrides.remove(permuts,p11);
		}
		var _g = 0;
		var _g1 = permuts.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = permuts[i].triangles;
			while(_g2 < _g3.length) {
				var tri = _g3[_g2];
				++_g2;
				this.triangleGroups[tri] = i;
			}
		}
		var jointsPermuts = [];
		var _g = 0;
		var _g1 = this.boundJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			var pl = [];
			var _g2 = 0;
			while(_g2 < permuts.length) {
				var p = permuts[_g2];
				++_g2;
				if(p.joints.indexOf(j) >= 0) {
					pl.push(p);
				}
			}
			jointsPermuts.push({ j : j, pl : pl, priority : 0});
		}
		while(true) {
			jointsPermuts.sort(function(j1,j2) {
				return j2.pl.length + j2.priority * 100 - (j1.pl.length + j1.priority * 100);
			});
			var _g = 0;
			while(_g < permuts.length) {
				var p = permuts[_g];
				++_g;
				p.indexedJoints = [];
			}
			var fail = false;
			var _g1 = 0;
			while(_g1 < jointsPermuts.length) {
				var j = jointsPermuts[_g1];
				++_g1;
				j.j.splitIndex = -1;
				var _g2 = 0;
				var _g3 = maxBones;
				while(_g2 < _g3) {
					var id = _g2++;
					var ok = true;
					var _g4 = 0;
					var _g5 = j.pl;
					while(_g4 < _g5.length) {
						var p1 = _g5[_g4];
						++_g4;
						if(p1.indexedJoints[id] != null) {
							ok = false;
							break;
						}
					}
					if(ok) {
						j.j.splitIndex = id;
						var _g6 = 0;
						var _g7 = j.pl;
						while(_g6 < _g7.length) {
							var p2 = _g7[_g6];
							++_g6;
							p2.indexedJoints[id] = j.j;
						}
						break;
					}
				}
				if(j.j.splitIndex < 0) {
					j.priority++;
					if(j.priority > 10) {
						throw haxe_Exception.thrown("Failed to assign index while spliting skin");
					}
					fail = true;
					break;
				}
			}
			if(!fail) {
				break;
			}
		}
		this.splitJoints = [];
		var _g = 0;
		while(_g < permuts.length) {
			var p = permuts[_g];
			++_g;
			var jl = [];
			var _g1 = 0;
			var _g2 = p.indexedJoints.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var j = p.indexedJoints[i];
				if(j == null) {
					j = this.boundJoints[0];
				}
				jl.push(j);
			}
			this.splitJoints.push({ material : p.material, joints : jl});
		}
		var _g = 0;
		var _g1 = this.vertexJoints.length;
		while(_g < _g1) {
			var i = _g++;
			this.vertexJoints[i] = this.boundJoints[this.vertexJoints[i]].splitIndex;
		}
		return true;
	}
	,__class__: h3d_anim_Skin
};
var h3d_col_Collider = function() { };
$hxClasses["h3d.col.Collider"] = h3d_col_Collider;
h3d_col_Collider.__name__ = "h3d.col.Collider";
h3d_col_Collider.prototype = {
	__class__: h3d_col_Collider
};
var h3d_col_Bounds = function() {
	this.xMin = 1e20;
	this.xMax = -1e20;
	this.yMin = 1e20;
	this.yMax = -1e20;
	this.zMin = 1e20;
	this.zMax = -1e20;
};
$hxClasses["h3d.col.Bounds"] = h3d_col_Bounds;
h3d_col_Bounds.__name__ = "h3d.col.Bounds";
h3d_col_Bounds.fromPoints = function(min,max) {
	var b = new h3d_col_Bounds();
	b.xMin = min.x;
	b.yMin = min.y;
	b.zMin = min.z;
	b.xMax = max.x;
	b.yMax = max.y;
	b.zMax = max.z;
	return b;
};
h3d_col_Bounds.fromValues = function(x,y,z,dx,dy,dz) {
	var b = new h3d_col_Bounds();
	b.xMin = x;
	b.yMin = y;
	b.zMin = z;
	b.xMax = x + dx;
	b.yMax = y + dy;
	b.zMax = z + dz;
	return b;
};
h3d_col_Bounds.__super__ = h3d_col_Collider;
h3d_col_Bounds.prototype = $extend(h3d_col_Collider.prototype,{
	inFrustum: function(f,m) {
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		return f.hasBounds(this);
	}
	,inSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var a = this.xMin;
		var a1 = s.x;
		var b = this.xMax;
		var b1 = a1 > b ? b : a1;
		var x = a < b1 ? b1 : a;
		var a = this.yMin;
		var a1 = s.y;
		var b = this.yMax;
		var b1 = a1 > b ? b : a1;
		var y = a < b1 ? b1 : a;
		var a = this.zMin;
		var a1 = s.z;
		var b = this.zMax;
		var b1 = a1 > b ? b : a1;
		var z = a < b1 ? b1 : a;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var dx = p_x - _this_x;
		var dy = p_y - _this_y;
		var dz = p_z - _this_z;
		return dx * dx + dy * dy + dz * dz < s.r * s.r;
	}
	,testPlane: function(p) {
		var a = p.nx;
		var b = p.ny;
		var c = p.nz;
		var dd = a * (this.xMax + this.xMin) + b * (this.yMax + this.yMin) + c * (this.zMax + this.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b < 0) {
			b = -b;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (this.xMax - this.xMin) + b * (this.yMax - this.yMin) + c * (this.zMax - this.zMin);
		return dd + rr - p.d * 2;
	}
	,rayIntersection: function(r,bestMatch) {
		var minTx = (this.xMin - r.px) / r.lx;
		var minTy = (this.yMin - r.py) / r.ly;
		var minTz = (this.zMin - r.pz) / r.lz;
		var maxTx = (this.xMax - r.px) / r.lx;
		var maxTy = (this.yMax - r.py) / r.ly;
		var maxTz = (this.zMax - r.pz) / r.lz;
		var realMinTx = minTx > maxTx ? maxTx : minTx;
		var realMinTy = minTy > maxTy ? maxTy : minTy;
		var realMinTz = minTz > maxTz ? maxTz : minTz;
		var realMaxTx = minTx < maxTx ? maxTx : minTx;
		var realMaxTy = minTy < maxTy ? maxTy : minTy;
		var realMaxTz = minTz < maxTz ? maxTz : minTz;
		var a = realMaxTx > realMaxTy ? realMaxTy : realMaxTx;
		var minmax = a > realMaxTz ? realMaxTz : a;
		var a = realMinTx < realMinTy ? realMinTy : realMinTx;
		var maxmin = a < realMinTz ? realMinTz : a;
		if(minmax < maxmin) {
			return -1;
		}
		return maxmin;
	}
	,inFrustumDetails: function(mvp,checkZ) {
		if(checkZ == null) {
			checkZ = true;
		}
		var ret = 1;
		var p_nx = mvp._14 + mvp._11;
		var p_ny = mvp._24 + mvp._21;
		var p_nz = mvp._34 + mvp._31;
		var p_d = mvp._44 + mvp._41;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		var p_nx = mvp._14 - mvp._11;
		var p_ny = mvp._24 - mvp._21;
		var p_nz = mvp._34 - mvp._31;
		var p_d = mvp._44 - mvp._41;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		var p_nx = mvp._14 + mvp._12;
		var p_ny = mvp._24 + mvp._22;
		var p_nz = mvp._34 + mvp._32;
		var p_d = mvp._44 + mvp._42;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		var p_nx = mvp._14 - mvp._12;
		var p_ny = mvp._24 - mvp._22;
		var p_nz = mvp._34 - mvp._32;
		var p_d = mvp._44 - mvp._42;
		var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
		if(m + p_d < 0) {
			return -1;
		}
		var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
		if(n + p_d < 0) {
			ret = 0;
		}
		if(checkZ) {
			var p_nx = mvp._13;
			var p_ny = mvp._23;
			var p_nz = mvp._33;
			var p_d = mvp._43;
			var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
			if(m + p_d < 0) {
				return -1;
			}
			var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
			if(n + p_d < 0) {
				ret = 0;
			}
			var p_nx = mvp._14 - mvp._13;
			var p_ny = mvp._24 - mvp._23;
			var p_nz = mvp._34 - mvp._33;
			var p_d = mvp._44 - mvp._43;
			var m = p_nx * (p_nx > 0 ? this.xMax : this.xMin) + p_ny * (p_ny > 0 ? this.yMax : this.yMin) + p_nz * (p_nz > 0 ? this.zMax : this.zMin);
			if(m + p_d < 0) {
				return -1;
			}
			var n = p_nx * (p_nx > 0 ? this.xMin : this.xMax) + p_ny * (p_ny > 0 ? this.yMin : this.yMax) + p_nz * (p_nz > 0 ? this.zMin : this.zMax);
			if(n + p_d < 0) {
				ret = 0;
			}
		}
		return ret;
	}
	,transform3x3: function(m) {
		var xMin = this.xMin;
		var yMin = this.yMin;
		var zMin = this.zMin;
		var xMax = this.xMax;
		var yMax = this.yMax;
		var zMax = this.zMax;
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var x = xMin;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
	}
	,transform: function(m) {
		var xMin = this.xMin;
		var yMin = this.yMin;
		var zMin = this.zMin;
		var xMax = this.xMax;
		var yMax = this.yMax;
		var zMax = this.zMax;
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
		if(xMax < xMin && yMax < yMin && zMax < zMin) {
			return;
		}
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var _this_x = x;
		var _this_y = y;
		var _this_z = z;
		var x = xMin;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMin;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMin;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
		var x = xMax;
		var y = yMax;
		var z = zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		if(_this_x < this.xMin) {
			this.xMin = _this_x;
		}
		if(_this_x > this.xMax) {
			this.xMax = _this_x;
		}
		if(_this_y < this.yMin) {
			this.yMin = _this_y;
		}
		if(_this_y > this.yMax) {
			this.yMax = _this_y;
		}
		if(_this_z < this.zMin) {
			this.zMin = _this_z;
		}
		if(_this_z > this.zMax) {
			this.zMax = _this_z;
		}
	}
	,collide: function(b) {
		return !(this.xMin > b.xMax || this.yMin > b.yMax || this.zMin > b.zMax || this.xMax < b.xMin || this.yMax < b.yMin || this.zMax < b.zMin);
	}
	,contains: function(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin && p.y < this.yMax && p.z >= this.zMin) {
			return p.z < this.zMax;
		} else {
			return false;
		}
	}
	,containsBounds: function(b) {
		if(this.xMin <= b.xMin && this.yMin <= b.yMin && this.zMin <= b.zMin && this.xMax >= b.xMax && this.yMax >= b.yMax) {
			return this.zMax >= b.zMax;
		} else {
			return false;
		}
	}
	,containsSphere: function(s) {
		if(this.xMin <= s.x - s.r && this.yMin <= s.y - s.r && this.zMin <= s.z - s.r && this.xMax >= s.x + s.r && this.yMax >= s.y + s.r) {
			return this.zMax >= s.z + s.r;
		} else {
			return false;
		}
	}
	,add: function(b) {
		if(b.xMin < this.xMin) {
			this.xMin = b.xMin;
		}
		if(b.xMax > this.xMax) {
			this.xMax = b.xMax;
		}
		if(b.yMin < this.yMin) {
			this.yMin = b.yMin;
		}
		if(b.yMax > this.yMax) {
			this.yMax = b.yMax;
		}
		if(b.zMin < this.zMin) {
			this.zMin = b.zMin;
		}
		if(b.zMax > this.zMax) {
			this.zMax = b.zMax;
		}
	}
	,addTransform: function(b,m) {
		var b1 = new h3d_col_Bounds();
		b1.xMin = b.xMin;
		b1.xMax = b.xMax;
		b1.yMin = b.yMin;
		b1.yMax = b.yMax;
		b1.zMin = b.zMin;
		b1.zMax = b.zMax;
		var tmp = b1;
		tmp.transform(m);
		if(tmp.xMin < this.xMin) {
			this.xMin = tmp.xMin;
		}
		if(tmp.xMax > this.xMax) {
			this.xMax = tmp.xMax;
		}
		if(tmp.yMin < this.yMin) {
			this.yMin = tmp.yMin;
		}
		if(tmp.yMax > this.yMax) {
			this.yMax = tmp.yMax;
		}
		if(tmp.zMin < this.zMin) {
			this.zMin = tmp.zMin;
		}
		if(tmp.zMax > this.zMax) {
			this.zMax = tmp.zMax;
		}
	}
	,addPoint: function(p) {
		if(p.x < this.xMin) {
			this.xMin = p.x;
		}
		if(p.x > this.xMax) {
			this.xMax = p.x;
		}
		if(p.y < this.yMin) {
			this.yMin = p.y;
		}
		if(p.y > this.yMax) {
			this.yMax = p.y;
		}
		if(p.z < this.zMin) {
			this.zMin = p.z;
		}
		if(p.z > this.zMax) {
			this.zMax = p.z;
		}
	}
	,addPos: function(x,y,z) {
		if(x < this.xMin) {
			this.xMin = x;
		}
		if(x > this.xMax) {
			this.xMax = x;
		}
		if(y < this.yMin) {
			this.yMin = y;
		}
		if(y > this.yMax) {
			this.yMax = y;
		}
		if(z < this.zMin) {
			this.zMin = z;
		}
		if(z > this.zMax) {
			this.zMax = z;
		}
	}
	,addSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		var r = s.r;
		if(x - r < this.xMin) {
			this.xMin = x - r;
		}
		if(x + r > this.xMax) {
			this.xMax = x + r;
		}
		if(y - r < this.yMin) {
			this.yMin = y - r;
		}
		if(y + r > this.yMax) {
			this.yMax = y + r;
		}
		if(z - r < this.zMin) {
			this.zMin = z - r;
		}
		if(z + r > this.zMax) {
			this.zMax = z + r;
		}
	}
	,addSpherePos: function(x,y,z,r) {
		if(x - r < this.xMin) {
			this.xMin = x - r;
		}
		if(x + r > this.xMax) {
			this.xMax = x + r;
		}
		if(y - r < this.yMin) {
			this.yMin = y - r;
		}
		if(y + r > this.yMax) {
			this.yMax = y + r;
		}
		if(z - r < this.zMin) {
			this.zMin = z - r;
		}
		if(z + r > this.zMax) {
			this.zMax = z + r;
		}
	}
	,intersection: function(a,b) {
		var a1 = a.xMin;
		var b1 = b.xMin;
		var xMin = a1 < b1 ? b1 : a1;
		var a1 = a.yMin;
		var b1 = b.yMin;
		var yMin = a1 < b1 ? b1 : a1;
		var a1 = a.zMin;
		var b1 = b.zMin;
		var zMin = a1 < b1 ? b1 : a1;
		var a1 = a.xMax;
		var b1 = b.xMax;
		var xMax = a1 > b1 ? b1 : a1;
		var a1 = a.yMax;
		var b1 = b.yMax;
		var yMax = a1 > b1 ? b1 : a1;
		var a1 = a.zMax;
		var b1 = b.zMax;
		var zMax = a1 > b1 ? b1 : a1;
		this.xMin = xMin;
		this.xMax = xMax;
		this.yMin = yMin;
		this.yMax = yMax;
		this.zMin = zMin;
		this.zMax = zMax;
	}
	,offset: function(dx,dy,dz) {
		this.xMin += dx;
		this.xMax += dx;
		this.yMin += dy;
		this.yMax += dy;
		this.zMin += dz;
		this.zMax += dz;
	}
	,setMin: function(p) {
		this.xMin = p.x;
		this.yMin = p.y;
		this.zMin = p.z;
	}
	,setMax: function(p) {
		this.xMax = p.x;
		this.yMax = p.y;
		this.zMax = p.z;
	}
	,load: function(b) {
		this.xMin = b.xMin;
		this.xMax = b.xMax;
		this.yMin = b.yMin;
		this.yMax = b.yMax;
		this.zMin = b.zMin;
		this.zMax = b.zMax;
	}
	,scalePivot: function(v) {
		this.xMin *= v;
		this.yMin *= v;
		this.zMin *= v;
		this.xMax *= v;
		this.yMax *= v;
		this.zMax *= v;
	}
	,scaleCenter: function(v) {
		var dx = (this.xMax - this.xMin) * 0.5 * v;
		var dy = (this.yMax - this.yMin) * 0.5 * v;
		var dz = (this.zMax - this.zMin) * 0.5 * v;
		var mx = (this.xMax + this.xMin) * 0.5;
		var my = (this.yMax + this.yMin) * 0.5;
		var mz = (this.zMax + this.zMin) * 0.5;
		this.xMin = mx - dx;
		this.yMin = my - dy;
		this.zMin = mz - dz;
		this.xMax = mx + dx;
		this.yMax = my + dy;
		this.zMax = mz + dz;
	}
	,getMin: function() {
		var x = this.xMin;
		var y = this.yMin;
		var z = this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getCenter: function() {
		var x = (this.xMin + this.xMax) * 0.5;
		var y = (this.yMin + this.yMax) * 0.5;
		var z = (this.zMin + this.zMax) * 0.5;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getSize: function() {
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		var z = this.zMax - this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getMax: function() {
		var x = this.xMax;
		var y = this.yMax;
		var z = this.zMax;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getVolume: function() {
		return (this.xMax - this.xMin) * (this.yMax - this.yMin) * (this.zMax - this.zMin);
	}
	,get_xSize: function() {
		return this.xMax - this.xMin;
	}
	,get_ySize: function() {
		return this.yMax - this.yMin;
	}
	,get_zSize: function() {
		return this.zMax - this.zMin;
	}
	,set_xSize: function(v) {
		this.xMax = this.xMin + v;
		return v;
	}
	,set_ySize: function(v) {
		this.yMax = this.yMin + v;
		return v;
	}
	,set_zSize: function(v) {
		this.zMax = this.zMin + v;
		return v;
	}
	,isEmpty: function() {
		if(!(this.xMax < this.xMin || this.yMax < this.yMin)) {
			return this.zMax < this.zMin;
		} else {
			return true;
		}
	}
	,empty: function() {
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
	}
	,all: function() {
		this.xMin = -1e20;
		this.xMax = 1e20;
		this.yMin = -1e20;
		this.yMax = 1e20;
		this.zMin = -1e20;
		this.zMax = 1e20;
	}
	,clone: function() {
		var b = new h3d_col_Bounds();
		b.xMin = this.xMin;
		b.xMax = this.xMax;
		b.yMin = this.yMin;
		b.yMax = this.yMax;
		b.zMin = this.zMin;
		b.zMax = this.zMax;
		return b;
	}
	,toString: function() {
		var x = this.xMin;
		var y = this.yMin;
		var z = this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var tmp = "Bounds{" + Std.string(new h3d_VectorImpl(x,y,z)) + ",";
		var x = this.xMax - this.xMin;
		var y = this.yMax - this.yMin;
		var z = this.zMax - this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return tmp + Std.string(new h3d_VectorImpl(x,y,z)) + "}";
	}
	,toSphere: function() {
		var dx = this.xMax - this.xMin;
		var dy = this.yMax - this.yMin;
		var dz = this.zMax - this.zMin;
		return new h3d_col_Sphere((this.xMin + this.xMax) * 0.5,(this.yMin + this.yMax) * 0.5,(this.zMin + this.zMax) * 0.5,Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5);
	}
	,makeDebugObj: function() {
		var prim = new h3d_prim_Cube(this.xMax - this.xMin,this.yMax - this.yMin,this.zMax - this.zMin);
		prim.translate(this.xMin,this.yMin,this.zMin);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_Bounds
});
var h3d_col_OptimizedCollider = function(a,b) {
	this.a = a;
	this.b = b;
};
$hxClasses["h3d.col.OptimizedCollider"] = h3d_col_OptimizedCollider;
h3d_col_OptimizedCollider.__name__ = "h3d.col.OptimizedCollider";
h3d_col_OptimizedCollider.__super__ = h3d_col_Collider;
h3d_col_OptimizedCollider.prototype = $extend(h3d_col_Collider.prototype,{
	rayIntersection: function(r,bestMatch) {
		if(this.a.rayIntersection(r,bestMatch) < 0) {
			if(!this.checkInside) {
				return -1;
			}
			var x = r.px + 0 * r.lx;
			var y = r.py + 0 * r.ly;
			var z = r.pz + 0 * r.lz;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			if(!this.a.contains(new h3d_VectorImpl(x,y,z))) {
				return -1;
			}
		}
		return this.b.rayIntersection(r,bestMatch);
	}
	,contains: function(p) {
		if(this.a.contains(p)) {
			return this.b.contains(p);
		} else {
			return false;
		}
	}
	,inFrustum: function(f,m) {
		if(this.a.inFrustum(f,m)) {
			return this.b.inFrustum(f,m);
		} else {
			return false;
		}
	}
	,inSphere: function(s) {
		if(this.a.inSphere(s)) {
			return this.b.inSphere(s);
		} else {
			return false;
		}
	}
	,makeDebugObj: function() {
		var bobj = this.b.makeDebugObj();
		var aobj = this.a.makeDebugObj();
		if(aobj == null && bobj == null) {
			return null;
		}
		var ret = new h3d_scene_Object();
		if(aobj != null) {
			ret.addChild(aobj);
		}
		if(bobj != null) {
			ret.addChild(bobj);
		}
		return ret;
	}
	,__class__: h3d_col_OptimizedCollider
});
var h3d_col_GroupCollider = function(colliders) {
	this.colliders = colliders;
};
$hxClasses["h3d.col.GroupCollider"] = h3d_col_GroupCollider;
h3d_col_GroupCollider.__name__ = "h3d.col.GroupCollider";
h3d_col_GroupCollider.__super__ = h3d_col_Collider;
h3d_col_GroupCollider.prototype = $extend(h3d_col_Collider.prototype,{
	rayIntersection: function(r,bestMatch) {
		var best = -1.;
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var d = c.rayIntersection(r,bestMatch);
			if(d >= 0) {
				if(!bestMatch) {
					return d;
				}
				if(best < 0 || d < best) {
					best = d;
				}
			}
		}
		return best;
	}
	,contains: function(p) {
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.contains(p)) {
				return true;
			}
		}
		return false;
	}
	,inFrustum: function(f,m) {
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.inFrustum(f,m)) {
				return true;
			}
		}
		return false;
	}
	,inSphere: function(s) {
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.inSphere(s)) {
				return true;
			}
		}
		return false;
	}
	,makeDebugObj: function() {
		var ret = null;
		var _g = 0;
		var _g1 = this.colliders;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var toAdd = c.makeDebugObj();
			if(toAdd == null) {
				continue;
			}
			if(ret == null) {
				ret = new h3d_scene_Object();
			}
			ret.addChild(toAdd);
		}
		return ret;
	}
	,__class__: h3d_col_GroupCollider
});
var h3d_col_FPoint = function(x,y,z) {
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.x = x;
	this.y = y;
	this.z = z;
};
$hxClasses["h3d.col.FPoint"] = h3d_col_FPoint;
h3d_col_FPoint.__name__ = "h3d.col.FPoint";
h3d_col_FPoint.prototype = {
	set: function(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
	,sub: function(p) {
		return new h3d_col_FPoint(this.x - p.x,this.y - p.y,this.z - p.z);
	}
	,add: function(p) {
		return new h3d_col_FPoint(this.x + p.x,this.y + p.y,this.z + p.z);
	}
	,cross: function(p) {
		return new h3d_col_FPoint(this.y * p.z - this.z * p.y,this.z * p.x - this.x * p.z,this.x * p.y - this.y * p.x);
	}
	,dot: function(p) {
		return this.x * p.x + this.y * p.y + this.z * p.z;
	}
	,toString: function() {
		return "FPoint{" + hxd_Math.fmt(this.x) + "," + hxd_Math.fmt(this.y) + "," + hxd_Math.fmt(this.z) + "}";
	}
	,__class__: h3d_col_FPoint
};
var h3d_col_Frustum = function(mvp) {
	this.checkNearFar = true;
	this.pleft = new h3d_col_Plane(1,0,0,0.0);
	this.pright = new h3d_col_Plane(1,0,0,0.0);
	this.ptop = new h3d_col_Plane(1,0,0,0.0);
	this.pbottom = new h3d_col_Plane(1,0,0,0.0);
	this.pnear = new h3d_col_Plane(1,0,0,0.0);
	this.pfar = new h3d_col_Plane(1,0,0,0.0);
	if(mvp != null) {
		this.loadMatrix(mvp);
	}
};
$hxClasses["h3d.col.Frustum"] = h3d_col_Frustum;
h3d_col_Frustum.__name__ = "h3d.col.Frustum";
h3d_col_Frustum.prototype = {
	clone: function() {
		var f = new h3d_col_Frustum();
		var _this = f.pleft;
		var p = this.pleft;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pright;
		var p = this.pright;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.ptop;
		var p = this.ptop;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pbottom;
		var p = this.pbottom;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pnear;
		var p = this.pnear;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		var _this = f.pfar;
		var p = this.pfar;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		f.checkNearFar = this.checkNearFar;
		return f;
	}
	,loadMatrix: function(mvp) {
		var _this = this.pleft;
		var p_nx = mvp._14 + mvp._11;
		var p_ny = mvp._24 + mvp._21;
		var p_nz = mvp._34 + mvp._31;
		var p_d = -(mvp._44 + mvp._41);
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pright;
		var p_nx = mvp._14 - mvp._11;
		var p_ny = mvp._24 - mvp._21;
		var p_nz = mvp._34 - mvp._31;
		var p_d = mvp._41 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.ptop;
		var p_nx = mvp._14 - mvp._12;
		var p_ny = mvp._24 - mvp._22;
		var p_nz = mvp._34 - mvp._32;
		var p_d = mvp._42 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pbottom;
		var p_nx = mvp._14 + mvp._12;
		var p_ny = mvp._24 + mvp._22;
		var p_nz = mvp._34 + mvp._32;
		var p_d = -(mvp._44 + mvp._42);
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pnear;
		var p_nx = mvp._13;
		var p_ny = mvp._23;
		var p_nz = mvp._33;
		var p_d = -mvp._43;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pfar;
		var p_nx = mvp._14 - mvp._13;
		var p_ny = mvp._24 - mvp._23;
		var p_nz = mvp._34 - mvp._33;
		var p_d = mvp._43 - mvp._44;
		_this.nx = p_nx;
		_this.ny = p_ny;
		_this.nz = p_nz;
		_this.d = p_d;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,transform: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse(m);
		m2.transpose();
		var _this = this.pleft;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pright;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.ptop;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pbottom;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pfar;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pnear;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,transform3x3: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse3x3(m);
		m2.transpose();
		var _this = this.pleft;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pright;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.ptop;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pbottom;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pfar;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pnear;
		var x = _this.nx;
		var y = _this.ny;
		var z = _this.nz;
		var w = -_this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		_this.nx = v_x;
		_this.ny = v_y;
		_this.nz = v_z;
		_this.d = -v_w;
		var _this = this.pleft;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pright;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.ptop;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pbottom;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pnear;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
		var _this = this.pfar;
		var len = 1. / Math.sqrt(_this.nx * _this.nx + _this.ny * _this.ny + _this.nz * _this.nz);
		_this.nx *= len;
		_this.ny *= len;
		_this.nz *= len;
		_this.d *= len;
	}
	,hasPoint: function(p) {
		var _this = this.pleft;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		var _this = this.pright;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		var _this = this.ptop;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		var _this = this.pbottom;
		if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
			return false;
		}
		if(this.checkNearFar) {
			var _this = this.pnear;
			if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
				return false;
			}
			var _this = this.pfar;
			if(_this.nx * p.x + _this.ny * p.y + _this.nz * p.z - _this.d < 0) {
				return false;
			}
		}
		return true;
	}
	,hasSphere: function(s) {
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var _this = this.pleft;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.pright;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.ptop;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		var _this = this.pbottom;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		if(this.checkNearFar) {
			var _this = this.pnear;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
			var _this = this.pfar;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
		}
		return true;
	}
	,hasBounds: function(b) {
		var p = this.pleft;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pright;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.ptop;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pbottom;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pnear;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		var p = this.pfar;
		var a = p.nx;
		var b1 = p.ny;
		var c = p.nz;
		var dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		var rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		return true;
	}
	,__class__: h3d_col_Frustum
};
var h3d_col_Ray = function() {
};
$hxClasses["h3d.col.Ray"] = h3d_col_Ray;
h3d_col_Ray.__name__ = "h3d.col.Ray";
h3d_col_Ray.fromPoints = function(p1,p2) {
	var r = new h3d_col_Ray();
	r.px = p1.x;
	r.py = p1.y;
	r.pz = p1.z;
	r.lx = p2.x - p1.x;
	r.ly = p2.y - p1.y;
	r.lz = p2.z - p1.z;
	r.normalize();
	return r;
};
h3d_col_Ray.fromValues = function(x,y,z,dx,dy,dz) {
	var r = new h3d_col_Ray();
	r.px = x;
	r.py = y;
	r.pz = z;
	r.lx = dx;
	r.ly = dy;
	r.lz = dz;
	r.normalize();
	return r;
};
h3d_col_Ray.prototype = {
	clone: function() {
		var r = new h3d_col_Ray();
		r.px = this.px;
		r.py = this.py;
		r.pz = this.pz;
		r.lx = this.lx;
		r.ly = this.ly;
		r.lz = this.lz;
		return r;
	}
	,load: function(r) {
		this.px = r.px;
		this.py = r.py;
		this.pz = r.pz;
		this.lx = r.lx;
		this.ly = r.ly;
		this.lz = r.lz;
	}
	,normalize: function() {
		var l = this.lx * this.lx + this.ly * this.ly + this.lz * this.lz;
		if(l == 1.) {
			return;
		}
		if(l < 1e-20) {
			l = 0;
		} else {
			l = 1. / Math.sqrt(l);
		}
		this.lx *= l;
		this.ly *= l;
		this.lz *= l;
	}
	,transform: function(m) {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
		var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
		var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
		p_x = px;
		p_y = py;
		p_z = pz;
		this.px = p_x;
		this.py = p_y;
		this.pz = p_z;
		var x = this.lx;
		var y = this.ly;
		var z = this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		this.lx = _this_x;
		this.ly = _this_y;
		this.lz = _this_z;
		this.normalize();
	}
	,getPos: function() {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getDir: function() {
		var x = this.lx;
		var y = this.ly;
		var z = this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getPoint: function(distance) {
		var x = this.px + distance * this.lx;
		var y = this.py + distance * this.ly;
		var z = this.pz + distance * this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,toString: function() {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var tmp = "Ray{" + Std.string(new h3d_VectorImpl(x,y,z)) + ",";
		var x = this.lx;
		var y = this.ly;
		var z = this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return tmp + Std.string(new h3d_VectorImpl(x,y,z)) + "}";
	}
	,distance: function(p) {
		var d = this.lx * p.nx + this.ly * p.ny + this.lz * p.nz;
		var nd = p.d - (this.px * p.nx + this.py * p.ny + this.pz * p.nz);
		if((d < 0 ? -d : d) < 1e-10) {
			if((nd < 0 ? -nd : nd) < 1e-10) {
				return 0.;
			} else {
				return -1;
			}
		} else {
			return nd / d;
		}
	}
	,intersect: function(p) {
		var d = this.lx * p.nx + this.ly * p.ny + this.lz * p.nz;
		var nd = p.d - (this.px * p.nx + this.py * p.ny + this.pz * p.nz);
		if((d < 0 ? -d : d) < 1e-10) {
			if((nd < 0 ? -nd : nd) < 1e-10) {
				var x = this.px;
				var y = this.py;
				var z = this.pz;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				return new h3d_VectorImpl(x,y,z);
			} else {
				return null;
			}
		} else {
			var k = nd / d;
			var x = this.px + this.lx * k;
			var y = this.py + this.ly * k;
			var z = this.pz + this.lz * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			return new h3d_VectorImpl(x,y,z);
		}
	}
	,collideFrustum: function(mvp) {
		var x = this.px;
		var y = this.py;
		var z = this.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * mvp._11 + _this_y * mvp._21 + _this_z * mvp._31 + mvp._41;
		var py = _this_x * mvp._12 + _this_y * mvp._22 + _this_z * mvp._32 + mvp._42;
		var pz = _this_x * mvp._13 + _this_y * mvp._23 + _this_z * mvp._33 + mvp._43;
		var iw = 1 / (_this_x * mvp._14 + _this_y * mvp._24 + _this_z * mvp._34 + mvp._44);
		_this_x = px * iw;
		_this_y = py * iw;
		_this_z = pz * iw;
		var x = this.px + this.lx;
		var y = this.py + this.ly;
		var z = this.pz + this.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var px = _this_x1 * mvp._11 + _this_y1 * mvp._21 + _this_z1 * mvp._31 + mvp._41;
		var py = _this_x1 * mvp._12 + _this_y1 * mvp._22 + _this_z1 * mvp._32 + mvp._42;
		var pz = _this_x1 * mvp._13 + _this_y1 * mvp._23 + _this_z1 * mvp._33 + mvp._43;
		var iw = 1 / (_this_x1 * mvp._14 + _this_y1 * mvp._24 + _this_z1 * mvp._34 + mvp._44);
		_this_x1 = px * iw;
		_this_y1 = py * iw;
		_this_z1 = pz * iw;
		var lx = _this_x1 - _this_x;
		var ly = _this_y1 - _this_y;
		var lz = _this_z1 - _this_z;
		var dx = 1 / lx;
		var dy = 1 / ly;
		var dz = 1 / lz;
		var t1 = (-1 - _this_x) * dx;
		var t2 = (1 - _this_x) * dx;
		var t3 = (-1 - _this_y) * dy;
		var t4 = (1 - _this_y) * dy;
		var t5 = (0 - _this_z) * dz;
		var t6 = (1 - _this_z) * dz;
		var a = t1 > t2 ? t2 : t1;
		var b = t3 > t4 ? t4 : t3;
		var a1 = a < b ? b : a;
		var b = t5 > t6 ? t6 : t5;
		var tmin = a1 < b ? b : a1;
		var a = t1 < t2 ? t2 : t1;
		var b = t3 < t4 ? t4 : t3;
		var a1 = a > b ? b : a;
		var b = t5 < t6 ? t6 : t5;
		var tmax = a1 > b ? b : a1;
		return !(tmax < 0 || tmin > tmax);
	}
	,collide: function(b) {
		var dx = 1 / this.lx;
		var dy = 1 / this.ly;
		var dz = 1 / this.lz;
		var t1 = (b.xMin - this.px) * dx;
		var t2 = (b.xMax - this.px) * dx;
		var t3 = (b.yMin - this.py) * dy;
		var t4 = (b.yMax - this.py) * dy;
		var t5 = (b.zMin - this.pz) * dz;
		var t6 = (b.zMax - this.pz) * dz;
		var a = t1 > t2 ? t2 : t1;
		var b = t3 > t4 ? t4 : t3;
		var a1 = a < b ? b : a;
		var b = t5 > t6 ? t6 : t5;
		var tmin = a1 < b ? b : a1;
		var a = t1 < t2 ? t2 : t1;
		var b = t3 < t4 ? t4 : t3;
		var a1 = a > b ? b : a;
		var b = t5 < t6 ? t6 : t5;
		var tmax = a1 > b ? b : a1;
		if(tmax < 0) {
			return false;
		} else if(tmin > tmax) {
			return false;
		} else {
			return true;
		}
	}
	,__class__: h3d_col_Ray
};
var h3d_col_ObjectCollider = function(obj,collider) {
	this.obj = obj;
	this.collider = collider;
};
$hxClasses["h3d.col.ObjectCollider"] = h3d_col_ObjectCollider;
h3d_col_ObjectCollider.__name__ = "h3d.col.ObjectCollider";
h3d_col_ObjectCollider.__super__ = h3d_col_Collider;
h3d_col_ObjectCollider.prototype = $extend(h3d_col_Collider.prototype,{
	rayIntersection: function(r,bestMatch) {
		var tmpRay = h3d_col_ObjectCollider.TMP_RAY;
		h3d_col_ObjectCollider.TMP_RAY = null;
		tmpRay.px = r.px;
		tmpRay.py = r.py;
		tmpRay.pz = r.pz;
		tmpRay.lx = r.lx;
		tmpRay.ly = r.ly;
		tmpRay.lz = r.lz;
		var m = this.obj.getInvPos();
		var x = r.px;
		var y = r.py;
		var z = r.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
		var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
		var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
		p_x = px;
		p_y = py;
		p_z = pz;
		r.px = p_x;
		r.py = p_y;
		r.pz = p_z;
		var x = r.lx;
		var y = r.ly;
		var z = r.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		r.lx = _this_x;
		r.ly = _this_y;
		r.lz = _this_z;
		r.normalize();
		var hit = this.collider.rayIntersection(r,bestMatch);
		if(hit < 0) {
			r.px = tmpRay.px;
			r.py = tmpRay.py;
			r.pz = tmpRay.pz;
			r.lx = tmpRay.lx;
			r.ly = tmpRay.ly;
			r.lz = tmpRay.lz;
			h3d_col_ObjectCollider.TMP_RAY = tmpRay;
			return hit;
		}
		var x = r.px + hit * r.lx;
		var y = r.py + hit * r.ly;
		var z = r.pz + hit * r.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var pt_x = x1;
		var pt_y = y1;
		var pt_z = z1;
		var m = this.obj.absPos;
		var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
		var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
		var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
		pt_x = px;
		pt_y = py;
		pt_z = pz;
		r.px = tmpRay.px;
		r.py = tmpRay.py;
		r.pz = tmpRay.pz;
		r.lx = tmpRay.lx;
		r.ly = tmpRay.ly;
		r.lz = tmpRay.lz;
		h3d_col_ObjectCollider.TMP_RAY = tmpRay;
		var dx = pt_x - r.px;
		var dy = pt_y - r.py;
		var dz = pt_z - r.pz;
		if(dz == null) {
			dz = 0.;
		}
		var dz1 = dz;
		if(dz1 == null) {
			dz1 = 0.;
		}
		return Math.sqrt(dx * dx + dy * dy + dz1 * dz1);
	}
	,contains: function(p) {
		var _this = p;
		var x = _this.x;
		var y = _this.y;
		var z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var ptmp_x = x1;
		var ptmp_y = y1;
		var ptmp_z = z1;
		var m = this.obj.getInvPos();
		var px = p.x * m._11 + p.y * m._21 + p.z * m._31 + m._41;
		var py = p.x * m._12 + p.y * m._22 + p.z * m._32 + m._42;
		var pz = p.x * m._13 + p.y * m._23 + p.z * m._33 + m._43;
		p.x = px;
		p.y = py;
		p.z = pz;
		var b = this.collider.contains(p);
		var _this = p;
		_this.x = ptmp_x;
		_this.y = ptmp_y;
		_this.z = ptmp_z;
		return b;
	}
	,inFrustum: function(f,m) {
		if(m == null) {
			return this.collider.inFrustum(f,this.obj.getAbsPos());
		}
		var mat = h3d_col_ObjectCollider.TMP_MAT;
		var _this = mat;
		var b = this.obj.getAbsPos();
		var m11 = m._11;
		var m12 = m._12;
		var m13 = m._13;
		var m21 = m._21;
		var m22 = m._22;
		var m23 = m._23;
		var a31 = m._31;
		var a32 = m._32;
		var a33 = m._33;
		var a41 = m._41;
		var a42 = m._42;
		var a43 = m._43;
		var b11 = b._11;
		var b12 = b._12;
		var b13 = b._13;
		var b21 = b._21;
		var b22 = b._22;
		var b23 = b._23;
		var b31 = b._31;
		var b32 = b._32;
		var b33 = b._33;
		var b41 = b._41;
		var b42 = b._42;
		var b43 = b._43;
		_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		_this._14 = 0;
		_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		_this._24 = 0;
		_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		_this._34 = 0;
		_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		_this._44 = 1;
		return this.collider.inFrustum(f,mat);
	}
	,inSphere: function(s) {
		var invMat = this.obj.getInvPos();
		var oldX = s.x;
		var oldY = s.y;
		var oldZ = s.z;
		var oldR = s.r;
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var center_x = x1;
		var center_y = y1;
		var center_z = z1;
		var px = center_x * invMat._11 + center_y * invMat._21 + center_z * invMat._31 + invMat._41;
		var py = center_x * invMat._12 + center_y * invMat._22 + center_z * invMat._32 + invMat._42;
		var pz = center_x * invMat._13 + center_y * invMat._23 + center_z * invMat._33 + invMat._43;
		center_x = px;
		center_y = py;
		center_z = pz;
		var _this = invMat;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var scale_x = x;
		var scale_y = y;
		var scale_z = z;
		scale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		scale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		scale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		s.x = center_x;
		s.y = center_y;
		s.z = center_z;
		s.r *= Math.max(Math.max(scale_x,scale_y),scale_z);
		var res = this.collider.inSphere(s);
		s.x = oldX;
		s.y = oldY;
		s.z = oldZ;
		s.r = oldR;
		return res;
	}
	,makeDebugObj: function() {
		var ret = this.collider.makeDebugObj();
		if(ret != null) {
			ret.set_follow(this.obj);
		}
		return ret;
	}
	,__class__: h3d_col_ObjectCollider
});
var h3d_col_Plane = function(nx,ny,nz,d) {
	this.nx = nx;
	this.ny = ny;
	this.nz = nz;
	this.d = d;
};
$hxClasses["h3d.col.Plane"] = h3d_col_Plane;
h3d_col_Plane.__name__ = "h3d.col.Plane";
h3d_col_Plane.fromPoints = function(p0,p1,p2) {
	var x = p1.x - p0.x;
	var y = p1.y - p0.y;
	var z = p1.z - p0.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	var x = p2.x - p0.x;
	var y = p2.y - p0.y;
	var z = p2.z - p0.z;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var d2_x = x1;
	var d2_y = y1;
	var d2_z = z1;
	var x = _this_y * d2_z - _this_z * d2_y;
	var y = _this_z * d2_x - _this_x * d2_z;
	var z = _this_x * d2_y - _this_y * d2_x;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var _this_x = x1;
	var _this_y = y1;
	var _this_z = z1;
	return new h3d_col_Plane(_this_x,_this_y,_this_z,_this_x * p0.x + _this_y * p0.y + _this_z * p0.z);
};
h3d_col_Plane.fromNormalPoint = function(n,p) {
	var _this = n;
	return new h3d_col_Plane(n.x,n.y,n.z,_this.x * p.x + _this.y * p.y + _this.z * p.z);
};
h3d_col_Plane.X = function(v) {
	if(v == null) {
		v = 0.0;
	}
	return new h3d_col_Plane(1,0,0,v);
};
h3d_col_Plane.Y = function(v) {
	if(v == null) {
		v = 0.0;
	}
	return new h3d_col_Plane(0,1,0,v);
};
h3d_col_Plane.Z = function(v) {
	if(v == null) {
		v = 0.0;
	}
	return new h3d_col_Plane(0,0,1,v);
};
h3d_col_Plane.frustumLeft = function(mvp) {
	return new h3d_col_Plane(mvp._14 + mvp._11,mvp._24 + mvp._21,mvp._34 + mvp._31,-(mvp._44 + mvp._41));
};
h3d_col_Plane.frustumRight = function(mvp) {
	return new h3d_col_Plane(mvp._14 - mvp._11,mvp._24 - mvp._21,mvp._34 - mvp._31,mvp._41 - mvp._44);
};
h3d_col_Plane.frustumBottom = function(mvp) {
	return new h3d_col_Plane(mvp._14 + mvp._12,mvp._24 + mvp._22,mvp._34 + mvp._32,-(mvp._44 + mvp._42));
};
h3d_col_Plane.frustumTop = function(mvp) {
	return new h3d_col_Plane(mvp._14 - mvp._12,mvp._24 - mvp._22,mvp._34 - mvp._32,mvp._42 - mvp._44);
};
h3d_col_Plane.frustumNear = function(mvp) {
	return new h3d_col_Plane(mvp._13,mvp._23,mvp._33,-mvp._43);
};
h3d_col_Plane.frustumFar = function(mvp) {
	return new h3d_col_Plane(mvp._14 - mvp._13,mvp._24 - mvp._23,mvp._34 - mvp._33,mvp._43 - mvp._44);
};
h3d_col_Plane.prototype = {
	getNormal: function() {
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getNormalDistance: function() {
		return this.d;
	}
	,load: function(p) {
		this.nx = p.nx;
		this.ny = p.ny;
		this.nz = p.nz;
		this.d = p.d;
	}
	,transform: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse(m);
		m2.transpose();
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		var w = -this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		this.nx = v_x;
		this.ny = v_y;
		this.nz = v_z;
		this.d = -v_w;
	}
	,transform3x3: function(m) {
		var m2 = new h3d_MatrixImpl();
		m2.initInverse3x3(m);
		m2.transpose();
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		var w = -this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m2._11 + v_y * m2._21 + v_z * m2._31 + v_w * m2._41;
		var py = v_x * m2._12 + v_y * m2._22 + v_z * m2._32 + v_w * m2._42;
		var pz = v_x * m2._13 + v_y * m2._23 + v_z * m2._33 + v_w * m2._43;
		var pw = v_x * m2._14 + v_y * m2._24 + v_z * m2._34 + v_w * m2._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		this.nx = v_x;
		this.ny = v_y;
		this.nz = v_z;
		this.d = -v_w;
	}
	,transformInverseTranspose: function(m) {
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		var w = -this.d;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		var w1 = w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var v_w = w1;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + v_w * m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + v_w * m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + v_w * m._43;
		var pw = v_x * m._14 + v_y * m._24 + v_z * m._34 + v_w * m._44;
		v_x = px;
		v_y = py;
		v_z = pz;
		v_w = pw;
		this.nx = v_x;
		this.ny = v_y;
		this.nz = v_z;
		this.d = -v_w;
	}
	,normalize: function() {
		var len = 1. / Math.sqrt(this.nx * this.nx + this.ny * this.ny + this.nz * this.nz);
		this.nx *= len;
		this.ny *= len;
		this.nz *= len;
		this.d *= len;
	}
	,toString: function() {
		var x = this.nx;
		var y = this.ny;
		var z = this.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return "Plane{" + Std.string(new h3d_VectorImpl(x,y,z)) + "," + hxd_Math.fmt(this.d) + "}";
	}
	,distance: function(p) {
		return this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d;
	}
	,side: function(p) {
		return this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d >= 0;
	}
	,project: function(p) {
		var d = this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d;
		var x = p.x - d * this.nx;
		var y = p.y - d * this.ny;
		var z = p.z - d * this.nz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,projectTo: function(p,out) {
		var d = this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d;
		out.x = p.x - d * this.nx;
		out.y = p.y - d * this.ny;
		out.z = p.z - d * this.nz;
	}
	,__class__: h3d_col_Plane
};
var h3d_col_TriPlane = function() {
	this.next = null;
};
$hxClasses["h3d.col.TriPlane"] = h3d_col_TriPlane;
h3d_col_TriPlane.__name__ = "h3d.col.TriPlane";
h3d_col_TriPlane.__super__ = h3d_col_Collider;
h3d_col_TriPlane.prototype = $extend(h3d_col_Collider.prototype,{
	init: function(p0,p1,p2) {
		this.p0x = p0.x;
		this.p0y = p0.y;
		this.p0z = p0.z;
		var x = p1.x - p0.x;
		var y = p1.y - p0.y;
		var z = p1.z - p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = p2.x - p0.x;
		var y = p2.y - p0.y;
		var z = p2.z - p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		this.d = _this_x2 * p0.x + _this_y2 * p0.y + _this_z2 * p0.z;
		this.nx = _this_x2;
		this.ny = _this_y2;
		this.nz = _this_z2;
		this.d1x = _this_x;
		this.d1y = _this_y;
		this.d1z = _this_z;
		this.d2x = _this_x1;
		this.d2y = _this_y1;
		this.d2z = _this_z1;
		this.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		this.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
		this.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		this.invDenom = 1 / (this.dot00 * this.dot11 - this.dot01 * this.dot01);
	}
	,clone: function() {
		var clone = new h3d_col_TriPlane();
		clone.p0x = this.p0x;
		clone.p0y = this.p0y;
		clone.p0z = this.p0z;
		clone.d1x = this.d1x;
		clone.d1y = this.d1y;
		clone.d1z = this.d1z;
		clone.d2x = this.d2x;
		clone.d2y = this.d2y;
		clone.d2z = this.d2z;
		clone.dot00 = this.dot00;
		clone.dot01 = this.dot01;
		clone.dot11 = this.dot11;
		clone.invDenom = this.invDenom;
		clone.nx = this.nx;
		clone.ny = this.ny;
		clone.nz = this.nz;
		clone.d = this.d;
		if(this.next != null) {
			clone.next = this.next.clone();
		}
		return clone;
	}
	,load: function(tp) {
		this.p0x = tp.p0x;
		this.p0y = tp.p0y;
		this.p0z = tp.p0z;
		this.d1x = tp.d1x;
		this.d1y = tp.d1y;
		this.d1z = tp.d1z;
		this.d2x = tp.d2x;
		this.d2y = tp.d2y;
		this.d2z = tp.d2z;
		this.dot00 = tp.dot00;
		this.dot01 = tp.dot01;
		this.dot11 = tp.dot11;
		this.invDenom = tp.invDenom;
		this.nx = tp.nx;
		this.ny = tp.ny;
		this.nz = tp.nz;
		this.d = tp.d;
	}
	,transform: function(m) {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p0_x = x1;
		var p0_y = y1;
		var p0_z = z1;
		var x = this.d1x + this.p0x;
		var y = this.d1y + this.p0y;
		var z = this.d1z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p1_x = x1;
		var p1_y = y1;
		var p1_z = z1;
		var x = this.d2x + this.p0x;
		var y = this.d2y + this.p0y;
		var z = this.d2z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p2_x = x1;
		var p2_y = y1;
		var p2_z = z1;
		var px = p0_x * m._11 + p0_y * m._21 + p0_z * m._31 + m._41;
		var py = p0_x * m._12 + p0_y * m._22 + p0_z * m._32 + m._42;
		var pz = p0_x * m._13 + p0_y * m._23 + p0_z * m._33 + m._43;
		p0_x = px;
		p0_y = py;
		p0_z = pz;
		var px = p1_x * m._11 + p1_y * m._21 + p1_z * m._31 + m._41;
		var py = p1_x * m._12 + p1_y * m._22 + p1_z * m._32 + m._42;
		var pz = p1_x * m._13 + p1_y * m._23 + p1_z * m._33 + m._43;
		p1_x = px;
		p1_y = py;
		p1_z = pz;
		var px = p2_x * m._11 + p2_y * m._21 + p2_z * m._31 + m._41;
		var py = p2_x * m._12 + p2_y * m._22 + p2_z * m._32 + m._42;
		var pz = p2_x * m._13 + p2_y * m._23 + p2_z * m._33 + m._43;
		p2_x = px;
		p2_y = py;
		p2_z = pz;
		this.p0x = p0_x;
		this.p0y = p0_y;
		this.p0z = p0_z;
		var x = p1_x - p0_x;
		var y = p1_y - p0_y;
		var z = p1_z - p0_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = p2_x - p0_x;
		var y = p2_y - p0_y;
		var z = p2_z - p0_z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x1 = x1;
		var _this_y1 = y1;
		var _this_z1 = z1;
		var x = _this_y * _this_z1 - _this_z * _this_y1;
		var y = _this_z * _this_x1 - _this_x * _this_z1;
		var z = _this_x * _this_y1 - _this_y * _this_x1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x2 = x1;
		var _this_y2 = y1;
		var _this_z2 = z1;
		this.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
		this.nx = _this_x2;
		this.ny = _this_y2;
		this.nz = _this_z2;
		this.d1x = _this_x;
		this.d1y = _this_y;
		this.d1z = _this_z;
		this.d2x = _this_x1;
		this.d2y = _this_y1;
		this.d2z = _this_z1;
		this.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		this.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
		this.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		this.invDenom = 1 / (this.dot00 * this.dot11 - this.dot01 * this.dot01);
	}
	,contains: function(p) {
		var x = p.x - this.p0x;
		var y = p.y - this.p0y;
		var z = p.z - this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v2_x = x1;
		var v2_y = y1;
		var v2_z = z1;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(u >= 0 && v >= 0) {
			return u + v < 1;
		} else {
			return false;
		}
	}
	,side: function(p) {
		return this.nx * p.x + this.ny * p.y + this.nz * p.z - this.d >= 0;
	}
	,inFrustum: function(f,m) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,inSphere: function(s) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,rayIntersection: function(r,bestMatch) {
		var dr = r.lx * this.nx + r.ly * this.ny + r.lz * this.nz;
		if(dr >= 0) {
			return -1.;
		}
		var nd = this.d - (r.px * this.nx + r.py * this.ny + r.pz * this.nz);
		var k = nd / dr;
		if(k < 0) {
			return -1;
		}
		var px = r.px + r.lx * k;
		var py = r.py + r.ly * k;
		var pz = r.pz + r.lz * k;
		var x = px - this.p0x;
		var y = py - this.p0y;
		var z = pz - this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v2_x = x1;
		var v2_y = y1;
		var v2_z = z1;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(!(u >= 0 && v >= 0 && u + v < 1)) {
			return -1;
		}
		return k;
	}
	,isPointInTriangle: function(x,y,z) {
		var x1 = x - this.p0x;
		var y1 = y - this.p0y;
		var z1 = z - this.p0z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var x = x1;
		var y = y1;
		var z = z1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v2_x = x;
		var v2_y = y;
		var v2_z = z;
		var dot02 = this.d1x * v2_x + this.d1y * v2_y + this.d1z * v2_z;
		var dot12 = this.d2x * v2_x + this.d2y * v2_y + this.d2z * v2_z;
		var u = (this.dot11 * dot02 - this.dot01 * dot12) * this.invDenom;
		var v = (this.dot00 * dot12 - this.dot01 * dot02) * this.invDenom;
		if(u >= 0 && v >= 0) {
			return u + v < 1;
		} else {
			return false;
		}
	}
	,getPoints: function() {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h3d_VectorImpl(x,y,z);
		var x = this.d1x + this.p0x;
		var y = this.d1y + this.p0y;
		var z = this.d1z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this2 = new h3d_VectorImpl(x,y,z);
		var x = this.d2x + this.p0x;
		var y = this.d2y + this.p0y;
		var z = this.d2z + this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return [this1,this2,new h3d_VectorImpl(x,y,z)];
	}
	,makeDebugObj: function() {
		var x = this.p0x;
		var y = this.p0y;
		var z = this.p0z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p0 = new h3d_VectorImpl(x,y,z);
		var x = this.d1x;
		var y = this.d1y;
		var z = this.d1z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var d1_x = x1;
		var d1_y = y1;
		var d1_z = z1;
		var x = this.d2x;
		var y = this.d2y;
		var z = this.d2z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var d2_x = x1;
		var d2_y = y1;
		var d2_z = z1;
		var x = d1_x + p0.x;
		var y = d1_y + p0.y;
		var z = d1_z + p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h3d_VectorImpl(x,y,z);
		var x = d2_x + p0.x;
		var y = d2_y + p0.y;
		var z = d2_z + p0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var points = [p0,this1,new h3d_VectorImpl(x,y,z)];
		var prim = new h3d_prim_Polygon(points);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_TriPlane
});
var h3d_col_Polygon = function() {
};
$hxClasses["h3d.col.Polygon"] = h3d_col_Polygon;
h3d_col_Polygon.__name__ = "h3d.col.Polygon";
h3d_col_Polygon.fromPolygon2D = function(p,z) {
	if(z == null) {
		z = 0.;
	}
	var pout = new h3d_col_Polygon();
	if(h2d_col_Polygon.isConvex(p)) {
		var p0 = p[0];
		var _g = 0;
		var _g1 = p.length - 2;
		while(_g < _g1) {
			var i = _g++;
			var p1 = p[i + 1];
			var p2 = p[i + 2];
			var t = new h3d_col_TriPlane();
			var x = p0.x;
			var y = p0.y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z2 = z1;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p0_x = x1;
			var p0_y = y1;
			var p0_z = z2;
			var x2 = p1.x;
			var y2 = p1.y;
			var z3 = z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z4 = z3;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var p1_x = x3;
			var p1_y = y3;
			var p1_z = z4;
			var x4 = p2.x;
			var y4 = p2.y;
			var z5 = z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z6 = z5;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p2_x = x5;
			var p2_y = y5;
			var p2_z = z6;
			t.p0x = p0_x;
			t.p0y = p0_y;
			t.p0z = p0_z;
			var x6 = p1_x - p0_x;
			var y6 = p1_y - p0_y;
			var z7 = p1_z - p0_z;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var x7 = x6;
			var y7 = y6;
			var z8 = z7;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var _this_x = x7;
			var _this_y = y7;
			var _this_z = z8;
			var x8 = p2_x - p0_x;
			var y8 = p2_y - p0_y;
			var z9 = p2_z - p0_z;
			if(z9 == null) {
				z9 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			var x9 = x8;
			var y9 = y8;
			var z10 = z9;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			var _this_x1 = x9;
			var _this_y1 = y9;
			var _this_z1 = z10;
			var x10 = _this_y * _this_z1 - _this_z * _this_y1;
			var y10 = _this_z * _this_x1 - _this_x * _this_z1;
			var z11 = _this_x * _this_y1 - _this_y * _this_x1;
			if(z11 == null) {
				z11 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			var x11 = x10;
			var y11 = y10;
			var z12 = z11;
			if(z12 == null) {
				z12 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			var _this_x2 = x11;
			var _this_y2 = y11;
			var _this_z2 = z12;
			t.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
			t.nx = _this_x2;
			t.ny = _this_y2;
			t.nz = _this_z2;
			t.d1x = _this_x;
			t.d1y = _this_y;
			t.d1z = _this_z;
			t.d2x = _this_x1;
			t.d2y = _this_y1;
			t.d2z = _this_z1;
			t.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			t.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			t.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			t.invDenom = 1 / (t.dot00 * t.dot11 - t.dot01 * t.dot01);
			t.next = pout.triPlanes;
			pout.triPlanes = t;
		}
	} else {
		var idx = h2d_col_Polygon.fastTriangulate(p);
		var _g = 0;
		var _g1 = idx.length / 3 | 0;
		while(_g < _g1) {
			var i = _g++;
			var p0 = p[idx[i * 3]];
			var p1 = p[idx[i * 3 + 1]];
			var p2 = p[idx[i * 3 + 2]];
			var t = new h3d_col_TriPlane();
			var x = p0.x;
			var y = p0.y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z2 = z1;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p0_x = x1;
			var p0_y = y1;
			var p0_z = z2;
			var x2 = p1.x;
			var y2 = p1.y;
			var z3 = z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z4 = z3;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var p1_x = x3;
			var p1_y = y3;
			var p1_z = z4;
			var x4 = p2.x;
			var y4 = p2.y;
			var z5 = z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z6 = z5;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p2_x = x5;
			var p2_y = y5;
			var p2_z = z6;
			t.p0x = p0_x;
			t.p0y = p0_y;
			t.p0z = p0_z;
			var x6 = p1_x - p0_x;
			var y6 = p1_y - p0_y;
			var z7 = p1_z - p0_z;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var x7 = x6;
			var y7 = y6;
			var z8 = z7;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var _this_x = x7;
			var _this_y = y7;
			var _this_z = z8;
			var x8 = p2_x - p0_x;
			var y8 = p2_y - p0_y;
			var z9 = p2_z - p0_z;
			if(z9 == null) {
				z9 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			var x9 = x8;
			var y9 = y8;
			var z10 = z9;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			var _this_x1 = x9;
			var _this_y1 = y9;
			var _this_z1 = z10;
			var x10 = _this_y * _this_z1 - _this_z * _this_y1;
			var y10 = _this_z * _this_x1 - _this_x * _this_z1;
			var z11 = _this_x * _this_y1 - _this_y * _this_x1;
			if(z11 == null) {
				z11 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			var x11 = x10;
			var y11 = y10;
			var z12 = z11;
			if(z12 == null) {
				z12 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			var _this_x2 = x11;
			var _this_y2 = y11;
			var _this_z2 = z12;
			t.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
			t.nx = _this_x2;
			t.ny = _this_y2;
			t.nz = _this_z2;
			t.d1x = _this_x;
			t.d1y = _this_y;
			t.d1z = _this_z;
			t.d2x = _this_x1;
			t.d2y = _this_y1;
			t.d2z = _this_z1;
			t.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			t.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			t.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			t.invDenom = 1 / (t.dot00 * t.dot11 - t.dot01 * t.dot01);
			t.next = pout.triPlanes;
			pout.triPlanes = t;
		}
	}
	return pout;
};
h3d_col_Polygon.__super__ = h3d_col_Collider;
h3d_col_Polygon.prototype = $extend(h3d_col_Collider.prototype,{
	addBuffers: function(vertexes,indexes,stride) {
		if(stride == null) {
			stride = 3;
		}
		var _g = 0;
		var _g1 = indexes.length / 3 | 0;
		while(_g < _g1) {
			var i = _g++;
			var k = i * 3;
			var t = new h3d_col_TriPlane();
			var i0 = indexes[k] * stride;
			var i1 = indexes[k + 1] * stride;
			var i2 = indexes[k + 2] * stride;
			var x = vertexes[i0];
			var y = vertexes[i0 + 1];
			var z = vertexes[i0 + 2];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p0_x = x1;
			var p0_y = y1;
			var p0_z = z1;
			var x2 = vertexes[i1];
			var y2 = vertexes[i1 + 1];
			var z2 = vertexes[i1 + 2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z3 = z2;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var p1_x = x3;
			var p1_y = y3;
			var p1_z = z3;
			var x4 = vertexes[i2];
			var y4 = vertexes[i2 + 1];
			var z4 = vertexes[i2 + 2];
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z5 = z4;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p2_x = x5;
			var p2_y = y5;
			var p2_z = z5;
			t.p0x = p0_x;
			t.p0y = p0_y;
			t.p0z = p0_z;
			var x6 = p1_x - p0_x;
			var y6 = p1_y - p0_y;
			var z6 = p1_z - p0_z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var x7 = x6;
			var y7 = y6;
			var z7 = z6;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var _this_x = x7;
			var _this_y = y7;
			var _this_z = z7;
			var x8 = p2_x - p0_x;
			var y8 = p2_y - p0_y;
			var z8 = p2_z - p0_z;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			var x9 = x8;
			var y9 = y8;
			var z9 = z8;
			if(z9 == null) {
				z9 = 0.;
			}
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			var _this_x1 = x9;
			var _this_y1 = y9;
			var _this_z1 = z9;
			var x10 = _this_y * _this_z1 - _this_z * _this_y1;
			var y10 = _this_z * _this_x1 - _this_x * _this_z1;
			var z10 = _this_x * _this_y1 - _this_y * _this_x1;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			var x11 = x10;
			var y11 = y10;
			var z11 = z10;
			if(z11 == null) {
				z11 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			var _this_x2 = x11;
			var _this_y2 = y11;
			var _this_z2 = z11;
			t.d = _this_x2 * p0_x + _this_y2 * p0_y + _this_z2 * p0_z;
			t.nx = _this_x2;
			t.ny = _this_y2;
			t.nz = _this_z2;
			t.d1x = _this_x;
			t.d1y = _this_y;
			t.d1z = _this_z;
			t.d2x = _this_x1;
			t.d2y = _this_y1;
			t.d2z = _this_z1;
			t.dot00 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			t.dot01 = _this_x * _this_x1 + _this_y * _this_y1 + _this_z * _this_z1;
			t.dot11 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
			t.invDenom = 1 / (t.dot00 * t.dot11 - t.dot01 * t.dot01);
			t.next = this.triPlanes;
			this.triPlanes = t;
		}
	}
	,isConvex: function() {
		return true;
	}
	,clone: function() {
		var clone = new h3d_col_Polygon();
		var _this = this.triPlanes;
		var clone1 = new h3d_col_TriPlane();
		clone1.p0x = _this.p0x;
		clone1.p0y = _this.p0y;
		clone1.p0z = _this.p0z;
		clone1.d1x = _this.d1x;
		clone1.d1y = _this.d1y;
		clone1.d1z = _this.d1z;
		clone1.d2x = _this.d2x;
		clone1.d2y = _this.d2y;
		clone1.d2z = _this.d2z;
		clone1.dot00 = _this.dot00;
		clone1.dot01 = _this.dot01;
		clone1.dot11 = _this.dot11;
		clone1.invDenom = _this.invDenom;
		clone1.nx = _this.nx;
		clone1.ny = _this.ny;
		clone1.nz = _this.nz;
		clone1.d = _this.d;
		if(_this.next != null) {
			var _this1 = _this.next;
			var clone2 = new h3d_col_TriPlane();
			clone2.p0x = _this1.p0x;
			clone2.p0y = _this1.p0y;
			clone2.p0z = _this1.p0z;
			clone2.d1x = _this1.d1x;
			clone2.d1y = _this1.d1y;
			clone2.d1z = _this1.d1z;
			clone2.d2x = _this1.d2x;
			clone2.d2y = _this1.d2y;
			clone2.d2z = _this1.d2z;
			clone2.dot00 = _this1.dot00;
			clone2.dot01 = _this1.dot01;
			clone2.dot11 = _this1.dot11;
			clone2.invDenom = _this1.invDenom;
			clone2.nx = _this1.nx;
			clone2.ny = _this1.ny;
			clone2.nz = _this1.nz;
			clone2.d = _this1.d;
			if(_this1.next != null) {
				clone2.next = _this1.next.clone();
			}
			clone1.next = clone2;
		}
		clone.triPlanes = clone1;
		return clone;
	}
	,transform: function(m) {
		var t = this.triPlanes;
		while(t != null) {
			t.transform(m);
			t = t.next;
		}
	}
	,getPoints: function() {
		var ret = [];
		var t = this.triPlanes;
		while(t != null) {
			ret = ret.concat(t.getPoints());
			t = t.next;
		}
		return ret;
	}
	,getBounds: function(bnds) {
		if(bnds == null) {
			bnds = new h3d_col_Bounds();
		}
		bnds.xMin = 1e20;
		bnds.xMax = -1e20;
		bnds.yMin = 1e20;
		bnds.yMax = -1e20;
		bnds.zMin = 1e20;
		bnds.zMax = -1e20;
		var t = this.triPlanes;
		while(t != null) {
			var x = t.p0x;
			var y = t.p0y;
			var z = t.p0z;
			if(x < bnds.xMin) {
				bnds.xMin = x;
			}
			if(x > bnds.xMax) {
				bnds.xMax = x;
			}
			if(y < bnds.yMin) {
				bnds.yMin = y;
			}
			if(y > bnds.yMax) {
				bnds.yMax = y;
			}
			if(z < bnds.zMin) {
				bnds.zMin = z;
			}
			if(z > bnds.zMax) {
				bnds.zMax = z;
			}
			var x1 = t.d1x + t.p0x;
			var y1 = t.d1y + t.p0y;
			var z1 = t.d1z + t.p0z;
			if(x1 < bnds.xMin) {
				bnds.xMin = x1;
			}
			if(x1 > bnds.xMax) {
				bnds.xMax = x1;
			}
			if(y1 < bnds.yMin) {
				bnds.yMin = y1;
			}
			if(y1 > bnds.yMax) {
				bnds.yMax = y1;
			}
			if(z1 < bnds.zMin) {
				bnds.zMin = z1;
			}
			if(z1 > bnds.zMax) {
				bnds.zMax = z1;
			}
			var x2 = t.d2x + t.p0x;
			var y2 = t.d2y + t.p0y;
			var z2 = t.d2z + t.p0z;
			if(x2 < bnds.xMin) {
				bnds.xMin = x2;
			}
			if(x2 > bnds.xMax) {
				bnds.xMax = x2;
			}
			if(y2 < bnds.yMin) {
				bnds.yMin = y2;
			}
			if(y2 > bnds.yMax) {
				bnds.yMax = y2;
			}
			if(z2 < bnds.zMin) {
				bnds.zMin = z2;
			}
			if(z2 > bnds.zMax) {
				bnds.zMax = z2;
			}
			t = t.next;
		}
		return bnds;
	}
	,contains: function(p) {
		if(!this.isConvex()) {
			throw haxe_Exception.thrown("Not implemented for concave polygon");
		}
		var t = this.triPlanes;
		while(t != null) {
			if(t.nx * p.x + t.ny * p.y + t.nz * p.z - t.d >= 0) {
				return false;
			}
			t = t.next;
		}
		return true;
	}
	,rayIntersection: function(r,bestMatch) {
		var t = this.triPlanes;
		var best = -1.;
		while(t != null) {
			var dr = r.lx * t.nx + r.ly * t.ny + r.lz * t.nz;
			var d;
			if(dr >= 0) {
				d = -1.;
			} else {
				var nd = t.d - (r.px * t.nx + r.py * t.ny + r.pz * t.nz);
				var k = nd / dr;
				if(k < 0) {
					d = -1;
				} else {
					var px = r.px + r.lx * k;
					var py = r.py + r.ly * k;
					var pz = r.pz + r.lz * k;
					var x = px - t.p0x;
					var y = py - t.p0y;
					var z = pz - t.p0z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v2_x = x1;
					var v2_y = y1;
					var v2_z = z1;
					var dot02 = t.d1x * v2_x + t.d1y * v2_y + t.d1z * v2_z;
					var dot12 = t.d2x * v2_x + t.d2y * v2_y + t.d2z * v2_z;
					var u = (t.dot11 * dot02 - t.dot01 * dot12) * t.invDenom;
					var v = (t.dot00 * dot12 - t.dot01 * dot02) * t.invDenom;
					d = !(u >= 0 && v >= 0 && u + v < 1) ? -1 : k;
				}
			}
			if(d >= 0) {
				if(!bestMatch) {
					return d;
				}
				if(best < 0 || d < best) {
					best = d;
				}
			}
			t = t.next;
		}
		return best;
	}
	,inFrustum: function(f,m) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,inSphere: function(s) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,makeDebugObj: function() {
		var points = [];
		var idx = new Array(0);
		var t = this.triPlanes;
		while(t != null) {
			var x = t.p0x;
			var y = t.p0y;
			var z = t.p0z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0 = new h3d_VectorImpl(x,y,z);
			var x1 = t.d1x;
			var y1 = t.d1y;
			var z1 = t.d1z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var x2 = x1;
			var y2 = y1;
			var z2 = z1;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var d1_x = x2;
			var d1_y = y2;
			var d1_z = z2;
			var x3 = t.d2x;
			var y3 = t.d2y;
			var z3 = t.d2z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var x4 = x3;
			var y4 = y3;
			var z4 = z3;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var d2_x = x4;
			var d2_y = y4;
			var d2_z = z4;
			points.push(p0);
			var x5 = d1_x + p0.x;
			var y5 = d1_y + p0.y;
			var z5 = d1_z + p0.z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			points.push(new h3d_VectorImpl(x5,y5,z5));
			var x6 = d2_x + p0.x;
			var y6 = d2_y + p0.y;
			var z6 = d2_z + p0.z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			points.push(new h3d_VectorImpl(x6,y6,z6));
			t = t.next;
		}
		var prim = new h3d_prim_Polygon(points);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_Polygon
});
var h3d_col_PolygonBuffer = function() {
};
$hxClasses["h3d.col.PolygonBuffer"] = h3d_col_PolygonBuffer;
h3d_col_PolygonBuffer.__name__ = "h3d.col.PolygonBuffer";
h3d_col_PolygonBuffer.__super__ = h3d_col_Collider;
h3d_col_PolygonBuffer.prototype = $extend(h3d_col_Collider.prototype,{
	setData: function(buffer,indexes,startIndex,triCount) {
		if(triCount == null) {
			triCount = -1;
		}
		if(startIndex == null) {
			startIndex = 0;
		}
		this.buffer = buffer;
		this.indexes = indexes;
		this.startIndex = startIndex;
		this.triCount = triCount >= 0 ? triCount : (indexes.length - startIndex) / 3 | 0;
	}
	,getBounds: function() {
		var i = this.startIndex;
		var b = new h3d_col_Bounds();
		var _g = 0;
		var _g1 = this.triCount * 3;
		while(_g < _g1) {
			var t = _g++;
			var pos = this.indexes[i++] * 3;
			var x = this.buffer[pos++];
			var y = this.buffer[pos++];
			var z = this.buffer[pos];
			if(x < b.xMin) {
				b.xMin = x;
			}
			if(x > b.xMax) {
				b.xMax = x;
			}
			if(y < b.yMin) {
				b.yMin = y;
			}
			if(y > b.yMax) {
				b.yMax = y;
			}
			if(z < b.zMin) {
				b.zMin = z;
			}
			if(z > b.zMax) {
				b.zMax = z;
			}
		}
		return b;
	}
	,getPoints: function() {
		var vmin = 1073741824;
		var vmax = -1073741824;
		var _g = this.startIndex;
		var _g1 = this.startIndex + this.triCount * 3;
		while(_g < _g1) {
			var i = _g++;
			var pos = this.indexes[i];
			if(pos < vmin) {
				vmin = pos;
			}
			if(pos > vmax) {
				vmax = pos;
			}
		}
		var vcount = vmax + 1 - vmin;
		var bits = hxd_impl_BitSet._new(vcount);
		var points = [];
		var _g = this.startIndex;
		var _g1 = this.startIndex + this.triCount * 3;
		while(_g < _g1) {
			var i = _g++;
			var pos = this.indexes[i];
			var vidx = pos - vmin;
			if(!hxd_impl_BitSet.get(bits,vidx)) {
				pos *= 3;
				points.push(new h3d_col_FPoint(this.buffer[pos++],this.buffer[pos++],this.buffer[pos]));
				hxd_impl_BitSet.set(bits,vidx);
			}
		}
		return points;
	}
	,contains: function(p) {
		var i = this.startIndex;
		var x = p.x;
		var y = p.y;
		var z = p.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var p_x = x;
		var p_y = y;
		var p_z = z;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			var i0 = this.indexes[i++] * 3;
			var x = this.buffer[i0++];
			var y = this.buffer[i0++];
			var z = this.buffer[i0];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0_x = x;
			var p0_y = y;
			var p0_z = z;
			var i1 = this.indexes[i++] * 3;
			var x1 = this.buffer[i1++];
			var y1 = this.buffer[i1++];
			var z1 = this.buffer[i1];
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var i2 = this.indexes[i++] * 3;
			var x2 = this.buffer[i2++];
			var y2 = this.buffer[i2++];
			var z2 = this.buffer[i2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var p2_x = x2;
			var p2_y = y2;
			var p2_z = z2;
			var x3 = p1_x - p0_x;
			var y3 = p1_y - p0_y;
			var z3 = p1_z - p0_z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var d1_x = x3;
			var d1_y = y3;
			var d1_z = z3;
			var x4 = p2_x - p0_x;
			var y4 = p2_y - p0_y;
			var z4 = p2_z - p0_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var d2_x = x4;
			var d2_y = y4;
			var d2_z = z4;
			var x5 = d1_y * d2_z - d1_z * d2_y;
			var y5 = d1_z * d2_x - d1_x * d2_z;
			var z5 = d1_x * d2_y - d1_y * d2_x;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var n_x = x5;
			var n_y = y5;
			var n_z = z5;
			var d = n_x * p0_x + n_y * p0_y + n_z * p0_z;
			if(n_x * p_x + n_y * p_y + n_z * p_z >= d) {
				return false;
			}
		}
		return true;
	}
	,inFrustum: function(f,m) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,inSphere: function(s) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,rayIntersection: function(r,bestMatch) {
		var i = this.startIndex;
		var x = r.lx;
		var y = r.ly;
		var z = r.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var rdir_x = x;
		var rdir_y = y;
		var rdir_z = z;
		var x = r.px;
		var y = r.py;
		var z = r.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var r0_x = x;
		var r0_y = y;
		var r0_z = z;
		var best = -1.;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			var i0 = this.indexes[i++] * 3;
			var x = this.buffer[i0++];
			var y = this.buffer[i0++];
			var z = this.buffer[i0];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var p0_x = x;
			var p0_y = y;
			var p0_z = z;
			var i1 = this.indexes[i++] * 3;
			var x1 = this.buffer[i1++];
			var y1 = this.buffer[i1++];
			var z1 = this.buffer[i1];
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var i2 = this.indexes[i++] * 3;
			var x2 = this.buffer[i2++];
			var y2 = this.buffer[i2++];
			var z2 = this.buffer[i2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var p2_x = x2;
			var p2_y = y2;
			var p2_z = z2;
			var x3 = p1_x - p0_x;
			var y3 = p1_y - p0_y;
			var z3 = p1_z - p0_z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var e1_x = x3;
			var e1_y = y3;
			var e1_z = z3;
			var x4 = p2_x - p0_x;
			var y4 = p2_y - p0_y;
			var z4 = p2_z - p0_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var e2_x = x4;
			var e2_y = y4;
			var e2_z = z4;
			var x5 = rdir_y * e2_z - rdir_z * e2_y;
			var y5 = rdir_z * e2_x - rdir_x * e2_z;
			var z5 = rdir_x * e2_y - rdir_y * e2_x;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var p_x = x5;
			var p_y = y5;
			var p_z = z5;
			var det = e1_x * p_x + e1_y * p_y + e1_z * p_z;
			if(det < 1e-10) {
				continue;
			}
			var invDet = 1 / det;
			var x6 = r0_x - p0_x;
			var y6 = r0_y - p0_y;
			var z6 = r0_z - p0_z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var T_x = x6;
			var T_y = y6;
			var T_z = z6;
			var u = (T_x * p_x + T_y * p_y + T_z * p_z) * invDet;
			if(u < 0 || u > 1) {
				continue;
			}
			var x7 = T_y * e1_z - T_z * e1_y;
			var y7 = T_z * e1_x - T_x * e1_z;
			var z7 = T_x * e1_y - T_y * e1_x;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			var q_x = x7;
			var q_y = y7;
			var q_z = z7;
			var v = (rdir_x * q_x + rdir_y * q_y + rdir_z * q_z) * invDet;
			if(v < 0 || u + v > 1) {
				continue;
			}
			var t1 = (e2_x * q_x + e2_y * q_y + e2_z * q_z) * invDet;
			if(t1 < 1e-10) {
				continue;
			}
			if(!bestMatch) {
				return t1;
			}
			if(best < 0 || t1 < best) {
				best = t1;
			}
		}
		return best;
	}
	,makeDebugObj: function() {
		var points = [];
		var idx = new Array(0);
		var i = this.startIndex;
		var _g = 0;
		var _g1 = this.triCount;
		while(_g < _g1) {
			var t = _g++;
			idx.push(this.indexes[i++]);
			idx.push(this.indexes[i++]);
			idx.push(this.indexes[i++]);
		}
		i = 0;
		while(i < this.buffer.length) {
			var x = this.buffer[i++];
			var y = this.buffer[i++];
			var z = this.buffer[i++];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			points.push(new h3d_VectorImpl(x,y,z));
		}
		var prim = new h3d_prim_Polygon(points,idx);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_PolygonBuffer
});
var h3d_col_SkinCollider = function(obj,col) {
	this.lastBoundsFrame = -1;
	this.lastFrame = -1;
	this.obj = obj;
	this.col = col;
	this.transform = new h3d_col_PolygonBuffer();
	var tmp = this.transform;
	var this1 = col.buffer;
	var r = new Array(this1.length);
	haxe_ds_Vector.blit(this1,0,r,0,this1.length);
	tmp.setData(r,col.indexes,col.startIndex,col.triCount);
	this.currentBounds = new h3d_col_Bounds();
};
$hxClasses["h3d.col.SkinCollider"] = h3d_col_SkinCollider;
h3d_col_SkinCollider.__name__ = "h3d.col.SkinCollider";
h3d_col_SkinCollider.__super__ = h3d_col_Collider;
h3d_col_SkinCollider.prototype = $extend(h3d_col_Collider.prototype,{
	contains: function(p) {
		this.checkBounds();
		var _this = this.currentBounds;
		if(!(p.x >= _this.xMin && p.x < _this.xMax && p.y >= _this.yMin && p.y < _this.yMax && p.z >= _this.zMin && p.z < _this.zMax)) {
			return false;
		}
		this.applyTransform();
		return this.transform.contains(p);
	}
	,inFrustum: function(p,m) {
		this.checkBounds();
		var _this = this.currentBounds;
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		if(!p.hasBounds(_this)) {
			return false;
		}
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		this.applyTransform();
		return this.transform.inFrustum(p);
	}
	,inSphere: function(s) {
		this.checkBounds();
		var _this = this.currentBounds;
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var a = _this.xMin;
		var a1 = s.x;
		var b = _this.xMax;
		var b1 = a1 > b ? b : a1;
		var x = a < b1 ? b1 : a;
		var a = _this.yMin;
		var a1 = s.y;
		var b = _this.yMax;
		var b1 = a1 > b ? b : a1;
		var y = a < b1 ? b1 : a;
		var a = _this.zMin;
		var a1 = s.z;
		var b = _this.zMax;
		var b1 = a1 > b ? b : a1;
		var z = a < b1 ? b1 : a;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var dx = p_x - _this_x;
		var dy = p_y - _this_y;
		var dz = p_z - _this_z;
		if(!(dx * dx + dy * dy + dz * dz < s.r * s.r)) {
			return false;
		}
		this.applyTransform();
		throw haxe_Exception.thrown("Not implemented");
	}
	,rayIntersection: function(r,bestMatch) {
		this.checkBounds();
		if(this.currentBounds.rayIntersection(r,false) < 0) {
			return -1.;
		}
		this.applyTransform();
		return this.transform.rayIntersection(r,bestMatch);
	}
	,checkBounds: function() {
		if(!this.obj.jointsUpdated && this.lastBoundsFrame == this.obj.lastFrame) {
			return;
		}
		this.lastBoundsFrame = this.obj.lastFrame;
		this.obj.syncJoints();
		var _this = this.currentBounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
		this.obj.addBoundsRec(this.currentBounds,null);
	}
	,applyTransform: function() {
		if(!this.obj.jointsUpdated && this.lastFrame == this.obj.lastFrame) {
			return;
		}
		this.lastFrame = this.obj.lastFrame;
		this.obj.syncJoints();
		var j = 0;
		var v = 0;
		var nbones = this.obj.skinData.bonesPerVertex;
		var _g = 0;
		var _g1 = this.obj.skinData.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var px = 0.;
			var py = 0.;
			var pz = 0.;
			var x = this.col.buffer[v];
			var y = this.col.buffer[v + 1];
			var z = this.col.buffer[v + 2];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var _g2 = 0;
			var _g3 = nbones;
			while(_g2 < _g3) {
				var k = _g2++;
				var w = this.obj.skinData.vertexWeights[j];
				if(w == 0) {
					++j;
					continue;
				}
				var bid = this.obj.skinData.vertexJoints[j++];
				var x2 = _this_x;
				var y2 = _this_y;
				var z2 = _this_z;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				var x3 = x2;
				var y3 = y2;
				var z3 = z2;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				var p2_x = x3;
				var p2_y = y3;
				var p2_z = z3;
				var m = this.obj.currentPalette[bid];
				var px1 = p2_x * m._11 + p2_y * m._21 + p2_z * m._31 + m._41;
				var py1 = p2_x * m._12 + p2_y * m._22 + p2_z * m._32 + m._42;
				var pz1 = p2_x * m._13 + p2_y * m._23 + p2_z * m._33 + m._43;
				p2_x = px1;
				p2_y = py1;
				p2_z = pz1;
				px += p2_x * w;
				py += p2_y * w;
				pz += p2_z * w;
			}
			this.transform.buffer[v++] = px;
			this.transform.buffer[v++] = py;
			this.transform.buffer[v++] = pz;
		}
	}
	,makeDebugObj: function() {
		return new h3d_col_SkinColliderDebugObj(this);
	}
	,__class__: h3d_col_SkinCollider
});
var h3d_scene_Object = function(parent) {
	this.flags = 32768;
	this.absPos = new h3d_MatrixImpl();
	this.absPos.identity();
	this.x = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.y = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.z = 0;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.scaleX = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.scaleY = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.scaleZ = 1;
	var f = 1;
	var b = true;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	this.qRot = new h3d_Quat();
	var f = 1;
	var b = this.follow != null;
	if(b) {
		this.flags |= f;
	} else {
		this.flags &= ~f;
	}
	var f = 2;
	this.flags |= f;
	this.children = [];
	if(parent != null) {
		parent.addChild(this);
	}
};
$hxClasses["h3d.scene.Object"] = h3d_scene_Object;
h3d_scene_Object.__name__ = "h3d.scene.Object";
h3d_scene_Object.prototype = {
	set_cullingCollider: function(c) {
		this.cullingCollider = c;
		var f = 4096;
		this.flags &= ~f;
		return c;
	}
	,get_visible: function() {
		return (this.flags & 2) != 0;
	}
	,get_allocated: function() {
		return (this.flags & 32) != 0;
	}
	,get_posChanged: function() {
		return (this.flags & 1) != 0;
	}
	,get_culled: function() {
		return (this.flags & 4) != 0;
	}
	,get_followPositionOnly: function() {
		return (this.flags & 8) != 0;
	}
	,get_lightCameraCenter: function() {
		return (this.flags & 16) != 0;
	}
	,get_alwaysSyncAnimation: function() {
		return (this.flags & 64) != 0;
	}
	,get_inheritCulled: function() {
		return (this.flags & 128) != 0;
	}
	,get_ignoreBounds: function() {
		return (this.flags & 512) != 0;
	}
	,get_ignoreCollide: function() {
		return (this.flags & 1024) != 0;
	}
	,get_modelRoot: function() {
		return (this.flags & 256) != 0;
	}
	,get_ignoreParentTransform: function() {
		return (this.flags & 2048) != 0;
	}
	,get_cullingColliderInherited: function() {
		return (this.flags & 4096) != 0;
	}
	,get_fixedPosition: function() {
		return (this.flags & 8192) != 0;
	}
	,get_alwaysSync: function() {
		return (this.flags & 32768) != 0;
	}
	,set_posChanged: function(b) {
		var f = 1;
		var b1 = b || this.follow != null;
		if(b1) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b1;
	}
	,set_culled: function(b) {
		var f = 4;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_visible: function(b) {
		var f = 2;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_allocated: function(b) {
		var f = 32;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_followPositionOnly: function(b) {
		var f = 8;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_lightCameraCenter: function(b) {
		var f = 16;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_alwaysSyncAnimation: function(b) {
		var f = 64;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_ignoreBounds: function(b) {
		var f = 512;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_inheritCulled: function(b) {
		var f = 128;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_ignoreCollide: function(b) {
		var f = 1024;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_modelRoot: function(b) {
		var f = 256;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_ignoreParentTransform: function(b) {
		if(b != ((this.flags & 2048) != 0)) {
			var f = 1;
			var b1 = true;
			if(b1) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
		}
		var f = 2048;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_cullingColliderInherited: function(b) {
		var f = 4096;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_fixedPosition: function(b) {
		var f = 8192;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,set_alwaysSync: function(b) {
		var f = 32768;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return b;
	}
	,playAnimation: function(a) {
		return this.currentAnimation = a.createInstance(this);
	}
	,switchToAnimation: function(a) {
		return this.currentAnimation = a;
	}
	,stopAnimation: function(recursive) {
		if(recursive == null) {
			recursive = false;
		}
		this.currentAnimation = null;
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.stopAnimation(true);
			}
		}
	}
	,applyAnimationTransform: function(recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(this.defaultTransform != null) {
			var _this = this.defaultTransform;
			var x = 0.;
			var y = 0.;
			var z = 0.;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var s_x = x;
			var s_y = y;
			var s_z = z;
			s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
			s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
			s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
			if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
				s_x *= -1;
				s_y *= -1;
				s_z *= -1;
			}
			var v = s_x;
			this.scaleX = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var v = s_y;
			this.scaleY = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var v = s_z;
			this.scaleZ = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			this.qRot.initRotateMatrix(this.defaultTransform);
			var v = this.defaultTransform._41;
			this.x = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var v = this.defaultTransform._42;
			this.y = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var v = this.defaultTransform._43;
			this.z = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			var v = null;
			this.defaultTransform = v;
			var f = 1;
			var b = true;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
		}
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				c.applyAnimationTransform();
			}
		}
	}
	,getObjectsCount: function() {
		var k = 0;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			k += c.getObjectsCount() + 1;
		}
		return k;
	}
	,getMaterialByName: function(name) {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var m = o.getMaterialByName(name);
			if(m != null) {
				return m;
			}
		}
		return null;
	}
	,contains: function(o) {
		while(o != null) {
			o = o.parent;
			if(o == this) {
				return true;
			}
		}
		return false;
	}
	,find: function(f) {
		var v = f(this);
		if(v != null) {
			return v;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var v = o.find(f);
			if(v != null) {
				return v;
			}
		}
		return null;
	}
	,findAll: function(f,arr) {
		if(arr == null) {
			arr = [];
		}
		var v = f(this);
		if(v != null) {
			arr.push(v);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.findAll(f,arr);
		}
		return arr;
	}
	,getMaterials: function(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var o = _g1[_g];
				++_g;
				o.getMaterials(a);
			}
		}
		return a;
	}
	,localToGlobal: function(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h3d_VectorImpl(0.,0.,0.);
		}
		var m = this.absPos;
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		return pt;
	}
	,globalToLocal: function(pt) {
		var m = this.getInvPos();
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		return pt;
	}
	,getInvPos: function() {
		this.syncPos();
		if(this.invPos == null) {
			this.invPos = new h3d_MatrixImpl();
			this.invPos._44 = 0;
		}
		if(this.invPos._44 == 0) {
			this.invPos.inverse3x4(this.absPos);
		}
		return this.invPos;
	}
	,getBounds: function(b,relativeTo) {
		if(b == null) {
			b = new h3d_col_Bounds();
		}
		if(this.parent != null && this.parent != relativeTo) {
			this.parent.syncPos();
		}
		this.addBoundsRec(b,relativeTo == null ? null : relativeTo.getInvPos());
		return b;
	}
	,addBoundsRec: function(b,relativeTo) {
		if((this.flags & 1) != 0) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b1 = true;
				if(b1) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
			}
			var f = 1;
			var b1 = this.follow != null;
			if(b1) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			this.calcAbsPos();
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.addBoundsRec(b,relativeTo);
		}
	}
	,getMeshes: function(out) {
		if(out == null) {
			out = [];
		}
		var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
		if(m != null) {
			out.push(m);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.getMeshes(out);
		}
		return out;
	}
	,getMeshByName: function(name) {
		var value = this.getObjectByName(name);
		if(((value) instanceof h3d_scene_Mesh)) {
			return value;
		} else {
			return null;
		}
	}
	,getObjectByName: function(name) {
		if(this.name == name) {
			return this;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var o = c.getObjectByName(name);
			if(o != null) {
				return o;
			}
		}
		return null;
	}
	,clone: function(o) {
		if(o == null) {
			o = new h3d_scene_Object();
		}
		var v = this.x;
		o.x = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var v = this.y;
		o.y = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var v = this.z;
		o.z = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var v = this.scaleX;
		o.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var v = this.scaleY;
		o.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var v = this.scaleZ;
		o.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var _this = o.qRot;
		var q = this.qRot;
		_this.x = q.x;
		_this.y = q.y;
		_this.z = q.z;
		_this.w = q.w;
		o.name = this.name;
		o.set_follow(this.follow);
		var b = (this.flags & 8) != 0;
		var f = 8;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		var b = (this.flags & 2) != 0;
		var f = 2;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		if(this.defaultTransform != null) {
			var v = this.defaultTransform.clone();
			o.defaultTransform = v;
			var f = 1;
			var b = true;
			if(b) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			var c1 = c.clone();
			c1.parent = o;
			o.children.push(c1);
		}
		return o;
	}
	,addChild: function(o) {
		this.addChildAt(o,this.children.length);
	}
	,addChildAt: function(o,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		var p = this;
		while(p != null) {
			if(p == o) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(o.parent != null) {
			var old = (o.flags & 32) != 0;
			var f = 32;
			o.flags &= ~f;
			o.parent.removeChild(o);
			var f = 32;
			if(old) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
		}
		this.children.splice(pos,0,o);
		if((this.flags & 32) == 0 && (o.flags & 32) != 0) {
			o.onRemove();
		}
		o.parent = this;
		var f = 1;
		var b = true;
		if(b) {
			o.flags |= f;
		} else {
			o.flags &= ~f;
		}
		if((this.flags & 32) != 0) {
			if((o.flags & 32) == 0) {
				o.onAdd();
			} else {
				o.onParentChanged();
			}
		}
	}
	,iterVisibleMeshes: function(callb) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			return;
		}
		if((this.flags & 4) == 0) {
			var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
			if(m != null) {
				callb(m);
			}
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			o.iterVisibleMeshes(callb);
		}
	}
	,onParentChanged: function() {
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onParentChanged();
		}
	}
	,onAdd: function() {
		var f = 32;
		this.flags |= f;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	,onRemove: function() {
		var f = 32;
		this.flags &= ~f;
		var i = this.children.length - 1;
		while(i >= 0) this.children[i--].onRemove();
	}
	,removeChild: function(o) {
		if(HxOverrides.remove(this.children,o)) {
			if((o.flags & 32) != 0) {
				o.onRemove();
			}
			o.parent = null;
			var f = 1;
			var b = true;
			if(b) {
				o.flags |= f;
			} else {
				o.flags &= ~f;
			}
		}
	}
	,removeChildren: function() {
		while(this.children.length > 0) this.removeChild(this.children[0]);
	}
	,remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,getScene: function() {
		var p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h3d_scene_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	,getAbsPos: function() {
		this.syncPos();
		return this.absPos;
	}
	,getRelPos: function(obj) {
		if(obj == null) {
			return this.getAbsPos();
		}
		this.syncPos();
		var m = new h3d_MatrixImpl();
		m.multiply(this.absPos,obj.getInvPos());
		return m;
	}
	,isMesh: function() {
		return (((this) instanceof h3d_scene_Mesh) ? this : null) != null;
	}
	,toMesh: function() {
		var m = ((this) instanceof h3d_scene_Mesh) ? this : null;
		if(m != null) {
			return m;
		}
		throw haxe_Exception.thrown(Std.string(this) + " is not a Mesh");
	}
	,getCollider: function() {
		if((this.flags & 1024) != 0) {
			return null;
		}
		var colliders = [];
		var col = this.getGlobalCollider();
		if(col != null) {
			colliders.push(col);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var obj = _g1[_g];
			++_g;
			var c = obj.getCollider();
			if(c == null) {
				continue;
			}
			var cgrp = ((c) instanceof h3d_col_GroupCollider) ? c : null;
			if(cgrp != null) {
				var _g2 = 0;
				var _g3 = cgrp.colliders;
				while(_g2 < _g3.length) {
					var c1 = _g3[_g2];
					++_g2;
					colliders.push(c1);
				}
			} else {
				colliders.push(c);
			}
		}
		if(colliders.length == 0) {
			return null;
		}
		if(colliders.length == 1) {
			return colliders[0];
		}
		return new h3d_col_GroupCollider(colliders);
	}
	,getGlobalCollider: function() {
		if((this.flags & 1024) != 0) {
			return null;
		}
		var col = this.getLocalCollider();
		if(col == null) {
			return null;
		} else {
			return new h3d_col_ObjectCollider(this,col);
		}
	}
	,getLocalCollider: function() {
		return null;
	}
	,draw: function(ctx) {
	}
	,set_follow: function(v) {
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return this.follow = v;
	}
	,calcAbsPos: function() {
		this.qRot.toMatrix(this.absPos);
		this.absPos._11 *= this.scaleX;
		this.absPos._12 *= this.scaleX;
		this.absPos._13 *= this.scaleX;
		this.absPos._21 *= this.scaleY;
		this.absPos._22 *= this.scaleY;
		this.absPos._23 *= this.scaleY;
		this.absPos._31 *= this.scaleZ;
		this.absPos._32 *= this.scaleZ;
		this.absPos._33 *= this.scaleZ;
		this.absPos._41 = this.x;
		this.absPos._42 = this.y;
		this.absPos._43 = this.z;
		if(this.follow != null) {
			this.follow.syncPos();
			if((this.flags & 8) != 0) {
				var _this = this.absPos;
				var a = this.absPos;
				var b = this.parent.absPos;
				var m11 = a._11;
				var m12 = a._12;
				var m13 = a._13;
				var m21 = a._21;
				var m22 = a._22;
				var m23 = a._23;
				var a31 = a._31;
				var a32 = a._32;
				var a33 = a._33;
				var a41 = a._41;
				var a42 = a._42;
				var a43 = a._43;
				var b11 = b._11;
				var b12 = b._12;
				var b13 = b._13;
				var b21 = b._21;
				var b22 = b._22;
				var b23 = b._23;
				var b31 = b._31;
				var b32 = b._32;
				var b33 = b._33;
				var b41 = b._41;
				var b42 = b._42;
				var b43 = b._43;
				_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
				_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
				_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
				_this._14 = 0;
				_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
				_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
				_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
				_this._24 = 0;
				_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
				_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
				_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
				_this._34 = 0;
				_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
				_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
				_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
				_this._44 = 1;
				this.absPos._41 = this.x + this.follow.absPos._41;
				this.absPos._42 = this.y + this.follow.absPos._42;
				this.absPos._43 = this.z + this.follow.absPos._43;
			} else {
				this.absPos.multiply3x4(this.absPos,this.follow.absPos);
			}
		} else if(this.parent != null && (this.flags & 2048) == 0) {
			var _this = this.absPos;
			var a = this.absPos;
			var b = this.parent.absPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.defaultTransform != null) {
			var _this = this.absPos;
			var a = this.defaultTransform;
			var b = this.absPos;
			var m11 = a._11;
			var m12 = a._12;
			var m13 = a._13;
			var m21 = a._21;
			var m22 = a._22;
			var m23 = a._23;
			var a31 = a._31;
			var a32 = a._32;
			var a33 = a._33;
			var a41 = a._41;
			var a42 = a._42;
			var a43 = a._43;
			var b11 = b._11;
			var b12 = b._12;
			var b13 = b._13;
			var b21 = b._21;
			var b22 = b._22;
			var b23 = b._23;
			var b31 = b._31;
			var b32 = b._32;
			var b33 = b._33;
			var b41 = b._41;
			var b42 = b._42;
			var b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.invPos != null) {
			this.invPos._44 = 0;
		}
	}
	,sync: function(ctx) {
	}
	,syncRec: function(ctx) {
		if(this.currentAnimation != null) {
			var old = this.parent;
			var dt = ctx.elapsedTime;
			while(dt > 0 && this.currentAnimation != null) dt = this.currentAnimation.update(dt);
			if(this.currentAnimation != null && (ctx.visibleFlag && (this.flags & 2) != 0 && (this.flags & 4) == 0 || (this.flags & 64) != 0)) {
				this.currentAnimation.sync();
			}
			if(this.parent == null && old != null) {
				return;
			}
		}
		if((this.flags & 32768) == 0 && ((this.flags & 4) != 0 || (this.flags & 2) == 0 || !ctx.visibleFlag)) {
			return;
		}
		var old = ctx.visibleFlag;
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			ctx.visibleFlag = false;
		}
		if(ctx.cullingCollider != null && (this.cullingCollider == null || (this.flags & 4096) != 0)) {
			this.set_cullingCollider(ctx.cullingCollider);
			var f = 4096;
			this.flags |= f;
		} else if((this.flags & 4096) != 0) {
			this.set_cullingCollider(null);
		}
		var prevCollider = ctx.cullingCollider;
		if((this.flags & 128) != 0) {
			ctx.cullingCollider = this.cullingCollider;
		}
		var changed = (this.flags & 1) != 0;
		if(changed) {
			this.calcAbsPos();
		}
		if((this.flags & 8192) != 0) {
			if((this.flags & 16384) != 0 && !changed && !ctx.wasContextLost) {
				ctx.visibleFlag = old;
				ctx.cullingCollider = prevCollider;
				return;
			}
			var f = 16384;
			this.flags |= f;
		}
		this.sync(ctx);
		var f = 1;
		var b = this.follow != null;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		this.lastFrame = ctx.frame;
		var p = 0;
		var len = this.children.length;
		while(p < len) {
			var c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					var f = 1;
					var b = true;
					if(b) {
						c.flags |= f;
					} else {
						c.flags &= ~f;
					}
				}
				c.syncRec(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
		ctx.visibleFlag = old;
		ctx.cullingCollider = prevCollider;
	}
	,syncPos: function() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if((this.flags & 1) != 0) {
			var f = 1;
			var b = this.follow != null;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b = true;
				if(b) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
			}
		}
	}
	,emit: function(ctx) {
	}
	,emitRec: function(ctx) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0 && !ctx.computingStatic) {
			return;
		}
		if((this.flags & 1) != 0) {
			if(this.currentAnimation != null) {
				this.currentAnimation.sync();
			}
			var f = 1;
			var b = this.follow != null;
			if(b) {
				this.flags |= f;
			} else {
				this.flags &= ~f;
			}
			this.calcAbsPos();
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var f = 1;
				var b = true;
				if(b) {
					c.flags |= f;
				} else {
					c.flags &= ~f;
				}
			}
		}
		if((this.flags & 4) == 0 || ctx.computingStatic) {
			this.emit(ctx);
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.emitRec(ctx);
		}
	}
	,set_x: function(v) {
		this.x = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,set_y: function(v) {
		this.y = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,set_z: function(v) {
		this.z = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,set_scaleX: function(v) {
		this.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,set_scaleY: function(v) {
		this.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,set_scaleZ: function(v) {
		this.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,set_defaultTransform: function(v) {
		this.defaultTransform = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		return v;
	}
	,setPosition: function(x,y,z) {
		this.x = x;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		this.y = y;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		this.z = z;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,setTransform: function(mat) {
		var _this = mat;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		var v = mat._41;
		this.x = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v = mat._42;
		this.y = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v = mat._43;
		this.z = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v = s_x;
		this.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v = s_y;
		this.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v = s_z;
		this.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		h3d_scene_Object.tmpMat.load(mat);
		h3d_scene_Object.tmpMat.prependScale(1.0 / s_x,1.0 / s_y,1.0 / s_z);
		this.qRot.initRotateMatrix(h3d_scene_Object.tmpMat);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,getTransform: function(mat) {
		if(mat == null) {
			mat = new h3d_MatrixImpl();
		}
		mat.initScale(this.scaleX,this.scaleY,this.scaleZ);
		this.qRot.toMatrix(h3d_scene_Object.tmpMat);
		mat.multiply3x4(mat,h3d_scene_Object.tmpMat);
		mat._41 = this.x;
		mat._42 = this.y;
		mat._43 = this.z;
		return mat;
	}
	,rotate: function(rx,ry,rz,qTmp) {
		if(qTmp == null) {
			qTmp = new h3d_Quat();
		}
		qTmp.initRotation(rx,ry,rz);
		this.qRot.multiply(qTmp,this.qRot);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,setRotation: function(rx,ry,rz) {
		this.qRot.initRotation(rx,ry,rz);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,setRotationAxis: function(ax,ay,az,angle) {
		this.qRot.initRotateAxis(ax,ay,az,angle);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,setDirection: function(v,up) {
		this.qRot.initDirection(v,up);
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,getLocalDirection: function() {
		var _this = this.qRot;
		var x = 1 - 2 * (_this.y * _this.y + _this.z * _this.z);
		var y = 2 * (_this.x * _this.y + _this.z * _this.w);
		var z = 2 * (_this.x * _this.z - _this.y * _this.w);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,getRotationQuat: function() {
		return this.qRot;
	}
	,setRotationQuat: function(q) {
		this.qRot = q;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,scale: function(v) {
		var v1 = this.scaleX * v;
		this.scaleX = v1;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v1 = this.scaleY * v;
		this.scaleY = v1;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var v1 = this.scaleZ * v;
		this.scaleZ = v1;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,setScale: function(v) {
		this.scaleX = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		this.scaleY = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		this.scaleZ = v;
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__.split(".").pop() + (this.name == null ? "" : "(" + this.name + ")");
	}
	,getChildAt: function(n) {
		return this.children[n];
	}
	,getChildIndex: function(o) {
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.children[i] == o) {
				return i;
			}
		}
		return -1;
	}
	,get_numChildren: function() {
		return this.children.length;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$h3d_$scene_$Object(this.children);
	}
	,__class__: h3d_scene_Object
};
var h3d_col_SkinColliderDebugObj = function(col) {
	this.boxes = [];
	h3d_scene_Object.call(this,null);
	this.col = col;
	this.skin = col.obj;
	this.box = new h3d_scene_Box(16777215,col.currentBounds);
	this.addChild(this.box);
	if(true != ((this.flags & 2048) != 0)) {
		var f = 1;
		var b = true;
		if(b) {
			this.flags |= f;
		} else {
			this.flags &= ~f;
		}
	}
	var f = 2048;
	this.flags |= f;
	this.createJoints();
};
$hxClasses["h3d.col.SkinColliderDebugObj"] = h3d_col_SkinColliderDebugObj;
h3d_col_SkinColliderDebugObj.__name__ = "h3d.col.SkinColliderDebugObj";
h3d_col_SkinColliderDebugObj.__super__ = h3d_scene_Object;
h3d_col_SkinColliderDebugObj.prototype = $extend(h3d_scene_Object.prototype,{
	createJoints: function() {
		var joints = this.skin.getSkinData().allJoints;
		var _g = 0;
		while(_g < joints.length) {
			var j = joints[_g];
			++_g;
			var b = new h3d_col_Bounds();
			b.xMin = -1;
			b.yMin = -1;
			b.zMin = -1;
			b.xMax = 1;
			b.yMax = 1;
			b.zMax = 1;
			var b1 = new h3d_scene_Box(10526880,b,null,this);
			if(j.offsets != null) {
				var _this = b1.bounds;
				_this.xMin = 1e20;
				_this.xMax = -1e20;
				_this.yMin = 1e20;
				_this.yMax = -1e20;
				_this.zMin = 1e20;
				_this.zMax = -1e20;
				var _this1 = j.offsets;
				var x = _this1.xMin;
				var y = _this1.yMin;
				var z = _this1.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var pt_x = x1;
				var pt_y = y1;
				var pt_z = z1;
				var _this2 = b1.bounds;
				var x2 = pt_x;
				var y2 = pt_y;
				var z2 = pt_z;
				var r = j.offsetRay;
				if(x2 - r < _this2.xMin) {
					_this2.xMin = x2 - r;
				}
				if(x2 + r > _this2.xMax) {
					_this2.xMax = x2 + r;
				}
				if(y2 - r < _this2.yMin) {
					_this2.yMin = y2 - r;
				}
				if(y2 + r > _this2.yMax) {
					_this2.yMax = y2 + r;
				}
				if(z2 - r < _this2.zMin) {
					_this2.zMin = z2 - r;
				}
				if(z2 + r > _this2.zMax) {
					_this2.zMax = z2 + r;
				}
				var _this3 = j.offsets;
				var x3 = _this3.xMax;
				var y3 = _this3.yMax;
				var z3 = _this3.zMax;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				var x4 = x3;
				var y4 = y3;
				var z4 = z3;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				var pt_x1 = x4;
				var pt_y1 = y4;
				var pt_z1 = z4;
				var _this4 = b1.bounds;
				var x5 = pt_x1;
				var y5 = pt_y1;
				var z5 = pt_z1;
				var r1 = j.offsetRay;
				if(x5 - r1 < _this4.xMin) {
					_this4.xMin = x5 - r1;
				}
				if(x5 + r1 > _this4.xMax) {
					_this4.xMax = x5 + r1;
				}
				if(y5 - r1 < _this4.yMin) {
					_this4.yMin = y5 - r1;
				}
				if(y5 + r1 > _this4.yMax) {
					_this4.yMax = y5 + r1;
				}
				if(z5 - r1 < _this4.zMin) {
					_this4.zMin = z5 - r1;
				}
				if(z5 + r1 > _this4.zMax) {
					_this4.zMax = z5 + r1;
				}
			} else {
				var _this5 = b1.bounds;
				_this5.xMin = 1e20;
				_this5.xMax = -1e20;
				_this5.yMin = 1e20;
				_this5.yMax = -1e20;
				_this5.zMin = 1e20;
				_this5.zMax = -1e20;
				var _this6 = b1.bounds;
				if(-0.1 < _this6.xMin) {
					_this6.xMin = -0.1;
				}
				if(0.1 > _this6.xMax) {
					_this6.xMax = 0.1;
				}
				if(-0.1 < _this6.yMin) {
					_this6.yMin = -0.1;
				}
				if(0.1 > _this6.yMax) {
					_this6.yMax = 0.1;
				}
				if(-0.1 < _this6.zMin) {
					_this6.zMin = -0.1;
				}
				if(0.1 > _this6.zMax) {
					_this6.zMax = 0.1;
				}
			}
			this.boxes.push(b1);
		}
	}
	,updateJoints: function() {
		var _g = 0;
		var _g1 = this.boxes.length;
		while(_g < _g1) {
			var i = _g++;
			var j = this.skin.skinData.allJoints[i];
			var b = this.boxes[i];
			if(j.offsets != null) {
				var m = this.skin.currentPalette[j.bindIndex];
				b.setTransform(m);
			} else {
				b.setTransform(this.skin.currentAbsPose[j.index]);
			}
		}
	}
	,sync: function(ctx) {
		this.col.checkBounds();
		this.updateJoints();
	}
	,__class__: h3d_col_SkinColliderDebugObj
});
var h3d_col_Sphere = function(x,y,z,r) {
	if(r == null) {
		r = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	var sx = x;
	var sy = y;
	var sz = z;
	var sr = r;
	if(sr == null) {
		sr = 0.;
	}
	if(sz == null) {
		sz = 0.;
	}
	if(sy == null) {
		sy = 0.;
	}
	if(sx == null) {
		sx = 0.;
	}
	this.x = sx;
	this.y = sy;
	this.z = sz;
	this.r = sr;
};
$hxClasses["h3d.col.Sphere"] = h3d_col_Sphere;
h3d_col_Sphere.__name__ = "h3d.col.Sphere";
h3d_col_Sphere.__super__ = h3d_col_Collider;
h3d_col_Sphere.prototype = $extend(h3d_col_Collider.prototype,{
	load: function(sx,sy,sz,sr) {
		if(sr == null) {
			sr = 0.;
		}
		if(sz == null) {
			sz = 0.;
		}
		if(sy == null) {
			sy = 0.;
		}
		if(sx == null) {
			sx = 0.;
		}
		this.x = sx;
		this.y = sy;
		this.z = sz;
		this.r = sr;
	}
	,getCenter: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,z);
	}
	,distance: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var dz = p.z - this.z;
		var d = dx * dx + dy * dy + dz * dz - this.r * this.r;
		if(d < 0) {
			return -Math.sqrt(-d);
		} else {
			return Math.sqrt(d);
		}
	}
	,distanceSq: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var dz = p.z - this.z;
		return dx * dx + dy * dy + dz * dz - this.r * this.r;
	}
	,contains: function(p) {
		var dx = p.x - this.x;
		var dy = p.y - this.y;
		var dz = p.z - this.z;
		return dx * dx + dy * dy + dz * dz - this.r * this.r < 0;
	}
	,rayIntersection: function(r,bestMatch) {
		var r2 = this.r * this.r;
		var px = r.px + r.lx;
		var py = r.py + r.ly;
		var pz = r.pz + r.lz;
		var a = r.lx * r.lx + r.ly * r.ly + r.lz * r.lz;
		var b = 2 * r.lx * (this.x - px) + 2 * r.ly * (this.y - py) + 2 * r.lz * (this.z - pz);
		var c = this.x * this.x + this.y * this.y + this.z * this.z + (px * px + py * py + pz * pz) - 2 * (this.x * px + this.y * py + this.z * pz) - r2;
		var d = b * b - 4 * a * c;
		if(d < 0) {
			return -1;
		}
		d = Math.sqrt(d);
		var t = (-b + d) / (2 * a);
		return 1 - t;
	}
	,inFrustum: function(f,m) {
		if(m != null) {
			return this.inFrustumMatrix(f,m);
		}
		return f.hasSphere(this);
	}
	,inFrustumMatrix: function(f,m) {
		var oldX = this.x;
		var oldY = this.y;
		var oldZ = this.z;
		var oldR = this.r;
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		var py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		var pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		this.x = v_x;
		this.y = v_y;
		this.z = v_z;
		var _this = m;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var scale_x = x;
		var scale_y = y;
		var scale_z = z;
		scale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		scale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		scale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		this.r *= Math.max(Math.max(scale_x,scale_y),scale_z);
		var res = f.hasSphere(this);
		this.x = oldX;
		this.y = oldY;
		this.z = oldZ;
		this.r = oldR;
		return res;
	}
	,transform: function(m) {
		var _this = m;
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var s_x = x;
		var s_y = y;
		var s_z = z;
		s_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		s_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		s_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		var f = s_x;
		var a = f < 0 ? -f : f;
		var f = s_y;
		var b = f < 0 ? -f : f;
		var a1 = a < b ? b : a;
		var f = s_z;
		var b = f < 0 ? -f : f;
		var smax = a1 < b ? b : a1;
		this.r *= smax;
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var pt_x = x1;
		var pt_y = y1;
		var pt_z = z1;
		var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
		var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
		var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
		pt_x = px;
		pt_y = py;
		pt_z = pz;
		this.x = pt_x;
		this.y = pt_y;
		this.z = pt_z;
	}
	,inSphere: function(s) {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var x = s.x;
		var y = s.y;
		var z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var v_x = x1;
		var v_y = y1;
		var v_z = z1;
		var dx = v_x - _this_x;
		var dy = v_y - _this_y;
		var dz = v_z - _this_z;
		return dx * dx + dy * dy + dz * dz < (s.r + this.r) * (s.r + this.r);
	}
	,toString: function() {
		var x = this.x;
		var y = this.y;
		var z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return "Sphere{" + Std.string(new h3d_VectorImpl(x,y,z)) + "," + hxd_Math.fmt(this.r) + "}";
	}
	,makeDebugObj: function() {
		var prim = new h3d_prim_Sphere(this.r,20,15);
		prim.translate(this.x,this.y,this.z);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
	,__class__: h3d_col_Sphere
});
var h3d_impl_Feature = $hxEnums["h3d.impl.Feature"] = { __ename__:"h3d.impl.Feature",__constructs__:null
	,StandardDerivatives: {_hx_name:"StandardDerivatives",_hx_index:0,__enum__:"h3d.impl.Feature",toString:$estr}
	,FloatTextures: {_hx_name:"FloatTextures",_hx_index:1,__enum__:"h3d.impl.Feature",toString:$estr}
	,AllocDepthBuffer: {_hx_name:"AllocDepthBuffer",_hx_index:2,__enum__:"h3d.impl.Feature",toString:$estr}
	,HardwareAccelerated: {_hx_name:"HardwareAccelerated",_hx_index:3,__enum__:"h3d.impl.Feature",toString:$estr}
	,MultipleRenderTargets: {_hx_name:"MultipleRenderTargets",_hx_index:4,__enum__:"h3d.impl.Feature",toString:$estr}
	,Queries: {_hx_name:"Queries",_hx_index:5,__enum__:"h3d.impl.Feature",toString:$estr}
	,SRGBTextures: {_hx_name:"SRGBTextures",_hx_index:6,__enum__:"h3d.impl.Feature",toString:$estr}
	,ShaderModel3: {_hx_name:"ShaderModel3",_hx_index:7,__enum__:"h3d.impl.Feature",toString:$estr}
	,BottomLeftCoords: {_hx_name:"BottomLeftCoords",_hx_index:8,__enum__:"h3d.impl.Feature",toString:$estr}
	,Wireframe: {_hx_name:"Wireframe",_hx_index:9,__enum__:"h3d.impl.Feature",toString:$estr}
	,InstancedRendering: {_hx_name:"InstancedRendering",_hx_index:10,__enum__:"h3d.impl.Feature",toString:$estr}
};
h3d_impl_Feature.__constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
h3d_impl_Feature.__empty_constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
var h3d_impl_QueryKind = $hxEnums["h3d.impl.QueryKind"] = { __ename__:"h3d.impl.QueryKind",__constructs__:null
	,TimeStamp: {_hx_name:"TimeStamp",_hx_index:0,__enum__:"h3d.impl.QueryKind",toString:$estr}
	,Samples: {_hx_name:"Samples",_hx_index:1,__enum__:"h3d.impl.QueryKind",toString:$estr}
};
h3d_impl_QueryKind.__constructs__ = [h3d_impl_QueryKind.TimeStamp,h3d_impl_QueryKind.Samples];
h3d_impl_QueryKind.__empty_constructs__ = [h3d_impl_QueryKind.TimeStamp,h3d_impl_QueryKind.Samples];
var h3d_impl_RenderFlag = $hxEnums["h3d.impl.RenderFlag"] = { __ename__:"h3d.impl.RenderFlag",__constructs__:null
	,CameraHandness: {_hx_name:"CameraHandness",_hx_index:0,__enum__:"h3d.impl.RenderFlag",toString:$estr}
};
h3d_impl_RenderFlag.__constructs__ = [h3d_impl_RenderFlag.CameraHandness];
h3d_impl_RenderFlag.__empty_constructs__ = [h3d_impl_RenderFlag.CameraHandness];
var h3d_impl_Driver = function() {
	this.shaderCache = h3d_impl_Driver.SHADER_CACHE;
};
$hxClasses["h3d.impl.Driver"] = h3d_impl_Driver;
h3d_impl_Driver.__name__ = "h3d.impl.Driver";
h3d_impl_Driver.setShaderCache = function(cache) {
	h3d_impl_Driver.SHADER_CACHE = cache;
};
h3d_impl_Driver.prototype = {
	hasFeature: function(f) {
		return false;
	}
	,setRenderFlag: function(r,value) {
	}
	,isSupportedFormat: function(fmt) {
		return false;
	}
	,isDisposed: function() {
		return true;
	}
	,dispose: function() {
	}
	,begin: function(frame) {
	}
	,log: function(str) {
	}
	,generateMipMaps: function(texture) {
		throw haxe_Exception.thrown("Mipmaps auto generation is not supported on this platform");
	}
	,getNativeShaderCode: function(shader) {
		return null;
	}
	,logImpl: function(str) {
	}
	,clear: function(color,depth,stencil) {
	}
	,captureRenderBuffer: function(pixels) {
	}
	,capturePixels: function(tex,layer,mipLevel,region) {
		throw haxe_Exception.thrown("Can't capture pixels on this platform");
	}
	,getDriverName: function(details) {
		return "Not available";
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
	}
	,resize: function(width,height) {
	}
	,selectShader: function(shader) {
		return false;
	}
	,selectMaterial: function(pass) {
	}
	,uploadShaderBuffers: function(buffers,which) {
	}
	,selectBuffer: function(buffer) {
	}
	,selectMultiBuffers: function(format,buffers) {
	}
	,draw: function(ibuf,startIndex,ntriangles) {
	}
	,drawInstanced: function(ibuf,commands) {
	}
	,setRenderZone: function(x,y,width,height) {
	}
	,setRenderTarget: function(tex,layer,mipLevel,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
	}
	,setRenderTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
	}
	,setDepth: function(tex) {
	}
	,allocDepthBuffer: function(b) {
		return null;
	}
	,disposeDepthBuffer: function(b) {
	}
	,getDefaultDepthBuffer: function() {
		return null;
	}
	,present: function() {
	}
	,end: function() {
	}
	,setDebug: function(b) {
	}
	,allocTexture: function(t) {
		return null;
	}
	,allocBuffer: function(b) {
		return null;
	}
	,allocInstanceBuffer: function(b,bytes) {
	}
	,disposeTexture: function(t) {
	}
	,disposeBuffer: function(b) {
	}
	,disposeInstanceBuffer: function(b) {
	}
	,uploadIndexData: function(i,startIndice,indiceCount,buf,bufPos) {
	}
	,uploadBufferData: function(b,startVertex,vertexCount,buf,bufPos) {
	}
	,uploadBufferBytes: function(b,startVertex,vertexCount,buf,bufPos) {
	}
	,uploadTextureBitmap: function(t,bmp,mipLevel,side) {
	}
	,uploadTexturePixels: function(t,pixels,mipLevel,side) {
	}
	,readBufferBytes: function(b,startVertex,vertexCount,buf,bufPos) {
		throw haxe_Exception.thrown("Driver does not allow to read vertex bytes");
	}
	,copyTexture: function(from,to) {
		return false;
	}
	,allocQuery: function(queryKind) {
		return null;
	}
	,deleteQuery: function(q) {
	}
	,beginQuery: function(q) {
	}
	,endQuery: function(q) {
	}
	,queryResultAvailable: function(q) {
		return true;
	}
	,queryResult: function(q) {
		return 0.;
	}
	,computeDispatch: function(x,y,z) {
		if(z == null) {
			z = 1;
		}
		if(y == null) {
			y = 1;
		}
		if(x == null) {
			x = 1;
		}
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: h3d_impl_Driver
};
var h3d_impl__$GlDriver_CompiledShader = function(s,kind,shader) {
	this.s = s;
	this.kind = kind;
	this.shader = shader;
};
$hxClasses["h3d.impl._GlDriver.CompiledShader"] = h3d_impl__$GlDriver_CompiledShader;
h3d_impl__$GlDriver_CompiledShader.__name__ = "h3d.impl._GlDriver.CompiledShader";
h3d_impl__$GlDriver_CompiledShader.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledShader
};
var h3d_impl__$GlDriver_CompiledAttribute = function() {
};
$hxClasses["h3d.impl._GlDriver.CompiledAttribute"] = h3d_impl__$GlDriver_CompiledAttribute;
h3d_impl__$GlDriver_CompiledAttribute.__name__ = "h3d.impl._GlDriver.CompiledAttribute";
h3d_impl__$GlDriver_CompiledAttribute.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledAttribute
};
var h3d_impl__$GlDriver_CompiledProgram = function() {
};
$hxClasses["h3d.impl._GlDriver.CompiledProgram"] = h3d_impl__$GlDriver_CompiledProgram;
h3d_impl__$GlDriver_CompiledProgram.__name__ = "h3d.impl._GlDriver.CompiledProgram";
h3d_impl__$GlDriver_CompiledProgram.prototype = {
	__class__: h3d_impl__$GlDriver_CompiledProgram
};
var h3d_impl_GlDriver = function(antiAlias) {
	if(antiAlias == null) {
		antiAlias = 0;
	}
	this.features = new haxe_ds_EnumValueMap();
	this.maxCompressedTexturesSupport = 0;
	this.hasMultiIndirect = false;
	this.rightHanded = false;
	this.firstShader = true;
	this.boundTextures = [];
	this.curTargets = [];
	var _g = [];
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	_g.push(0);
	this.currentDivisor = _g;
	this.curColorMask = -1;
	this.lastActiveIndex = 0;
	this.curStEnabled = false;
	this.curStMaskBits = -1;
	this.curStOpBits = -1;
	this.curMatBits = -1;
	this.maxIdxCurAttribs = 0;
	this.curAttribs = [];
	h3d_impl_Driver.call(this);
	this.canvas = hxd_Window.getInstance().canvas;
	var options = { alpha : false, stencil : true, antialias : antiAlias > 0};
	if(h3d_impl_GlDriver.ALLOW_WEBGL2) {
		this.gl = this.canvas.getContext("webgl2",options);
	}
	if(this.gl == null) {
		this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvas,options);
	}
	if(this.gl == null) {
		throw haxe_Exception.thrown("Could not acquire GL context");
	}
	if(typeof(WebGLDebugUtils) != "undefined") {
		this.gl = WebGLDebugUtils.makeDebugContext(this.gl);
		this.glDebug = true;
	}
	this.commonFB = this.gl.createFramebuffer();
	this.programs = new haxe_ds_IntMap();
	this.defStencil = new h3d_mat_Stencil();
	this.frame = hxd_Timer.frameCount;
	var v = this.gl.getParameter(7938);
	var reg = new EReg("ES ([0-9]+\\.[0-9]+)","");
	if(reg.match(v)) {
		this.glES = parseFloat(reg.matched(1));
	}
	var reg = new EReg("[0-9]+\\.[0-9]+","");
	var v = this.gl.getParameter(35724);
	if(reg.match(v)) {
		this.glES = parseFloat(reg.matched(0));
		this.shaderVersion = Math.round(parseFloat(reg.matched(0)) * 100);
	}
	this.drawMode = 4;
	this.makeFeatures();
	if(this.hasFeature(h3d_impl_Feature.InstancedRendering) && this.glES < 3) {
		var extension = this.gl.getExtension("ANGLE_instanced_arrays");
		this.gl["vertexAttribDivisor"] = $bind(extension,extension.vertexAttribDivisorANGLE);
		this.gl["drawElementsInstanced"] = $bind(extension,extension.drawElementsInstancedANGLE);
	}
	hxsl_SharedShader.UNROLL_LOOPS = !this.hasFeature(h3d_impl_Feature.ShaderModel3);
	this.gl.pixelStorei(3333,1);
	this.gl.pixelStorei(3317,1);
};
$hxClasses["h3d.impl.GlDriver"] = h3d_impl_GlDriver;
h3d_impl_GlDriver.__name__ = "h3d.impl.GlDriver";
h3d_impl_GlDriver.__super__ = h3d_impl_Driver;
h3d_impl_GlDriver.prototype = $extend(h3d_impl_Driver.prototype,{
	setRenderFlag: function(r,value) {
		this.rightHanded = value > 0;
	}
	,logImpl: function(str) {
		console.log(str);
	}
	,setDebug: function(d) {
		this.debug = d;
	}
	,begin: function(frame) {
		this.frame = frame;
		this.resetStream();
		this.gl.useProgram(null);
		this.curShader = null;
		this.curBuffer = null;
	}
	,makeCompiler: function() {
		var glout = new hxsl_GlslOut();
		glout.glES = this.glES;
		glout.version = this.shaderVersion;
		glout.intelDriverFix = this.isIntelGpu;
		return glout;
	}
	,getNativeShaderCode: function(shader) {
		var _gthis = this;
		var sh = shader.vertex.data;
		var tmp = "// vertex:\n" + _gthis.makeCompiler().run(sh) + "// fragment:\n";
		var sh = shader.fragment.data;
		return tmp + _gthis.makeCompiler().run(sh);
	}
	,getDriverName: function(details) {
		var render = this.gl.getParameter(7937);
		if(details) {
			render += " GLv" + Std.string(this.gl.getParameter(7938));
		} else {
			render = render.split("/").shift();
		}
		render = render.split("WebGL ").join("");
		return "OpenGL " + render;
	}
	,compileShader: function(glout,shader) {
		var type = shader.kind == hxsl_FunctionKind.Vertex ? 35633 : 35632;
		var s = this.gl.createShader(type);
		if(shader.code == null) {
			shader.code = glout.run(shader.data);
			shader.data.funs = null;
		}
		this.gl.shaderSource(s,shader.code);
		this.gl.compileShader(s);
		var log = this.gl.getShaderInfoLog(s);
		if(this.gl.getShaderParameter(s,35713) != 1) {
			var log = this.gl.getShaderInfoLog(s);
			var lid = Std.parseInt(HxOverrides.substr(log,9,null));
			var line = lid == null ? null : shader.code.split("\n")[lid - 1];
			if(line == null) {
				line = "";
			} else {
				line = "(" + StringTools.trim(line) + ")";
			}
			var codeLines = shader.code.split("\n");
			var _g = 0;
			var _g1 = codeLines.length;
			while(_g < _g1) {
				var i = _g++;
				codeLines[i] = i + 1 + "\t" + codeLines[i];
			}
			throw haxe_Exception.thrown("An error occurred compiling the shaders: " + log + line + "\n\n" + codeLines.join("\n"));
		}
		return new h3d_impl__$GlDriver_CompiledShader(s,shader.kind,shader);
	}
	,initShader: function(p,s,shader,rt) {
		var prefix = s.kind == hxsl_FunctionKind.Vertex ? "vertex" : "fragment";
		s.globals = this.gl.getUniformLocation(p.p,prefix + "Globals");
		s.params = this.gl.getUniformLocation(p.p,prefix + "Params");
		s.textures = [];
		var index = 0;
		var curT = null;
		var mode = 0;
		var name = "";
		var t = shader.textures;
		while(t != null) {
			var tt = t.type;
			var count = 1;
			switch(tt._hx_index) {
			case 15:
				var _g = tt.size;
				if(_g._hx_index == 0) {
					var n = _g.v;
					var t1 = tt.t;
					tt = t1;
					count = n;
				}
				break;
			case 17:
				var _g1 = tt.size;
				tt = hxsl_Type.TSampler2D;
				break;
			default:
			}
			if(tt != curT) {
				curT = tt;
				switch(tt._hx_index) {
				case 10:
					mode = 3553;
					name = "Textures";
					break;
				case 11:
					mode = 35866;
					name = "TexturesArray";
					break;
				case 12:
					mode = 34067;
					name = "TexturesCube";
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture type " + Std.string(tt));
				}
				index = 0;
			}
			var _g2 = 0;
			var _g3 = count;
			while(_g2 < _g3) {
				var i = _g2++;
				var loc = this.gl.getUniformLocation(p.p,prefix + name + "[" + index + "]");
				if(loc == null) {
					throw haxe_Exception.thrown("Texture " + rt.spec.instances[t.instance].shader.data.name + "." + t.name + " is missing from generated shader");
				}
				s.textures.push({ u : loc, t : curT, mode : mode});
				++index;
			}
			t = t.next;
		}
		if(shader.bufferCount > 0) {
			var _g = [];
			var _g1 = 0;
			var _g2 = shader.bufferCount;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this.gl.getUniformBlockIndex(p.p,(shader.kind == hxsl_FunctionKind.Vertex ? "vertex_" : "") + "uniform_buffer" + i));
			}
			s.buffers = _g;
			var start = 0;
			if(s.kind == hxsl_FunctionKind.Fragment) {
				start = rt.vertex.bufferCount;
			}
			var _g = 0;
			var _g1 = shader.bufferCount;
			while(_g < _g1) {
				var i = _g++;
				this.gl.uniformBlockBinding(p.p,s.buffers[i],i + start);
			}
		}
	}
	,selectShader: function(shader) {
		var p = this.programs.h[shader.id];
		if(p == null) {
			p = new h3d_impl__$GlDriver_CompiledProgram();
			var glout = this.makeCompiler();
			p.vertex = this.compileShader(glout,shader.vertex);
			p.fragment = this.compileShader(glout,shader.fragment);
			p.p = this.gl.createProgram();
			this.gl.attachShader(p.p,p.vertex.s);
			this.gl.attachShader(p.p,p.fragment.s);
			var log = null;
			try {
				this.gl.linkProgram(p.p);
				if(this.gl.getProgramParameter(p.p,35714) != 1) {
					log = this.gl.getProgramInfoLog(p.p);
				}
			} catch( _g ) {
				var e = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Shader linkage error: " + Std.string(e) + " (" + this.getDriverName(false) + ")");
			}
			this.gl.deleteShader(p.vertex.s);
			this.gl.deleteShader(p.fragment.s);
			if(log != null) {
				this.gl.deleteProgram(p.p);
				throw haxe_Exception.thrown("Program linkage failure: " + log + "\nVertex=\n" + shader.vertex.code + "\n\nFragment=\n" + shader.fragment.code);
			}
			this.firstShader = false;
			this.initShader(p,p.vertex,shader.vertex,shader);
			this.initShader(p,p.fragment,shader.fragment,shader);
			p.attribs = [];
			p.hasAttribIndex = 0;
			var format = [];
			var _g = 0;
			var _g1 = shader.vertex.data.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				if(v.kind._hx_index == 1) {
					var t = hxd_InputFormat.fromHXSL(v.type);
					var index = this.gl.getAttribLocation(p.p,glout.varNames.h.hasOwnProperty(v.id) ? glout.varNames.h[v.id] : v.name);
					if(index < 0) {
						continue;
					}
					if(index >= 32) {
						throw haxe_Exception.thrown("assert");
					}
					var a = new h3d_impl__$GlDriver_CompiledAttribute();
					a.type = 5126;
					a.index = index;
					a.size = t & 7;
					var _g2 = v.type;
					if(_g2._hx_index == 9) {
						var n = _g2.size;
						a.type = 5120;
						a.size = n;
					}
					a.divisor = 0;
					if(v.qualifiers != null) {
						var _g3 = 0;
						var _g4 = v.qualifiers;
						while(_g3 < _g4.length) {
							var q = _g4[_g3];
							++_g3;
							if(q._hx_index == 9) {
								var n1 = q.v;
								a.divisor = n1;
							}
						}
					}
					p.attribs.push(a);
					p.hasAttribIndex |= 1 << a.index;
					format.push(new hxd_BufferInput(v.name,t,0));
				}
			}
			p.format = hxd_BufferFormat.make(format);
			this.programs.h[shader.id] = p;
		}
		if(this.curShader == p) {
			return false;
		}
		this.setProgram(p);
		return true;
	}
	,setProgram: function(p) {
		this.gl.useProgram(p.p);
		var _g = 0;
		var _g1 = p.attribs;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(!this.curAttribs[a.index]) {
				this.gl.enableVertexAttribArray(a.index);
				this.curAttribs[a.index] = true;
				if(this.maxIdxCurAttribs < a.index) {
					this.maxIdxCurAttribs = a.index;
				}
			}
		}
		var lastIdxCurAttribTrue = 0;
		var _g = 0;
		var _g1 = this.maxIdxCurAttribs + 1;
		while(_g < _g1) {
			var i = _g++;
			if(this.curAttribs[i] && (p.hasAttribIndex & 1 << i) == 0) {
				this.gl.disableVertexAttribArray(i);
				this.curAttribs[i] = false;
			} else if(this.curAttribs[i]) {
				lastIdxCurAttribTrue = i;
			}
		}
		this.maxIdxCurAttribs = lastIdxCurAttribTrue;
		this.curShader = p;
		this.curBuffer = null;
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
	}
	,uploadShaderBuffers: function(buf,which) {
		this.uploadBuffer(buf,this.curShader.vertex,buf.vertex,which);
		this.uploadBuffer(buf,this.curShader.fragment,buf.fragment,which);
	}
	,uploadBuffer: function(buffer,s,buf,which) {
		switch(which) {
		case 0:
			if(s.globals != null) {
				var a = buf.globals.subarray(0,s.shader.globalsSize * 4);
				this.gl.uniform4fv(s.globals,a);
			}
			break;
		case 1:
			if(s.params != null) {
				var a = buf.params.subarray(0,s.shader.paramsSize * 4);
				this.gl.uniform4fv(s.params,a);
			}
			break;
		case 2:
			var tcount = s.textures.length;
			var _g = 0;
			var _g1 = s.textures.length;
			while(_g < _g1) {
				var i = _g++;
				var t = buf.tex[i];
				var pt = s.textures[i];
				if(t == null || (t.isDepth() ? t.t == null : t.t == null && t.realloc == null)) {
					switch(pt.t._hx_index) {
					case 10:
						var color = h3d_mat_Defaults.loadingTextureColor;
						t = h3d_mat_Texture.fromColor(color,(color >>> 24) / 255);
						break;
					case 12:
						t = h3d_mat_Texture.defaultCubeTexture();
						break;
					default:
						throw haxe_Exception.thrown("Missing texture");
					}
				}
				if(t != null && t.t == null && t.realloc != null) {
					var s1 = this.curShader;
					t.alloc();
					t.realloc();
					if(this.curShader != s1) {
						this.setProgram(s1);
						this.uploadShaderBuffers(buffer,0);
						this.uploadShaderBuffers(buffer,1);
						this.uploadShaderBuffers(buffer,2);
						return;
					}
				}
				t.set_lastFrame(this.frame);
				if(pt.u == null) {
					continue;
				}
				var idx = s.kind == hxsl_FunctionKind.Fragment ? this.curShader.vertex.textures.length + i : i;
				if(this.boundTextures[idx] != t.t) {
					this.boundTextures[idx] = t.t;
					var mode = this.getBindType(t);
					if(mode != pt.mode) {
						throw haxe_Exception.thrown("Texture format mismatch: " + Std.string(t) + " should be " + Std.string(pt.t));
					}
					this.gl.activeTexture(33984 + idx);
					this.gl.uniform1i(pt.u,idx);
					this.gl.bindTexture(mode,t.t.t);
					this.lastActiveIndex = idx;
				}
				var mip = t.mipMap._hx_index;
				var filter = t.filter._hx_index;
				var wrap = t.wrap._hx_index;
				var bits = mip | filter << 3 | wrap << 6;
				if(bits != t.t.bits) {
					t.t.bits = bits;
					var flags = h3d_impl_GlDriver.TFILTERS[mip][filter];
					var mode1 = pt.mode;
					this.gl.texParameteri(mode1,10240,flags[0]);
					this.gl.texParameteri(mode1,10241,flags[1]);
					this.gl.texParameteri(mode1,34892,0);
					var w = h3d_impl_GlDriver.TWRAP[wrap];
					this.gl.texParameteri(mode1,10242,w);
					this.gl.texParameteri(mode1,10243,w);
				}
				if(t.t.startMip != t.startingMip) {
					this.gl.texParameteri(pt.mode,33084,t.startingMip);
					t.t.startMip = t.startingMip;
				}
			}
			break;
		case 3:
			if(s.buffers != null) {
				var start = 0;
				if(s.kind == hxsl_FunctionKind.Fragment && this.curShader.vertex.buffers != null) {
					start = this.curShader.vertex.buffers.length;
				}
				var _g = 0;
				var _g1 = s.buffers.length;
				while(_g < _g1) {
					var i = _g++;
					this.gl.bindBufferBase(35345,i + start,buf.buffers[i].vbuf);
				}
			}
			break;
		}
	}
	,selectMaterial: function(pass) {
		var bits = pass.bits;
		if(this.curTarget == null == this.rightHanded) {
			switch(pass.culling._hx_index) {
			case 1:
				bits = bits & -4 | 2;
				break;
			case 2:
				bits = bits & -4 | 1;
				break;
			default:
			}
		}
		this.selectMaterialBits(bits);
		if(this.curColorMask != pass.colorMask) {
			var m = pass.colorMask;
			this.gl.colorMask((m & 1) != 0,(m & 2) != 0,(m & 4) != 0,(m & 8) != 0);
			var mi = m >> 4;
			if(mi > 0) {
				throw haxe_Exception.thrown("GL ColorMaski support requires hlsdl 1.14+");
			}
			this.curColorMask = m;
		}
		var s = this.defStencil;
		if(pass.stencil == null) {
			if(this.curStEnabled) {
				this.gl.disable(2960);
				this.curStEnabled = false;
			}
		} else {
			s = pass.stencil;
			if(!this.curStEnabled) {
				this.gl.enable(2960);
				this.curStEnabled = true;
			}
		}
		this.selectStencilBits(s.opBits,s.maskBits);
	}
	,selectMaterialBits: function(bits) {
		var diff = bits ^ this.curMatBits;
		if(this.curMatBits < 0) {
			diff = -1;
		}
		if(diff == 0) {
			return;
		}
		var wireframe = (bits & 268435456) != 0;
		this.drawMode = wireframe ? 3 : 4;
		if((diff & 3) != 0) {
			var cull = bits & 3;
			if(cull == 0) {
				this.gl.disable(2884);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits & 3) == 0) {
					this.gl.enable(2884);
				}
				this.gl.cullFace(h3d_impl_GlDriver.FACES[cull]);
			}
		}
		if((diff & 4194240) != 0) {
			var csrc = bits >> 6 & 15;
			var cdst = bits >> 10 & 15;
			var asrc = bits >> 14 & 15;
			var adst = bits >> 18 & 15;
			if(csrc == asrc && cdst == adst) {
				if(csrc == 0 && cdst == 1) {
					this.gl.disable(3042);
				} else {
					if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
						this.gl.enable(3042);
					}
					this.gl.blendFunc(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst]);
				}
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
					this.gl.enable(3042);
				}
				this.gl.blendFuncSeparate(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst],h3d_impl_GlDriver.BLEND[asrc],h3d_impl_GlDriver.BLEND[adst]);
			}
		}
		if((diff & 264241152) != 0) {
			var cop = bits >> 22 & 7;
			var aop = bits >> 25 & 7;
			if(cop == aop) {
				this.gl.blendEquation(h3d_impl_GlDriver.OP[cop]);
			} else {
				this.gl.blendEquationSeparate(h3d_impl_GlDriver.OP[cop],h3d_impl_GlDriver.OP[aop]);
			}
		}
		if((diff & 4) != 0) {
			this.gl.depthMask((bits >> 2 & 1) != 0);
		}
		if((diff & 56) != 0) {
			var cmp = bits >> 3 & 7;
			if(cmp == 0) {
				this.gl.disable(2929);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 3 & 7) == 0) {
					this.gl.enable(2929);
				}
				this.gl.depthFunc(h3d_impl_GlDriver.COMPARE[cmp]);
			}
		}
		this.curMatBits = bits;
	}
	,selectStencilBits: function(opBits,maskBits) {
		var diffOp = opBits ^ this.curStOpBits;
		var diffMask = maskBits ^ this.curStMaskBits;
		if((diffOp | diffMask) == 0) {
			return;
		}
		if((diffOp & 4088) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.STENCIL_OP[opBits >> 6 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 9 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 3 & 7]);
		}
		if((diffOp & 16744448) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.STENCIL_OP[opBits >> 18 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 21 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 15 & 7]);
		}
		if((diffOp & 7 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.COMPARE[opBits & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffOp & 28672 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.COMPARE[opBits >> 12 & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffMask & 65280) != 0) {
			var w = maskBits >> 8 & 255;
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[2],w);
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[1],w);
		}
		this.curStOpBits = opBits;
		this.curStMaskBits = maskBits;
	}
	,clear: function(color,depth,stencil) {
		var bits = 0;
		if(color != null) {
			this.gl.colorMask(true,true,true,true);
			this.curColorMask = 15;
			this.gl.clearColor(color.x,color.y,color.z,color.w);
			bits |= 16384;
		}
		if(depth != null) {
			this.gl.depthMask(true);
			if(this.curMatBits >= 0) {
				this.curMatBits |= 4;
			}
			this.gl.clearDepth(depth);
			bits |= 256;
		}
		if(stencil != null) {
			this.selectStencilBits(this.defStencil.opBits,this.defStencil.maskBits);
			this.gl.clearStencil(stencil);
			bits |= 1024;
		}
		if(bits != 0) {
			this.gl.clear(bits);
		}
		if(this.curTarget != null) {
			this.curTarget.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		}
	}
	,resize: function(width,height) {
		if(this.canvas.style.width == "") {
			var tmp = width / window.devicePixelRatio | 0;
			this.canvas.style.width = tmp + "px";
			var tmp = height / window.devicePixelRatio | 0;
			this.canvas.style.height = tmp + "px";
		}
		this.canvas.width = width;
		this.canvas.height = height;
		this.bufferWidth = width;
		this.bufferHeight = height;
		this.gl.viewport(0,0,width,height);
		if(this.defaultDepth != null) {
			this.disposeDepthBuffer(this.defaultDepth);
			this.defaultDepth.width = this.bufferWidth;
			this.defaultDepth.height = this.bufferHeight;
			this.defaultDepth.t = this.allocDepthBuffer(this.defaultDepth);
		}
	}
	,getChannels: function(t) {
		switch(t.internalFmt) {
		case 6407:
			return 6407;
		case 6408:
			return 6408;
		case 32857:
			return 6408;
		case 6403:case 33321:case 33322:case 33325:case 33326:
			return 6403;
		case 33319:case 33323:case 33324:case 33327:case 33328:
			return 33319;
		case 34836:case 34842:
			return 6408;
		case 35898:
			return 6407;
		case 35904:case 35905:
			return 6407;
		case 32859:case 33777:case 33778:case 33779:case 36492:
			return 6408;
		case 32852:case 34837:case 34843:case 36495:
			return 6407;
		default:
			throw haxe_Exception.thrown("Invalid format " + t.internalFmt);
		}
	}
	,isSupportedFormat: function(fmt) {
		switch(fmt._hx_index) {
		case 2:
			return true;
		case 3:case 4:
			return this.hasFeature(h3d_impl_Feature.FloatTextures);
		case 14:case 15:
			return this.hasFeature(h3d_impl_Feature.SRGBTextures);
		case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 16:case 17:
			return this.glES >= 3;
		case 22:
			var n = fmt.v;
			return n <= this.maxCompressedTexturesSupport;
		default:
			return false;
		}
	}
	,getBindType: function(t) {
		var isCube = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var isArray = (t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0;
		if(isCube) {
			return 34067;
		} else if(isArray) {
			return 35866;
		} else {
			return 3553;
		}
	}
	,allocTexture: function(t) {
		var _gthis = this;
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var tt = this.gl.createTexture();
		var bind = this.getBindType(t);
		var tt1 = { t : tt, width : t.width, height : t.height, internalFmt : 6408, pixelFmt : 5121, bits : -1, bind : bind, bias : 0, startMip : t.startingMip};
		var _g = t.format;
		switch(_g._hx_index) {
		case 1:
			tt1.internalFmt = 32856;
			break;
		case 2:
			break;
		case 3:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.pixelFmt = 5131;
				tt1.internalFmt = 34842;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 4:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.internalFmt = 34836;
				tt1.pixelFmt = 5126;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 5:
			tt1.internalFmt = 33321;
			break;
		case 6:
			tt1.internalFmt = 33325;
			tt1.pixelFmt = 5131;
			break;
		case 7:
			tt1.internalFmt = 33326;
			tt1.pixelFmt = 5126;
			break;
		case 8:
			tt1.internalFmt = 33323;
			break;
		case 9:
			tt1.internalFmt = 33327;
			tt1.pixelFmt = 5131;
			break;
		case 10:
			tt1.internalFmt = 33328;
			tt1.pixelFmt = 5126;
			break;
		case 11:
			tt1.internalFmt = 6407;
			break;
		case 12:
			tt1.internalFmt = 34843;
			tt1.pixelFmt = 5131;
			break;
		case 13:
			tt1.internalFmt = 34837;
			tt1.pixelFmt = 5126;
			break;
		case 14:
			tt1.internalFmt = 35905;
			break;
		case 16:
			tt1.internalFmt = 32857;
			tt1.pixelFmt = 33640;
			break;
		case 17:
			tt1.internalFmt = 35898;
			tt1.pixelFmt = 35899;
			break;
		case 18:
			tt1.internalFmt = 33322;
			tt1.pixelFmt = 5123;
			break;
		case 19:
			tt1.internalFmt = 33324;
			tt1.pixelFmt = 5123;
			break;
		case 20:
			tt1.internalFmt = 32852;
			tt1.pixelFmt = 5123;
			break;
		case 21:
			tt1.internalFmt = 32859;
			tt1.pixelFmt = 5123;
			break;
		case 22:
			var n = _g.v;
			if(n <= this.maxCompressedTexturesSupport) {
				if((t.width & 3) != 0 || (t.height & 3) != 0) {
					throw haxe_Exception.thrown("Compressed texture " + Std.string(t) + " has size " + t.width + "x" + t.height + " - must be a multiple of 4");
				}
				switch(n) {
				case 1:
					tt1.internalFmt = 33777;
					break;
				case 2:
					tt1.internalFmt = 33778;
					break;
				case 3:
					tt1.internalFmt = 33779;
					break;
				case 6:
					tt1.internalFmt = 36495;
					break;
				case 7:
					tt1.internalFmt = 36492;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
				}
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
		}
		if(tt1.pixelFmt == 5123 && !this.has16Bits) {
			throw haxe_Exception.thrown("16 bit textures requires EXT_texture_norm16 extension");
		}
		t.set_lastFrame(this.frame);
		t.flags &= -1 - (1 << h3d_mat_TextureFlags.WasCleared._hx_index);
		this.gl.bindTexture(bind,tt1.t);
		var outOfMem = false;
		this.gl.texParameteri(bind,33084,t.startingMip);
		this.gl.texParameteri(bind,33085,t.get_mipLevels() - 1);
		var sizedFormat = tt1.internalFmt == 6408 ? 32856 : tt1.internalFmt;
		if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 && (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) == 0) {
			this.gl.texStorage3D(bind,t.get_mipLevels(),sizedFormat,tt1.width,tt1.height,t.get_layerCount());
			if(h3d_impl_GlDriver.outOfMemoryCheck) {
				var err = _gthis.gl.getError();
				if(err == 1285) {
					outOfMem = true;
				} else if(err != 0) {
					throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
				}
			}
		} else {
			this.gl.texStorage2D(bind,t.get_mipLevels(),sizedFormat,tt1.width,tt1.height);
			if(h3d_impl_GlDriver.outOfMemoryCheck) {
				var err = _gthis.gl.getError();
				if(err == 1285) {
					outOfMem = true;
				} else if(err != 0) {
					throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
				}
			}
		}
		this.restoreBind();
		if(outOfMem) {
			this.gl.deleteTexture(tt1.t);
			return null;
		}
		return tt1;
	}
	,restoreBind: function() {
		var t = this.boundTextures[this.lastActiveIndex];
		if(t == null) {
			this.gl.bindTexture(3553,null);
		} else {
			this.gl.bindTexture(t.bind,t.t);
		}
	}
	,allocDepthBuffer: function(t) {
		var tt = this.gl.createTexture();
		var tt1 = { t : tt, width : t.width, height : t.height, internalFmt : 6408, pixelFmt : 5121, bits : -1, bind : 3553, bias : 0, startMip : 0};
		var fmt = 6402;
		switch(t.format._hx_index) {
		case 23:
			tt1.internalFmt = 33189;
			break;
		case 24:
			if(this.glES >= 3) {
				tt1.internalFmt = 6402;
			} else {
				throw haxe_Exception.thrown("Unsupported depth format " + Std.string(t.format));
			}
			break;
		case 25:
			tt1.internalFmt = 35056;
			tt1.pixelFmt = 34042;
			fmt = 34041;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported depth format " + Std.string(t.format));
		}
		t.set_lastFrame(this.frame);
		t.flags &= -1 - (1 << h3d_mat_TextureFlags.WasCleared._hx_index);
		this.gl.bindTexture(tt1.bind,tt1.t);
		this.gl.texParameteri(tt1.bind,10241,9728);
		this.gl.texParameteri(tt1.bind,10240,9728);
		this.gl.texParameteri(tt1.bind,10242,33071);
		this.gl.texParameteri(tt1.bind,10243,33071);
		this.gl.texImage2D(tt1.bind,0,tt1.internalFmt,tt1.width,tt1.height,0,fmt,tt1.pixelFmt,null);
		this.restoreBind();
		return tt1;
	}
	,disposeDepthBuffer: function(b) {
		if(b.t != null && b.t.t != null) {
			this.gl.deleteTexture(b.t.t);
			b.t = null;
		}
	}
	,getDefaultDepthBuffer: function() {
		if(this.defaultDepth != null) {
			return this.defaultDepth;
		}
		this.defaultDepth = new h3d_mat_Texture(0,0,null,hxd_PixelFormat.Depth24Stencil8);
		this.defaultDepth.name = "defaultDepthBuffer";
		this.defaultDepth.width = this.bufferWidth;
		this.defaultDepth.height = this.bufferHeight;
		this.defaultDepth.t = this.allocDepthBuffer(this.defaultDepth);
		return this.defaultDepth;
	}
	,discardError: function() {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
	}
	,allocBuffer: function(b) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		var vb = this.gl.createBuffer();
		var type = (b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0 ? 34963 : 34962;
		this.gl.bindBuffer(type,vb);
		if(b.vertices * b.format.stride == 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.gl.bufferData(type,b.vertices * b.format.strideBytes,(b.flags & 1 << h3d_BufferFlag.Dynamic._hx_index) != 0 ? 35048 : 35044);
		var outOfMem = h3d_impl_GlDriver.outOfMemoryCheck && this.gl.getError() == 1285;
		this.gl.bindBuffer(type,null);
		if((b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0) {
			this.curIndexBuffer = null;
		}
		if(outOfMem) {
			this.gl.deleteBuffer(vb);
			return null;
		}
		return vb;
	}
	,disposeTexture: function(t) {
		var tt = t.t;
		if(tt == null) {
			return;
		}
		t.t = null;
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.boundTextures[i] == tt) {
				this.boundTextures[i] = null;
			}
		}
		this.gl.deleteTexture(tt.t);
	}
	,disposeBuffer: function(b) {
		this.gl.deleteBuffer(b.vbuf);
	}
	,generateMipMaps: function(t) {
		var bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		this.gl.generateMipmap(bind);
		this.restoreBind();
	}
	,uploadTextureBitmap: function(t,bmp,mipLevel,side) {
		if(t.format != hxd_PixelFormat.RGBA || t.get_layerCount() != 1) {
			var pixels = bmp.getPixels();
			this.uploadTexturePixels(t,pixels,mipLevel,side);
			pixels.dispose();
		} else {
			var img = bmp.ctx;
			this.gl.bindTexture(3553,t.t.t);
			this.gl.texSubImage2D(3553,mipLevel,0,0,this.getChannels(t.t),t.t.pixelFmt,img.getImageData(0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height));
			this.restoreBind();
		}
	}
	,resetStream: function() {
	}
	,streamData: function(data,pos,length) {
		return data;
	}
	,uploadTexturePixels: function(t,pixels,mipLevel,side) {
		var cubic = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var face = cubic ? h3d_impl_GlDriver.CUBE_FACES[side] : (t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 ? 35866 : 3553;
		var bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		pixels.convert(t.format);
		var dataLen = pixels.dataSize;
		var buffer;
		switch(t.format._hx_index) {
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		case 16:case 17:
			buffer = new Uint32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		case 3:case 6:case 9:case 12:case 18:case 19:case 20:case 21:
			buffer = new Uint16Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 1);
			break;
		default:
			buffer = new Uint8Array(pixels.bytes.b.buffer,pixels.offset,dataLen);
		}
		var _g = t.format;
		var tmp;
		if(_g._hx_index == 22) {
			var _g1 = _g.v;
			tmp = true;
		} else {
			tmp = false;
		}
		if(tmp) {
			if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
				this.gl.compressedTexSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,t.t.internalFmt,buffer);
			} else {
				this.gl.compressedTexSubImage2D(face,mipLevel,0,0,pixels.width,pixels.height,t.t.internalFmt,buffer);
			}
		} else if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			this.gl.texSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,this.getChannels(t.t),t.t.pixelFmt,buffer);
		} else {
			this.gl.texSubImage2D(face,mipLevel,0,0,pixels.width,pixels.height,this.getChannels(t.t),t.t.pixelFmt,buffer);
		}
		t.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.restoreBind();
	}
	,uploadBufferData: function(b,startVertex,vertexCount,buf,bufPos) {
		var stride = b.format.strideBytes;
		this.gl.bindBuffer(34962,b.vbuf);
		var buf1 = buf.array;
		var sub = new Float32Array(buf1.buffer,bufPos * 4,vertexCount * stride >> 2);
		this.gl.bufferSubData(34962,startVertex * stride,sub);
		this.gl.bindBuffer(34962,null);
	}
	,uploadBufferBytes: function(b,startVertex,vertexCount,buf,bufPos) {
		var stride = b.format.strideBytes;
		var type = (b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0 ? 34963 : 34962;
		this.gl.bindBuffer(type,b.vbuf);
		var sub = new Uint8Array(buf.b.bufferValue,bufPos,vertexCount * stride);
		this.gl.bufferSubData(type,startVertex * stride,sub);
		this.gl.bindBuffer(type,null);
		if((b.flags & 1 << h3d_BufferFlag.IndexBuffer._hx_index) != 0) {
			this.curIndexBuffer = null;
		}
	}
	,uploadIndexData: function(i,startIndice,indiceCount,buf,bufPos) {
		var bits = i.format.strideBytes >> 1;
		this.gl.bindBuffer(34963,i.vbuf);
		var buf1 = new Uint16Array(buf);
		var sub = new Uint16Array(buf1.buffer,bufPos << bits,indiceCount);
		this.gl.bufferSubData(34963,startIndice << bits,sub);
		this.gl.bindBuffer(34963,null);
		this.curIndexBuffer = null;
	}
	,updateDivisor: function(a) {
		if(this.currentDivisor[a.index] != a.divisor) {
			this.currentDivisor[a.index] = a.divisor;
			this.gl.vertexAttribDivisor(a.index,a.divisor);
		}
	}
	,selectBuffer: function(b) {
		if(b == this.curBuffer) {
			return;
		}
		if(this.curShader == null) {
			throw haxe_Exception.thrown("No shader selected");
		}
		this.gl.bindBuffer(34962,b.vbuf);
		this.curBuffer = b;
		var strideBytes = b.format.strideBytes;
		var map = b.format.resolveMapping(this.curShader.format);
		var _g_current = 0;
		var _g_array = this.curShader.attribs;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var a = _g_value;
			var inf = map[i];
			var norm = false;
			var tmp = this.gl;
			var a1 = a.index;
			var a2 = a.size;
			var tmp1;
			switch(inf & 7) {
			case 0:
				tmp1 = a.type;
				break;
			case 1:
				tmp1 = 5131;
				break;
			case 2:
				norm = true;
				tmp1 = 5121;
				break;
			case 3:
				norm = true;
				tmp1 = 5120;
				break;
			}
			tmp.vertexAttribPointer(a1,a2,tmp1,norm,strideBytes,inf >> 16);
			if(this.currentDivisor[a.index] != a.divisor) {
				this.currentDivisor[a.index] = a.divisor;
				this.gl.vertexAttribDivisor(a.index,a.divisor);
			}
		}
	}
	,selectMultiBuffers: function(format,buffers) {
		var format1 = this.curShader.format;
		var m = format.mappings[format1.uid];
		if(m == null) {
			m = format.makeMapping(format1);
		}
		var map = m;
		var _g_current = 0;
		var _g_array = this.curShader.attribs;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var a = _g_value;
			var inf = map[i];
			var b = buffers[inf >> 3 & 255];
			if(this.curBuffer != b) {
				this.gl.bindBuffer(34962,b.vbuf);
				this.curBuffer = b;
			}
			var norm = false;
			var tmp = this.gl;
			var a1 = a.index;
			var a2 = a.size;
			var tmp1;
			switch(inf & 7) {
			case 0:
				tmp1 = a.type;
				break;
			case 1:
				tmp1 = 5131;
				break;
			case 2:
				norm = true;
				tmp1 = 5121;
				break;
			case 3:
				norm = true;
				tmp1 = 5120;
				break;
			}
			tmp.vertexAttribPointer(a1,a2,tmp1,norm,b.format.strideBytes,inf >> 16);
			if(this.currentDivisor[a.index] != a.divisor) {
				this.currentDivisor[a.index] = a.divisor;
				this.gl.vertexAttribDivisor(a.index,a.divisor);
			}
		}
	}
	,draw: function(ibuf,startIndex,ntriangles) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.vbuf);
		}
		if(ibuf.format.strideBytes == 4) {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5125,startIndex * 4);
		} else {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5123,startIndex * 2);
		}
	}
	,allocInstanceBuffer: function(b,bytes) {
		var data = [];
		var _g = 0;
		var _g1 = b.commandCount;
		while(_g < _g1) {
			var i = _g++;
			var p = i * 5 * 4;
			var indexCount = bytes.getInt32(p);
			var instanceCount = bytes.getInt32(p + 4);
			var offIndex = bytes.getInt32(p + 8);
			var offVertex = bytes.getInt32(p + 12);
			var offInstance = bytes.getInt32(p + 16);
			if(offVertex != 0 || offInstance != 0) {
				throw haxe_Exception.thrown("baseVertex and baseInstance must be zero on this platform");
			}
			data.push(indexCount);
			data.push(offIndex);
			data.push(instanceCount);
		}
		b.data = data;
	}
	,disposeInstanceBuffer: function(b) {
		b.data = null;
	}
	,drawInstanced: function(ibuf,commands) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.vbuf);
		}
		var kind;
		var size;
		if(ibuf.format.strideBytes == 4) {
			kind = 5125;
			size = 4;
		} else {
			kind = 5123;
			size = 2;
		}
		var args = commands.data;
		if(args != null) {
			var p = 0;
			var _g = 0;
			var _g1 = args.length / 3 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.gl.drawElementsInstanced(this.drawMode,args[p++],kind,args[p++] * size,args[p++]);
			}
		} else {
			this.gl.drawElementsInstanced(this.drawMode,commands.indexCount,kind,commands.startIndex * size,commands.commandCount);
		}
	}
	,end: function() {
	}
	,present: function() {
	}
	,isDisposed: function() {
		return this.gl.isContextLost();
	}
	,setRenderZone: function(x,y,width,height) {
		if(x == 0 && y == 0 && width < 0 && height < 0) {
			this.gl.disable(3089);
		} else {
			this.gl.enable(3089);
			if(this.curTarget == null) {
				y = this.bufferHeight - (y + height);
			}
			this.gl.scissor(x,y,width,height);
		}
	}
	,setDrawBuffers: function(k) {
		if(this.glES >= 3) {
			this.gl.drawBuffers(h3d_impl_GlDriver.CBUFFERS[k]);
		} else if(this.mrtExt != null) {
			this.mrtExt.drawBuffersWEBGL(h3d_impl_GlDriver.CBUFFERS[k]);
		}
	}
	,unbindTargets: function() {
		if(this.curTarget != null && this.numTargets > 1) {
			while(this.numTargets > 1) {
				this.gl.framebufferTexture2D(36160,36064 + --this.numTargets,3553,null,0);
				this.curTargets[this.numTargets] = null;
			}
			this.setDrawBuffers(1);
		}
	}
	,capturePixels: function(tex,layer,mipLevel,region) {
		var x;
		var y;
		var w;
		var h;
		if(region != null) {
			if(region.xMax > tex.width) {
				region.xMax = tex.width;
			}
			if(region.yMax > tex.height) {
				region.yMax = tex.height;
			}
			if(region.xMin < 0) {
				region.xMin = 0;
			}
			if(region.yMin < 0) {
				region.yMin = 0;
			}
			w = region.xMax - region.xMin;
			h = region.yMax - region.yMin;
			x = region.xMin;
			y = region.yMin;
		} else {
			w = tex.width;
			h = tex.height;
			x = 0;
			y = 0;
		}
		w >>= mipLevel;
		h >>= mipLevel;
		if(w == 0) {
			w = 1;
		}
		if(h == 0) {
			h = 1;
		}
		var pixels = hxd_Pixels.alloc(w,h,tex.format);
		var old = this.curTarget;
		var oldCount = this.numTargets;
		var oldLayer = this.curTargetLayer;
		var oldMip = this.curTargetMip;
		if(oldCount > 1) {
			this.numTargets = 1;
			var _g = 1;
			var _g1 = oldCount;
			while(_g < _g1) {
				var i = _g++;
				if(this.curTargets[i] == tex) {
					this.gl.framebufferTexture2D(36160,36064 + i,3553,null,0);
				}
			}
		}
		this.setRenderTarget(tex,layer,mipLevel);
		this.captureSubRenderBuffer(pixels,x,y);
		this.setRenderTarget(old,oldLayer,oldMip);
		if(oldCount > 1) {
			var _g = 1;
			var _g1 = oldCount;
			while(_g < _g1) {
				var i = _g++;
				if(this.curTargets[i] == tex) {
					this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
				}
			}
			this.setDrawBuffers(oldCount);
			this.numTargets = oldCount;
		}
		return pixels;
	}
	,setRenderTarget: function(tex,layer,mipLevel,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		this.unbindTargets();
		this.curTarget = tex;
		if(tex == null) {
			this.gl.bindFramebuffer(36160,null);
			this.gl.viewport(0,0,this.bufferWidth,this.bufferHeight);
			return;
		}
		if(tex.depthBuffer != null && (tex.depthBuffer.width != tex.width || tex.depthBuffer.height != tex.height)) {
			throw haxe_Exception.thrown("Invalid depth buffer size : does not match render target size");
		}
		if(mipLevel > 0 && this.glES == 1) {
			throw haxe_Exception.thrown("Cannot render to mipLevel in WebGL1, use upload() instead");
		}
		if(tex.t == null) {
			tex.alloc();
		}
		if((tex.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 && (tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
			var bind = this.getBindType(tex);
			this.gl.bindTexture(bind,tex.t.t);
			this.gl.generateMipmap(bind);
			this.restoreBind();
		}
		tex.set_lastFrame(this.frame);
		this.curTargetLayer = layer;
		this.curTargetMip = mipLevel;
		this.gl.bindFramebuffer(36160,this.commonFB);
		if((tex.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			this.gl.framebufferTextureLayer(36160,36064,tex.t.t,mipLevel,layer);
		} else {
			this.gl.framebufferTexture2D(36160,36064,(tex.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0 ? h3d_impl_GlDriver.CUBE_FACES[layer] : 3553,tex.t.t,mipLevel);
		}
		if(tex.depthBuffer != null && depthBinding != h3d_DepthBinding.NotBound) {
			if(tex.depthBuffer.hasStencil() && tex.depthBuffer.format == hxd_PixelFormat.Depth24Stencil8) {
				this.gl.framebufferTexture2D(36160,33306,3553,tex.depthBuffer.t.t,0);
			} else {
				this.gl.framebufferTexture2D(36160,33306,3553,null,0);
				this.gl.framebufferTexture2D(36160,36096,3553,tex.depthBuffer.t.t,0);
				this.gl.framebufferTexture2D(36160,36128,3553,tex.depthBuffer.hasStencil() ? tex.depthBuffer.t.t : null,0);
			}
		} else {
			this.gl.framebufferTexture2D(36160,33306,3553,null,0);
			this.gl.framebufferTexture2D(36160,36096,3553,null,0);
			this.gl.framebufferTexture2D(36160,36128,3553,null,0);
		}
		var w = tex.width >> mipLevel;
		if(w == 0) {
			w = 1;
		}
		var h = tex.height >> mipLevel;
		if(h == 0) {
			h = 1;
		}
		this.gl.viewport(0,0,w,h);
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
		if((tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
			tex.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
			this.clear(h3d_impl_GlDriver.BLACK);
		}
		if(this.glDebug) {
			var code = this.gl.checkFramebufferStatus(36160);
			if(code != 36053) {
				throw haxe_Exception.thrown("Invalid frame buffer: " + code);
			}
		}
	}
	,setRenderTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		this.unbindTargets();
		this.setRenderTarget(textures[0],null,null,depthBinding);
		if(textures.length < 2) {
			return;
		}
		this.numTargets = textures.length;
		var needClear = false;
		var _g = 1;
		var _g1 = textures.length;
		while(_g < _g1) {
			var i = _g++;
			var tex = textures[i];
			if(tex.t == null) {
				tex.alloc();
			}
			this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
			this.curTargets[i] = tex;
			tex.set_lastFrame(this.frame);
			if((tex.flags & 1 << h3d_mat_TextureFlags.WasCleared._hx_index) == 0) {
				tex.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
				needClear = true;
			}
		}
		this.setDrawBuffers(textures.length);
		if(needClear) {
			this.clear(h3d_impl_GlDriver.BLACK);
		}
	}
	,setDepth: function(depthBuffer) {
		this.unbindTargets();
		this.curTarget = depthBuffer;
		depthBuffer.set_lastFrame(this.frame);
		this.curTargetLayer = 0;
		this.curTargetMip = 0;
		this.gl.bindFramebuffer(36160,this.commonFB);
		this.gl.framebufferTexture2D(36160,36064,3553,null,0);
		if(depthBuffer.hasStencil() && depthBuffer.format == hxd_PixelFormat.Depth24Stencil8) {
			this.gl.framebufferTexture2D(36160,33306,3553,depthBuffer.t.t,0);
		} else {
			this.gl.framebufferTexture2D(36160,33306,3553,null,0);
			this.gl.framebufferTexture2D(36160,36096,3553,depthBuffer.t.t,0);
			this.gl.framebufferTexture2D(36160,36128,3553,depthBuffer.hasStencil() ? depthBuffer.t.t : null,0);
		}
		var w = depthBuffer.width;
		if(w == 0) {
			w = 1;
		}
		var h = depthBuffer.height;
		if(h == 0) {
			h = 1;
		}
		this.gl.viewport(0,0,w,h);
		var _g = 0;
		var _g1 = this.boundTextures.length;
		while(_g < _g1) {
			var i = _g++;
			this.boundTextures[i] = null;
		}
		if(this.glDebug) {
			var code = this.gl.checkFramebufferStatus(36160);
			if(code != 36053) {
				throw haxe_Exception.thrown("Invalid frame buffer: " + code);
			}
		}
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		if(window.document.readyState == "complete") {
			var _g = onCreate;
			var a1 = false;
			haxe_Timer.delay(function() {
				_g(a1);
			},1);
		} else {
			var onLoad = null;
			onLoad = function() {
				window.removeEventListener("load",onLoad);
				onCreate(false);
			};
			window.addEventListener("load",onLoad);
		}
	}
	,hasFeature: function(f) {
		return this.features.get(f);
	}
	,makeFeatures: function() {
		var _g = 0;
		var _g1 = h3d_impl_Feature.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.features.set(f,this.checkFeature(f));
		}
		if(this.gl.getExtension("WEBGL_compressed_texture_s3tc") != null) {
			this.maxCompressedTexturesSupport = 3;
			if(this.gl.getExtension("EXT_texture_compression_bptc") != null) {
				this.maxCompressedTexturesSupport = 7;
			}
		}
		if(this.glES < 3) {
			this.gl.getExtension("WEBGL_depth_texture");
		}
		this.has16Bits = this.gl.getExtension("EXT_texture_norm16") != null;
	}
	,checkFeature: function(f) {
		switch(f._hx_index) {
		case 0:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("OES_standard_derivatives") != null;
			}
			break;
		case 1:
			if(this.glES >= 3) {
				if(this.gl.getExtension("EXT_color_buffer_float") != null) {
					return this.gl.getExtension("OES_texture_float_linear") != null;
				} else {
					return false;
				}
			} else if(this.gl.getExtension("OES_texture_float") != null && this.gl.getExtension("OES_texture_float_linear") != null && this.gl.getExtension("OES_texture_half_float") != null) {
				return this.gl.getExtension("OES_texture_half_float_linear") != null;
			} else {
				return false;
			}
			break;
		case 4:
			if(this.glES >= 3) {
				return true;
			} else if(this.mrtExt == null) {
				return (this.mrtExt = this.gl.getExtension("WEBGL_draw_buffers")) != null;
			} else {
				return true;
			}
			break;
		case 6:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("EXT_sRGB") != null;
			}
			break;
		case 7:
			if(this.glES >= 3) {
				return true;
			} else {
				return false;
			}
			break;
		case 2:case 3:case 8:case 9:
			return true;
		case 10:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("ANGLE_instanced_arrays") != null;
			}
			break;
		default:
			return false;
		}
	}
	,uploadTextureVideoElement: function(t,v,mipLevel,side) {
		var cubic = (t.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var bind = this.getBindType(t);
		if((t.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0) {
			throw haxe_Exception.thrown("TODO:texImage3D");
		}
		var face = cubic ? h3d_impl_GlDriver.CUBE_FACES[side] : 3553;
		this.gl.bindTexture(bind,t.t.t);
		this.gl.texSubImage2D(face,mipLevel,0,0,v.videoWidth,v.videoHeight,this.getChannels(t.t),t.t.pixelFmt,v);
		this.restoreBind();
	}
	,captureRenderBuffer: function(pixels) {
		this.captureSubRenderBuffer(pixels,0,0);
	}
	,captureSubRenderBuffer: function(pixels,x,y) {
		if(this.curTarget == null) {
			throw haxe_Exception.thrown("Can't capture main render buffer in GL");
		}
		this.gl.getError();
		var buffer = pixels.bytes.b;
		switch(this.curTarget.format._hx_index) {
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(buffer.buffer);
			break;
		case 16:case 17:
			buffer = new Uint32Array(buffer.buffer);
			break;
		case 3:case 6:case 9:case 12:case 18:case 19:case 20:case 21:
			buffer = new Uint16Array(buffer.buffer);
			break;
		default:
		}
		this.gl.readPixels(x,y,pixels.width,pixels.height,this.getChannels(this.curTarget.t),this.curTarget.t.pixelFmt,buffer);
		var error = this.gl.getError();
		if(error != 0) {
			throw haxe_Exception.thrown("Failed to capture pixels (error " + error + ")");
		}
		pixels.set_innerFormat(this.curTarget.format);
	}
	,__class__: h3d_impl_GlDriver
});
var h3d_impl_InstanceBuffer = function() {
	this.triCount = 0;
};
$hxClasses["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer;
h3d_impl_InstanceBuffer.__name__ = "h3d.impl.InstanceBuffer";
h3d_impl_InstanceBuffer.prototype = {
	setCommand: function(commandCount,indexCount,startIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		this.commandCount = commandCount;
		this.indexCount = indexCount;
		this.triCount = commandCount * indexCount / 3 | 0;
		this.startIndex = startIndex;
	}
	,setBuffer: function(commandCount,bytes) {
		this.dispose();
		var _g = 0;
		var _g1 = commandCount;
		while(_g < _g1) {
			var i = _g++;
			var idxCount = bytes.getInt32(i * 20);
			var instCount = bytes.getInt32(i * 20 + 4);
			var tri = idxCount * instCount / 3 | 0;
			this.triCount += tri;
		}
		this.commandCount = commandCount;
		this.indexCount = 0;
		this.driver = h3d_Engine.CURRENT.driver;
		this.driver.allocInstanceBuffer(this,bytes);
	}
	,dispose: function() {
		if(this.data != null) {
			this.driver.disposeInstanceBuffer(this);
		}
	}
	,__class__: h3d_impl_InstanceBuffer
};
var h3d_impl_MemoryManager = function(driver) {
	this.texMemory = 0;
	this.usedMemory = 0;
	this.driver = driver;
};
$hxClasses["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager;
h3d_impl_MemoryManager.__name__ = "h3d.impl.MemoryManager";
h3d_impl_MemoryManager.prototype = {
	init: function() {
		this.textures = [];
		this.buffers = [];
		this.depths = [];
		this.initIndexes();
	}
	,initIndexes: function() {
		var indices = new Array(0);
		var _g = 0;
		while(_g < 65532) {
			var i = _g++;
			indices.push(i);
		}
		this.triIndexes16 = h3d_Indexes.alloc(indices);
		var indices = new Array(0);
		var p = 0;
		var _g = 0;
		while(_g < 10922) {
			var i = _g++;
			var k = i << 2;
			indices.push(k);
			indices.push(k + 1);
			indices.push(k + 2);
			indices.push(k + 2);
			indices.push(k + 1);
			indices.push(k + 3);
		}
		indices.push(65532);
		this.quadIndexes16 = h3d_Indexes.alloc(indices);
	}
	,garbage: function() {
	}
	,getTriIndexes: function(vertices) {
		if(vertices <= 65532) {
			return this.triIndexes16;
		}
		if(this.triIndexes32 == null || this.triIndexes32.vertices < vertices) {
			var sz = 131072;
			while(sz < vertices) sz <<= 1;
			var bytes = new haxe_io_Bytes(new ArrayBuffer(sz << 2));
			var _g = 0;
			var _g1 = sz;
			while(_g < _g1) {
				var i = _g++;
				bytes.setInt32(i << 2,i);
			}
			if(this.triIndexes32 != null) {
				this.triIndexes32.dispose();
			}
			this.triIndexes32 = h3d_Indexes._new(sz,true);
			this.triIndexes32.uploadBytes(bytes,0,sz);
		}
		return this.triIndexes32;
	}
	,getQuadIndexes: function(vertices) {
		var nquads = (vertices + 3 >> 2) * 6;
		if(nquads <= 65532) {
			return this.quadIndexes16;
		}
		if(this.quadIndexes32 == null || this.quadIndexes32.vertices < vertices) {
			var sz = 131072;
			while(sz < nquads) sz <<= 1;
			var bytes = new haxe_io_Bytes(new ArrayBuffer(sz << 2));
			var p = 0;
			var _g = 0;
			var _g1 = sz / 6 | 0;
			while(_g < _g1) {
				var i = _g++;
				var k = i << 2;
				bytes.setInt32(p++ << 2,k);
				bytes.setInt32(p++ << 2,k + 1);
				bytes.setInt32(p++ << 2,k + 2);
				bytes.setInt32(p++ << 2,k + 2);
				bytes.setInt32(p++ << 2,k + 1);
				bytes.setInt32(p++ << 2,k + 3);
			}
			if(this.quadIndexes32 != null) {
				this.quadIndexes32.dispose();
			}
			this.quadIndexes32 = h3d_Indexes._new(sz,true);
			this.quadIndexes32.uploadBytes(bytes,0,sz);
		}
		return this.quadIndexes32;
	}
	,allocBuffer: function(b) {
		if(b.vbuf != null) {
			return;
		}
		var mem = b.vertices * b.format.strideBytes;
		if(mem == 0) {
			return;
		}
		while(this.usedMemory + mem > 4294967296. || (b.vbuf = this.driver.allocBuffer(b)) == null) {
			if(this.driver.isDisposed()) {
				return;
			}
			var size = this.usedMemory;
			this.garbage();
			if(this.usedMemory == size) {
				throw haxe_Exception.thrown("Memory full (" + Math.ceil(size / 1024) + " KB," + this.buffers.length + " buffers)");
			}
		}
		this.usedMemory += mem;
		this.buffers.push(b);
	}
	,freeBuffer: function(b) {
		if(b.vbuf == null) {
			return;
		}
		this.driver.disposeBuffer(b);
		b.vbuf = null;
		if(HxOverrides.remove(this.buffers,b)) {
			this.usedMemory -= b.vertices * b.format.strideBytes;
		}
	}
	,memSize: function(t) {
		if((t.flags & 1 << h3d_mat_TextureFlags.AsyncLoading._hx_index) != 0 && (t.flags & 1 << h3d_mat_TextureFlags.Loading._hx_index) != 0) {
			return 4;
		}
		var size = hxd_Pixels.calcDataSize(t.width,t.height,t.format);
		if(t.get_mipLevels() > 0) {
			var _g = 1;
			var _g1 = t.get_mipLevels();
			while(_g < _g1) {
				var i = _g++;
				var w = t.width >> i;
				if(w == 0) {
					w = 1;
				}
				var h = t.height >> i;
				if(h == 0) {
					h = 1;
				}
				size += hxd_Pixels.calcDataSize(w,h,t.format);
			}
		}
		return size * t.get_layerCount();
	}
	,cleanTextures: function(force) {
		if(force == null) {
			force = true;
		}
		this.textures.sort($bind(this,this.sortByLRU));
		var _g = 0;
		var _g1 = this.textures;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.realloc == null || (t.isDepth() ? t.t == null : t.t == null && t.realloc == null)) {
				continue;
			}
			if((force || t._lastFrame < hxd_Timer.frameCount - 3600) && t._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
				t.dispose();
				return true;
			}
		}
		return false;
	}
	,sortByLRU: function(t1,t2) {
		return t1._lastFrame - t2._lastFrame;
	}
	,deleteTexture: function(t) {
		if(!HxOverrides.remove(this.textures,t)) {
			return;
		}
		this.driver.disposeTexture(t);
		this.texMemory -= this.memSize(t);
	}
	,allocTexture: function(t) {
		while(true) {
			var free = this.cleanTextures(false);
			t.t = this.driver.allocTexture(t);
			if(t.t != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.textures.push(t);
		this.texMemory += this.memSize(t);
	}
	,allocDepth: function(b) {
		while(true) {
			var free = this.cleanTextures(false);
			b.t = this.driver.allocDepthBuffer(b);
			if(b.t != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.depths.push(b);
		this.texMemory += b.width * b.height * 4;
	}
	,deleteDepth: function(b) {
		if(!HxOverrides.remove(this.depths,b)) {
			return;
		}
		this.driver.disposeDepthBuffer(b);
		this.texMemory -= b.width * b.height * 4;
	}
	,onContextLost: function() {
		this.dispose();
		this.initIndexes();
	}
	,dispose: function() {
		if(this.triIndexes16 != null) {
			this.triIndexes16.dispose();
		}
		if(this.quadIndexes16 != null) {
			this.quadIndexes16.dispose();
		}
		if(this.triIndexes32 != null) {
			this.triIndexes32.dispose();
		}
		if(this.quadIndexes32 != null) {
			this.quadIndexes32.dispose();
		}
		this.triIndexes16 = null;
		this.quadIndexes16 = null;
		this.triIndexes32 = null;
		this.quadIndexes32 = null;
		var _g = 0;
		var _g1 = this.textures.slice();
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			t.dispose();
		}
		var _g = 0;
		var _g1 = this.depths.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.dispose();
		}
		var _g = 0;
		var _g1 = this.buffers.slice();
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.dispose();
		}
		this.buffers = [];
		this.textures = [];
		this.usedMemory = 0;
		this.texMemory = 0;
	}
	,stats: function() {
		var total = 0.;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			total += b.vertices * b.format.strideBytes;
		}
		return { bufferCount : this.buffers.length, bufferMemory : total, totalMemory : this.usedMemory + this.texMemory, textureCount : this.textures.length, textureMemory : this.texMemory};
	}
	,allocStats: function() {
		return [];
	}
	,__class__: h3d_impl_MemoryManager
};
var h3d_impl_NullDriver = function() {
	h3d_impl_Driver.call(this);
};
$hxClasses["h3d.impl.NullDriver"] = h3d_impl_NullDriver;
h3d_impl_NullDriver.__name__ = "h3d.impl.NullDriver";
h3d_impl_NullDriver.__super__ = h3d_impl_Driver;
h3d_impl_NullDriver.prototype = $extend(h3d_impl_Driver.prototype,{
	hasFeature: function(f) {
		return true;
	}
	,isSupportedFormat: function(fmt) {
		return true;
	}
	,logImpl: function(str) {
		haxe_Log.trace(str,{ fileName : "h3d/impl/NullDriver.hx", lineNumber : 23, className : "h3d.impl.NullDriver", methodName : "logImpl"});
	}
	,isDisposed: function() {
		return false;
	}
	,getDriverName: function(details) {
		return "NullDriver";
	}
	,init: function(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		onCreate(false);
	}
	,selectShader: function(shader) {
		if(this.cur == shader) {
			return false;
		}
		this.cur = shader;
		return true;
	}
	,allocTexture: function(t) {
		return { };
	}
	,allocBuffer: function(b) {
		return { };
	}
	,__class__: h3d_impl_NullDriver
});
var h3d_impl_Step = $hxEnums["h3d.impl.Step"] = { __ename__:"h3d.impl.Step",__constructs__:null
	,MainDraw: {_hx_name:"MainDraw",_hx_index:0,__enum__:"h3d.impl.Step",toString:$estr}
	,Decals: {_hx_name:"Decals",_hx_index:1,__enum__:"h3d.impl.Step",toString:$estr}
	,Shadows: {_hx_name:"Shadows",_hx_index:2,__enum__:"h3d.impl.Step",toString:$estr}
	,Lighting: {_hx_name:"Lighting",_hx_index:3,__enum__:"h3d.impl.Step",toString:$estr}
	,Forward: {_hx_name:"Forward",_hx_index:4,__enum__:"h3d.impl.Step",toString:$estr}
	,BeforeTonemapping: {_hx_name:"BeforeTonemapping",_hx_index:5,__enum__:"h3d.impl.Step",toString:$estr}
	,AfterTonemapping: {_hx_name:"AfterTonemapping",_hx_index:6,__enum__:"h3d.impl.Step",toString:$estr}
	,Overlay: {_hx_name:"Overlay",_hx_index:7,__enum__:"h3d.impl.Step",toString:$estr}
	,Custom: ($_=function(name) { return {_hx_index:8,name:name,__enum__:"h3d.impl.Step",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["name"],$_)
};
h3d_impl_Step.__constructs__ = [h3d_impl_Step.MainDraw,h3d_impl_Step.Decals,h3d_impl_Step.Shadows,h3d_impl_Step.Lighting,h3d_impl_Step.Forward,h3d_impl_Step.BeforeTonemapping,h3d_impl_Step.AfterTonemapping,h3d_impl_Step.Overlay,h3d_impl_Step.Custom];
h3d_impl_Step.__empty_constructs__ = [h3d_impl_Step.MainDraw,h3d_impl_Step.Decals,h3d_impl_Step.Shadows,h3d_impl_Step.Lighting,h3d_impl_Step.Forward,h3d_impl_Step.BeforeTonemapping,h3d_impl_Step.AfterTonemapping,h3d_impl_Step.Overlay];
var h3d_impl_RendererFX = function() { };
$hxClasses["h3d.impl.RendererFX"] = h3d_impl_RendererFX;
h3d_impl_RendererFX.__name__ = "h3d.impl.RendererFX";
h3d_impl_RendererFX.__isInterface__ = true;
h3d_impl_RendererFX.prototype = {
	__class__: h3d_impl_RendererFX
};
var h3d_impl_ShaderCache = function(file,outputFile) {
	this.file = file;
	var tmp = outputFile;
	this.outputFile = tmp != null ? tmp : file;
	this.sourceFile = file + ".source";
};
$hxClasses["h3d.impl.ShaderCache"] = h3d_impl_ShaderCache;
h3d_impl_ShaderCache.__name__ = "h3d.impl.ShaderCache";
h3d_impl_ShaderCache.prototype = {
	disableSave: function() {
		this.outputFile = null;
	}
	,initEmpty: function() {
		this.data = new haxe_ds_StringMap();
		this.sources = new haxe_ds_StringMap();
	}
	,load: function() {
		this.data = new haxe_ds_StringMap();
		try {
			this.loadFile(this.file);
		} catch( _g ) {
		}
		if(this.outputFile != this.file) {
			try {
				this.loadFile(this.outputFile);
			} catch( _g ) {
			}
		}
		if(this.keepSource) {
			try {
				this.loadSources();
			} catch( _g ) {
			}
		}
	}
	,loadFile: function(file) {
		throw haxe_Exception.thrown("Cannot load shader cache with this platform");
	}
	,loadSources: function() {
		throw haxe_Exception.thrown("Cannot load shader cache with this platform");
	}
	,resolveShaderBinary: function(source,configurationKey) {
		if(configurationKey == null) {
			configurationKey = "";
		}
		if(this.data == null) {
			this.load();
		}
		var this1 = this.data;
		var key = configurationKey + haxe_crypto_Md5.encode(source);
		return this1.h[key];
	}
	,saveCompiledShader: function(source,bytes,configurationKey,saveToFile) {
		if(saveToFile == null) {
			saveToFile = true;
		}
		if(configurationKey == null) {
			configurationKey = "";
		}
		if(this.outputFile == null) {
			return;
		}
		if(this.data == null) {
			this.load();
		}
		var key = configurationKey + haxe_crypto_Md5.encode(source);
		if(this.data.h[key] == bytes && (!this.keepSource || this.sources.h[key] == source)) {
			return;
		}
		this.data.h[key] = bytes;
		if(saveToFile) {
			this.save();
		}
		if(this.keepSource) {
			this.sources.h[key] = source;
			this.saveSources();
		}
	}
	,save: function() {
		var out = new haxe_io_BytesOutput();
		var _e = this.data;
		var keys = Lambda.array({ iterator : function() {
			return new haxe_ds__$StringMap_StringMapKeyIterator(_e.h);
		}});
		keys.sort(Reflect.compare);
		var _g = 0;
		while(_g < keys.length) {
			var key = keys[_g];
			++_g;
			out.writeInt32(key.length);
			out.writeString(key);
			var b64 = haxe_crypto_Base64.encode(this.data.h[key]);
			out.writeInt32(b64.length);
			out.writeString(b64);
			out.writeByte(10);
		}
	}
	,saveSources: function() {
		var out = new haxe_io_BytesOutput();
		var _e = this.sources;
		var keys = Lambda.array({ iterator : function() {
			return new haxe_ds__$StringMap_StringMapKeyIterator(_e.h);
		}});
		keys.sort(Reflect.compare);
		var _g = 0;
		while(_g < keys.length) {
			var key = keys[_g];
			++_g;
			out.writeInt32(key.length);
			out.writeString(key);
			var src = this.sources.h[key];
			out.writeInt32(src.length);
			out.writeString(src);
			out.writeByte(10);
			out.writeByte(10);
		}
	}
	,__class__: h3d_impl_ShaderCache
};
var h3d_impl_TextureCache = function() {
	this.position = 0;
	this.cache = [];
	var engine = h3d_Engine.CURRENT;
	this.defaultFormat = h3d_mat_Texture.nativeFormat;
	this.defaultDepthBuffer = h3d_mat_Texture.getDefaultDepth();
};
$hxClasses["h3d.impl.TextureCache"] = h3d_impl_TextureCache;
h3d_impl_TextureCache.__name__ = "h3d.impl.TextureCache";
h3d_impl_TextureCache.prototype = {
	get: function(index) {
		if(index == null) {
			index = 0;
		}
		return this.cache[index];
	}
	,getNamed: function(name) {
		var _g = 0;
		var _g1 = this.position;
		while(_g < _g1) {
			var i = _g++;
			if(this.cache[i].name == name) {
				return this.cache[i];
			}
		}
		return null;
	}
	,set: function(t,index) {
		this.cache[index] = t;
	}
	,begin: function() {
		while(this.cache.length > this.position) {
			var t = this.cache.pop();
			if(t != null) {
				t.dispose();
			}
		}
		this.position = 0;
	}
	,lookupTarget: function(name,width,height,format,flags) {
		var t = this.cache[this.position];
		var _g = this.position + 1;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var t2 = this.cache[i];
			if(t2 != null && !(t2.isDepth() ? t2.t == null : t2.t == null && t2.realloc == null) && t2.width == width && t2.height == height && t2.format == format) {
				if(flags != null) {
					var fitFlags = true;
					var _g2 = 0;
					while(_g2 < flags.length) {
						var f = flags[_g2];
						++_g2;
						if((t2.flags & 1 << f._hx_index) == 0) {
							fitFlags = false;
							break;
						}
					}
					if(!fitFlags) {
						continue;
					}
				}
				this.cache[this.position] = t2;
				this.cache[i] = t;
				return t2;
			}
		}
		if(t != null && t.name == name) {
			t.dispose();
			t = null;
		}
		if(flags == null) {
			flags = [];
		}
		if(flags.indexOf(h3d_mat_TextureFlags.Target) == -1) {
			flags.push(h3d_mat_TextureFlags.Target);
		}
		var newt = new h3d_mat_Texture(width,height,flags,format);
		newt.realloc = function() {
		};
		if(t != null) {
			this.cache.splice(this.position,0,newt);
		} else {
			this.cache[this.position] = newt;
		}
		return newt;
	}
	,allocTarget: function(name,width,height,defaultDepth,format,flags) {
		if(defaultDepth == null) {
			defaultDepth = true;
		}
		var t = this.cache[this.position];
		if(format == null) {
			format = this.defaultFormat;
		}
		var alloc = false;
		if(t == null || (t.isDepth() ? t.t == null : t.t == null && t.realloc == null) || t.width != width || t.height != height || t.format != format) {
			alloc = true;
		}
		if(!alloc && flags != null) {
			var _g = 0;
			while(_g < flags.length) {
				var f = flags[_g];
				++_g;
				if((t.flags & 1 << f._hx_index) == 0) {
					alloc = true;
					break;
				}
			}
		}
		if(alloc) {
			t = this.lookupTarget(name,width,height,format,flags);
		}
		t.depthBuffer = defaultDepth ? this.defaultDepthBuffer : null;
		t.setName(name);
		this.position++;
		return t;
	}
	,allocTargetScale: function(name,scale,defaultDepth,format) {
		if(defaultDepth == null) {
			defaultDepth = true;
		}
		var e = h3d_Engine.CURRENT;
		return this.allocTarget(name,Math.ceil(e.width * scale),Math.ceil(e.height * scale),defaultDepth,format);
	}
	,allocTileTarget: function(name,tile,defaultDepth,format) {
		if(defaultDepth == null) {
			defaultDepth = false;
		}
		return this.allocTarget(name,Math.ceil(tile.width + tile.x) - Math.floor(tile.x),Math.ceil(tile.height + tile.y) - Math.floor(tile.y),defaultDepth,format);
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.cache;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			t.dispose();
		}
		this.cache = [];
	}
	,__class__: h3d_impl_TextureCache
};
var hxd_impl_AnyProps = function() { };
$hxClasses["hxd.impl.AnyProps"] = hxd_impl_AnyProps;
hxd_impl_AnyProps.__name__ = "hxd.impl.AnyProps";
hxd_impl_AnyProps.prototype = {
	set_props: function(p) {
		this.props = p;
		this.refreshProps();
		return p;
	}
	,setDefaultProps: function(kind) {
		this.set_props(this.getDefaultProps(kind));
	}
	,getDefaultProps: function(kind) {
		return { };
	}
	,refreshProps: function() {
	}
	,__class__: hxd_impl_AnyProps
};
var h3d_mat_BaseMaterial = function(shader) {
	if(shader != null) {
		this.addPass(new h3d_mat_Pass("default",null)).addShader(shader);
	}
};
$hxClasses["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial;
h3d_mat_BaseMaterial.__name__ = "h3d.mat.BaseMaterial";
h3d_mat_BaseMaterial.__super__ = hxd_impl_AnyProps;
h3d_mat_BaseMaterial.prototype = $extend(hxd_impl_AnyProps.prototype,{
	addPass: function(p) {
		var prev = null;
		var cur = this.passes;
		while(cur != null) {
			prev = cur;
			cur = cur.nextPass;
		}
		if(prev == null) {
			this.passes = p;
		} else {
			prev.nextPass = p;
		}
		p.nextPass = null;
		return p;
	}
	,removePass: function(p) {
		var prev = null;
		var cur = this.passes;
		while(cur != null) {
			if(cur == p) {
				if(prev == null) {
					this.passes = p.nextPass;
				} else {
					prev.nextPass = p.nextPass;
				}
				p.nextPass = null;
				return true;
			}
			prev = cur;
			cur = cur.nextPass;
		}
		return false;
	}
	,get_mainPass: function() {
		return this.passes;
	}
	,getPasses: function() {
		var p = this.passes;
		var out = [];
		while(p != null) {
			out.push(p);
			p = p.nextPass;
		}
		return out;
	}
	,getPass: function(name) {
		var p = this.passes;
		while(p != null) {
			if(p.name == name) {
				return p;
			}
			p = p.nextPass;
		}
		return null;
	}
	,allocPass: function(name,inheritMain) {
		if(inheritMain == null) {
			inheritMain = true;
		}
		var p = this.getPass(name);
		if(p != null) {
			return p;
		}
		var p = new h3d_mat_Pass(name,null,inheritMain ? this.passes : null);
		if(inheritMain && this.passes != null) {
			p.set_batchMode(this.passes.batchMode);
		}
		this.addPass(p);
		return p;
	}
	,clone: function(m) {
		if(m == null) {
			m = new h3d_mat_BaseMaterial();
		}
		m.passes.load(this.passes);
		m.name = this.name;
		m.set_props(this.props);
		return m;
	}
	,__class__: h3d_mat_BaseMaterial
});
var h3d_mat_Face = $hxEnums["h3d.mat.Face"] = { __ename__:"h3d.mat.Face",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.Face",toString:$estr}
	,Back: {_hx_name:"Back",_hx_index:1,__enum__:"h3d.mat.Face",toString:$estr}
	,Front: {_hx_name:"Front",_hx_index:2,__enum__:"h3d.mat.Face",toString:$estr}
	,Both: {_hx_name:"Both",_hx_index:3,__enum__:"h3d.mat.Face",toString:$estr}
};
h3d_mat_Face.__constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
h3d_mat_Face.__empty_constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
var h3d_mat_Blend = $hxEnums["h3d.mat.Blend"] = { __ename__:"h3d.mat.Blend",__constructs__:null
	,One: {_hx_name:"One",_hx_index:0,__enum__:"h3d.mat.Blend",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlpha: {_hx_name:"SrcAlpha",_hx_index:2,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcColor: {_hx_name:"SrcColor",_hx_index:3,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstAlpha: {_hx_name:"DstAlpha",_hx_index:4,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstColor: {_hx_name:"DstColor",_hx_index:5,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcAlpha: {_hx_name:"OneMinusSrcAlpha",_hx_index:6,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcColor: {_hx_name:"OneMinusSrcColor",_hx_index:7,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstAlpha: {_hx_name:"OneMinusDstAlpha",_hx_index:8,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstColor: {_hx_name:"OneMinusDstColor",_hx_index:9,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantColor: {_hx_name:"ConstantColor",_hx_index:10,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantAlpha: {_hx_name:"ConstantAlpha",_hx_index:11,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantColor: {_hx_name:"OneMinusConstantColor",_hx_index:12,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantAlpha: {_hx_name:"OneMinusConstantAlpha",_hx_index:13,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlphaSaturate: {_hx_name:"SrcAlphaSaturate",_hx_index:14,__enum__:"h3d.mat.Blend",toString:$estr}
};
h3d_mat_Blend.__constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
h3d_mat_Blend.__empty_constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
var h3d_mat_Compare = $hxEnums["h3d.mat.Compare"] = { __ename__:"h3d.mat.Compare",__constructs__:null
	,Always: {_hx_name:"Always",_hx_index:0,__enum__:"h3d.mat.Compare",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:1,__enum__:"h3d.mat.Compare",toString:$estr}
	,Equal: {_hx_name:"Equal",_hx_index:2,__enum__:"h3d.mat.Compare",toString:$estr}
	,NotEqual: {_hx_name:"NotEqual",_hx_index:3,__enum__:"h3d.mat.Compare",toString:$estr}
	,Greater: {_hx_name:"Greater",_hx_index:4,__enum__:"h3d.mat.Compare",toString:$estr}
	,GreaterEqual: {_hx_name:"GreaterEqual",_hx_index:5,__enum__:"h3d.mat.Compare",toString:$estr}
	,Less: {_hx_name:"Less",_hx_index:6,__enum__:"h3d.mat.Compare",toString:$estr}
	,LessEqual: {_hx_name:"LessEqual",_hx_index:7,__enum__:"h3d.mat.Compare",toString:$estr}
};
h3d_mat_Compare.__constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
h3d_mat_Compare.__empty_constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
var h3d_mat_StencilOp = $hxEnums["h3d.mat.StencilOp"] = { __ename__:"h3d.mat.StencilOp",__constructs__:null
	,Keep: {_hx_name:"Keep",_hx_index:0,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Replace: {_hx_name:"Replace",_hx_index:2,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Increment: {_hx_name:"Increment",_hx_index:3,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,IncrementWrap: {_hx_name:"IncrementWrap",_hx_index:4,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Decrement: {_hx_name:"Decrement",_hx_index:5,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,DecrementWrap: {_hx_name:"DecrementWrap",_hx_index:6,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Invert: {_hx_name:"Invert",_hx_index:7,__enum__:"h3d.mat.StencilOp",toString:$estr}
};
h3d_mat_StencilOp.__constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
h3d_mat_StencilOp.__empty_constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
var h3d_mat_MipMap = $hxEnums["h3d.mat.MipMap"] = { __ename__:"h3d.mat.MipMap",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Nearest: {_hx_name:"Nearest",_hx_index:1,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:2,__enum__:"h3d.mat.MipMap",toString:$estr}
};
h3d_mat_MipMap.__constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
h3d_mat_MipMap.__empty_constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
var h3d_mat_Filter = $hxEnums["h3d.mat.Filter"] = { __ename__:"h3d.mat.Filter",__constructs__:null
	,Nearest: {_hx_name:"Nearest",_hx_index:0,__enum__:"h3d.mat.Filter",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:1,__enum__:"h3d.mat.Filter",toString:$estr}
};
h3d_mat_Filter.__constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
h3d_mat_Filter.__empty_constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
var h3d_mat_Wrap = $hxEnums["h3d.mat.Wrap"] = { __ename__:"h3d.mat.Wrap",__constructs__:null
	,Clamp: {_hx_name:"Clamp",_hx_index:0,__enum__:"h3d.mat.Wrap",toString:$estr}
	,Repeat: {_hx_name:"Repeat",_hx_index:1,__enum__:"h3d.mat.Wrap",toString:$estr}
};
h3d_mat_Wrap.__constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
h3d_mat_Wrap.__empty_constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
var h3d_mat_Operation = $hxEnums["h3d.mat.Operation"] = { __ename__:"h3d.mat.Operation",__constructs__:null
	,Add: {_hx_name:"Add",_hx_index:0,__enum__:"h3d.mat.Operation",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:1,__enum__:"h3d.mat.Operation",toString:$estr}
	,ReverseSub: {_hx_name:"ReverseSub",_hx_index:2,__enum__:"h3d.mat.Operation",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:3,__enum__:"h3d.mat.Operation",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:4,__enum__:"h3d.mat.Operation",toString:$estr}
};
h3d_mat_Operation.__constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
h3d_mat_Operation.__empty_constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
var h3d_mat_TextureFlags = $hxEnums["h3d.mat.TextureFlags"] = { __ename__:"h3d.mat.TextureFlags",__constructs__:null
	,Target: {_hx_name:"Target",_hx_index:0,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Cube: {_hx_name:"Cube",_hx_index:1,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,MipMapped: {_hx_name:"MipMapped",_hx_index:2,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,ManualMipMapGen: {_hx_name:"ManualMipMapGen",_hx_index:3,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsNPOT: {_hx_name:"IsNPOT",_hx_index:4,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:5,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:6,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:7,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,WasCleared: {_hx_name:"WasCleared",_hx_index:8,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Loading: {_hx_name:"Loading",_hx_index:9,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Serialize: {_hx_name:"Serialize",_hx_index:10,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsArray: {_hx_name:"IsArray",_hx_index:11,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AsyncLoading: {_hx_name:"AsyncLoading",_hx_index:12,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,LazyLoading: {_hx_name:"LazyLoading",_hx_index:13,__enum__:"h3d.mat.TextureFlags",toString:$estr}
};
h3d_mat_TextureFlags.__constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading,h3d_mat_TextureFlags.LazyLoading];
h3d_mat_TextureFlags.__empty_constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading,h3d_mat_TextureFlags.LazyLoading];
var h3d_mat_Defaults = function() { };
$hxClasses["h3d.mat.Defaults"] = h3d_mat_Defaults;
h3d_mat_Defaults.__name__ = "h3d.mat.Defaults";
h3d_mat_Defaults.get_shadowShader = function() {
	var s = h3d_mat_Defaults.shadowShader;
	if(s == null) {
		s = new h3d_shader_Shadow();
		h3d_mat_Defaults.set_shadowShader(s);
		h3d_mat_Defaults.shadowShader.setPriority(-1);
	}
	return s;
};
h3d_mat_Defaults.set_shadowShader = function(s) {
	return h3d_mat_Defaults.shadowShader = s;
};
h3d_mat_Defaults.makeVolumeDecal = function(bounds) {
	return new h3d_shader_VolumeDecal(bounds.xMax - bounds.xMin,bounds.yMax - bounds.yMin);
};
var h3d_mat_Material = function(texture) {
	this.mshader = new h3d_shader_BaseMesh();
	this.set_blendMode(h2d_BlendMode.None);
	h3d_mat_BaseMaterial.call(this,this.mshader);
	this.set_texture(texture);
};
$hxClasses["h3d.mat.Material"] = h3d_mat_Material;
h3d_mat_Material.__name__ = "h3d.mat.Material";
h3d_mat_Material.create = function(tex) {
	var mat = h3d_mat_MaterialSetup.current.createMaterial();
	mat.set_texture(tex);
	mat.set_props(mat.getDefaultProps());
	return mat;
};
h3d_mat_Material.__super__ = h3d_mat_BaseMaterial;
h3d_mat_Material.prototype = $extend(h3d_mat_BaseMaterial.prototype,{
	get_specularPower: function() {
		return this.mshader.specularPower__;
	}
	,set_specularPower: function(v) {
		return this.mshader.specularPower__ = v;
	}
	,get_specularAmount: function() {
		return this.mshader.specularAmount__;
	}
	,set_specularAmount: function(v) {
		return this.mshader.specularAmount__ = v;
	}
	,get_color: function() {
		return this.mshader.color__;
	}
	,set_color: function(v) {
		return this.mshader.color__ = v;
	}
	,get_shadows: function() {
		if(this.castShadows) {
			return this.receiveShadows;
		} else {
			return false;
		}
	}
	,set_shadows: function(v) {
		this.set_castShadows(v);
		this.set_receiveShadows(v);
		return v;
	}
	,set_castShadows: function(v) {
		if(this.castShadows == v) {
			return v;
		}
		if(this.passes != null) {
			if(v) {
				this.addPass(new h3d_mat_Pass("shadow",null,this.passes)).set_isStatic(this.staticShadows);
			} else {
				this.removePass(this.getPass("shadow"));
			}
		}
		return this.castShadows = v;
	}
	,set_receiveShadows: function(v) {
		if(v == this.receiveShadows) {
			return v;
		}
		if(this.passes != null) {
			var shadows = h3d_mat_Defaults.get_shadowShader();
			if(v) {
				this.passes.addShader(shadows);
			} else {
				this.passes.removeShader(shadows);
			}
		}
		return this.receiveShadows = v;
	}
	,set_staticShadows: function(v) {
		var p = this.getPass("shadow");
		if(p != null) {
			p.set_isStatic(v);
		}
		return this.staticShadows = v;
	}
	,clone: function(m) {
		var m1 = m == null ? new h3d_mat_Material() : m;
		h3d_mat_BaseMaterial.prototype.clone.call(this,m1);
		m1.set_castShadows(this.castShadows);
		m1.set_receiveShadows(this.receiveShadows);
		m1.set_texture(this.get_texture());
		m1.set_specularTexture(this.get_specularTexture());
		m1.set_normalMap(this.get_normalMap());
		if(this.textureShader != null) {
			var _this = m1.textureShader;
			_this.constModified = true;
			_this.additive__ = this.textureShader.additive__;
			var _this = m1.textureShader;
			_this.constModified = true;
			_this.killAlpha__ = this.textureShader.killAlpha__;
			m1.textureShader.killAlphaThreshold__ = this.textureShader.killAlphaThreshold__;
		}
		m1.mshader.color__ = this.mshader.color__;
		m1.set_blendMode(this.blendMode);
		return m1;
	}
	,set_blendMode: function(v) {
		if(this.passes != null) {
			this.passes.setBlendMode(v);
			switch(v._hx_index) {
			case 0:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("default");
				break;
			case 1:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("alpha");
				break;
			case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:
				this.passes.set_depthWrite(false);
				this.passes.setPassName("additive");
				break;
			}
		}
		return this.blendMode = v;
	}
	,get_specularTexture: function() {
		if(this.specularShader == null) {
			return null;
		} else {
			return this.specularShader.texture__;
		}
	}
	,get_texture: function() {
		if(this.textureShader == null) {
			return null;
		} else {
			return this.textureShader.texture__;
		}
	}
	,set_texture: function(t) {
		if(t == null) {
			if(this.textureShader != null) {
				this.passes.removeShader(this.textureShader);
				this.textureShader = null;
			}
		} else {
			if(this.textureShader == null) {
				this.textureShader = new h3d_shader_Texture();
				this.passes.addShader(this.textureShader);
			}
			this.textureShader.texture__ = t;
		}
		return t;
	}
	,get_normalMap: function() {
		if(this.normalShader == null) {
			return null;
		} else {
			return this.normalShader.texture__;
		}
	}
	,set_normalMap: function(t) {
		if(t == null) {
			if(this.normalShader != null) {
				this.passes.removeShader(this.normalShader);
				this.normalShader = null;
			}
		} else {
			if(this.normalShader == null) {
				this.normalShader = new h3d_shader_NormalMap();
				if(this.textureShader != null) {
					this.passes.addShaderAtIndex(this.normalShader,this.passes.getShaderIndex(this.textureShader) + 1);
				} else {
					this.passes.addShader(this.normalShader);
				}
			}
			this.normalShader.texture__ = t;
		}
		return t;
	}
	,set_specularTexture: function(t) {
		if(t == null) {
			if(this.specularShader != null) {
				this.passes.removeShader(this.specularShader);
				this.specularShader = null;
			}
		} else {
			if(this.specularShader == null) {
				this.specularShader = new h3d_shader_SpecularTexture();
				this.passes.addShader(this.specularShader);
			}
			this.specularShader.texture__ = t;
		}
		return t;
	}
	,getDefaultModelProps: function() {
		var props = this.getDefaultProps();
		switch(this.blendMode._hx_index) {
		case 0:
			break;
		case 1:
			props.kind = "Alpha";
			break;
		case 2:
			props.kind = "Add";
			props.culling = false;
			props.shadows = false;
			props.light = false;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported HMD material " + Std.string(this.blendMode));
		}
		return props;
	}
	,getDefaultProps: function(type) {
		var props;
		if(type == null) {
			props = { kind : "Opaque", shadows : true, culling : true, light : true};
		} else {
			switch(type) {
			case "particles3D":case "trail3D":
				props = { kind : "Alpha", shadows : false, culling : false, light : true};
				break;
			case "ui":
				props = { kind : "Alpha", shadows : false, culling : false, light : false};
				break;
			default:
				props = { kind : "Opaque", shadows : true, culling : true, light : true};
			}
		}
		return props;
	}
	,refreshProps: function() {
		if(this.props == null || this.passes == null) {
			return;
		}
		var props = this.props;
		switch(props.kind) {
		case "Add":
			this.set_blendMode(h2d_BlendMode.Add);
			break;
		case "Alpha":
			this.set_blendMode(h2d_BlendMode.Alpha);
			break;
		case "AlphaKill":case "Hidden":case "Opaque":
			this.set_blendMode(h2d_BlendMode.None);
			break;
		case "SoftAdd":
			this.set_blendMode(h2d_BlendMode.SoftAdd);
			break;
		}
		var tshader = this.textureShader;
		if(tshader != null) {
			tshader.constModified = true;
			tshader.killAlpha__ = props.kind == "AlphaKill";
			tshader.killAlphaThreshold__ = 0.5;
		}
		this.passes.set_culling(props.kind == "Hidden" ? h3d_mat_Face.Both : props.culling ? h3d_mat_Face.Back : h3d_mat_Face.None);
		this.passes.set_enableLights(props.light);
		var v = props.shadows;
		this.set_castShadows(v);
		this.set_receiveShadows(v);
		if(this.castShadows && this.receiveShadows) {
			this.getPass("shadow").set_culling(this.passes.culling);
		}
	}
	,__class__: h3d_mat_Material
});
var h3d_mat_MaterialDatabase = function() {
	this.db = new haxe_ds_StringMap();
};
$hxClasses["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase;
h3d_mat_MaterialDatabase.__name__ = "h3d.mat.MaterialDatabase";
h3d_mat_MaterialDatabase.prototype = {
	getFilePath: function(model) {
		var dir = model.entry.get_directory();
		var filename = "materials.props";
		if(dir == null || dir == "") {
			return filename;
		} else {
			return model.entry.get_directory() + "/" + filename;
		}
	}
	,getModelData: function(model) {
		if(model == null) {
			return null;
		}
		var this1 = this.db;
		var key = model.entry.get_directory();
		var cached = this1.h[key];
		if(cached != null) {
			return cached.v;
		}
		var file = this.getFilePath(model);
		var value;
		try {
			value = JSON.parse(hxd_res_Loader.currentInstance.load(file).toText());
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof hxd_fs_NotFound)) {
				value = { };
			} else {
				throw _g;
			}
		}
		var this1 = this.db;
		var key = model.entry.get_directory();
		this1.h[key] = { v : value};
		return value;
	}
	,saveData: function(model,data) {
		var file = this.getFilePath(model);
		throw haxe_Exception.thrown("Can't save material props database " + file);
	}
	,loadMatProps: function(material,setup) {
		var p = this.getModelData(material.model);
		if(p == null) {
			return p;
		}
		p = p.materials;
		if(p == null) {
			return p;
		}
		p = Reflect.field(p,setup.name);
		if(p == null) {
			return p;
		}
		if(material.model != null) {
			var specData = Reflect.field(p,material.name + "/" + material.model.entry.name);
			if(specData != null) {
				return specData;
			}
		}
		return Reflect.field(p,material.name);
	}
	,saveMatProps: function(material,setup,defaultProps) {
		var path = ["materials",setup.name,material.name];
		var root = this.getModelData(material.model);
		if(root == null) {
			return;
		}
		var realRoot = root;
		var prevs = [];
		var _g = 0;
		var _g1 = path.length - 1;
		while(_g < _g1) {
			var i = _g++;
			var next = Reflect.field(root,path[i]);
			if(next == null) {
				next = { };
				root[path[i]] = next;
			}
			prevs.push(root);
			root = next;
		}
		var currentProps = material.props;
		var modelSpec = currentProps.__refMode == "modelSpec";
		var name = path.pop();
		if(!modelSpec) {
			Reflect.deleteField(root,name);
		}
		var specName = name + "/" + (material.model != null ? material.model.entry.name : "");
		Reflect.deleteField(root,specName);
		if(defaultProps == null) {
			defaultProps = material.getDefaultProps();
		}
		if(currentProps == null || (defaultProps == null ? "null" : Std.string(defaultProps)) == (currentProps == null ? "null" : Std.string(currentProps))) {
			while(path.length > 0) {
				var name1 = path.pop();
				var root1 = prevs.pop();
				if(Reflect.fields(Reflect.field(root1,name1)).length != 0) {
					break;
				}
				Reflect.deleteField(root1,name1);
			}
		} else {
			root[modelSpec ? specName : name] = currentProps;
		}
		var file = this.getFilePath(material.model);
		if(Reflect.fields(realRoot).length == 0) {
			realRoot = null;
		}
		this.saveData(material.model,realRoot);
	}
	,__class__: h3d_mat_MaterialDatabase
};
var h3d_mat_MaterialSetup = function(name) {
	if(this.database == null) {
		this.database = new h3d_mat_MaterialDatabase();
	}
	this.name = name;
};
$hxClasses["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup;
h3d_mat_MaterialSetup.__name__ = "h3d.mat.MaterialSetup";
h3d_mat_MaterialSetup.prototype = {
	createRenderer: function() {
		return new h3d_scene_fwd_Renderer();
	}
	,createLightSystem: function() {
		return new h3d_scene_fwd_LightSystem();
	}
	,createMaterial: function() {
		return new h3d_mat_Material();
	}
	,getDefaults: function(kind) {
		if(this.emptyMat == null) {
			this.emptyMat = this.createMaterial();
		}
		return this.emptyMat.getDefaultProps(kind);
	}
	,loadMaterialProps: function(material) {
		return this.database.loadMatProps(material,this);
	}
	,saveMaterialProps: function(material,defaultProps) {
		this.database.saveMatProps(material,this,defaultProps);
	}
	,customMeshInit: function(mesh) {
	}
	,__class__: h3d_mat_MaterialSetup
};
var h3d_mat_Pass = function(name,shaders,parent) {
	this.layer = 0;
	this.rendererFlags = 0;
	this.culled = false;
	this.bits = 0;
	this.parentPass = parent;
	this.shaders = shaders;
	this.setPassName(name);
	this.set_culling(h3d_mat_Face.Back);
	var src = h3d_mat_Blend.One;
	var dst = h3d_mat_Blend.Zero;
	this.set_blendSrc(src);
	this.set_blendAlphaSrc(src);
	this.set_blendDst(dst);
	this.set_blendAlphaDst(dst);
	this.depth(true,h3d_mat_Compare.Less);
	this.set_blendOp(this.set_blendAlphaOp(h3d_mat_Operation.Add));
	this.colorMask = 15;
};
$hxClasses["h3d.mat.Pass"] = h3d_mat_Pass;
h3d_mat_Pass.__name__ = "h3d.mat.Pass";
h3d_mat_Pass.getEnableLights = function(v) {
	return v & 1;
};
h3d_mat_Pass.getDynamicParameters = function(v) {
	return v >> 1 & 1;
};
h3d_mat_Pass.getIsStatic = function(v) {
	return v >> 2 & 1;
};
h3d_mat_Pass.getBatchMode = function(v) {
	return v >> 3 & 1;
};
h3d_mat_Pass.getCulling = function(v) {
	return v & 3;
};
h3d_mat_Pass.getDepthWrite = function(v) {
	return v >> 2 & 1;
};
h3d_mat_Pass.getDepthTest = function(v) {
	return v >> 3 & 7;
};
h3d_mat_Pass.getBlendSrc = function(v) {
	return v >> 6 & 15;
};
h3d_mat_Pass.getBlendDst = function(v) {
	return v >> 10 & 15;
};
h3d_mat_Pass.getBlendAlphaSrc = function(v) {
	return v >> 14 & 15;
};
h3d_mat_Pass.getBlendAlphaDst = function(v) {
	return v >> 18 & 15;
};
h3d_mat_Pass.getBlendOp = function(v) {
	return v >> 22 & 7;
};
h3d_mat_Pass.getBlendAlphaOp = function(v) {
	return v >> 25 & 7;
};
h3d_mat_Pass.getWireframe = function(v) {
	return v >> 28 & 1;
};
h3d_mat_Pass.getReserved = function(v) {
	return v >> 29 & 1;
};
h3d_mat_Pass.prototype = {
	load: function(p) {
		this.name = p.name;
		this.passId = p.passId;
		this.bits = p.bits;
		this.set_enableLights(p.enableLights);
		this.set_dynamicParameters(p.dynamicParameters);
		this.set_culling(p.culling);
		this.set_depthWrite(p.depthWrite);
		this.set_depthTest(p.depthTest);
		this.set_blendSrc(p.blendSrc);
		this.set_blendDst(p.blendDst);
		this.set_blendOp(p.blendOp);
		this.set_blendAlphaSrc(p.blendAlphaSrc);
		this.set_blendAlphaDst(p.blendAlphaDst);
		this.set_blendAlphaOp(p.blendAlphaOp);
		this.colorMask = p.colorMask;
		if(p.stencil != null) {
			if(this.stencil == null) {
				this.stencil = new h3d_mat_Stencil();
			}
			this.stencil.load(p.stencil);
		}
	}
	,setPassName: function(name) {
		this.name = name;
		this.passId = hxsl_Globals.allocID(name);
	}
	,blend: function(src,dst) {
		this.set_blendSrc(src);
		this.set_blendAlphaSrc(src);
		this.set_blendDst(dst);
		this.set_blendAlphaDst(dst);
	}
	,setBlendMode: function(b) {
		this.set_blendOp(h3d_mat_Operation.Add);
		this.set_blendAlphaOp(h3d_mat_Operation.Add);
		switch(b._hx_index) {
		case 0:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 1:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 2:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 3:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 4:
			var src = h3d_mat_Blend.OneMinusDstColor;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 5:
			var src = h3d_mat_Blend.DstColor;
			var dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 6:
			var src = h3d_mat_Blend.DstColor;
			var dst = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 7:
			var src = h3d_mat_Blend.Zero;
			var dst = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 8:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 9:
			var src = h3d_mat_Blend.SrcAlpha;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendOp(h3d_mat_Operation.ReverseSub);
			this.set_blendAlphaOp(h3d_mat_Operation.ReverseSub);
			break;
		case 10:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaOp(h3d_mat_Operation.Max);
			this.set_blendOp(h3d_mat_Operation.Max);
			break;
		case 11:
			var src = h3d_mat_Blend.One;
			var dst = h3d_mat_Blend.One;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			this.set_blendAlphaOp(h3d_mat_Operation.Min);
			this.set_blendOp(h3d_mat_Operation.Min);
			break;
		}
	}
	,depth: function(write,test) {
		this.set_depthWrite(write);
		this.set_depthTest(test);
	}
	,setColorMask: function(r,g,b,a) {
		this.colorMask = (r ? 1 : 0) | (g ? 2 : 0) | (b ? 4 : 0) | (a ? 8 : 0);
	}
	,setColorChannel: function(c) {
		switch(c._hx_index) {
		case 1:
			this.setColorMask(true,false,false,false);
			break;
		case 2:
			this.setColorMask(false,true,false,false);
			break;
		case 3:
			this.setColorMask(false,false,true,false);
			break;
		case 4:
			this.setColorMask(false,false,false,true);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported channel " + Std.string(c));
		}
	}
	,setColorMaski: function(r,g,b,a,i) {
		if(i > 8) {
			throw haxe_Exception.thrown("Color mask i supports 8 Render target");
		}
		var mask = (r ? 1 : 0) | (g ? 2 : 0) | (b ? 4 : 0) | (a ? 8 : 0);
		mask <<= i * 4;
		this.colorMask |= mask;
	}
	,resetRendererFlags: function() {
		this.rendererFlags = 0;
	}
	,addShader: function(s) {
		if(s == null) {
			return null;
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		this.resetRendererFlags();
		return s;
	}
	,addSelfShader: function(s) {
		if(s == null) {
			return null;
		}
		this.selfShadersChanged = true;
		this.selfShaders = hxsl_ShaderList.addSort(s,this.selfShaders);
		this.resetRendererFlags();
		return s;
	}
	,addShaderAtIndex: function(s,index) {
		var prev = null;
		var cur = this.shaders;
		while(index > 0 && cur != this.parentShaders) {
			prev = cur;
			cur = cur.next;
			--index;
		}
		if(prev == null) {
			this.shaders = new hxsl_ShaderList(s,cur);
		} else {
			prev.next = new hxsl_ShaderList(s,cur);
		}
		return s;
	}
	,getShaderIndex: function(s) {
		var index = 0;
		var cur = this.shaders;
		while(cur != this.parentShaders) {
			if(cur.s == s) {
				return index;
			}
			cur = cur.next;
			++index;
		}
		return -1;
	}
	,removeShader: function(s) {
		var sl = this.shaders;
		var prev = null;
		while(sl != null) {
			if(sl.s == s) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.shaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				return true;
			}
			prev = sl;
			sl = sl.next;
		}
		sl = this.selfShaders;
		prev = null;
		while(sl != null) {
			if(sl.s == s) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.selfShaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				return true;
			}
			prev = sl;
			sl = sl.next;
		}
		return false;
	}
	,removeShaders: function(t) {
		var sl = this.shaders;
		var prev = null;
		while(sl != null) {
			if(js_Boot.__instanceof(sl.s,t)) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.shaders = sl.next;
				} else {
					prev.next = sl.next;
				}
			} else {
				prev = sl;
			}
			sl = sl.next;
		}
		sl = this.selfShaders;
		prev = null;
		while(sl != null) {
			if(js_Boot.__instanceof(sl.s,t)) {
				this.resetRendererFlags();
				if(this.selfShadersCache == sl) {
					this.selfShadersCache = this.selfShadersCache.next;
				}
				if(prev == null) {
					this.selfShaders = sl.next;
				} else {
					prev.next = sl.next;
				}
			} else {
				prev = sl;
			}
			sl = sl.next;
		}
	}
	,getShader: function(t) {
		var s = this._getShader(t,this.shaders);
		if(s != null) {
			return s;
		} else {
			return this._getShader(t,this.selfShaders);
		}
	}
	,_getShader: function(t,s) {
		while(s != null && s != this.parentShaders) {
			var value = s.s;
			var sh = js_Boot.__downcastCheck(value,t) ? value : null;
			if(sh != null) {
				return sh;
			}
			s = s.next;
		}
		return null;
	}
	,getShaderByName: function(name) {
		var s = this._getShaderByName(name,this.shaders);
		if(s != null) {
			return s;
		} else {
			return this._getShaderByName(name,this.selfShaders);
		}
	}
	,_getShaderByName: function(name,sl) {
		while(sl != null && sl != this.parentShaders) {
			if(sl.s.shader.data.name == name) {
				return sl.s;
			}
			sl = sl.next;
		}
		return null;
	}
	,getShaders: function() {
		return new hxsl__$ShaderList_ShaderIterator(this.shaders,this.parentShaders);
	}
	,checkInfiniteLoop: function() {
		var shaderList = [];
		var s = this.selfShaders;
		while(s != null) {
			var _g = 0;
			while(_g < shaderList.length) {
				var already = shaderList[_g];
				++_g;
				if(already == s) {
					throw haxe_Exception.thrown("infinite loop");
				}
			}
			shaderList.push(s);
			s = s.next;
		}
	}
	,selfShadersRec: function(rebuild) {
		if(this.selfShaders == null) {
			return this.shaders;
		}
		if(!this.selfShadersChanged && !rebuild && this.shaders == this.selfShadersCache) {
			return this.selfShaders;
		}
		var sl = this.selfShaders;
		var prev = null;
		while(sl != null && sl != this.selfShadersCache) {
			prev = sl;
			sl = sl.next;
		}
		this.selfShadersCache = this.shaders;
		if(prev != null) {
			prev.next = this.selfShadersCache;
		} else {
			this.selfShaders = this.shaders;
		}
		return this.selfShaders;
	}
	,getShadersRec: function() {
		if(this.parentPass == null || this.parentShaders == this.parentPass.shaders) {
			return this.selfShadersRec(false);
		}
		var s = this.shaders;
		var prev = null;
		while(s != null && s != this.parentShaders) {
			prev = s;
			s = s.next;
		}
		this.parentShaders = this.parentPass.shaders;
		if(prev == null) {
			this.shaders = this.parentShaders;
		} else {
			prev.next = this.parentShaders;
		}
		return this.selfShadersRec(true);
	}
	,clone: function() {
		var p = new h3d_mat_Pass(this.name,this.shaders.clone());
		p.selfShaders = this.selfShaders;
		p.bits = this.bits;
		p.set_enableLights(this.enableLights);
		if(this.stencil != null) {
			p.stencil = this.stencil.clone();
		}
		return p;
	}
	,set_enableLights: function(v) {
		this.flags = this.flags & -2 | (v ? 1 : 0);
		return this.enableLights = v;
	}
	,set_dynamicParameters: function(v) {
		this.flags = this.flags & -3 | (v ? 1 : 0) << 1;
		return this.dynamicParameters = v;
	}
	,set_isStatic: function(v) {
		this.flags = this.flags & -5 | (v ? 1 : 0) << 2;
		return this.isStatic = v;
	}
	,set_batchMode: function(v) {
		this.flags = this.flags & -9 | (v ? 1 : 0) << 3;
		return this.batchMode = v;
	}
	,set_culling: function(v) {
		this.bits = this.bits & -4 | v._hx_index;
		return this.culling = v;
	}
	,set_depthWrite: function(v) {
		this.bits = this.bits & -5 | (v ? 1 : 0) << 2;
		return this.depthWrite = v;
	}
	,set_depthTest: function(v) {
		this.bits = this.bits & -57 | v._hx_index << 3;
		return this.depthTest = v;
	}
	,set_blendSrc: function(v) {
		this.bits = this.bits & -961 | v._hx_index << 6;
		return this.blendSrc = v;
	}
	,set_blendDst: function(v) {
		this.bits = this.bits & -15361 | v._hx_index << 10;
		return this.blendDst = v;
	}
	,set_blendAlphaSrc: function(v) {
		this.bits = this.bits & -245761 | v._hx_index << 14;
		return this.blendAlphaSrc = v;
	}
	,set_blendAlphaDst: function(v) {
		this.bits = this.bits & -3932161 | v._hx_index << 18;
		return this.blendAlphaDst = v;
	}
	,set_blendOp: function(v) {
		this.bits = this.bits & -29360129 | v._hx_index << 22;
		return this.blendOp = v;
	}
	,set_blendAlphaOp: function(v) {
		this.bits = this.bits & -234881025 | v._hx_index << 25;
		return this.blendAlphaOp = v;
	}
	,set_wireframe: function(v) {
		this.bits = this.bits & -268435457 | (v ? 1 : 0) << 28;
		return this.wireframe = v;
	}
	,set_reserved: function(v) {
		this.bits = this.bits & -536870913 | (v ? 1 : 0) << 29;
		return this.reserved = v;
	}
	,loadFlags: function(bits) {
		this.flags = bits;
		this.set_enableLights((this.flags & 1) != 0);
		this.set_dynamicParameters((this.flags >> 1 & 1) != 0);
		this.set_isStatic((this.flags >> 2 & 1) != 0);
		this.set_batchMode((this.flags >> 3 & 1) != 0);
	}
	,loadBits: function(bits) {
		this.bits = bits;
		this.set_culling(Type.createEnumIndex(h3d_mat_Face,this.bits & 3));
		this.set_depthWrite((this.bits >> 2 & 1) != 0);
		this.set_depthTest(Type.createEnumIndex(h3d_mat_Compare,this.bits >> 3 & 7));
		this.set_blendSrc(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 6 & 15));
		this.set_blendDst(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 10 & 15));
		this.set_blendAlphaSrc(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 14 & 15));
		this.set_blendAlphaDst(Type.createEnumIndex(h3d_mat_Blend,this.bits >> 18 & 15));
		this.set_blendOp(Type.createEnumIndex(h3d_mat_Operation,this.bits >> 22 & 7));
		this.set_blendAlphaOp(Type.createEnumIndex(h3d_mat_Operation,this.bits >> 25 & 7));
		this.set_wireframe((this.bits >> 28 & 1) != 0);
		this.set_reserved((this.bits >> 29 & 1) != 0);
	}
	,__class__: h3d_mat_Pass
};
var h3d_mat_Stencil = function() {
	this.opBits = 0;
	this.maskBits = 0;
	this.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep);
	this.setFunc(h3d_mat_Compare.Always);
};
$hxClasses["h3d.mat.Stencil"] = h3d_mat_Stencil;
h3d_mat_Stencil.__name__ = "h3d.mat.Stencil";
h3d_mat_Stencil.getReadMask = function(v) {
	return v & 255;
};
h3d_mat_Stencil.getWriteMask = function(v) {
	return v >> 8 & 255;
};
h3d_mat_Stencil.getReference = function(v) {
	return v >> 16 & 255;
};
h3d_mat_Stencil.getFrontTest = function(v) {
	return v & 7;
};
h3d_mat_Stencil.getFrontPass = function(v) {
	return v >> 3 & 7;
};
h3d_mat_Stencil.getFrontSTfail = function(v) {
	return v >> 6 & 7;
};
h3d_mat_Stencil.getFrontDPfail = function(v) {
	return v >> 9 & 7;
};
h3d_mat_Stencil.getBackTest = function(v) {
	return v >> 12 & 7;
};
h3d_mat_Stencil.getBackPass = function(v) {
	return v >> 15 & 7;
};
h3d_mat_Stencil.getBackSTfail = function(v) {
	return v >> 18 & 7;
};
h3d_mat_Stencil.getBackDPfail = function(v) {
	return v >> 21 & 7;
};
h3d_mat_Stencil.prototype = {
	setFront: function(stfail,dpfail,pass) {
		this.set_frontSTfail(stfail);
		this.set_frontDPfail(dpfail);
		this.set_frontPass(pass);
	}
	,setBack: function(stfail,dpfail,pass) {
		this.set_backSTfail(stfail);
		this.set_backDPfail(dpfail);
		this.set_backPass(pass);
	}
	,setOp: function(stfail,dpfail,pass) {
		this.setFront(stfail,dpfail,pass);
		this.setBack(stfail,dpfail,pass);
	}
	,setFunc: function(f,reference,readMask,writeMask) {
		if(writeMask == null) {
			writeMask = 255;
		}
		if(readMask == null) {
			readMask = 255;
		}
		if(reference == null) {
			reference = 0;
		}
		this.set_frontTest(this.set_backTest(f));
		this.set_reference(reference);
		this.set_readMask(readMask);
		this.set_writeMask(writeMask);
	}
	,clone: function() {
		var s = new h3d_mat_Stencil();
		s.opBits = this.opBits;
		s.maskBits = this.maskBits;
		return s;
	}
	,load: function(s) {
		this.opBits = s.opBits;
		this.maskBits = s.maskBits;
	}
	,set_readMask: function(v) {
		this.maskBits = this.maskBits & -256 | v & 255;
		return this.readMask = v;
	}
	,set_writeMask: function(v) {
		this.maskBits = this.maskBits & -65281 | (v & 255) << 8;
		return this.writeMask = v;
	}
	,set_reference: function(v) {
		this.maskBits = this.maskBits & -16711681 | (v & 255) << 16;
		return this.reference = v;
	}
	,set_frontTest: function(v) {
		this.opBits = this.opBits & -8 | v._hx_index;
		return this.frontTest = v;
	}
	,set_frontPass: function(v) {
		this.opBits = this.opBits & -57 | v._hx_index << 3;
		return this.frontPass = v;
	}
	,set_frontSTfail: function(v) {
		this.opBits = this.opBits & -449 | v._hx_index << 6;
		return this.frontSTfail = v;
	}
	,set_frontDPfail: function(v) {
		this.opBits = this.opBits & -3585 | v._hx_index << 9;
		return this.frontDPfail = v;
	}
	,set_backTest: function(v) {
		this.opBits = this.opBits & -28673 | v._hx_index << 12;
		return this.backTest = v;
	}
	,set_backPass: function(v) {
		this.opBits = this.opBits & -229377 | v._hx_index << 15;
		return this.backPass = v;
	}
	,set_backSTfail: function(v) {
		this.opBits = this.opBits & -1835009 | v._hx_index << 18;
		return this.backSTfail = v;
	}
	,set_backDPfail: function(v) {
		this.opBits = this.opBits & -14680065 | v._hx_index << 21;
		return this.backDPfail = v;
	}
	,loadOpBits: function(bits) {
		this.opBits = bits;
		this.set_frontTest(Type.createEnumIndex(h3d_mat_Compare,this.opBits & 7));
		this.set_frontPass(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 3 & 7));
		this.set_frontSTfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 6 & 7));
		this.set_frontDPfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 9 & 7));
		this.set_backTest(Type.createEnumIndex(h3d_mat_Compare,this.opBits >> 12 & 7));
		this.set_backPass(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 15 & 7));
		this.set_backSTfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 18 & 7));
		this.set_backDPfail(Type.createEnumIndex(h3d_mat_StencilOp,this.opBits >> 21 & 7));
	}
	,loadMaskBits: function(bits) {
		this.maskBits = bits;
		this.set_readMask(this.maskBits & 255);
		this.set_writeMask(this.maskBits >> 8 & 255);
		this.set_reference(this.maskBits >> 16 & 255);
	}
	,__class__: h3d_mat_Stencil
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	remove: function(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var hxd_PixelFormat = $hxEnums["hxd.PixelFormat"] = { __ename__:"hxd.PixelFormat",__constructs__:null
	,ARGB: {_hx_name:"ARGB",_hx_index:0,__enum__:"hxd.PixelFormat",toString:$estr}
	,BGRA: {_hx_name:"BGRA",_hx_index:1,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA: {_hx_name:"RGBA",_hx_index:2,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16F: {_hx_name:"RGBA16F",_hx_index:3,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA32F: {_hx_name:"RGBA32F",_hx_index:4,__enum__:"hxd.PixelFormat",toString:$estr}
	,R8: {_hx_name:"R8",_hx_index:5,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16F: {_hx_name:"R16F",_hx_index:6,__enum__:"hxd.PixelFormat",toString:$estr}
	,R32F: {_hx_name:"R32F",_hx_index:7,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG8: {_hx_name:"RG8",_hx_index:8,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG16F: {_hx_name:"RG16F",_hx_index:9,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG32F: {_hx_name:"RG32F",_hx_index:10,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB8: {_hx_name:"RGB8",_hx_index:11,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16F: {_hx_name:"RGB16F",_hx_index:12,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB32F: {_hx_name:"RGB32F",_hx_index:13,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB: {_hx_name:"SRGB",_hx_index:14,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB_ALPHA: {_hx_name:"SRGB_ALPHA",_hx_index:15,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB10A2: {_hx_name:"RGB10A2",_hx_index:16,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG11B10UF: {_hx_name:"RG11B10UF",_hx_index:17,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16U: {_hx_name:"R16U",_hx_index:18,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG16U: {_hx_name:"RG16U",_hx_index:19,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16U: {_hx_name:"RGB16U",_hx_index:20,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16U: {_hx_name:"RGBA16U",_hx_index:21,__enum__:"hxd.PixelFormat",toString:$estr}
	,S3TC: ($_=function(v) { return {_hx_index:22,v:v,__enum__:"hxd.PixelFormat",toString:$estr}; },$_._hx_name="S3TC",$_.__params__ = ["v"],$_)
	,Depth16: {_hx_name:"Depth16",_hx_index:23,__enum__:"hxd.PixelFormat",toString:$estr}
	,Depth24: {_hx_name:"Depth24",_hx_index:24,__enum__:"hxd.PixelFormat",toString:$estr}
	,Depth24Stencil8: {_hx_name:"Depth24Stencil8",_hx_index:25,__enum__:"hxd.PixelFormat",toString:$estr}
};
hxd_PixelFormat.__constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RG16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U,hxd_PixelFormat.S3TC,hxd_PixelFormat.Depth16,hxd_PixelFormat.Depth24,hxd_PixelFormat.Depth24Stencil8];
hxd_PixelFormat.__empty_constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RG16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U,hxd_PixelFormat.Depth16,hxd_PixelFormat.Depth24,hxd_PixelFormat.Depth24Stencil8];
var h3d_mat_Texture = function(w,h,flags,format) {
	this.lodBias = 0.;
	this.startingMip = 0;
	if(format == null) {
		format = h3d_mat_Texture.nativeFormat;
	}
	this.id = ++h3d_mat_Texture.UID;
	this.format = format;
	this.flags = 0;
	if(flags != null) {
		var _g = 0;
		while(_g < flags.length) {
			var f = flags[_g];
			++_g;
			this.flags |= 1 << f._hx_index;
		}
	}
	if(!this.isDepth()) {
		var engine = h3d_Engine.CURRENT;
		this.mem = engine.mem;
	}
	var tw = 1;
	var th = 1;
	while(tw < w) tw <<= 1;
	while(th < h) th <<= 1;
	if(tw != w || th != h) {
		this.flags |= 1 << h3d_mat_TextureFlags.IsNPOT._hx_index;
	}
	this.width = w;
	this.height = h;
	if((this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0) {
		this.set_mipMap(h3d_mat_Texture.TRILINEAR_FILTERING_ENABLED ? h3d_mat_MipMap.Linear : h3d_mat_MipMap.Nearest);
	} else {
		this.set_mipMap(h3d_mat_MipMap.None);
	}
	this.set_filter(h3d_mat_Filter.Linear);
	this.set_wrap(h3d_mat_Texture.DEFAULT_WRAP);
	this.bits &= 32767;
	if((this.flags & 1 << h3d_mat_TextureFlags.NoAlloc._hx_index) == 0 && (!this.isDepth() || this.width > 0)) {
		this.alloc();
	}
};
$hxClasses["h3d.mat.Texture"] = h3d_mat_Texture;
h3d_mat_Texture.__name__ = "h3d.mat.Texture";
h3d_mat_Texture.fromBitmap = function(bmp) {
	var t = new h3d_mat_Texture(bmp.ctx.canvas.width,bmp.ctx.canvas.height);
	t.uploadBitmap(bmp);
	return t;
};
h3d_mat_Texture.fromPixels = function(pixels,format) {
	var t = new h3d_mat_Texture(pixels.width,pixels.height,null,format != null ? format : pixels.innerFormat);
	t.uploadPixels(pixels);
	return t;
};
h3d_mat_Texture.fromColor = function(color,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	var engine = h3d_Engine.CURRENT;
	var aval = alpha * 255 | 0;
	if(aval < 0) {
		aval = 0;
	} else if(aval > 255) {
		aval = 255;
	}
	var key = color & 16777215 | aval << 24;
	var t = engine.textureColorCache.h[key];
	if(t != null) {
		return t;
	}
	var t = new h3d_mat_Texture(1,1,null);
	t.clear(color,alpha);
	t.realloc = function() {
		t.clear(color,alpha);
	};
	engine.textureColorCache.h[key] = t;
	return t;
};
h3d_mat_Texture.genDisc = function(size,color,alpha) {
	if(alpha == null) {
		alpha = 1.;
	}
	return h3d_mat_Texture.genTexture(0,size,color,alpha);
};
h3d_mat_Texture.genTexture = function(mode,size,color,alpha) {
	var engine = h3d_Engine.CURRENT;
	var aval = alpha * 255 | 0;
	if(aval < 0) {
		aval = 0;
	} else if(aval > 255) {
		aval = 255;
	}
	color = color & 16777215 | aval << 24;
	var key = (size << 16 | mode) + "," + color;
	var k = h3d_mat_Texture.genTextureKeys.h[key];
	var t = k == null ? null : engine.resCache.h[k.__id__];
	if(t != null) {
		return t;
	}
	if(k == null) {
		k = { };
		h3d_mat_Texture.genTextureKeys.h[key] = k;
	}
	t = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target]);
	t.realloc = function() {
		h3d_mat_Texture.drawGenTexture(t,color,mode);
	};
	h3d_mat_Texture.drawGenTexture(t,color,mode);
	engine.resCache.set(k,t);
	return t;
};
h3d_mat_Texture.drawGenTexture = function(t,color,mode) {
	var s = new h3d_pass_ScreenFx(new h3d_shader_GenTexture());
	var engine = h3d_Engine.CURRENT;
	var _this = s.shader;
	_this.constModified = true;
	_this.mode__ = mode;
	var _this = s.shader.color__;
	_this.x = (color >> 16 & 255) / 255;
	_this.y = (color >> 8 & 255) / 255;
	_this.z = (color & 255) / 255;
	_this.w = (color >>> 24) / 255;
	engine.pushTarget(t);
	s.render();
	engine.popTarget();
};
h3d_mat_Texture.defaultCubeTexture = function() {
	var engine = h3d_Engine.CURRENT;
	var t = engine.resCache.h[h3d_mat_Texture.__id__];
	if(t != null) {
		return t;
	}
	t = new h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube]);
	t.clear(2105376);
	t.realloc = function() {
		t.clear(2105376);
	};
	engine.resCache.set(h3d_mat_Texture,t);
	return t;
};
h3d_mat_Texture.genChecker = function(size) {
	var engine = h3d_Engine.CURRENT;
	var k = h3d_mat_Texture.checkerTextureKeys.h[size];
	var t = k == null ? null : engine.resCache.h[k.__id__];
	if(t != null && !(t.isDepth() ? t.t == null : t.t == null && t.realloc == null)) {
		return t;
	}
	if(k == null) {
		k = { };
		h3d_mat_Texture.checkerTextureKeys.h[size] = k;
	}
	var t = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc]);
	var t1 = t;
	var size1 = size;
	t.realloc = function() {
		h3d_mat_Texture.allocChecker(t1,size1);
	};
	engine.resCache.set(k,t);
	return t;
};
h3d_mat_Texture.genNoise = function(size) {
	var engine = h3d_Engine.CURRENT;
	var k = h3d_mat_Texture.noiseTextureKeys.h[size];
	var t = k == null ? null : engine.resCache.h[k.__id__];
	if(t != null && !(t.isDepth() ? t.t == null : t.t == null && t.realloc == null)) {
		return t;
	}
	if(k == null) {
		k = { };
		h3d_mat_Texture.noiseTextureKeys.h[size] = k;
	}
	var t = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc]);
	var t1 = t;
	var size1 = size;
	t.realloc = function() {
		h3d_mat_Texture.allocNoise(t1,size1);
	};
	engine.resCache.set(k,t);
	return t;
};
h3d_mat_Texture.allocNoise = function(t,size) {
	var b = new hxd_BitmapData(size,size);
	var _g = 0;
	var _g1 = size;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = size;
		while(_g2 < _g3) {
			var y = _g2++;
			var n = Std.random(256);
			b.setPixel(x,y,-16777216 | n | n << 8 | n << 16);
		}
	}
	t.uploadBitmap(b);
	b.ctx = null;
	b.pixel = null;
};
h3d_mat_Texture.allocChecker = function(t,size) {
	var b = new hxd_BitmapData(size,size);
	b.clear(-1);
	var _g = 0;
	var _g1 = size >> 1;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = 0;
		var _g3 = size >> 1;
		while(_g2 < _g3) {
			var y = _g2++;
			b.setPixel(x,y,-16777216);
			b.setPixel(x + (size >> 1),y + (size >> 1),-16777216);
		}
	}
	t.uploadBitmap(b);
	b.ctx = null;
	b.pixel = null;
};
h3d_mat_Texture.getDefaultDepth = function() {
	return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer();
};
h3d_mat_Texture.prototype = {
	set_lastFrame: function(lf) {
		if(this._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
			this._lastFrame = lf;
		}
		return this._lastFrame;
	}
	,get_lastFrame: function() {
		return this._lastFrame;
	}
	,get_mipLevels: function() {
		if((this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) == 0) {
			return 1;
		}
		if(this.customMipLevels > 0) {
			return this.customMipLevels;
		}
		var lv = 1;
		var w = this.width;
		var h = this.height;
		while(w >> lv >= 1 || h >> lv >= 1) ++lv;
		return lv;
	}
	,get_layerCount: function() {
		if((this.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
			return 6;
		} else {
			return 1;
		}
	}
	,alloc: function() {
		if(this.isDepth()) {
			h3d_Engine.CURRENT.mem.allocDepth(this);
		} else if(this.t == null) {
			this.mem.allocTexture(this);
		}
	}
	,isSRGB: function() {
		switch(this.format._hx_index) {
		case 14:case 15:
			return true;
		default:
			return false;
		}
	}
	,checkAlloc: function() {
		if(this.t == null && this.realloc != null) {
			this.alloc();
			this.realloc();
		}
	}
	,clone: function() {
		this.checkAlloc();
		if(this.t == null) {
			throw haxe_Exception.thrown("Can't clone disposed texture");
		}
		var old = this._lastFrame;
		this.preventAutoDispose();
		var flags = [];
		var f = h3d_mat_TextureFlags.Target;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var f = h3d_mat_TextureFlags.Cube;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var f = h3d_mat_TextureFlags.MipMapped;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var f = h3d_mat_TextureFlags.IsArray;
		if((this.flags & 1 << f._hx_index) != 0) {
			flags.push(f);
		}
		var t = new h3d_mat_Texture(this.width,this.height,flags,this.format);
		t.name = this.name;
		if((this.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0) {
			h3d_pass_CubeCopy.run(this,t);
		} else {
			h3d_pass_Copy.run(this,t);
		}
		this.set_lastFrame(old);
		return t;
	}
	,preventAutoDispose: function() {
		this.set_lastFrame(h3d_mat_Texture.PREVENT_AUTO_DISPOSE);
	}
	,preventForcedDispose: function() {
		this.set_lastFrame(h3d_mat_Texture.PREVENT_FORCED_DISPOSE);
	}
	,waitLoad: function(f) {
		if((this.flags & 1 << h3d_mat_TextureFlags.Loading._hx_index) == 0) {
			f();
			return;
		}
		if(this.waitLoads == null) {
			this.waitLoads = [];
		}
		this.waitLoads.push(f);
	}
	,toString: function() {
		var str = this.name;
		if(this.name == null) {
			str = "Texture_" + this.id;
		}
		return str + "(" + this.width + "x" + this.height + ")";
	}
	,setName: function(n) {
		this.name = n;
	}
	,set_mipMap: function(m) {
		this.bits = this.bits & -4 | m._hx_index;
		return this.mipMap = m;
	}
	,set_filter: function(f) {
		this.bits = this.bits & -25 | f._hx_index << 3;
		return this.filter = f;
	}
	,set_wrap: function(w) {
		this.bits = this.bits & -193 | w._hx_index << 6;
		return this.wrap = w;
	}
	,isDisposed: function() {
		if(this.isDepth()) {
			return this.t == null;
		} else if(this.t == null) {
			return this.realloc == null;
		} else {
			return false;
		}
	}
	,resize: function(width,height) {
		this.dispose();
		var tw = 1;
		var th = 1;
		while(tw < width) tw <<= 1;
		while(th < height) th <<= 1;
		if(tw != width || th != height) {
			this.flags |= 1 << h3d_mat_TextureFlags.IsNPOT._hx_index;
		} else {
			this.flags &= -1 - (1 << h3d_mat_TextureFlags.IsNPOT._hx_index);
		}
		this.width = width;
		this.height = height;
		if((this.flags & 1 << h3d_mat_TextureFlags.NoAlloc._hx_index) == 0) {
			this.alloc();
		}
	}
	,clearF: function(r,g,b,a,layer) {
		if(layer == null) {
			layer = -1;
		}
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		this.alloc();
		if((this.flags & 1 << h3d_mat_TextureFlags.Target._hx_index) == 0) {
			throw haxe_Exception.thrown("Texture should be target");
		}
		var engine = h3d_Engine.CURRENT;
		var x = r;
		var y = g;
		var z = b;
		var w = a;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var color = new h3d_Vector4Impl(x,y,z,w);
		if(layer < 0) {
			var _g = 0;
			var _g1 = this.get_layerCount();
			while(_g < _g1) {
				var i = _g++;
				engine.pushTarget(this,i);
				engine.clearF(color);
				engine.popTarget();
			}
		} else {
			engine.pushTarget(this,layer);
			engine.clearF(color);
			engine.popTarget();
		}
	}
	,clear: function(color,alpha,layer) {
		if(layer == null) {
			layer = -1;
		}
		if(alpha == null) {
			alpha = 1.;
		}
		this.alloc();
		if(this.width == 0 || this.height == 0) {
			return;
		}
		if(this.width != 1 || this.height != 1) {
			var engine = h3d_Engine.CURRENT;
			color |= ((alpha < 0. ? 0. : alpha > 1. ? 1. : alpha) * 255 | 0) << 24;
			if(layer < 0) {
				var _g = 0;
				var _g1 = this.get_layerCount();
				while(_g < _g1) {
					var i = _g++;
					engine.pushTarget(this,i);
					engine.clear(color);
					engine.popTarget();
				}
			} else {
				engine.pushTarget(this,layer);
				engine.clear(color);
				engine.popTarget();
			}
		} else {
			var p = hxd_Pixels.alloc(this.width,this.height,h3d_mat_Texture.nativeFormat);
			var k = 0;
			var b = color & 255;
			var g = color >> 8 & 255;
			var r = color >> 16 & 255;
			var a = alpha * 255 | 0;
			if(a < 0) {
				a = 0;
			} else if(a > 255) {
				a = 255;
			}
			switch(h3d_mat_Texture.nativeFormat._hx_index) {
			case 1:
				var tmp = r;
				r = b;
				b = tmp;
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("TODO");
			}
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				p.bytes.b[k++] = r;
				p.bytes.b[k++] = g;
				p.bytes.b[k++] = b;
				p.bytes.b[k++] = a;
			}
			if(layer < 0) {
				var _g = 0;
				var _g1 = this.get_layerCount();
				while(_g < _g1) {
					var i = _g++;
					this.uploadPixels(p,0,i);
				}
			} else {
				this.uploadPixels(p,0,layer);
			}
			p.dispose();
		}
	}
	,checkSize: function(width,height,mip) {
		var mw = this.width >> mip;
		if(mw == 0) {
			mw = 1;
		}
		var mh = this.height >> mip;
		if(mh == 0) {
			mh = 1;
		}
		if(width != mw || height != mh) {
			throw haxe_Exception.thrown("Invalid upload size : " + width + "x" + height + " should be " + mw + "x" + mh);
		}
	}
	,checkMipMapGen: function(mipLevel,layer) {
		if(mipLevel == 0 && (this.flags & 1 << h3d_mat_TextureFlags.MipMapped._hx_index) != 0 && (this.flags & 1 << h3d_mat_TextureFlags.ManualMipMapGen._hx_index) == 0 && layer == this.get_layerCount() - 1) {
			this.mem.driver.generateMipMaps(this);
		}
	}
	,uploadBitmap: function(bmp,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(bmp.ctx.canvas.width,bmp.ctx.canvas.height,mipLevel);
		this.mem.driver.uploadTextureBitmap(this,bmp,mipLevel,layer);
		this.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.checkMipMapGen(mipLevel,layer);
	}
	,uploadPixels: function(pixels,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(pixels.width,pixels.height,mipLevel);
		this.mem.driver.uploadTexturePixels(this,pixels,mipLevel,layer);
		this.flags |= 1 << h3d_mat_TextureFlags.WasCleared._hx_index;
		this.checkMipMapGen(mipLevel,layer);
	}
	,dispose: function() {
		if(this.t != null) {
			if(this.isDepth()) {
				h3d_Engine.CURRENT.mem.deleteDepth(this);
			} else {
				this.mem.deleteTexture(this);
			}
		}
	}
	,capturePixels: function(face,mipLevel,region) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(face == null) {
			face = 0;
		}
		var old = this._lastFrame;
		this.preventAutoDispose();
		var pix = this.mem.driver.capturePixels(this,face,mipLevel,region);
		this.set_lastFrame(old);
		return pix;
	}
	,hasStencil: function() {
		if(this.format._hx_index == 25) {
			return true;
		} else {
			return false;
		}
	}
	,isDepth: function() {
		switch(this.format._hx_index) {
		case 23:case 24:case 25:
			return true;
		default:
			return false;
		}
	}
	,__class__: h3d_mat_Texture
};
var h3d_mat_TextureArray = function(w,h,layers,flags,format) {
	this.layers = layers;
	if(flags == null) {
		flags = [];
	}
	flags.push(h3d_mat_TextureFlags.IsArray);
	h3d_mat_Texture.call(this,w,h,flags,format);
};
$hxClasses["h3d.mat.TextureArray"] = h3d_mat_TextureArray;
h3d_mat_TextureArray.__name__ = "h3d.mat.TextureArray";
h3d_mat_TextureArray.__super__ = h3d_mat_Texture;
h3d_mat_TextureArray.prototype = $extend(h3d_mat_Texture.prototype,{
	get_layerCount: function() {
		return this.layers;
	}
	,clone: function() {
		var old = this._lastFrame;
		this.preventAutoDispose();
		var t = new h3d_mat_TextureArray(this.width,this.height,this.layers,null,this.format);
		h3d_pass_Copy.run(this,t);
		this.set_lastFrame(old);
		return t;
	}
	,toString: function() {
		return h3d_mat_Texture.prototype.toString.call(this) + "[" + this.layers + "]";
	}
	,__class__: h3d_mat_TextureArray
});
var h3d_pass_ScreenFx = function(shader,output) {
	this.shader = shader;
	this.output = new h3d_pass_OutputShader(output);
	this.pass = new h3d_mat_Pass("screenfx",new hxsl_ShaderList(shader));
	this.pass.set_culling(h3d_mat_Face.None);
	this.pass.depth(false,h3d_mat_Compare.Always);
};
$hxClasses["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx;
h3d_pass_ScreenFx.__name__ = "h3d.pass.ScreenFx";
h3d_pass_ScreenFx.run = function(shader,output,layer) {
	var engine = h3d_Engine.CURRENT;
	engine.pushTarget(output,layer);
	new h3d_pass_ScreenFx(shader).render();
	engine.popTarget();
};
h3d_pass_ScreenFx.prototype = {
	get_engine: function() {
		if(this._engine == null) {
			this._engine = h3d_Engine.CURRENT;
		}
		return this._engine;
	}
	,copy: function(src,dst) {
		h3d_pass_Copy.run(src,dst);
	}
	,addShader: function(s) {
		return this.pass.addShader(s);
	}
	,removeShader: function(s) {
		return this.pass.removeShader(s);
	}
	,getShader: function(cl) {
		return this.pass.getShader(cl);
	}
	,render: function() {
		if(this.primitive == null) {
			this.primitive = h3d_prim_Plane2D.get();
		}
		this.shader.flipY__ = this.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.get_engine().getCurrentTarget() != null ? -1 : 1;
		var shaders = this.pass.shaders;
		var ctx = h3d_impl_RenderContext.get();
		var isNewCtx = false;
		if(ctx == null) {
			isNewCtx = true;
			ctx = new h3d_impl_RenderContext();
			ctx.setCurrent();
		}
		var rts = this.output.compileShaders(ctx.globals,shaders);
		this.get_engine().selectMaterial(this.pass);
		this.get_engine().selectShader(rts);
		if(this.buffers == null) {
			this.buffers = new h3d_shader_Buffers(rts);
		} else {
			var _this = this.buffers;
			_this.vertex.grow(rts.vertex);
			_this.fragment.grow(rts.fragment);
		}
		ctx.fillGlobals(this.buffers,rts);
		ctx.fillParams(this.buffers,rts,shaders);
		this.get_engine().uploadShaderBuffers(this.buffers,0);
		this.get_engine().uploadShaderBuffers(this.buffers,1);
		this.get_engine().uploadShaderBuffers(this.buffers,2);
		this.get_engine().uploadShaderBuffers(this.buffers,3);
		this.primitive.render(this.get_engine());
		if(isNewCtx) {
			ctx.clearCurrent();
		}
	}
	,dispose: function() {
	}
	,__class__: h3d_pass_ScreenFx
};
var h3d_pass_Blur = function(radius,gain,linear,quality) {
	if(quality == null) {
		quality = 1.;
	}
	if(linear == null) {
		linear = 0.;
	}
	if(gain == null) {
		gain = 1.;
	}
	if(radius == null) {
		radius = 1.;
	}
	this.cubeDir = [h3d_Matrix.L([0,0,-1,0,0,-1,0,0,1,0,0,0]),h3d_Matrix.L([0,0,1,0,0,-1,0,0,-1,0,0,0]),h3d_Matrix.L([1,0,0,0,0,0,1,0,0,1,0,0]),h3d_Matrix.L([1,0,0,0,0,0,-1,0,0,-1,0,0]),h3d_Matrix.L([1,0,0,0,0,-1,0,0,0,0,1,0]),h3d_Matrix.L([-1,0,0,0,0,-1,0,0,0,0,-1,0])];
	h3d_pass_ScreenFx.call(this,new h3d_shader_Blur());
	this.set_radius(radius);
	this.set_quality(quality);
	this.set_gain(gain);
	this.set_linear(linear);
};
$hxClasses["h3d.pass.Blur"] = h3d_pass_Blur;
h3d_pass_Blur.__name__ = "h3d.pass.Blur";
h3d_pass_Blur.__super__ = h3d_pass_ScreenFx;
h3d_pass_Blur.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	set_radius: function(r) {
		if(this.radius == r) {
			return r;
		}
		this.values = null;
		return this.radius = r;
	}
	,set_quality: function(q) {
		if(this.quality == q) {
			return q;
		}
		this.values = null;
		return this.quality = q;
	}
	,set_gain: function(s) {
		if(this.gain == s) {
			return s;
		}
		this.values = null;
		return this.gain = s;
	}
	,set_linear: function(b) {
		if(this.linear == b) {
			return b;
		}
		this.values = null;
		return this.linear = b;
	}
	,gauss: function(x,s) {
		if(s <= 0) {
			if(x == 0) {
				return 1;
			} else {
				return 0;
			}
		}
		var sq = s * s;
		var p = Math.pow(2.718281828459,-(x * x) / (2 * sq));
		return p / Math.sqrt(2 * Math.PI * sq);
	}
	,calcValues: function() {
		this.values = [];
		this.offsets = [];
		var tot = 0.;
		var f = this.quality;
		var qadj = (f < 0. ? 0. : f > 1. ? 1. : f) * 0.7 + 0.3;
		var width;
		if(this.radius > 0) {
			var a = this.radius - 1;
			width = Math.ceil((a < 1 ? 1 : a) * qadj / 2);
		} else {
			width = 0;
		}
		var sigma = Math.sqrt(this.radius);
		var _g = 0;
		var _g1 = width + 1;
		while(_g < _g1) {
			var i = _g++;
			var i1 = i * 2;
			var i2 = i == 0 ? 0 : i * 2 - 1;
			var g1 = this.gauss(i1,sigma);
			var g2 = this.gauss(i2,sigma);
			var g = g1 + g2;
			this.values[i] = g;
			this.offsets[i] = i == 0 ? 0 : (g1 * i1 + g2 * i2) / (g * i * Math.sqrt(qadj));
			tot += g;
			if(i > 0) {
				tot += g;
			}
		}
		var minVal = this.values[0] * (0.01 / qadj);
		while(this.values.length > 2) {
			var last = this.values[this.values.length - 1];
			if(last > minVal) {
				break;
			}
			tot -= last * 2;
			this.values.pop();
		}
		tot /= this.gain;
		var _g = 0;
		var _g1 = this.values.length;
		while(_g < _g1) {
			var i = _g++;
			this.values[i] /= tot;
		}
		if(this.linear > 0) {
			var m = this.gain / (this.values.length * 2 - 1);
			var _g = 0;
			var _g1 = this.values.length;
			while(_g < _g1) {
				var i = _g++;
				var a = this.values[i];
				this.values[i] = a + this.linear * (m - a);
				var a1 = this.offsets[i];
				this.offsets[i] = a1 + this.linear * ((i == 0 ? 0 : (i * 2 - 0.5) / (i * qadj)) - a1);
			}
		}
	}
	,getKernelSize: function() {
		if(this.values == null) {
			this.calcValues();
		}
		if(this.radius <= 0) {
			return 0;
		} else {
			return this.values.length * 2 - 1;
		}
	}
	,apply: function(ctx,src,output) {
		if(this.radius <= 0 && this.shader.fixedColor__ == null) {
			if(output != null) {
				h3d_pass_Copy.run(src,output);
			}
			return;
		}
		if(output == null) {
			output = src;
		}
		if(this.values == null) {
			this.calcValues();
		}
		var isCube = (src.flags & 1 << h3d_mat_TextureFlags.Cube._hx_index) != 0;
		var faceCount = isCube ? 6 : 1;
		var tmp = ctx.textures.allocTarget(src.name + "BlurTmp",src.width,src.height,false,src.format,isCube ? [h3d_mat_TextureFlags.Cube] : null);
		var _this = this.shader;
		_this.constModified = true;
		_this.Quality__ = this.values.length;
		this.shader.values__ = this.values;
		this.shader.offsets__ = this.offsets;
		if(isCube) {
			this.shader.cubeTexture__ = src;
			var _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = true;
		} else {
			this.shader.texture__ = src;
			var _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = false;
		}
		var _this = this.shader.pixel__;
		var x = 1 / src.width;
		var y = 0;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var _g = 0;
		var _g1 = faceCount;
		while(_g < _g1) {
			var i = _g++;
			this.get_engine().pushTarget(tmp,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		if(isCube) {
			this.shader.cubeTexture__ = tmp;
		} else {
			this.shader.texture__ = tmp;
		}
		var _this = this.shader.pixel__;
		var x = 0;
		var y = 1 / src.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		var outDepth = output.depthBuffer;
		output.depthBuffer = null;
		var _g = 0;
		var _g1 = faceCount;
		while(_g < _g1) {
			var i = _g++;
			this.get_engine().pushTarget(output,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		output.depthBuffer = outDepth;
	}
	,__class__: h3d_pass_Blur
});
var h3d_pass__$Border_BorderShader = function() {
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Border.BorderShader"] = h3d_pass__$Border_BorderShader;
h3d_pass__$Border_BorderShader.__name__ = "h3d.pass._Border.BorderShader";
h3d_pass__$Border_BorderShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Border_BorderShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.color__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$Border_BorderShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.color__ = this.color__;
		return s;
	}
	,__class__: h3d_pass__$Border_BorderShader
});
var h3d_pass_Border = function(width,height,size) {
	if(size == null) {
		size = 1;
	}
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Border_BorderShader());
	var bbuf = hxd__$FloatBuffer_Float32Expand._new(0);
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - size / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - size / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = size / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = size / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - (height - size) / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - (height - size) / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = (width - size) / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = (width - size) / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = width / width * 2 - 1;
	if(bbuf.pos == bbuf.array.length) {
		var newSize = bbuf.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(bbuf.array);
		bbuf.array = newArray;
	}
	bbuf.array[bbuf.pos++] = 1 - height / height * 2;
	this.primitive = new h3d_prim_RawPrimitive({ vbuf : bbuf, format : hxd_BufferFormat.make([new hxd_BufferInput("position",2,0)])},true);
	var _this = this.shader.color__;
	var x = 1;
	var y = 1;
	var z = 1;
	var w = 1;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = w;
};
$hxClasses["h3d.pass.Border"] = h3d_pass_Border;
h3d_pass_Border.__name__ = "h3d.pass.Border";
h3d_pass_Border.__super__ = h3d_pass_ScreenFx;
h3d_pass_Border.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	dispose: function() {
		h3d_pass_ScreenFx.prototype.dispose.call(this);
		this.primitive.dispose();
	}
	,__class__: h3d_pass_Border
});
var h3d_pass__$Copy_ArrayCopyShader = function() {
	this.layer__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__$Copy_ArrayCopyShader;
h3d_pass__$Copy_ArrayCopyShader.__name__ = "h3d.pass._Copy.ArrayCopyShader";
h3d_pass__$Copy_ArrayCopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Copy_ArrayCopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_layer: function() {
		return this.layer__;
	}
	,set_layer: function(_v) {
		return this.layer__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.layer__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$Copy_ArrayCopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.layer__ = this.layer__;
		return s;
	}
	,__class__: h3d_pass__$Copy_ArrayCopyShader
});
var h3d_pass_ArrayCopy = function() {
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Copy_ArrayCopyShader());
};
$hxClasses["h3d.pass.ArrayCopy"] = h3d_pass_ArrayCopy;
h3d_pass_ArrayCopy.__name__ = "h3d.pass.ArrayCopy";
h3d_pass_ArrayCopy.run = function(from,fromLayer,to,blend,pass,layer) {
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && pass == null && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_ArrayCopy.__id__];
	if(inst == null) {
		inst = new h3d_pass_ArrayCopy();
		engine.resCache.set(h3d_pass_ArrayCopy,inst);
	}
	inst.apply(from,fromLayer,to,blend,pass,layer);
};
h3d_pass_ArrayCopy.__super__ = h3d_pass_ScreenFx;
h3d_pass_ArrayCopy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,fromLayer,to,blend,customPass,layer) {
		if(to != null) {
			this.get_engine().pushTarget(to,layer != null ? layer : 0);
		}
		this.shader.texture__ = from;
		this.shader.layer__ = fromLayer;
		if(customPass != null) {
			if(blend != null) {
				customPass.setBlendMode(blend);
			}
			var h = customPass.shaders;
			while(h.next != null) h = h.next;
			h.next = this.pass.shaders;
			var old = this.pass;
			this.pass = customPass;
			this.render();
			this.pass = old;
			h.next = null;
		} else {
			this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
			this.render();
		}
		this.shader.texture__ = null;
		this.shader.layer__ = 0;
		if(to != null) {
			this.get_engine().popTarget();
		}
	}
	,__class__: h3d_pass_ArrayCopy
});
var h3d_pass__$Copy_CopyShader = function() {
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._Copy.CopyShader"] = h3d_pass__$Copy_CopyShader;
h3d_pass__$Copy_CopyShader.__name__ = "h3d.pass._Copy.CopyShader";
h3d_pass__$Copy_CopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$Copy_CopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$Copy_CopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_pass__$Copy_CopyShader
});
var h3d_pass_Copy = function() {
	h3d_pass_ScreenFx.call(this,new h3d_pass__$Copy_CopyShader());
};
$hxClasses["h3d.pass.Copy"] = h3d_pass_Copy;
h3d_pass_Copy.__name__ = "h3d.pass.Copy";
h3d_pass_Copy.run = function(from,to,blend,pass,layer) {
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && pass == null && layer == null && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_Copy.__id__];
	if(inst == null) {
		inst = new h3d_pass_Copy();
		engine.resCache.set(h3d_pass_Copy,inst);
	}
	inst.apply(from,to,blend,pass,layer);
};
h3d_pass_Copy.__super__ = h3d_pass_ScreenFx;
h3d_pass_Copy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,to,blend,customPass,layer) {
		if(to != null) {
			this.get_engine().pushTarget(to,layer != null ? layer : 0);
		}
		this.shader.texture__ = from;
		if(customPass != null) {
			if(blend != null) {
				customPass.setBlendMode(blend);
			}
			var h = customPass.shaders;
			while(h.next != null) h = h.next;
			h.next = this.pass.shaders;
			var old = this.pass;
			this.pass = customPass;
			this.render();
			this.pass = old;
			h.next = null;
		} else {
			this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
			this.render();
		}
		this.shader.texture__ = null;
		if(to != null) {
			this.get_engine().popTarget();
		}
	}
	,__class__: h3d_pass_Copy
});
var h3d_pass__$CubeCopy_CubeCopyShader = function() {
	this.mat__ = new h3d_MatrixImpl();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__$CubeCopy_CubeCopyShader;
h3d_pass__$CubeCopy_CubeCopyShader.__name__ = "h3d.pass._CubeCopy.CubeCopyShader";
h3d_pass__$CubeCopy_CubeCopyShader.__super__ = h3d_shader_ScreenShader;
h3d_pass__$CubeCopy_CubeCopyShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_mat: function() {
		return this.mat__;
	}
	,set_mat: function(_v) {
		return this.mat__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.mat__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_pass__$CubeCopy_CubeCopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.mat__ = this.mat__;
		return s;
	}
	,__class__: h3d_pass__$CubeCopy_CubeCopyShader
});
var h3d_pass_CubeCopy = function() {
	this.cubeDir = [h3d_Matrix.L([0,0,-1,0,0,-1,0,0,1,0,0,0]),h3d_Matrix.L([0,0,1,0,0,-1,0,0,-1,0,0,0]),h3d_Matrix.L([1,0,0,0,0,0,1,0,0,1,0,0]),h3d_Matrix.L([1,0,0,0,0,0,-1,0,0,-1,0,0]),h3d_Matrix.L([1,0,0,0,0,-1,0,0,0,0,1,0]),h3d_Matrix.L([-1,0,0,0,0,-1,0,0,0,0,-1,0])];
	h3d_pass_ScreenFx.call(this,new h3d_pass__$CubeCopy_CubeCopyShader());
};
$hxClasses["h3d.pass.CubeCopy"] = h3d_pass_CubeCopy;
h3d_pass_CubeCopy.__name__ = "h3d.pass.CubeCopy";
h3d_pass_CubeCopy.run = function(from,to,blend,mip) {
	if(mip == null) {
		mip = 0;
	}
	var engine = h3d_Engine.CURRENT;
	if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && mip == 0 && engine.driver.copyTexture(from,to)) {
		return;
	}
	var inst = engine.resCache.h[h3d_pass_CubeCopy.__id__];
	if(inst == null) {
		inst = new h3d_pass_CubeCopy();
		engine.resCache.set(h3d_pass_CubeCopy,inst);
	}
	inst.apply(from,to,blend,mip);
};
h3d_pass_CubeCopy.__super__ = h3d_pass_ScreenFx;
h3d_pass_CubeCopy.prototype = $extend(h3d_pass_ScreenFx.prototype,{
	apply: function(from,to,blend,mip) {
		if(mip == null) {
			mip = 0;
		}
		this.shader.texture__ = from;
		if(to != null) {
			this.get_engine().pushTarget(to,0,mip);
		}
		this.shader.mat__ = this.cubeDir[0];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,1,mip);
		}
		this.shader.mat__ = this.cubeDir[1];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,2,mip);
		}
		this.shader.mat__ = this.cubeDir[2];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,3,mip);
		}
		this.shader.mat__ = this.cubeDir[3];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,4,mip);
		}
		this.shader.mat__ = this.cubeDir[4];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		if(to != null) {
			this.get_engine().pushTarget(to,5,mip);
		}
		this.shader.mat__ = this.cubeDir[5];
		this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
		this.render();
		if(to != null) {
			this.get_engine().popTarget();
		}
		this.shader.texture__ = null;
	}
	,__class__: h3d_pass_CubeCopy
});
var h3d_pass_Output = function(name,output) {
	this.defaultSort = ($_=new h3d_pass_SortByMaterial(),$bind($_,$_.sort));
	this.name = name;
	this.output = new h3d_pass_OutputShader(output);
};
$hxClasses["h3d.pass.Output"] = h3d_pass_Output;
h3d_pass_Output.__name__ = "h3d.pass.Output";
h3d_pass_Output.prototype = {
	get_globals: function() {
		return this.ctx.globals;
	}
	,setContext: function(ctx) {
		this.ctx = ctx;
	}
	,dispose: function() {
	}
	,processShaders: function(p,shaders) {
		var p = this.ctx.extraShaders;
		while(p != null) {
			shaders = this.ctx.allocShaderList(p.s,shaders);
			p = p.next;
		}
		return shaders;
	}
	,setupShaders: function(passes) {
		var lightInit = false;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var shaders = p.pass.getShadersRec();
			shaders = this.processShaders(p,shaders);
			if(p.pass.enableLights && this.ctx.lightSystem != null) {
				if(!lightInit) {
					this.ctx.lightSystem.initGlobals(this.ctx.globals);
					lightInit = true;
				}
				shaders = this.ctx.lightSystem.computeLight(p.obj,shaders);
			}
			p.shader = this.output.compileShaders(this.ctx.globals,shaders,p.pass.batchMode ? hxsl_LinkMode.Batch : hxsl_LinkMode.Default);
			p.shaders = shaders;
			var t = p.shader.fragment.textures;
			var tmp1;
			if(t != null) {
				var _g = t.type;
				if(_g._hx_index == 15) {
					var _g1 = _g.t;
					var _g2 = _g.size;
					tmp1 = true;
				} else {
					tmp1 = false;
				}
			} else {
				tmp1 = true;
			}
			if(tmp1) {
				p.texture = 0;
			} else {
				var _this = this.ctx;
				var opt = true;
				if(opt == null) {
					opt = false;
				}
				var t1;
				if(t.perObjectGlobal != null) {
					var v = _this.globals.map.h[t.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + t.perObjectGlobal.path + " for shader " + _this.shaderInfo(shaders,t.perObjectGlobal.path));
					}
					var _g3 = t.type;
					var t2;
					if(_g3._hx_index == 17) {
						var _g4 = _g3.size;
						t2 = true;
					} else {
						t2 = false;
					}
					t1 = t2 ? v.texture : v;
				} else {
					var si = shaders;
					var n = t.instance;
					while(--n > 0) si = si.next;
					var v1 = si.s.getParamValue(t.index);
					if(v1 == null && !opt) {
						throw haxe_Exception.thrown("Missing param value " + Std.string(si.s) + "." + t.name);
					}
					t1 = v1;
				}
				p.texture = t1 == null ? 0 : t1.id;
			}
		}
	}
	,log: function(str) {
	}
	,drawObject: function(p) {
		this.ctx.drawPass = p;
		this.ctx.engine.selectMaterial(p.pass);
		p.obj.draw(this.ctx);
	}
	,draw: function(passes,sort) {
		if(passes.current == null) {
			return;
		}
		this.ctx.setupTarget();
		this.setupShaders(passes);
		if(sort == null) {
			this.defaultSort(passes);
		} else {
			sort(passes);
		}
		var buf = this.ctx.shaderBuffers;
		var prevShader = null;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var _this = this.ctx;
			var v = p.obj.absPos;
			_this.globals.map.h[_this.globalModelView_id] = v;
			if(p.shader.globals.h.hasOwnProperty(this.ctx.globalModelViewInverse_id)) {
				var _this1 = this.ctx;
				var v1 = p.obj.getInvPos();
				_this1.globals.map.h[_this1.globalModelViewInverse_id] = v1;
			}
			if(prevShader != p.shader) {
				prevShader = p.shader;
				if(h3d_pass_Output.onShaderError != null) {
					try {
						this.ctx.engine.selectShader(p.shader);
					} catch( _g ) {
						var e = haxe_Exception.caught(_g).unwrap();
						h3d_pass_Output.onShaderError(e,p);
						continue;
					}
				} else {
					this.ctx.engine.selectShader(p.shader);
				}
				if(buf == null) {
					buf = this.ctx.shaderBuffers = new h3d_shader_Buffers(p.shader);
				} else {
					var s = p.shader;
					buf.vertex.grow(s.vertex);
					buf.fragment.grow(s.fragment);
				}
				this.ctx.fillGlobals(buf,p.shader);
				this.ctx.engine.uploadShaderBuffers(buf,0);
			}
			if(!p.pass.dynamicParameters) {
				this.ctx.fillParams(buf,p.shader,p.shaders);
				this.ctx.engine.uploadShaderBuffers(buf,1);
				this.ctx.engine.uploadShaderBuffers(buf,2);
				this.ctx.engine.uploadShaderBuffers(buf,3);
			}
			this.drawObject(p);
		}
		var _this = this.ctx;
		_this.cachedPos = 0;
		_this.drawPass = null;
	}
	,__class__: h3d_pass_Output
};
var h3d_pass_Shadows = function(light) {
	this.pcfScale = 1.0;
	this.pcfQuality = 1;
	this.bias = 0.01;
	this.power = 30.0;
	this.samplingKind = h3d_pass_ShadowSamplingKind.None;
	this.size = 1024;
	this.mode = h3d_pass_RenderMode.None;
	this.enabled = true;
	if(this.format == null) {
		this.format = hxd_PixelFormat.R16F;
	}
	if(!h3d_Engine.CURRENT.driver.isSupportedFormat(this.format)) {
		this.format = h3d_mat_Texture.nativeFormat;
	}
	h3d_pass_Output.call(this,"shadow",this.getOutputs());
	this.light = light;
	this.blur = new h3d_pass_Blur(5);
	this.blur.set_quality(0.5);
	var _this = this.blur.shader;
	_this.constModified = true;
	_this.isDepth__ = this.format == h3d_mat_Texture.nativeFormat;
};
$hxClasses["h3d.pass.Shadows"] = h3d_pass_Shadows;
h3d_pass_Shadows.__name__ = "h3d.pass.Shadows";
h3d_pass_Shadows.__super__ = h3d_pass_Output;
h3d_pass_Shadows.prototype = $extend(h3d_pass_Output.prototype,{
	set_mode: function(m) {
		if(m != h3d_pass_RenderMode.None) {
			throw haxe_Exception.thrown("Shadow mode " + Std.string(m) + " not supported for " + Std.string(this.light));
		}
		return this.mode = m;
	}
	,set_enabled: function(b) {
		return this.enabled = b;
	}
	,set_size: function(s) {
		if(s != this.size && this.staticTexture != null) {
			this.staticTexture.dispose();
			this.staticTexture = null;
		}
		return this.size = s;
	}
	,dispose: function() {
		h3d_pass_Output.prototype.dispose.call(this);
		this.blur.dispose();
		if(this.staticTexture != null) {
			this.staticTexture.dispose();
		}
	}
	,getShadowProj: function() {
		return this.lightCamera.m;
	}
	,getShadowTex: function() {
		return null;
	}
	,isUsingWorldDist: function() {
		return false;
	}
	,getOutputs: function() {
		if(this.isUsingWorldDist()) {
			return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
		}
		if(this.format == h3d_mat_Texture.nativeFormat) {
			return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))];
		}
		return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
	}
	,loadStaticData: function(bytes) {
		return false;
	}
	,saveStaticData: function() {
		return null;
	}
	,computeStatic: function(passes) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,createDefaultShadowMap: function() {
		var tex = h3d_mat_Texture.fromColor(16777215);
		tex.name = "defaultShadowMap";
		return tex;
	}
	,syncShader: function(texture) {
	}
	,filterPasses: function(passes) {
		if(!this.ctx.computingStatic) {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				var tmp;
				if(this.staticTexture != null) {
					var _this = this.staticTexture;
					tmp = _this.isDepth() ? _this.t == null : _this.t == null && _this.realloc == null;
				} else {
					tmp = true;
				}
				if(tmp) {
					this.staticTexture = this.createDefaultShadowMap();
				}
				this.syncShader(this.staticTexture);
				return false;
			case 2:
				return true;
			case 3:
				var tmp;
				if(this.staticTexture != null) {
					var _this = this.staticTexture;
					tmp = _this.isDepth() ? _this.t == null : _this.t == null && _this.realloc == null;
				} else {
					tmp = true;
				}
				if(tmp) {
					this.staticTexture = this.createDefaultShadowMap();
				}
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == false) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		} else {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == true) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			case 2:
				return false;
			case 3:
				var head = null;
				var prev = null;
				var disc = passes.discarded;
				var discQueue = passes.lastDisc;
				var cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == true) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		}
	}
	,cullPasses: function(passes,f) {
		var prevCollider = null;
		var prevResult = true;
		var head = null;
		var prev = null;
		var disc = passes.discarded;
		var discQueue = passes.lastDisc;
		var cur = passes.current;
		while(cur != null) {
			var col = cur.obj.cullingCollider;
			var tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider) {
					prevCollider = col;
					prevResult = f(col);
				}
				tmp = prevResult;
			}
			if(tmp) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		passes.current = head;
		passes.discarded = disc;
		passes.lastDisc = discQueue;
	}
	,__class__: h3d_pass_Shadows
});
var h3d_pass_DirShadowMap = function(light) {
	this.minDist = -1.0;
	this.maxDist = -1.0;
	this.autoZPlanes = false;
	this.autoShrink = true;
	this.mergePass = new h3d_pass_ScreenFx(new h3d_shader_MinMaxShader());
	h3d_pass_Shadows.call(this,light);
	this.lightCamera = new h3d_Camera();
	this.lightCamera.orthoBounds = new h3d_col_Bounds();
	this.shader = this.dshader = new h3d_shader_DirShadow();
	this.border = new h3d_pass_Border(this.size,this.size);
};
$hxClasses["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap;
h3d_pass_DirShadowMap.__name__ = "h3d.pass.DirShadowMap";
h3d_pass_DirShadowMap.__super__ = h3d_pass_Shadows;
h3d_pass_DirShadowMap.prototype = $extend(h3d_pass_Shadows.prototype,{
	set_mode: function(m) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.enable__ = m != h3d_pass_RenderMode.None;
		return this.mode = m;
	}
	,set_enabled: function(b) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.enable__ = b && this.mode != h3d_pass_RenderMode.None;
		return this.enabled = b;
	}
	,set_size: function(s) {
		if(this.border != null && this.size != s) {
			this.border.dispose();
			this.border = new h3d_pass_Border(s,s);
		}
		return h3d_pass_Shadows.prototype.set_size.call(this,s);
	}
	,dispose: function() {
		h3d_pass_Shadows.prototype.dispose.call(this);
		if(this.depth != null) {
			this.depth.dispose();
		}
		if(this.border != null) {
			this.border.dispose();
		}
	}
	,getShadowTex: function() {
		return this.dshader.shadowMap__;
	}
	,calcShadowBounds: function(camera) {
		var _gthis = this;
		var bounds = camera.orthoBounds;
		var zMax = -1e9;
		var zMin = 1e9;
		if(this.autoShrink) {
			var mtmp = new h3d_MatrixImpl();
			var identity = h3d_Matrix.I();
			var btmp = this.autoZPlanes ? new h3d_col_Bounds() : null;
			var obj = this.boundingObject != null ? this.boundingObject : this.ctx.scene;
			obj.iterVisibleMeshes(function(m) {
				if(m.primitive == null || !m.material.castShadows) {
					return;
				}
				var b = m.primitive.getBounds();
				if(b.xMin > b.xMax) {
					return;
				}
				var absPos = ((m.primitive) instanceof h3d_prim_Instanced) ? identity : m.getAbsPos();
				if(_gthis.autoZPlanes) {
					btmp.load(b);
					btmp.transform(absPos);
					if(btmp.zMax > zMax) {
						zMax = btmp.zMax;
					}
					if(btmp.zMin < zMin) {
						zMin = btmp.zMin;
					}
				}
				mtmp.multiply3x4(absPos,camera.mcam);
				var x = b.xMin;
				var y = b.yMin;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMin;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMax;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMin;
				var y = b.yMax;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMin;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMin;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMax;
				var z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				var x = b.xMax;
				var y = b.yMax;
				var z = b.zMax;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p_x = x1;
				var p_y = y1;
				var p_z = z1;
				var px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				var py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				var pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
			});
		} else if(this.mode == h3d_pass_RenderMode.Dynamic) {
			bounds.xMin = -1e20;
			bounds.xMax = 1e20;
			bounds.yMin = -1e20;
			bounds.yMax = 1e20;
			bounds.zMin = -1e20;
			bounds.zMax = 1e20;
		}
		if(this.mode == h3d_pass_RenderMode.Dynamic) {
			var cameraBounds = new h3d_col_Bounds();
			var minDist = this.minDist < 0 ? this.ctx.camera.zNear : this.minDist;
			var maxDist = this.maxDist < 0 ? this.ctx.camera.zFar : this.maxDist;
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = minDist;
			var this1 = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMax;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = 1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			var dist = maxDist;
			var this1 = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist));
			var x = this1.x;
			var y = this1.y;
			var z = this1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				var this1 = _gthis.ctx.camera.pos;
				var x = this1.x;
				var y = this1.y;
				var z = this1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var p1_x = x1;
				var p1_y = y1;
				var p1_z = z1;
				var r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = _this_x - p1_x;
				r.ly = _this_y - p1_y;
				r.lz = _this_z - p1_z;
				r.normalize();
				var r1 = r;
				var v = zMin;
				if(v == null) {
					v = 0.0;
				}
				var p_nx = 0;
				var p_ny = 0;
				var p_nz = 1;
				var p_d = v;
				var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
				var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
				var d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				var k = -1;
				if(d2 > 0 && d2 * k > dist * k) {
					var x = r1.px + d2 * r1.lx;
					var y = r1.py + d2 * r1.ly;
					var z = r1.pz + d2 * r1.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					_this_x = v_x;
					_this_y = v_y;
					_this_z = v_z;
				}
			}
			var m = camera.mcam;
			var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31 + m._41;
			var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32 + m._42;
			var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33 + m._43;
			_this_x = px;
			_this_y = py;
			_this_z = pz;
			var x = _this_x;
			var y = _this_y;
			var z = _this_z;
			if(x < cameraBounds.xMin) {
				cameraBounds.xMin = x;
			}
			if(x > cameraBounds.xMax) {
				cameraBounds.xMax = x;
			}
			if(y < cameraBounds.yMin) {
				cameraBounds.yMin = y;
			}
			if(y > cameraBounds.yMax) {
				cameraBounds.yMax = y;
			}
			if(z < cameraBounds.zMin) {
				cameraBounds.zMin = z;
			}
			if(z > cameraBounds.zMax) {
				cameraBounds.zMax = z;
			}
			if(this.autoShrink) {
				cameraBounds.zMin = bounds.zMin;
				bounds.intersection(bounds,cameraBounds);
				if(this.autoZPlanes) {
					var this1 = camera.target;
					var v = camera.pos;
					var x = this1.x - v.x;
					var y = this1.y - v.y;
					var z = this1.z - v.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var _this_x = x1;
					var _this_y = y1;
					var _this_z = z1;
					var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-20) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					var x = _this_x * k;
					var y = _this_y * k;
					var z = _this_z * k;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var v_x = x1;
					var v_y = y1;
					var v_z = z1;
					var dMin = 1e9;
					var px = bounds.xMin;
					var py = bounds.yMin;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMin;
					var py = bounds.yMax;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMax;
					var py = bounds.yMin;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					var px = bounds.xMax;
					var py = bounds.yMax;
					var x = px;
					var y = py;
					var z = bounds.zMin;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var this_x = x1;
					var this_y = y1;
					var this_z = z1;
					var m = camera.getInverseView();
					var px = this_x * m._11 + this_y * m._21 + this_z * m._31 + m._41;
					var py = this_x * m._12 + this_y * m._22 + this_z * m._32 + m._42;
					var pz = this_x * m._13 + this_y * m._23 + this_z * m._33 + m._43;
					var x = px;
					var y = py;
					var z = pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var r0_x = x1;
					var r0_y = y1;
					var r0_z = z1;
					var r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					var r1 = r;
					var v = zMax;
					if(v == null) {
						v = 0.0;
					}
					var p_nx = 0;
					var p_ny = 0;
					var p_nz = 1;
					var p_d = v;
					var d = r1.lx * p_nx + r1.ly * p_ny + r1.lz * p_nz;
					var nd = p_d - (r1.px * p_nx + r1.py * p_ny + r1.pz * p_nz);
					var d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < dMin) {
						dMin = d1;
					}
					bounds.zMin += dMin;
				}
			} else {
				bounds.load(cameraBounds);
			}
		}
		bounds.scaleCenter(1.01);
	}
	,syncShader: function(texture) {
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMap__ = texture;
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMapChannel__ = this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R;
		this.dshader.shadowBias__ = this.bias;
		this.dshader.shadowPower__ = this.power;
		this.dshader.shadowProj__ = this.getShadowProj();
		var _this = this.dshader;
		_this.constModified = true;
		_this.USE_ESM__ = this.samplingKind == h3d_pass_ShadowSamplingKind.ESM;
		this.dshader.shadowPower__ = this.power;
		var _this = this.dshader;
		_this.constModified = true;
		_this.USE_PCF__ = this.samplingKind == h3d_pass_ShadowSamplingKind.PCF;
		var _this = this.dshader.shadowRes__;
		var x = texture.width;
		var y = texture.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		this.dshader.pcfScale__ = this.pcfScale;
		this.dshader.set_pcfQuality(this.pcfQuality);
	}
	,saveStaticData: function() {
		if(this.mode != h3d_pass_RenderMode.Mixed && this.mode != h3d_pass_RenderMode.Static) {
			return null;
		}
		if(this.staticTexture == null) {
			throw haxe_Exception.thrown("Data not computed");
		}
		var bytes = haxe_zip_Compress.run(this.staticTexture.capturePixels().bytes,9);
		var buffer = new haxe_io_BytesBuffer();
		buffer.addInt32(this.staticTexture.width);
		buffer.addFloat(this.lightCamera.pos.x);
		buffer.addFloat(this.lightCamera.pos.y);
		buffer.addFloat(this.lightCamera.pos.z);
		buffer.addFloat(this.lightCamera.target.x);
		buffer.addFloat(this.lightCamera.target.y);
		buffer.addFloat(this.lightCamera.target.z);
		buffer.addFloat(this.lightCamera.orthoBounds.xMin);
		buffer.addFloat(this.lightCamera.orthoBounds.yMin);
		buffer.addFloat(this.lightCamera.orthoBounds.zMin);
		buffer.addFloat(this.lightCamera.orthoBounds.xMax);
		buffer.addFloat(this.lightCamera.orthoBounds.yMax);
		buffer.addFloat(this.lightCamera.orthoBounds.zMax);
		buffer.addInt32(bytes.length);
		buffer.add(bytes);
		return buffer.getBytes();
	}
	,loadStaticData: function(bytes) {
		if(this.mode != h3d_pass_RenderMode.Mixed && this.mode != h3d_pass_RenderMode.Static || bytes == null) {
			return false;
		}
		var buffer = new haxe_io_BytesInput(bytes);
		var size = buffer.readInt32();
		if(size != this.size) {
			return false;
		}
		this.lightCamera.pos.x = buffer.readFloat();
		this.lightCamera.pos.y = buffer.readFloat();
		this.lightCamera.pos.z = buffer.readFloat();
		this.lightCamera.target.x = buffer.readFloat();
		this.lightCamera.target.y = buffer.readFloat();
		this.lightCamera.target.z = buffer.readFloat();
		this.lightCamera.orthoBounds.xMin = buffer.readFloat();
		this.lightCamera.orthoBounds.yMin = buffer.readFloat();
		this.lightCamera.orthoBounds.zMin = buffer.readFloat();
		this.lightCamera.orthoBounds.xMax = buffer.readFloat();
		this.lightCamera.orthoBounds.yMax = buffer.readFloat();
		this.lightCamera.orthoBounds.zMax = buffer.readFloat();
		this.lightCamera.update();
		var len = buffer.readInt32();
		var pixels = new hxd_Pixels(size,size,haxe_zip_Uncompress.run(buffer.read(len)),this.format);
		if(this.staticTexture != null) {
			this.staticTexture.dispose();
		}
		this.staticTexture = new h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target],this.format);
		this.staticTexture.uploadPixels(pixels);
		this.staticTexture.name = "staticTexture";
		this.staticTexture.preventAutoDispose();
		this.syncShader(this.staticTexture);
		return true;
	}
	,processShadowMap: function(passes,tex,sort) {
		var _this = this.ctx;
		var prevViewProj = _this.globals.map.h[_this.cameraViewProj_id];
		var _this = this.ctx;
		var v = this.getShadowProj();
		_this.globals.map.h[_this.cameraViewProj_id] = v;
		if(tex.isDepth()) {
			this.ctx.engine.pushDepth(tex);
			this.ctx.engine.clear(null,1.0);
		} else {
			this.ctx.engine.pushTarget(tex);
			this.ctx.engine.clear(16777215);
		}
		h3d_pass_Shadows.prototype.draw.call(this,passes,sort);
		var doBlur = this.blur.radius > 0 && (this.mode != h3d_pass_RenderMode.Mixed || !this.ctx.computingStatic);
		if(this.border != null && !doBlur) {
			this.border.render();
		}
		this.ctx.engine.popTarget();
		if(this.mode == h3d_pass_RenderMode.Mixed && !this.ctx.computingStatic) {
			var merge = this.ctx.textures.allocTarget("mergedDirShadowMap",this.size,this.size,false,this.format);
			this.mergePass.shader.texA__ = tex;
			this.mergePass.shader.texB__ = this.staticTexture;
			this.ctx.engine.pushTarget(merge);
			this.mergePass.render();
			this.ctx.engine.popTarget();
			tex = merge;
		}
		if(doBlur) {
			if(tex.isDepth()) {
				var tmp = this.ctx.textures.allocTarget("dirShadowMapFloat",this.size,this.size,false,this.format);
				h3d_pass_Copy.run(tex,tmp);
				tex = tmp;
			}
			this.blur.apply(this.ctx,tex);
			if(this.border != null) {
				this.ctx.engine.pushTarget(tex);
				this.border.render();
				this.ctx.engine.popTarget();
			}
		}
		var _this = this.ctx;
		_this.globals.map.h[_this.cameraViewProj_id] = prevViewProj;
		return tex;
	}
	,draw: function(passes,sort) {
		var _gthis = this;
		if(!this.enabled) {
			return;
		}
		if(!this.filterPasses(passes)) {
			return;
		}
		if(this.mode != h3d_pass_RenderMode.Mixed || this.ctx.computingStatic) {
			var ct = this.ctx.camera.target;
			var slight = this.light == null ? this.ctx.lightSystem.shadowLight : this.light;
			var ldir = slight == null ? null : slight.getShadowDirection();
			if(ldir == null) {
				var _this = this.lightCamera.target;
				var x = 0;
				var y = 0;
				var z = -1;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
			} else {
				var _this = this.lightCamera.target;
				var x = ldir.x;
				var y = ldir.y;
				var z = ldir.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
				var _this = this.lightCamera.target;
				var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
				if(k < 1e-20) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				_this.x *= k;
				_this.y *= k;
				_this.z *= k;
			}
			this.lightCamera.target.x += ct.x;
			this.lightCamera.target.y += ct.y;
			this.lightCamera.target.z += ct.z;
			var _this = this.lightCamera.pos;
			_this.x = ct.x;
			_this.y = ct.y;
			_this.z = ct.z;
			this.lightCamera.update();
			var _this = this.lightCamera.orthoBounds;
			_this.xMin = 1e20;
			_this.xMax = -1e20;
			_this.yMin = 1e20;
			_this.yMax = -1e20;
			_this.zMin = 1e20;
			_this.zMax = -1e20;
			if(passes.current != null) {
				this.calcShadowBounds(this.lightCamera);
			}
			this.lightCamera.update();
		}
		var f = function(col) {
			return col.inFrustum(_gthis.lightCamera.frustum);
		};
		var prevCollider = null;
		var prevResult = true;
		var head = null;
		var prev = null;
		var disc = passes.discarded;
		var discQueue = passes.lastDisc;
		var cur = passes.current;
		while(cur != null) {
			var col = cur.obj.cullingCollider;
			var tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider) {
					prevCollider = col;
					prevResult = f(col);
				}
				tmp = prevResult;
			}
			if(tmp) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		passes.current = head;
		passes.discarded = disc;
		passes.lastDisc = discQueue;
		var texture = this.ctx.textures.allocTarget("dirShadowMap",this.size,this.size,false,this.format);
		var tmp;
		if(!(this.depth == null || this.depth.width != this.size || this.depth.height != this.size)) {
			var _this = this.depth;
			tmp = _this.isDepth() ? _this.t == null : _this.t == null && _this.realloc == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			if(this.depth != null) {
				this.depth.dispose();
			}
			this.depth = new h3d_mat_Texture(this.size,this.size,null,hxd_PixelFormat.Depth24Stencil8);
			this.depth.name = "dirShadowMapDepth";
		}
		texture.depthBuffer = this.depth;
		texture = this.processShadowMap(passes,texture,sort);
		this.syncShader(texture);
	}
	,computeStatic: function(passes) {
		if(this.mode != h3d_pass_RenderMode.Static && this.mode != h3d_pass_RenderMode.Mixed) {
			return;
		}
		this.draw(passes);
		var texture = this.dshader.shadowMap__;
		var old = this.staticTexture;
		this.staticTexture = texture.clone();
		this.staticTexture.name = "StaticDirShadowMap";
		this.staticTexture.preventAutoDispose();
		var _this = this.dshader;
		_this.constModified = true;
		_this.shadowMap__ = this.staticTexture;
		if(old != null) {
			old.dispose();
		}
	}
	,drawDebug: function() {
		if(this.g == null) {
			this.g = new h3d_scene_Graphics(this.ctx.scene);
			this.g.name = "frustumDebug";
			this.g.material.passes.setPassName("overlay");
			var _this = this.g;
			var f = 512;
			_this.flags |= f;
		}
		if(!this.debug) {
			return;
		}
		this.g.clear();
		this.drawBounds(this.lightCamera,16777215);
	}
	,drawBounds: function(camera,color) {
		var nearPlaneCorner = [camera.unproject(-1,1,0),camera.unproject(1,1,0),camera.unproject(1,-1,0),camera.unproject(-1,-1,0)];
		var farPlaneCorner = [camera.unproject(-1,1,1),camera.unproject(1,1,1),camera.unproject(1,-1,1),camera.unproject(-1,-1,1)];
		this.g.lineStyle(1,color);
		var last = nearPlaneCorner[nearPlaneCorner.length - 1];
		this.g.moveTo(last.x,last.y,last.z);
		var _g = 0;
		while(_g < nearPlaneCorner.length) {
			var fc = nearPlaneCorner[_g];
			++_g;
			this.g.lineTo(fc.x,fc.y,fc.z);
		}
		var last = farPlaneCorner[farPlaneCorner.length - 1];
		this.g.moveTo(last.x,last.y,last.z);
		var _g = 0;
		while(_g < farPlaneCorner.length) {
			var fc = farPlaneCorner[_g];
			++_g;
			this.g.lineTo(fc.x,fc.y,fc.z);
		}
		var np = nearPlaneCorner[0];
		var fp = farPlaneCorner[0];
		this.g.moveTo(np.x,np.y,np.z);
		this.g.lineTo(fp.x,fp.y,fp.z);
		var np = nearPlaneCorner[1];
		var fp = farPlaneCorner[1];
		this.g.moveTo(np.x,np.y,np.z);
		this.g.lineTo(fp.x,fp.y,fp.z);
		var np = nearPlaneCorner[2];
		var fp = farPlaneCorner[2];
		this.g.moveTo(np.x,np.y,np.z);
		this.g.lineTo(fp.x,fp.y,fp.z);
		var np = nearPlaneCorner[3];
		var fp = farPlaneCorner[3];
		this.g.moveTo(np.x,np.y,np.z);
		this.g.lineTo(fp.x,fp.y,fp.z);
	}
	,__class__: h3d_pass_DirShadowMap
});
var h3d_pass_DefaultShadowMap = function(size,format) {
	if(size == null) {
		size = 1024;
	}
	if(format != null) {
		this.format = format;
	}
	h3d_pass_DirShadowMap.call(this,null);
	this.set_size(size);
	this.color = new h3d_VectorImpl(0.,0.,0.);
	this.set_mode(h3d_pass_RenderMode.Dynamic);
	this.shadowMapId = hxsl_Globals.allocID("shadow.map");
	this.shadowProjId = hxsl_Globals.allocID("shadow.proj");
	this.shadowColorId = hxsl_Globals.allocID("shadow.color");
	this.shadowPowerId = hxsl_Globals.allocID("shadow.power");
	this.shadowBiasId = hxsl_Globals.allocID("shadow.bias");
};
$hxClasses["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap;
h3d_pass_DefaultShadowMap.__name__ = "h3d.pass.DefaultShadowMap";
h3d_pass_DefaultShadowMap.__super__ = h3d_pass_DirShadowMap;
h3d_pass_DefaultShadowMap.prototype = $extend(h3d_pass_DirShadowMap.prototype,{
	draw: function(passes,sort) {
		h3d_pass_DirShadowMap.prototype.draw.call(this,passes,sort);
		this.ctx.globals.map.h[this.shadowMapId] = { texture : this.dshader.shadowMap__, channel : this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R};
		var _this = this.ctx.globals;
		var id = this.shadowProjId;
		var v = this.getShadowProj();
		_this.map.h[id] = v;
		this.ctx.globals.map.h[this.shadowColorId] = this.color;
		this.ctx.globals.map.h[this.shadowPowerId] = this.power;
		this.ctx.globals.map.h[this.shadowBiasId] = this.bias;
	}
	,__class__: h3d_pass_DefaultShadowMap
});
var h3d_pass_OutputShader = function(output) {
	this.shaderCache = hxsl_Cache.get();
	this.currentOutput = new hxsl_ShaderList(null);
	this.setOutput(output);
};
$hxClasses["h3d.pass.OutputShader"] = h3d_pass_OutputShader;
h3d_pass_OutputShader.__name__ = "h3d.pass.OutputShader";
h3d_pass_OutputShader.prototype = {
	setOutput: function(output) {
		if(output == null) {
			output = [hxsl_Output.Value("output.color")];
		}
		this.currentOutput.s = this.shaderCache.getLinkShader(output);
	}
	,compileShaders: function(globals,shaders,mode) {
		if(mode == null) {
			mode = hxsl_LinkMode.Default;
		}
		globals.maxChannels = 0;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			s1.updateConstants(globals);
		}
		this.currentOutput.next = shaders;
		var s = this.shaderCache.link(this.currentOutput,mode);
		this.currentOutput.next = null;
		return s;
	}
	,__class__: h3d_pass_OutputShader
};
var h3d_pass_PassListIterator = function(o) {
	this.o = o;
};
$hxClasses["h3d.pass.PassListIterator"] = h3d_pass_PassListIterator;
h3d_pass_PassListIterator.__name__ = "h3d.pass.PassListIterator";
h3d_pass_PassListIterator.prototype = {
	hasNext: function() {
		return this.o != null;
	}
	,next: function() {
		var tmp = this.o;
		this.o = this.o.next;
		return tmp;
	}
	,__class__: h3d_pass_PassListIterator
};
var h3d_pass_PassList = function(current) {
	this.current = current;
	this.discarded = this.lastDisc = null;
};
$hxClasses["h3d.pass.PassList"] = h3d_pass_PassList;
h3d_pass_PassList.__name__ = "h3d.pass.PassList";
h3d_pass_PassList.prototype = {
	init: function(pass) {
		this.current = pass;
		this.discarded = this.lastDisc = null;
	}
	,reset: function() {
		if(this.discarded != null) {
			this.lastDisc.next = this.current;
			this.current = this.discarded;
			this.discarded = this.lastDisc = null;
		}
	}
	,count: function() {
		var c = this.current;
		var n = 0;
		while(c != null) {
			++n;
			c = c.next;
		}
		return n;
	}
	,save: function() {
		return this.lastDisc;
	}
	,load: function(p) {
		if(this.lastDisc != p) {
			this.lastDisc.next = this.current;
			if(p == null) {
				this.current = this.discarded;
				this.discarded = null;
			} else {
				this.current = p.next;
				p.next = null;
			}
			this.lastDisc = p;
		}
	}
	,isEmpty: function() {
		return this.current == null;
	}
	,clear: function() {
		if(this.current == null) {
			return;
		}
		if(this.discarded == null) {
			this.discarded = this.current;
		} else {
			this.lastDisc.next = this.current;
		}
		var p = this.current;
		while(p.next != null) p = p.next;
		this.lastDisc = p;
		this.current = null;
	}
	,sort: function(f) {
		var list = this.current;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || f(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		this.current = tmp;
	}
	,filter: function(f) {
		var head = null;
		var prev = null;
		var disc = this.discarded;
		var discQueue = this.lastDisc;
		var cur = this.current;
		while(cur != null) {
			if(f(cur)) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		this.current = head;
		this.discarded = disc;
		this.lastDisc = discQueue;
	}
	,iterator: function() {
		return new h3d_pass_PassListIterator(this.current);
	}
	,getFiltered: function() {
		return new h3d_pass_PassListIterator(this.discarded);
	}
	,__class__: h3d_pass_PassList
};
var h3d_pass_PassObject = function() {
	this.texture = 0;
};
$hxClasses["h3d.pass.PassObject"] = h3d_pass_PassObject;
h3d_pass_PassObject.__name__ = "h3d.pass.PassObject";
h3d_pass_PassObject.prototype = {
	__class__: h3d_pass_PassObject
};
var h3d_pass_RenderMode = $hxEnums["h3d.pass.RenderMode"] = { __ename__:"h3d.pass.RenderMode",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Static: {_hx_name:"Static",_hx_index:1,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:2,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Mixed: {_hx_name:"Mixed",_hx_index:3,__enum__:"h3d.pass.RenderMode",toString:$estr}
};
h3d_pass_RenderMode.__constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
h3d_pass_RenderMode.__empty_constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
var h3d_pass_ShadowSamplingKind = $hxEnums["h3d.pass.ShadowSamplingKind"] = { __ename__:"h3d.pass.ShadowSamplingKind",__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,PCF: {_hx_name:"PCF",_hx_index:1,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,ESM: {_hx_name:"ESM",_hx_index:2,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
};
h3d_pass_ShadowSamplingKind.__constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
h3d_pass_ShadowSamplingKind.__empty_constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
var h3d_pass_SortByMaterial = function() {
	this.textureCount = 1;
	this.shaderCount = 1;
	this.shaderIdMap = [];
	this.textureIdMap = [];
};
$hxClasses["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial;
h3d_pass_SortByMaterial.__name__ = "h3d.pass.SortByMaterial";
h3d_pass_SortByMaterial.prototype = {
	sort: function(passes) {
		var _gthis = this;
		var shaderStart = this.shaderCount;
		var textureStart = this.textureCount;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			if(this.shaderIdMap[p.shader.id] < shaderStart || this.shaderIdMap[p.shader.id] == null) {
				this.shaderIdMap[p.shader.id] = this.shaderCount++;
			}
			if(this.textureIdMap[p.texture] < textureStart || this.textureIdMap[p.shader.id] == null) {
				this.textureIdMap[p.texture] = this.textureCount++;
			}
		}
		var list = passes.current;
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else {
							var tmp1;
							if(!(qsize == 0 || q == null)) {
								var tmp2;
								if(p.pass.layer != q.pass.layer) {
									tmp2 = p.pass.layer - q.pass.layer;
								} else {
									var d = _gthis.shaderIdMap[p.shader.id] - _gthis.shaderIdMap[q.shader.id];
									tmp2 = d != 0 ? d : _gthis.textureIdMap[p.texture] - _gthis.textureIdMap[q.texture];
								}
								tmp1 = tmp2 <= 0;
							} else {
								tmp1 = true;
							}
							if(tmp1) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		passes.current = tmp;
	}
	,__class__: h3d_pass_SortByMaterial
};
var h3d_prim_BigPrimitive = function(format,alloc) {
	this.isStatic = true;
	this.hasTangents = false;
	this.startIndex = 0;
	this.idxPos = 0;
	this.bufPos = 0;
	h3d_prim_Primitive.call(this);
	this.format = format;
	this.buffers = [];
	this.allIndexes = [];
	this.bounds = new h3d_col_Bounds();
	this.allocator = alloc;
	if(format.stride < 3) {
		throw haxe_Exception.thrown("Minimum stride = 3");
	}
};
$hxClasses["h3d.prim.BigPrimitive"] = h3d_prim_BigPrimitive;
h3d_prim_BigPrimitive.__name__ = "h3d.prim.BigPrimitive";
h3d_prim_BigPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_BigPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	begin: function(vcount,icount) {
		this.startIndex = this.bufPos / this.format.stride | 0;
		if(this.startIndex + vcount >= 65535) {
			if(vcount >= 65535) {
				throw haxe_Exception.thrown("Too many vertices in begin()");
			}
			this.flush();
		}
		if(this.tmpBuf == null) {
			this.tmpBuf = h3d_prim_BigPrimitive.PREV_BUFFER;
			if(this.tmpBuf == null) {
				this.tmpBuf = hxd__$FloatBuffer_Float32Expand._new(0);
			} else {
				h3d_prim_BigPrimitive.PREV_BUFFER = null;
			}
			if(this.isStatic) {
				var this1 = this.tmpBuf;
				var _g = this1.pos;
				var _g1 = 65535 * this.format.stride;
				while(_g < _g1) {
					var i = _g++;
					if(this1.pos == this1.array.length) {
						var newSize = this1.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						var newArray = new Float32Array(newSize);
						newArray.set(this1.array);
						this1.array = newArray;
					}
					this1.array[this1.pos++] = 0.;
				}
			}
		}
		if(!this.isStatic) {
			var this1 = this.tmpBuf;
			var _g = this1.pos;
			var _g1 = vcount * this.format.stride + this.bufPos;
			while(_g < _g1) {
				var i = _g++;
				if(this1.pos == this1.array.length) {
					var newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = 0.;
			}
		}
		if(this.tmpIdx == null) {
			this.tmpIdx = h3d_prim_BigPrimitive.PREV_INDEX;
			if(this.tmpIdx == null) {
				this.tmpIdx = new Array(0);
			} else {
				h3d_prim_BigPrimitive.PREV_INDEX = null;
			}
		}
		if(this.idxPos + icount > this.tmpIdx.length) {
			var size = this.tmpIdx.length == 0 ? 1024 : this.tmpIdx.length;
			var req = this.idxPos + icount;
			while(size < req) size <<= 1;
			var this1 = this.tmpIdx;
			while(this1.length < size) this1.push(0);
		}
	}
	,addPoint: function(x,y,z) {
		this.tmpBuf.array[this.bufPos++] = x;
		this.tmpBuf.array[this.bufPos++] = y;
		this.tmpBuf.array[this.bufPos++] = z;
		var _this = this.bounds;
		if(x < _this.xMin) {
			_this.xMin = x;
		}
		if(x > _this.xMax) {
			_this.xMax = x;
		}
		if(y < _this.yMin) {
			_this.yMin = y;
		}
		if(y > _this.yMax) {
			_this.yMax = y;
		}
		if(z < _this.zMin) {
			_this.zMin = z;
		}
		if(z > _this.zMax) {
			_this.zMax = z;
		}
	}
	,addBounds: function(x,y,z) {
		var _this = this.bounds;
		if(x < _this.xMin) {
			_this.xMin = x;
		}
		if(x > _this.xMax) {
			_this.xMax = x;
		}
		if(y < _this.yMin) {
			_this.yMin = y;
		}
		if(y > _this.yMax) {
			_this.yMax = y;
		}
		if(z < _this.zMin) {
			_this.zMin = z;
		}
		if(z > _this.zMax) {
			_this.zMax = z;
		}
	}
	,addVertexValue: function(v) {
		this.tmpBuf.array[this.bufPos++] = v;
	}
	,addIndex: function(i) {
		this.tmpIdx[this.idxPos++] = i + this.startIndex;
	}
	,triCount: function() {
		var count = 0;
		var _g = 0;
		var _g1 = this.allIndexes;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			count += i.vertices;
		}
		count += this.idxPos;
		return count / 3 | 0;
	}
	,vertexCount: function() {
		var count = 0;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			count += b.vertices;
		}
		count += this.bufPos / this.format.stride | 0;
		return count;
	}
	,flush: function() {
		if(this.tmpBuf != null) {
			if(this.bufPos > 0 && this.idxPos > 0) {
				this.flushing = true;
				var b;
				if(this.allocator != null) {
					b = this.allocator.ofSubFloats(this.tmpBuf,this.bufPos / this.format.stride | 0,this.format);
				} else {
					b = h3d_Buffer.ofSubFloats(this.tmpBuf,this.bufPos / this.format.stride | 0,this.format);
				}
				this.buffers.push(b);
				var idx = this.allocator != null ? this.allocator.ofIndexes(this.tmpIdx,this.idxPos) : h3d_Indexes.alloc(this.tmpIdx,0,this.idxPos);
				this.allIndexes.push(idx);
				this.flushing = false;
			}
			if(h3d_prim_BigPrimitive.PREV_BUFFER == null || h3d_prim_BigPrimitive.PREV_BUFFER.pos < this.tmpBuf.pos) {
				h3d_prim_BigPrimitive.PREV_BUFFER = this.tmpBuf;
			}
			if(h3d_prim_BigPrimitive.PREV_INDEX == null || h3d_prim_BigPrimitive.PREV_INDEX.length < this.tmpIdx.length) {
				h3d_prim_BigPrimitive.PREV_INDEX = this.tmpIdx;
			}
			this.tmpBuf = null;
			this.tmpIdx = null;
			this.bufPos = 0;
			this.idxPos = 0;
			this.startIndex = 0;
		}
	}
	,render: function(engine) {
		if(this.tmpBuf != null) {
			this.flush();
		}
		var _g = 0;
		var _g1 = this.buffers.length;
		while(_g < _g1) {
			var i = _g++;
			engine.renderIndexed(this.buffers[i],this.allIndexes[i]);
		}
	}
	,getBounds: function() {
		return this.bounds;
	}
	,dispose: function() {
		this.clear();
	}
	,clear: function() {
		if(this.flushing) {
			throw haxe_Exception.thrown("Cannot clear() BigPrimitive while it's flushing");
		}
		var _this = this.bounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(this.allocator != null) {
				this.allocator.disposeBuffer(b);
			} else {
				b.dispose();
			}
		}
		var _g = 0;
		var _g1 = this.allIndexes;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(this.allocator != null) {
				this.allocator.disposeIndexBuffer(i);
			} else {
				i.dispose();
			}
		}
		this.buffers = [];
		this.allIndexes = [];
		this.bufPos = 0;
		this.idxPos = 0;
		this.tmpBuf = null;
		this.tmpIdx = null;
	}
	,add: function(buf,idx,dx,dy,dz,rotation,scale,stride) {
		if(stride == null) {
			stride = -1;
		}
		if(scale == null) {
			scale = 1.;
		}
		if(rotation == null) {
			rotation = 0.;
		}
		if(dz == null) {
			dz = 0.;
		}
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		this.addSub(buf,idx,0,0,buf.pos / (stride < 0 ? this.format.stride : stride) | 0,idx.length / 3 | 0,dx,dy,dz,rotation,scale,stride);
	}
	,addSub: function(buf,idx,startVert,startTri,nvert,triCount,dx,dy,dz,rotation,scale,stride,deltaU,deltaV,color,mat) {
		if(color == null) {
			color = 1.;
		}
		if(deltaV == null) {
			deltaV = 0.;
		}
		if(deltaU == null) {
			deltaU = 0.;
		}
		if(stride == null) {
			stride = -1;
		}
		if(scale == null) {
			scale = 1.;
		}
		if(rotation == null) {
			rotation = 0.;
		}
		if(dz == null) {
			dz = 0.;
		}
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		if(stride < 0) {
			stride = this.format.stride;
		}
		if(stride < this.format.stride) {
			throw haxe_Exception.thrown("only stride >= " + this.format.stride + " allowed");
		}
		this.begin(nvert,triCount * 3);
		var start = this.startIndex;
		var cr = Math.cos(rotation);
		var sr = Math.sin(rotation);
		var pos = this.bufPos;
		var tmpBuf = this.tmpBuf;
		var _g = 0;
		var _g1 = nvert;
		while(_g < _g1) {
			var i = _g++;
			var p = (i + startVert) * stride;
			var x = buf.array[p++];
			var y = buf.array[p++];
			var z = buf.array[p++];
			if(mat != null) {
				var x1 = x;
				var y1 = y;
				var z1 = z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				var x2 = x1;
				var y2 = y1;
				var z2 = z1;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				var pt_x = x2;
				var pt_y = y2;
				var pt_z = z2;
				var px = pt_x * mat._11 + pt_y * mat._21 + pt_z * mat._31 + mat._41;
				var py = pt_x * mat._12 + pt_y * mat._22 + pt_z * mat._32 + mat._42;
				var pz = pt_x * mat._13 + pt_y * mat._23 + pt_z * mat._33 + mat._43;
				pt_x = px;
				pt_y = py;
				pt_z = pz;
				tmpBuf.array[pos++] = pt_x;
				tmpBuf.array[pos++] = pt_y;
				tmpBuf.array[pos++] = pt_z;
				var _this = this.bounds;
				if(pt_x < _this.xMin) {
					_this.xMin = pt_x;
				}
				if(pt_x > _this.xMax) {
					_this.xMax = pt_x;
				}
				if(pt_y < _this.yMin) {
					_this.yMin = pt_y;
				}
				if(pt_y > _this.yMax) {
					_this.yMax = pt_y;
				}
				if(pt_z < _this.zMin) {
					_this.zMin = pt_z;
				}
				if(pt_z > _this.zMax) {
					_this.zMax = pt_z;
				}
			} else {
				var tx = (x * cr - y * sr) * scale;
				var ty = (x * sr + y * cr) * scale;
				var vx = dx + tx;
				var vy = dy + ty;
				var vz = dz + z * scale;
				tmpBuf.array[pos++] = vx;
				tmpBuf.array[pos++] = vy;
				tmpBuf.array[pos++] = vz;
				var _this1 = this.bounds;
				if(vx < _this1.xMin) {
					_this1.xMin = vx;
				}
				if(vx > _this1.xMax) {
					_this1.xMax = vx;
				}
				if(vy < _this1.yMin) {
					_this1.yMin = vy;
				}
				if(vy > _this1.yMax) {
					_this1.yMax = vy;
				}
				if(vz < _this1.zMin) {
					_this1.zMin = vz;
				}
				if(vz > _this1.zMax) {
					_this1.zMax = vz;
				}
			}
			var stride1 = this.format.stride;
			if(stride1 >= 6) {
				var nx = buf.array[p++];
				var ny = buf.array[p++];
				var nz = buf.array[p++];
				if(mat != null) {
					var x3 = nx;
					var y3 = ny;
					var z3 = nz;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					var x4 = x3;
					var y4 = y3;
					var z4 = z3;
					if(z4 == null) {
						z4 = 0.;
					}
					if(y4 == null) {
						y4 = 0.;
					}
					if(x4 == null) {
						x4 = 0.;
					}
					var _this_x = x4;
					var _this_y = y4;
					var _this_z = z4;
					var px1 = _this_x * mat._11 + _this_y * mat._21 + _this_z * mat._31;
					var py1 = _this_x * mat._12 + _this_y * mat._22 + _this_z * mat._32;
					var pz1 = _this_x * mat._13 + _this_y * mat._23 + _this_z * mat._33;
					_this_x = px1;
					_this_y = py1;
					_this_z = pz1;
					var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-20) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					_this_x *= k;
					_this_y *= k;
					_this_z *= k;
					tmpBuf.array[pos++] = _this_x;
					tmpBuf.array[pos++] = _this_y;
					tmpBuf.array[pos++] = _this_z;
				} else {
					var tnx = nx * cr - ny * sr;
					var tny = nx * sr + ny * cr;
					tmpBuf.array[pos++] = tnx;
					tmpBuf.array[pos++] = tny;
					tmpBuf.array[pos++] = nz;
				}
			}
			if(this.hasTangents) {
				var tx1 = buf.array[p++];
				var ty1 = buf.array[p++];
				var tz = buf.array[p++];
				if(mat != null) {
					var x5 = tx1;
					var y5 = ty1;
					var z5 = tz;
					if(z5 == null) {
						z5 = 0.;
					}
					if(y5 == null) {
						y5 = 0.;
					}
					if(x5 == null) {
						x5 = 0.;
					}
					var x6 = x5;
					var y6 = y5;
					var z6 = z5;
					if(z6 == null) {
						z6 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					var _this_x1 = x6;
					var _this_y1 = y6;
					var _this_z1 = z6;
					var len = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
					var px2 = _this_x1 * mat._11 + _this_y1 * mat._21 + _this_z1 * mat._31;
					var py2 = _this_x1 * mat._12 + _this_y1 * mat._22 + _this_z1 * mat._32;
					var pz2 = _this_x1 * mat._13 + _this_y1 * mat._23 + _this_z1 * mat._33;
					_this_x1 = px2;
					_this_y1 = py2;
					_this_z1 = pz2;
					var k1 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
					if(k1 < 1e-20) {
						k1 = 0;
					} else {
						k1 = 1. / Math.sqrt(k1);
					}
					_this_x1 *= k1;
					_this_y1 *= k1;
					_this_z1 *= k1;
					if(len < 0.5) {
						_this_x1 *= 0.5;
						_this_y1 *= 0.5;
						_this_z1 *= 0.5;
					}
					tmpBuf.array[pos++] = _this_x1;
					tmpBuf.array[pos++] = _this_y1;
					tmpBuf.array[pos++] = _this_z1;
				} else {
					var tnx1 = tx1 * cr - ty1 * sr;
					var tny1 = tx1 * sr + ty1 * cr;
					tmpBuf.array[pos++] = tnx1;
					tmpBuf.array[pos++] = tny1;
					tmpBuf.array[pos++] = tz;
				}
				stride1 -= 3;
			}
			switch(stride1) {
			case 3:case 6:
				continue;
			case 4:case 7:
				tmpBuf.array[pos++] = buf.array[p++] + deltaU;
				break;
			case 5:case 8:case 9:case 10:
				tmpBuf.array[pos++] = buf.array[p++] + deltaU;
				tmpBuf.array[pos++] = buf.array[p++] + deltaV;
				var _g2 = 8;
				var _g3 = stride1;
				while(_g2 < _g3) {
					var i1 = _g2++;
					tmpBuf.array[pos++] = buf.array[p++];
				}
				break;
			default:
				tmpBuf.array[pos++] = buf.array[p++] + deltaU;
				tmpBuf.array[pos++] = buf.array[p++] + deltaV;
				tmpBuf.array[pos++] = buf.array[p++] * color;
				tmpBuf.array[pos++] = buf.array[p++] * color;
				tmpBuf.array[pos++] = buf.array[p++] * color;
				var _g4 = 11;
				var _g5 = stride1;
				while(_g4 < _g5) {
					var i2 = _g4++;
					tmpBuf.array[pos++] = buf.array[p++];
				}
			}
		}
		this.bufPos = pos;
		start -= startVert;
		var _g = 0;
		var _g1 = triCount * 3;
		while(_g < _g1) {
			var i = _g++;
			var tmp = idx[i + startTri * 3] + start;
			this.tmpIdx[this.idxPos++] = tmp;
		}
	}
	,__class__: h3d_prim_BigPrimitive
});
var h3d_prim_MeshPrimitive = function() {
	h3d_prim_Primitive.call(this);
};
$hxClasses["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive;
h3d_prim_MeshPrimitive.__name__ = "h3d.prim.MeshPrimitive";
h3d_prim_MeshPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_MeshPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	hasInput: function(name) {
		return this.resolveBuffer(name) != null;
	}
	,resolveBuffer: function(name) {
		if(this.buffers != null) {
			var _g = 0;
			var _g1 = this.buffers;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				if(b.format.hasInput(name)) {
					return b;
				}
			}
			return null;
		}
		if(this.buffer != null && this.buffer.format.hasInput(name)) {
			return this.buffer;
		}
		return null;
	}
	,removeBuffer: function(buf) {
		if(this.buffers != null) {
			HxOverrides.remove(this.buffers,buf);
			if(buf == this.buffer) {
				this.buffer = this.buffers[this.buffers.length - 1];
			}
			if(this.buffers.length == 1) {
				this.buffers = null;
				this.formats = null;
			}
		} else if(this.buffer == buf) {
			this.buffer = null;
		}
	}
	,addBuffer: function(buf) {
		if(this.buffer == null) {
			this.buffer = buf;
		} else {
			if(this.buffers == null) {
				if(buf == this.buffer) {
					throw haxe_Exception.thrown("Duplicate addBuffer()");
				}
				this.buffers = [this.buffer];
			} else if(this.buffers.indexOf(buf) >= 0) {
				throw haxe_Exception.thrown("Duplicate addBuffer()");
			}
			this.buffers.unshift(buf);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.buffers;
			while(_g1 < _g2.length) {
				var b = _g2[_g1];
				++_g1;
				_g.push(b.format);
			}
			this.formats = hxd_MultiFormat.make(_g);
		}
	}
	,dispose: function() {
		h3d_prim_Primitive.prototype.dispose.call(this);
		if(this.buffers != null) {
			var _g = 0;
			var _g1 = this.buffers;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				b.dispose();
			}
			this.buffers = null;
			this.formats = null;
		}
	}
	,render: function(engine) {
		if(this.indexes == null || this.indexes.vbuf == null || this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		if(this.buffers != null) {
			engine.renderMultiBuffers(this.formats,this.buffers,this.indexes);
		} else {
			engine.renderIndexed(this.buffer,this.indexes);
		}
	}
	,__class__: h3d_prim_MeshPrimitive
});
var h3d_prim_Polygon = function(points,idx) {
	this.translatedZ = 0.;
	this.translatedY = 0.;
	this.translatedX = 0.;
	this.scaled = 1.;
	h3d_prim_MeshPrimitive.call(this);
	this.points = points;
	this.idx = idx;
};
$hxClasses["h3d.prim.Polygon"] = h3d_prim_Polygon;
h3d_prim_Polygon.__name__ = "h3d.prim.Polygon";
h3d_prim_Polygon.__super__ = h3d_prim_MeshPrimitive;
h3d_prim_Polygon.prototype = $extend(h3d_prim_MeshPrimitive.prototype,{
	getBounds: function() {
		var b = new h3d_col_Bounds();
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p.x < b.xMin) {
				b.xMin = p.x;
			}
			if(p.x > b.xMax) {
				b.xMax = p.x;
			}
			if(p.y < b.yMin) {
				b.yMin = p.y;
			}
			if(p.y > b.yMax) {
				b.yMax = p.y;
			}
			if(p.z < b.zMin) {
				b.zMin = p.z;
			}
			if(p.z > b.zMax) {
				b.zMax = p.z;
			}
		}
		return b;
	}
	,alloc: function(engine) {
		this.dispose();
		var format = hxd_BufferFormat.get_POS3D();
		if(this.normals != null) {
			format = format.append("normal",3);
		}
		if(this.tangents != null) {
			format = format.append("tangent",3);
		}
		if(this.uvs != null) {
			format = format.append("uv",2);
		}
		if(this.colors != null) {
			format = format.append("color",3);
		}
		var buf = hxd__$FloatBuffer_Float32Expand._new(0);
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var k = _g++;
			var p = this.points[k];
			var v = p.x;
			if(buf.pos == buf.array.length) {
				var newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v;
			var v1 = p.y;
			if(buf.pos == buf.array.length) {
				var newSize1 = buf.array.length << 1;
				if(newSize1 < 128) {
					newSize1 = 128;
				}
				var newArray1 = new Float32Array(newSize1);
				newArray1.set(buf.array);
				buf.array = newArray1;
			}
			buf.array[buf.pos++] = v1;
			var v2 = p.z;
			if(buf.pos == buf.array.length) {
				var newSize2 = buf.array.length << 1;
				if(newSize2 < 128) {
					newSize2 = 128;
				}
				var newArray2 = new Float32Array(newSize2);
				newArray2.set(buf.array);
				buf.array = newArray2;
			}
			buf.array[buf.pos++] = v2;
			if(this.normals != null) {
				var n = this.normals[k];
				var v3 = n.x;
				if(buf.pos == buf.array.length) {
					var newSize3 = buf.array.length << 1;
					if(newSize3 < 128) {
						newSize3 = 128;
					}
					var newArray3 = new Float32Array(newSize3);
					newArray3.set(buf.array);
					buf.array = newArray3;
				}
				buf.array[buf.pos++] = v3;
				var v4 = n.y;
				if(buf.pos == buf.array.length) {
					var newSize4 = buf.array.length << 1;
					if(newSize4 < 128) {
						newSize4 = 128;
					}
					var newArray4 = new Float32Array(newSize4);
					newArray4.set(buf.array);
					buf.array = newArray4;
				}
				buf.array[buf.pos++] = v4;
				var v5 = n.z;
				if(buf.pos == buf.array.length) {
					var newSize5 = buf.array.length << 1;
					if(newSize5 < 128) {
						newSize5 = 128;
					}
					var newArray5 = new Float32Array(newSize5);
					newArray5.set(buf.array);
					buf.array = newArray5;
				}
				buf.array[buf.pos++] = v5;
			}
			if(this.tangents != null) {
				var t = this.tangents[k];
				var v6 = t.x;
				if(buf.pos == buf.array.length) {
					var newSize6 = buf.array.length << 1;
					if(newSize6 < 128) {
						newSize6 = 128;
					}
					var newArray6 = new Float32Array(newSize6);
					newArray6.set(buf.array);
					buf.array = newArray6;
				}
				buf.array[buf.pos++] = v6;
				var v7 = t.y;
				if(buf.pos == buf.array.length) {
					var newSize7 = buf.array.length << 1;
					if(newSize7 < 128) {
						newSize7 = 128;
					}
					var newArray7 = new Float32Array(newSize7);
					newArray7.set(buf.array);
					buf.array = newArray7;
				}
				buf.array[buf.pos++] = v7;
				var v8 = t.z;
				if(buf.pos == buf.array.length) {
					var newSize8 = buf.array.length << 1;
					if(newSize8 < 128) {
						newSize8 = 128;
					}
					var newArray8 = new Float32Array(newSize8);
					newArray8.set(buf.array);
					buf.array = newArray8;
				}
				buf.array[buf.pos++] = v8;
			}
			if(this.uvs != null) {
				var t1 = this.uvs[k];
				var v9 = t1.u;
				if(buf.pos == buf.array.length) {
					var newSize9 = buf.array.length << 1;
					if(newSize9 < 128) {
						newSize9 = 128;
					}
					var newArray9 = new Float32Array(newSize9);
					newArray9.set(buf.array);
					buf.array = newArray9;
				}
				buf.array[buf.pos++] = v9;
				var v10 = t1.v;
				if(buf.pos == buf.array.length) {
					var newSize10 = buf.array.length << 1;
					if(newSize10 < 128) {
						newSize10 = 128;
					}
					var newArray10 = new Float32Array(newSize10);
					newArray10.set(buf.array);
					buf.array = newArray10;
				}
				buf.array[buf.pos++] = v10;
			}
			if(this.colors != null) {
				var c = this.colors[k];
				var v11 = c.x;
				if(buf.pos == buf.array.length) {
					var newSize11 = buf.array.length << 1;
					if(newSize11 < 128) {
						newSize11 = 128;
					}
					var newArray11 = new Float32Array(newSize11);
					newArray11.set(buf.array);
					buf.array = newArray11;
				}
				buf.array[buf.pos++] = v11;
				var v12 = c.y;
				if(buf.pos == buf.array.length) {
					var newSize12 = buf.array.length << 1;
					if(newSize12 < 128) {
						newSize12 = 128;
					}
					var newArray12 = new Float32Array(newSize12);
					newArray12.set(buf.array);
					buf.array = newArray12;
				}
				buf.array[buf.pos++] = v12;
				var v13 = c.z;
				if(buf.pos == buf.array.length) {
					var newSize13 = buf.array.length << 1;
					if(newSize13 < 128) {
						newSize13 = 128;
					}
					var newArray13 = new Float32Array(newSize13);
					newArray13.set(buf.array);
					buf.array = newArray13;
				}
				buf.array[buf.pos++] = v13;
			}
		}
		this.buffer = h3d_Buffer.ofFloats(buf,format);
		if(this.idx != null) {
			this.indexes = h3d_Indexes.alloc(this.idx);
		}
	}
	,unindex: function() {
		if(this.idx != null && this.points.length != this.idx.length) {
			var p = [];
			var _g = 0;
			var _g1 = this.idx.length;
			while(_g < _g1) {
				var i = _g++;
				var _this = this.points[this.idx[i]];
				var x = _this.x;
				var y = _this.y;
				var z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				p.push(new h3d_VectorImpl(x,y,z));
			}
			if(this.normals != null) {
				var n = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					var _this = this.normals[this.idx[i]];
					var x = _this.x;
					var y = _this.y;
					var z = _this.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					n.push(new h3d_VectorImpl(x,y,z));
				}
				this.normals = n;
			}
			if(this.tangents != null) {
				var t = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					var _this = this.tangents[this.idx[i]];
					var x = _this.x;
					var y = _this.y;
					var z = _this.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					t.push(new h3d_VectorImpl(x,y,z));
				}
				this.tangents = t;
			}
			if(this.colors != null) {
				var n = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					var _this = this.colors[this.idx[i]];
					var x = _this.x;
					var y = _this.y;
					var z = _this.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					n.push(new h3d_VectorImpl(x,y,z));
				}
				this.colors = n;
			}
			if(this.uvs != null) {
				var t = [];
				var _g = 0;
				var _g1 = this.idx.length;
				while(_g < _g1) {
					var i = _g++;
					t.push(this.uvs[this.idx[i]].clone());
				}
				this.uvs = t;
			}
			this.points = p;
			this.idx = null;
		}
	}
	,translate: function(dx,dy,dz) {
		this.translatedX += dx;
		this.translatedY += dy;
		this.translatedZ += dz;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.x += dx;
			p.y += dy;
			p.z += dz;
		}
	}
	,scale: function(s) {
		this.scaled *= s;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.x *= s;
			p.y *= s;
			p.z *= s;
		}
	}
	,addNormals: function() {
		this.normals = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			this.normals[i] = new h3d_VectorImpl(0.,0.,0.);
		}
		var pos = 0;
		var _g = 0;
		var _g1 = this.triCount();
		while(_g < _g1) {
			var i = _g++;
			var i0;
			var i1;
			var i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			var p0 = this.points[i0];
			var p1 = this.points[i1];
			var p2 = this.points[i2];
			var x = p1.x - p0.x;
			var y = p1.y - p0.y;
			var z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var _this_x = x1;
			var _this_y = y1;
			var _this_z = z1;
			var x2 = p2.x - p0.x;
			var y2 = p2.y - p0.y;
			var z2 = p2.z - p0.z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z3 = z2;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var v_x = x3;
			var v_y = y3;
			var v_z = z3;
			var x4 = _this_y * v_z - _this_z * v_y;
			var y4 = _this_z * v_x - _this_x * v_z;
			var z4 = _this_x * v_y - _this_y * v_x;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var x5 = x4;
			var y5 = y4;
			var z5 = z4;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var n_x = x5;
			var n_y = y5;
			var n_z = z5;
			this.normals[i0].x += n_x;
			this.normals[i0].y += n_y;
			this.normals[i0].z += n_z;
			this.normals[i1].x += n_x;
			this.normals[i1].y += n_y;
			this.normals[i1].z += n_z;
			this.normals[i2].x += n_x;
			this.normals[i2].y += n_y;
			this.normals[i2].z += n_z;
		}
		var _g = 0;
		var _g1 = this.normals;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			var _this = n;
			var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this.x *= k;
			_this.y *= k;
			_this.z *= k;
		}
	}
	,addTangents: function() {
		if(this.normals == null) {
			this.addNormals();
		}
		if(this.uvs == null) {
			this.addUVs();
		}
		this.tangents = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			this.tangents[i] = new h3d_VectorImpl(0.,0.,0.);
		}
		var pos = 0;
		var _g = 0;
		var _g1 = this.triCount();
		while(_g < _g1) {
			var i = _g++;
			var i0;
			var i1;
			var i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			var p0 = this.points[i0];
			var p1 = this.points[i1];
			var p2 = this.points[i2];
			var uv0 = this.uvs[i0];
			var uv1 = this.uvs[i1];
			var uv2 = this.uvs[i2];
			var n = this.normals[i0];
			var x = p1.x - p0.x;
			var y = p1.y - p0.y;
			var z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var k0_x = x1;
			var k0_y = y1;
			var k0_z = z1;
			var x2 = p2.x - p0.x;
			var y2 = p2.y - p0.y;
			var z2 = p2.z - p0.z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			var x3 = x2;
			var y3 = y2;
			var z3 = z2;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			var k1_x = x3;
			var k1_y = y3;
			var k1_z = z3;
			var v = uv2.v - uv0.v;
			k0_x *= v;
			k0_y *= v;
			k0_z *= v;
			var v1 = uv1.v - uv0.v;
			k1_x *= v1;
			k1_y *= v1;
			k1_z *= v1;
			var x4 = k0_x - k1_x;
			var y4 = k0_y - k1_y;
			var z4 = k0_z - k1_z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			var t = new h3d_VectorImpl(x4,y4,z4);
			var _this = n;
			var x5 = _this.y * t.z - _this.z * t.y;
			var y5 = _this.z * t.x - _this.x * t.z;
			var z5 = _this.x * t.y - _this.y * t.x;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			var x6 = x5;
			var y6 = y5;
			var z6 = z5;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			var _this_x = x6;
			var _this_y = y6;
			var _this_z = z6;
			var k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this_x *= k;
			_this_y *= k;
			_this_z *= k;
			var x7 = _this_y * n.z - _this_z * n.y;
			var y7 = _this_z * n.x - _this_x * n.z;
			var z7 = _this_x * n.y - _this_y * n.x;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			t = new h3d_VectorImpl(x7,y7,z7);
			var _this1 = t;
			var k1 = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z;
			if(k1 < 1e-20) {
				k1 = 0;
			} else {
				k1 = 1. / Math.sqrt(k1);
			}
			_this1.x *= k1;
			_this1.y *= k1;
			_this1.z *= k1;
			this.tangents[i0].x += t.x;
			this.tangents[i0].y += t.y;
			this.tangents[i0].z += t.z;
			this.tangents[i1].x += t.x;
			this.tangents[i1].y += t.y;
			this.tangents[i1].z += t.z;
			this.tangents[i2].x += t.x;
			this.tangents[i2].y += t.y;
			this.tangents[i2].z += t.z;
		}
		var _g = 0;
		var _g1 = this.tangents;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			var _this = t;
			var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
			if(k < 1e-20) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this.x *= k;
			_this.y *= k;
			_this.z *= k;
		}
	}
	,addUVs: function() {
		this.uvs = [];
		var _g = 0;
		var _g1 = this.points.length;
		while(_g < _g1) {
			var i = _g++;
			this.uvs[i] = new h3d_prim_UV(this.points[i].x,this.points[i].y);
		}
	}
	,uvScale: function(su,sv) {
		if(this.uvs == null) {
			throw haxe_Exception.thrown("Missing UVs");
		}
		var m = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = this.uvs;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(m.h.__keys__[t.__id__] != null) {
				continue;
			}
			m.set(t,true);
			t.u *= su;
			t.v *= sv;
		}
	}
	,triCount: function() {
		var n = h3d_prim_MeshPrimitive.prototype.triCount.call(this);
		if(n != 0) {
			return n;
		}
		return (this.idx == null ? this.points.length : this.idx.length) / 3 | 0;
	}
	,vertexCount: function() {
		return this.points.length;
	}
	,getCollider: function() {
		var vertexes = new Array(this.points.length * 3);
		var indexes = new Array(this.idx.length);
		var vid = 0;
		var _g = 0;
		var _g1 = this.points;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			vertexes[vid++] = p.x;
			vertexes[vid++] = p.y;
			vertexes[vid++] = p.z;
		}
		var _g = 0;
		var _g1 = this.idx.length;
		while(_g < _g1) {
			var i = _g++;
			indexes[i] = this.idx[i];
		}
		var poly = new h3d_col_Polygon();
		poly.addBuffers(vertexes,indexes);
		return poly;
	}
	,render: function(engine) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		var indexes = this.indexes;
		var count = this.triCount();
		if(indexes == null) {
			indexes = engine.mem.getTriIndexes(count * 3);
		}
		if(this.buffers != null) {
			engine.renderMultiBuffers(this.formats,this.buffers,indexes,0,count);
		} else {
			engine.renderIndexed(this.buffer,indexes,0,count);
		}
	}
	,__class__: h3d_prim_Polygon
});
var h3d_prim_Cube = function(x,y,z,centered) {
	if(centered == null) {
		centered = false;
	}
	if(z == null) {
		z = 1.;
	}
	if(y == null) {
		y = 1.;
	}
	if(x == null) {
		x = 1.;
	}
	this.sizeX = x;
	this.sizeY = y;
	this.sizeZ = z;
	var x1 = 0;
	var y1 = 0;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this1 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = 0;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this2 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = 0;
	var y1 = y;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this3 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = 0;
	var y1 = 0;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this4 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = y;
	var z1 = 0;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this5 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = 0;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this6 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = 0;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var this7 = new h3d_VectorImpl(x1,y1,z1);
	var x1 = x;
	var y1 = y;
	var z1 = z;
	if(z1 == null) {
		z1 = 0.;
	}
	if(y1 == null) {
		y1 = 0.;
	}
	if(x1 == null) {
		x1 = 0.;
	}
	var p = [this1,this2,this3,this4,this5,this6,this7,new h3d_VectorImpl(x1,y1,z1)];
	var idx = new Array(0);
	idx.push(0);
	idx.push(1);
	idx.push(5);
	idx.push(0);
	idx.push(5);
	idx.push(3);
	idx.push(1);
	idx.push(4);
	idx.push(7);
	idx.push(1);
	idx.push(7);
	idx.push(5);
	idx.push(3);
	idx.push(5);
	idx.push(7);
	idx.push(3);
	idx.push(7);
	idx.push(6);
	idx.push(0);
	idx.push(6);
	idx.push(2);
	idx.push(0);
	idx.push(3);
	idx.push(6);
	idx.push(2);
	idx.push(7);
	idx.push(4);
	idx.push(2);
	idx.push(6);
	idx.push(7);
	idx.push(0);
	idx.push(4);
	idx.push(1);
	idx.push(0);
	idx.push(2);
	idx.push(4);
	h3d_prim_Polygon.call(this,p,idx);
	if(centered) {
		this.translate(-x * 0.5,-y * 0.5,-z * 0.5);
	}
};
$hxClasses["h3d.prim.Cube"] = h3d_prim_Cube;
h3d_prim_Cube.__name__ = "h3d.prim.Cube";
h3d_prim_Cube.defaultUnitCube = function() {
	var engine = h3d_Engine.CURRENT;
	var c = engine.resCache.h[h3d_prim_Cube.__id__];
	if(c != null) {
		return c;
	}
	c = new h3d_prim_Cube(1,1,1);
	c.translate(-0.5,-0.5,-0.5);
	c.unindex();
	c.addNormals();
	c.addUniformUVs(1.0);
	c.addTangents();
	engine.resCache.set(h3d_prim_Cube,c);
	return c;
};
h3d_prim_Cube.__super__ = h3d_prim_Polygon;
h3d_prim_Cube.prototype = $extend(h3d_prim_Polygon.prototype,{
	addUVs: function() {
		this.unindex();
		var z = new h3d_prim_UV(0,1);
		var x = new h3d_prim_UV(1,1);
		var y = new h3d_prim_UV(0,0);
		var o = new h3d_prim_UV(1,0);
		this.uvs = [x,z,y,x,y,o,x,z,y,x,y,o,x,z,y,x,y,o,z,o,x,z,y,o,z,o,x,z,y,o,z,o,x,z,y,o];
	}
	,addUniformUVs: function(scale) {
		if(scale == null) {
			scale = 1.;
		}
		this.unindex();
		var v = scale;
		this.uvs = [new h3d_prim_UV(v * this.sizeX,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(v * this.sizeY,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeY,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeY,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeY),new h3d_prim_UV(0,v * this.sizeY),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeY),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(v * this.sizeY,0),new h3d_prim_UV(v * this.sizeY,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeY,0),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeZ),new h3d_prim_UV(0,v * this.sizeZ),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(0,v * this.sizeY),new h3d_prim_UV(v * this.sizeX,0),new h3d_prim_UV(v * this.sizeX,v * this.sizeY),new h3d_prim_UV(0,v * this.sizeY),new h3d_prim_UV(0,0),new h3d_prim_UV(v * this.sizeX,0)];
	}
	,getCollider: function() {
		var x = this.translatedX;
		var y = this.translatedY;
		var z = this.translatedZ;
		var dx = this.sizeX * this.scaled;
		var dy = this.sizeY * this.scaled;
		var dz = this.sizeZ * this.scaled;
		var b = new h3d_col_Bounds();
		b.xMin = x;
		b.yMin = y;
		b.zMin = z;
		b.xMax = x + dx;
		b.yMax = y + dy;
		b.zMax = z + dz;
		return b;
	}
	,__class__: h3d_prim_Cube
});
var h3d_prim_HMDModel = function(data,dataPos,lib) {
	h3d_prim_MeshPrimitive.call(this);
	this.data = data;
	this.dataPosition = dataPos;
	this.lib = lib;
};
$hxClasses["h3d.prim.HMDModel"] = h3d_prim_HMDModel;
h3d_prim_HMDModel.__name__ = "h3d.prim.HMDModel";
h3d_prim_HMDModel.__super__ = h3d_prim_MeshPrimitive;
h3d_prim_HMDModel.prototype = $extend(h3d_prim_MeshPrimitive.prototype,{
	hasInput: function(name) {
		if(!h3d_prim_MeshPrimitive.prototype.hasInput.call(this,name)) {
			return this.data.vertexFormat.hasInput(name);
		} else {
			return true;
		}
	}
	,triCount: function() {
		return this.data.get_indexCount() / 3 | 0;
	}
	,vertexCount: function() {
		return this.data.vertexCount;
	}
	,getBounds: function() {
		return this.data.bounds;
	}
	,selectMaterial: function(i) {
		this.curMaterial = i;
	}
	,getMaterialIndexes: function(material) {
		return { start : this.indexesTriPos[material] * 3, count : this.data.indexCounts[material]};
	}
	,getDataBuffers: function(fmt,defaults,material) {
		return this.lib.getBuffers(this.data,fmt,defaults,material);
	}
	,loadSkin: function(skin) {
		this.lib.loadSkin(this.data,skin);
	}
	,alloc: function(engine) {
		this.dispose();
		this.buffer = new h3d_Buffer(this.data.vertexCount,this.data.vertexFormat);
		var entry = this.lib.resource.entry;
		var size = this.data.vertexCount * this.data.vertexFormat.strideBytes;
		var bytes = entry.fetchBytes(this.dataPosition + this.data.vertexPosition,size);
		this.buffer.uploadBytes(bytes,0,this.data.vertexCount);
		this.indexCount = 0;
		this.indexesTriPos = [];
		var _g = 0;
		var _g1 = this.data.indexCounts;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			this.indexesTriPos.push(this.indexCount / 3 | 0);
			this.indexCount += n;
		}
		var is32 = this.data.vertexCount > 65536;
		this.indexes = h3d_Indexes._new(this.indexCount,is32);
		var size = (is32 ? 4 : 2) * this.indexCount;
		var bytes = entry.fetchBytes(this.dataPosition + this.data.indexPosition,size);
		this.indexes.uploadBytes(bytes,0,this.indexCount);
		if(this.normalsRecomputed != null) {
			var name = this.normalsRecomputed;
			this.normalsRecomputed = null;
			this.recomputeNormals(name);
		}
	}
	,recomputeNormals: function(name) {
		if(this.normalsRecomputed != null) {
			return;
		}
		if(name != null && this.data.vertexFormat.hasInput(name)) {
			return;
		}
		if(name == null) {
			name = "normal";
		}
		var pos = this.lib.getBuffers(this.data,hxd_BufferFormat.get_POS3D());
		var ids = [];
		var pts = [];
		var mpts_h = { };
		var _g = 0;
		var _g1 = this.data.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var added = false;
			var px = pos.vertexes[i * 3];
			var py = pos.vertexes[i * 3 + 1];
			var pz = pos.vertexes[i * 3 + 2];
			var pid = (px + py + pz) * 10.01 | 0;
			var arr = mpts_h[pid];
			if(arr == null) {
				arr = [];
				mpts_h[pid] = arr;
			} else {
				var _g2 = 0;
				while(_g2 < arr.length) {
					var idx = arr[_g2];
					++_g2;
					var p = pts[idx];
					if(p.x == px && p.y == py && p.z == pz) {
						ids.push(idx);
						added = true;
						break;
					}
				}
			}
			if(!added) {
				ids.push(pts.length);
				arr.push(pts.length);
				var x = px;
				var y = py;
				var z = pz;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				pts.push(new h3d_VectorImpl(x,y,z));
			}
		}
		var idx = new Array(0);
		var _g = 0;
		var _g1 = pos.indexes;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			idx.push(ids[i]);
		}
		var pol = new h3d_prim_Polygon(pts,idx);
		pol.addNormals();
		var v = hxd__$FloatBuffer_Float32Expand._new(0);
		var _g = v.pos;
		var _g1 = this.data.vertexCount * 3;
		while(_g < _g1) {
			var i = _g++;
			if(v.pos == v.array.length) {
				var newSize = v.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(v.array);
				v.array = newArray;
			}
			v.array[v.pos++] = 0.;
		}
		var k = 0;
		var _g = 0;
		var _g1 = this.data.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var n = pol.normals[ids[i]];
			v.array[k++] = n.x;
			v.array[k++] = n.y;
			v.array[k++] = n.z;
		}
		var buf = h3d_Buffer.ofFloats(v,hxd_BufferFormat.make([new hxd_BufferInput(name,3,0)]));
		this.addBuffer(buf);
		this.normalsRecomputed = name;
	}
	,addTangents: function() {
		if(this.hasInput("tangent")) {
			return;
		}
		var pos = this.lib.getBuffers(this.data,hxd_BufferFormat.get_POS3D());
		var ids = [];
		var pts = [];
		var _g = 0;
		var _g1 = this.data.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var added = false;
			var px = pos.vertexes[i * 3];
			var py = pos.vertexes[i * 3 + 1];
			var pz = pos.vertexes[i * 3 + 2];
			var _g2 = 0;
			var _g3 = pts.length;
			while(_g2 < _g3) {
				var i1 = _g2++;
				var p = pts[i1];
				if(p.x == px && p.y == py && p.z == pz) {
					ids.push(i1);
					added = true;
					break;
				}
			}
			if(!added) {
				ids.push(pts.length);
				var x = px;
				var y = py;
				var z = pz;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				pts.push(new h3d_VectorImpl(x,y,z));
			}
		}
		var idx = new Array(0);
		var _g = 0;
		var _g1 = pos.indexes;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			idx.push(ids[i]);
		}
		var pol = new h3d_prim_Polygon(pts,idx);
		pol.addNormals();
		pol.addTangents();
		var v = hxd__$FloatBuffer_Float32Expand._new(0);
		var _g = v.pos;
		var _g1 = this.data.vertexCount * 3;
		while(_g < _g1) {
			var i = _g++;
			if(v.pos == v.array.length) {
				var newSize = v.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				var newArray = new Float32Array(newSize);
				newArray.set(v.array);
				v.array = newArray;
			}
			v.array[v.pos++] = 0.;
		}
		var k = 0;
		var _g = 0;
		var _g1 = this.data.vertexCount;
		while(_g < _g1) {
			var i = _g++;
			var t = pol.tangents[ids[i]];
			v.array[k++] = t.x;
			v.array[k++] = t.y;
			v.array[k++] = t.z;
		}
		var buf = h3d_Buffer.ofFloats(v,hxd_BufferFormat.make([new hxd_BufferInput("tangent",3,0)]));
		this.addBuffer(buf);
	}
	,render: function(engine) {
		if(this.curMaterial < 0) {
			h3d_prim_MeshPrimitive.prototype.render.call(this,engine);
			return;
		}
		if(this.indexes == null || this.indexes.vbuf == null) {
			this.alloc(engine);
		}
		if(this.buffers == null) {
			engine.renderIndexed(this.buffer,this.indexes,this.indexesTriPos[this.curMaterial],this.data.indexCounts[this.curMaterial] / 3 | 0);
		} else {
			engine.renderMultiBuffers(this.formats,this.buffers,this.indexes,this.indexesTriPos[this.curMaterial],this.data.indexCounts[this.curMaterial] / 3 | 0);
		}
		this.curMaterial = -1;
	}
	,initCollider: function(poly) {
		var buf = this.lib.getBuffers(this.data,hxd_BufferFormat.get_POS3D());
		poly.setData(buf.vertexes,buf.indexes);
		if(this.collider == null) {
			var _this = this.data.bounds;
			var dx = _this.xMax - _this.xMin;
			var dy = _this.yMax - _this.yMin;
			var dz = _this.zMax - _this.zMin;
			var sphere = new h3d_col_Sphere((_this.xMin + _this.xMax) * 0.5,(_this.yMin + _this.yMax) * 0.5,(_this.zMin + _this.zMax) * 0.5,Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5);
			this.collider = new h3d_col_OptimizedCollider(sphere,poly);
		}
	}
	,getCollider: function() {
		if(this.collider != null) {
			return this.collider;
		}
		var poly = new h3d_col_PolygonBuffer();
		poly.source = { entry : this.lib.resource.entry, geometryName : null};
		var _g = 0;
		var _g1 = this.lib.header.models;
		while(_g < _g1.length) {
			var h = _g1[_g];
			++_g;
			if(this.lib.header.geometries[h.geometry] == this.data) {
				poly.source.geometryName = h.name;
				break;
			}
		}
		this.initCollider(poly);
		return this.collider;
	}
	,__class__: h3d_prim_HMDModel
});
var h3d_prim_Instanced = function() {
	h3d_prim_Primitive.call(this);
	this.bounds = new h3d_col_Bounds();
	var _this = this.bounds;
	if(0 < _this.xMin) {
		_this.xMin = 0;
	}
	if(0 > _this.xMax) {
		_this.xMax = 0;
	}
	if(0 < _this.yMin) {
		_this.yMin = 0;
	}
	if(0 > _this.yMax) {
		_this.yMax = 0;
	}
	if(0 < _this.zMin) {
		_this.zMin = 0;
	}
	if(0 > _this.zMax) {
		_this.zMax = 0;
	}
	this.tmpBounds = new h3d_col_Bounds();
};
$hxClasses["h3d.prim.Instanced"] = h3d_prim_Instanced;
h3d_prim_Instanced.__name__ = "h3d.prim.Instanced";
h3d_prim_Instanced.__super__ = h3d_prim_Primitive;
h3d_prim_Instanced.prototype = $extend(h3d_prim_Primitive.prototype,{
	setMesh: function(m) {
		if(this.refCount > 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			m.incref();
		}
		this.primitive = m;
		this.baseBounds = m.getBounds();
		if(m.buffer == null || m.indexes == null) {
			m.alloc(h3d_Engine.CURRENT);
		}
	}
	,initBounds: function() {
		var _this = this.bounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
	}
	,addInstanceBounds: function(absPos) {
		this.tmpBounds.load(this.baseBounds);
		this.tmpBounds.transform(absPos);
		var _this = this.bounds;
		var b = this.tmpBounds;
		if(b.xMin < _this.xMin) {
			_this.xMin = b.xMin;
		}
		if(b.xMax > _this.xMax) {
			_this.xMax = b.xMax;
		}
		if(b.yMin < _this.yMin) {
			_this.yMin = b.yMin;
		}
		if(b.yMax > _this.yMax) {
			_this.yMax = b.yMax;
		}
		if(b.zMin < _this.zMin) {
			_this.zMin = b.zMin;
		}
		if(b.zMax > _this.zMax) {
			_this.zMax = b.zMax;
		}
	}
	,dispose: function() {
	}
	,incref: function() {
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.incref();
		}
		h3d_prim_Primitive.prototype.incref.call(this);
	}
	,decref: function() {
		h3d_prim_Primitive.prototype.decref.call(this);
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.decref();
		}
	}
	,getBounds: function() {
		return this.bounds;
	}
	,render: function(engine) {
		if(this.primitive.indexes == null || this.primitive.buffer.vbuf == null) {
			this.primitive.alloc(engine);
		}
		if(engine.needFlushTarget) {
			engine.doFlushTarget();
		}
		if(this.primitive.buffers == null) {
			engine.driver.selectBuffer(this.primitive.buffer);
		} else {
			engine.driver.selectMultiBuffers(this.primitive.formats,this.primitive.buffers);
		}
		var indexes = this.primitive.indexes;
		if(indexes == null) {
			indexes = engine.mem.getTriIndexes(this.triCount() * 3);
		}
		engine.renderInstanced(indexes,this.commands);
	}
	,__class__: h3d_prim_Instanced
});
var h3d_prim_Plane2D = function() {
	h3d_prim_Primitive.call(this);
};
$hxClasses["h3d.prim.Plane2D"] = h3d_prim_Plane2D;
h3d_prim_Plane2D.__name__ = "h3d.prim.Plane2D";
h3d_prim_Plane2D.get = function() {
	var engine = h3d_Engine.CURRENT;
	var inst = engine.resCache.h[h3d_prim_Plane2D.__id__];
	if(inst == null) {
		inst = new h3d_prim_Plane2D();
		engine.resCache.set(h3d_prim_Plane2D,inst);
	}
	return inst;
};
h3d_prim_Plane2D.__super__ = h3d_prim_Primitive;
h3d_prim_Plane2D.prototype = $extend(h3d_prim_Primitive.prototype,{
	triCount: function() {
		return 2;
	}
	,vertexCount: function() {
		return 4;
	}
	,alloc: function(engine) {
		var v = hxd__$FloatBuffer_Float32Expand._new(0);
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			var newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		this.buffer = h3d_Buffer.ofFloats(v,hxd_BufferFormat.get_XY_UV());
	}
	,render: function(engine) {
		if(this.buffer == null || this.buffer.vbuf == null) {
			this.alloc(engine);
		}
		var b = this.buffer;
		engine.renderBuffer(b,engine.mem.getQuadIndexes(b.vertices),2,0,-1);
	}
	,__class__: h3d_prim_Plane2D
});
var h3d_prim_RawPrimitive = function(inf,persist) {
	if(persist == null) {
		persist = false;
	}
	h3d_prim_Primitive.call(this);
	this.onContextLost = function() {
		return inf;
	};
	this.bounds = inf.bounds;
	this.alloc(null);
	if(!persist) {
		this.onContextLost = null;
	}
};
$hxClasses["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive;
h3d_prim_RawPrimitive.__name__ = "h3d.prim.RawPrimitive";
h3d_prim_RawPrimitive.__super__ = h3d_prim_Primitive;
h3d_prim_RawPrimitive.prototype = $extend(h3d_prim_Primitive.prototype,{
	alloc: function(engine) {
		if(this.onContextLost == null) {
			throw haxe_Exception.thrown("Cannot realloc " + Std.string(this));
		}
		var inf = this.onContextLost();
		this.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.format);
		this.vcount = this.buffer.vertices;
		this.tcount = inf.ibuf != null ? inf.ibuf.length / 3 | 0 : this.vcount / 3 | 0;
		if(inf.ibuf != null) {
			this.indexes = h3d_Indexes.alloc(inf.ibuf);
		} else if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	,getBounds: function() {
		if(this.bounds == null) {
			throw haxe_Exception.thrown("Bounds not defined for " + Std.string(this));
		}
		return this.bounds;
	}
	,triCount: function() {
		return this.tcount;
	}
	,vertexCount: function() {
		return this.vcount;
	}
	,__class__: h3d_prim_RawPrimitive
});
var h3d_prim_Sphere = function(ray,segsW,segsH,portion) {
	if(portion == null) {
		portion = 1.;
	}
	if(segsH == null) {
		segsH = 6;
	}
	if(segsW == null) {
		segsW = 8;
	}
	if(ray == null) {
		ray = 1.;
	}
	this.ray = ray;
	this.segsH = segsH;
	this.segsW = segsW;
	this.portion = portion;
	var dp = Math.PI * 2 / segsW;
	var pts = [];
	var idx = new Array(0);
	var _g = 0;
	var _g1 = segsH + 1;
	while(_g < _g1) {
		var y = _g++;
		var t = y / segsH * Math.PI * portion;
		var st = Math.sin(t);
		var pz = Math.cos(t);
		var p = 0.;
		var _g2 = 0;
		var _g3 = segsW + 1;
		while(_g2 < _g3) {
			var x = _g2++;
			var px = st * Math.cos(p);
			var py = st * Math.sin(p);
			var x1 = px * ray;
			var y1 = py * ray;
			var z = pz * ray;
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			pts.push(new h3d_VectorImpl(x1,y1,z));
			p += dp;
		}
	}
	var _g = 0;
	var _g1 = segsH;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g3 = segsW;
		while(_g2 < _g3) {
			var x = _g2++;
			var v1 = x + 1 + y * (segsW + 1);
			var v2 = x + y * (segsW + 1);
			var v3 = x + (y + 1) * (segsW + 1);
			var v4 = x + 1 + (y + 1) * (segsW + 1);
			if(y != 0) {
				idx.push(v1);
				idx.push(v2);
				idx.push(v4);
			}
			if(y != segsH - 1 || portion != 1.) {
				idx.push(v2);
				idx.push(v3);
				idx.push(v4);
			}
		}
	}
	h3d_prim_Polygon.call(this,pts,idx);
};
$hxClasses["h3d.prim.Sphere"] = h3d_prim_Sphere;
h3d_prim_Sphere.__name__ = "h3d.prim.Sphere";
h3d_prim_Sphere.defaultUnitSphere = function() {
	var engine = h3d_Engine.CURRENT;
	var s = engine.resCache.h[h3d_prim_Sphere.__id__];
	if(s != null) {
		return s;
	}
	s = new h3d_prim_Sphere(1,16,16);
	s.addNormals();
	s.addUVs();
	engine.resCache.set(h3d_prim_Sphere,s);
	return s;
};
h3d_prim_Sphere.__super__ = h3d_prim_Polygon;
h3d_prim_Sphere.prototype = $extend(h3d_prim_Polygon.prototype,{
	getCollider: function() {
		return new h3d_col_Sphere(this.translatedX,this.translatedY,this.translatedZ,this.ray * this.scaled);
	}
	,addNormals: function() {
		this.normals = this.points;
	}
	,addUVs: function() {
		this.uvs = [];
		var _g = 0;
		var _g1 = this.segsH + 1;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = this.segsW + 1;
			while(_g2 < _g3) {
				var x = _g2++;
				this.uvs.push(new h3d_prim_UV(1 - x / this.segsW,y / this.segsH));
			}
		}
	}
	,__class__: h3d_prim_Sphere
});
var h3d_prim_UV = function(u,v) {
	this.u = u;
	this.v = v;
};
$hxClasses["h3d.prim.UV"] = h3d_prim_UV;
h3d_prim_UV.__name__ = "h3d.prim.UV";
h3d_prim_UV.prototype = {
	clone: function() {
		return new h3d_prim_UV(this.u,this.v);
	}
	,toString: function() {
		return "{" + hxd_Math.fmt(this.u) + "," + hxd_Math.fmt(this.v) + "}";
	}
	,__class__: h3d_prim_UV
};
var h3d_scene_Mesh = function(primitive,material,parent) {
	h3d_scene_Object.call(this,parent);
	this.set_primitive(primitive);
	if(material == null) {
		material = h3d_mat_MaterialSetup.current.createMaterial();
		material.set_props(material.getDefaultProps());
	}
	this.material = material;
};
$hxClasses["h3d.scene.Mesh"] = h3d_scene_Mesh;
h3d_scene_Mesh.__name__ = "h3d.scene.Mesh";
h3d_scene_Mesh.__super__ = h3d_scene_Object;
h3d_scene_Mesh.prototype = $extend(h3d_scene_Object.prototype,{
	getMeshMaterials: function() {
		return [this.material];
	}
	,addBoundsRec: function(b,relativeTo) {
		h3d_scene_Object.prototype.addBoundsRec.call(this,b,relativeTo);
		if(this.primitive == null || (this.flags & 512) != 0) {
			return;
		}
		var bounds = this.primitive.getBounds();
		if(relativeTo == null) {
			var m = this.absPos;
			var b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			var tmp = b1;
			tmp.transform(m);
			if(tmp.xMin < b.xMin) {
				b.xMin = tmp.xMin;
			}
			if(tmp.xMax > b.xMax) {
				b.xMax = tmp.xMax;
			}
			if(tmp.yMin < b.yMin) {
				b.yMin = tmp.yMin;
			}
			if(tmp.yMax > b.yMax) {
				b.yMax = tmp.yMax;
			}
			if(tmp.zMin < b.zMin) {
				b.zMin = tmp.zMin;
			}
			if(tmp.zMax > b.zMax) {
				b.zMax = tmp.zMax;
			}
		} else {
			h3d_scene_Mesh.tmpMat.multiply(this.absPos,relativeTo);
			var m = h3d_scene_Mesh.tmpMat;
			var b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			var tmp = b1;
			tmp.transform(m);
			if(tmp.xMin < b.xMin) {
				b.xMin = tmp.xMin;
			}
			if(tmp.xMax > b.xMax) {
				b.xMax = tmp.xMax;
			}
			if(tmp.yMin < b.yMin) {
				b.yMin = tmp.yMin;
			}
			if(tmp.yMax > b.yMax) {
				b.yMax = tmp.yMax;
			}
			if(tmp.zMin < b.zMin) {
				b.zMin = tmp.zMin;
			}
			if(tmp.zMax > b.zMax) {
				b.zMax = tmp.zMax;
			}
		}
	}
	,clone: function(o) {
		var m = o == null ? new h3d_scene_Mesh(null,this.material) : o;
		m.set_primitive(this.primitive);
		m.material = this.material.clone();
		h3d_scene_Object.prototype.clone.call(this,m);
		return m;
	}
	,getLocalCollider: function() {
		return this.primitive.getCollider();
	}
	,draw: function(ctx) {
		this.primitive.render(ctx.engine);
	}
	,emit: function(ctx) {
		var p = this.material.passes;
		while(p != null) {
			if(!p.culled) {
				ctx.emitPass(p,this).index = 0;
			}
			p = p.nextPass;
		}
	}
	,getMaterialByName: function(name) {
		if(this.material != null && this.material.name == name) {
			return this.material;
		}
		return h3d_scene_Object.prototype.getMaterialByName.call(this,name);
	}
	,getMaterials: function(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		if(this.material != null && a.indexOf(this.material) < 0) {
			a.push(this.material);
		}
		return h3d_scene_Object.prototype.getMaterials.call(this,a,recursive);
	}
	,onAdd: function() {
		h3d_scene_Object.prototype.onAdd.call(this);
		if(this.primitive != null) {
			this.primitive.incref();
		}
	}
	,onRemove: function() {
		if(this.primitive != null) {
			this.primitive.decref();
		}
		h3d_scene_Object.prototype.onRemove.call(this);
	}
	,set_primitive: function(prim) {
		if(prim != this.primitive && (this.flags & 32) != 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			if(prim != null) {
				prim.incref();
			}
		}
		return this.primitive = prim;
	}
	,__class__: h3d_scene_Mesh
});
var h3d_scene_Graphics = function(parent) {
	this.lineSize = 0.;
	this.curR = 0.;
	this.curZ = 0.;
	this.curY = 0.;
	this.curX = 0.;
	this.bprim = new h3d_prim_BigPrimitive(hxd_BufferFormat.get_POS3D_NORMAL_UV_RGBA());
	this.bprim.isStatic = false;
	h3d_scene_Mesh.call(this,this.bprim,null,parent);
	this.tmpPoints = [];
	this.lineShader = new h3d_shader_LineShader();
	this.lineShader.setPriority(-100);
	var _this = this.material;
	_this.set_castShadows(false);
	_this.set_receiveShadows(false);
	this.material.passes.set_enableLights(false);
	this.material.passes.addShader(this.lineShader);
	var vcolor = new h3d_shader_VertexColorAlpha();
	vcolor.setPriority(-100);
	this.material.passes.addShader(vcolor);
	this.material.passes.set_culling(h3d_mat_Face.None);
};
$hxClasses["h3d.scene.Graphics"] = h3d_scene_Graphics;
h3d_scene_Graphics.__name__ = "h3d.scene.Graphics";
h3d_scene_Graphics.__super__ = h3d_scene_Mesh;
h3d_scene_Graphics.prototype = $extend(h3d_scene_Mesh.prototype,{
	onRemove: function() {
		h3d_scene_Mesh.prototype.onRemove.call(this);
		this.bprim.clear();
	}
	,set_is3D: function(v) {
		if(this.is3D == v) {
			return v;
		}
		if(v) {
			this.material.set_texture(h3d_mat_Texture.fromColor(-1));
			this.material.passes.removeShader(this.lineShader);
		} else {
			this.material.set_texture(null);
			this.material.passes.addShader(this.lineShader);
		}
		this.bprim.clear();
		this.tmpPoints = [];
		return this.is3D = v;
	}
	,flushLine: function() {
		var _gthis = this;
		var pts = this.tmpPoints;
		var last = pts.length - 1;
		var prev = pts[last];
		var p = pts[0];
		var closed = p.x == prev.x && p.y == prev.y && p.z == prev.z;
		var count = pts.length;
		if(!closed) {
			var prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			pts.push(new h3d_scene__$Graphics_GPoint(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,prev.z * 2 - prevLast.z,0,0,0,0));
			var pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			prev = new h3d_scene__$Graphics_GPoint(p.x * 2 - pNext.x,p.y * 2 - pNext.y,p.z * 2 - pNext.z,0,0,0,0);
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		var start = this.bprim.vertexCount();
		var pindex = start;
		var v = 0.;
		var _g = 0;
		var _g1 = count;
		while(_g < _g1) {
			var i = _g++;
			var next = pts[(i + 1) % pts.length];
			var nx1 = prev.y - p.y;
			var ny1 = p.x - prev.x;
			var ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			var nx2 = p.y - next.y;
			var ny2 = next.x - p.x;
			var ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			var nx = nx1 * ns1 + nx2 * ns2;
			var ny = ny1 * ns1 + ny2 * ns2;
			var ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			var size = nx * nx1 * ns1 + ny * ny1 * ns1;
			var d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			var hasIndex = i < count - 1 || closed;
			this.bprim.begin(2,hasIndex ? 6 : 0);
			var _this = _gthis.bprim;
			_this.tmpBuf.array[_this.bufPos++] = p.x + nx;
			var _this1 = _gthis.bprim;
			_this1.tmpBuf.array[_this1.bufPos++] = p.y + ny;
			var _this2 = _gthis.bprim;
			_this2.tmpBuf.array[_this2.bufPos++] = p.z;
			var _this3 = _gthis.bprim;
			_this3.tmpBuf.array[_this3.bufPos++] = 0;
			var _this4 = _gthis.bprim;
			_this4.tmpBuf.array[_this4.bufPos++] = 0;
			var _this5 = _gthis.bprim;
			_this5.tmpBuf.array[_this5.bufPos++] = 1;
			var _this6 = _gthis.bprim;
			_this6.tmpBuf.array[_this6.bufPos++] = 0;
			var _this7 = _gthis.bprim;
			_this7.tmpBuf.array[_this7.bufPos++] = v;
			var _this8 = _gthis.bprim;
			_this8.tmpBuf.array[_this8.bufPos++] = p.r;
			var _this9 = _gthis.bprim;
			_this9.tmpBuf.array[_this9.bufPos++] = p.g;
			var _this10 = _gthis.bprim;
			_this10.tmpBuf.array[_this10.bufPos++] = p.b;
			var _this11 = _gthis.bprim;
			_this11.tmpBuf.array[_this11.bufPos++] = p.a;
			var _this12 = _gthis.bprim;
			_this12.tmpBuf.array[_this12.bufPos++] = p.x - nx;
			var _this13 = _gthis.bprim;
			_this13.tmpBuf.array[_this13.bufPos++] = p.y - ny;
			var _this14 = _gthis.bprim;
			_this14.tmpBuf.array[_this14.bufPos++] = p.z;
			var _this15 = _gthis.bprim;
			_this15.tmpBuf.array[_this15.bufPos++] = 0;
			var _this16 = _gthis.bprim;
			_this16.tmpBuf.array[_this16.bufPos++] = 0;
			var _this17 = _gthis.bprim;
			_this17.tmpBuf.array[_this17.bufPos++] = 1;
			var _this18 = _gthis.bprim;
			_this18.tmpBuf.array[_this18.bufPos++] = 1;
			var _this19 = _gthis.bprim;
			_this19.tmpBuf.array[_this19.bufPos++] = v;
			var _this20 = _gthis.bprim;
			_this20.tmpBuf.array[_this20.bufPos++] = p.r;
			var _this21 = _gthis.bprim;
			_this21.tmpBuf.array[_this21.bufPos++] = p.g;
			var _this22 = _gthis.bprim;
			_this22.tmpBuf.array[_this22.bufPos++] = p.b;
			var _this23 = _gthis.bprim;
			_this23.tmpBuf.array[_this23.bufPos++] = p.a;
			v = 1 - v;
			if(hasIndex) {
				var pnext = i == last ? start - pindex : 2;
				var _this24 = this.bprim;
				_this24.tmpIdx[_this24.idxPos++] = _this24.startIndex;
				var _this25 = this.bprim;
				_this25.tmpIdx[_this25.idxPos++] = 1 + _this25.startIndex;
				var _this26 = this.bprim;
				_this26.tmpIdx[_this26.idxPos++] = pnext + _this26.startIndex;
				var _this27 = this.bprim;
				_this27.tmpIdx[_this27.idxPos++] = pnext + _this27.startIndex;
				var _this28 = this.bprim;
				_this28.tmpIdx[_this28.idxPos++] = 1 + _this28.startIndex;
				var _this29 = this.bprim;
				_this29.tmpIdx[_this29.idxPos++] = pnext + 1 + _this29.startIndex;
			}
			pindex += 2;
			prev = p;
			p = next;
		}
	}
	,flush: function() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.is3D) {
			this.flushLine();
			this.tmpPoints = [];
		}
	}
	,sync: function(ctx) {
		h3d_scene_Mesh.prototype.sync.call(this,ctx);
		this.flush();
		this.bprim.flush();
	}
	,draw: function(ctx) {
		this.flush();
		this.bprim.flush();
		h3d_scene_Mesh.prototype.draw.call(this,ctx);
	}
	,clear: function() {
		this.flush();
		this.bprim.clear();
	}
	,lineStyle: function(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0.;
		}
		this.flush();
		if(size > 0 && this.lineSize != size) {
			this.lineSize = size;
			if(!this.is3D) {
				this.lineShader.width__ = this.lineSize;
			}
		}
		this.setColor(color,alpha);
	}
	,setColorF: function(r,g,b,a) {
		if(a == null) {
			a = 1.;
		}
		this.curA = a;
		this.curR = r;
		this.curG = g;
		this.curB = b;
	}
	,setColor: function(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.curA = alpha;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
	}
	,drawLine: function(p1,p2) {
		this.moveTo(p1.x,p1.y,p1.z);
		this.lineTo(p2.x,p2.y,p2.z);
	}
	,moveTo: function(x,y,z) {
		if(this.is3D) {
			this.flush();
			this.lineTo(x,y,z);
		} else {
			this.curX = x;
			this.curY = y;
			this.curZ = z;
		}
	}
	,addVertex: function(x,y,z,r,g,b,a) {
		this.tmpPoints.push(new h3d_scene__$Graphics_GPoint(x,y,z,r,g,b,a));
	}
	,lineTo: function(x,y,z) {
		var _gthis = this;
		if(this.is3D) {
			var x1 = this.curX;
			var y1 = this.curY;
			var z1 = this.curZ;
			var _this = this.bprim.bounds;
			if(x1 < _this.xMin) {
				_this.xMin = x1;
			}
			if(x1 > _this.xMax) {
				_this.xMax = x1;
			}
			if(y1 < _this.yMin) {
				_this.yMin = y1;
			}
			if(y1 > _this.yMax) {
				_this.yMax = y1;
			}
			if(z1 < _this.zMin) {
				_this.zMin = z1;
			}
			if(z1 > _this.zMax) {
				_this.zMax = z1;
			}
			var _this = this.bprim.bounds;
			if(x < _this.xMin) {
				_this.xMin = x;
			}
			if(x > _this.xMax) {
				_this.xMax = x;
			}
			if(y < _this.yMin) {
				_this.yMin = y;
			}
			if(y > _this.yMax) {
				_this.yMax = y;
			}
			if(z < _this.zMin) {
				_this.zMin = z;
			}
			if(z > _this.zMax) {
				_this.zMax = z;
			}
			this.tmpPoints.push(new h3d_scene__$Graphics_GPoint(x,y,z,this.curR,this.curG,this.curB,this.curA));
			return;
		}
		this.bprim.begin(4,6);
		var nx = x - this.curX;
		var ny = y - this.curY;
		var nz = z - this.curZ;
		var x1 = this.curX;
		var y1 = this.curY;
		var z1 = this.curZ;
		var _this = this.bprim.bounds;
		if(x1 < _this.xMin) {
			_this.xMin = x1;
		}
		if(x1 > _this.xMax) {
			_this.xMax = x1;
		}
		if(y1 < _this.yMin) {
			_this.yMin = y1;
		}
		if(y1 > _this.yMax) {
			_this.yMax = y1;
		}
		if(z1 < _this.zMin) {
			_this.zMin = z1;
		}
		if(z1 > _this.zMax) {
			_this.zMax = z1;
		}
		var _this = this.bprim.bounds;
		if(x < _this.xMin) {
			_this.xMin = x;
		}
		if(x > _this.xMax) {
			_this.xMax = x;
		}
		if(y < _this.yMin) {
			_this.yMin = y;
		}
		if(y > _this.yMax) {
			_this.yMax = y;
		}
		if(z < _this.zMin) {
			_this.zMin = z;
		}
		if(z > _this.zMax) {
			_this.zMax = z;
		}
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 0;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curX;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curY;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curZ;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nx;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = ny;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = nz;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = 1;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curR;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curG;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curB;
		var _this = _gthis.bprim;
		_this.tmpBuf.array[_this.bufPos++] = _gthis.curA;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 1 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 2 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 2 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 3 + _this.startIndex;
		var _this = this.bprim;
		_this.tmpIdx[_this.idxPos++] = 1 + _this.startIndex;
		this.curX = x;
		this.curY = y;
		this.curZ = z;
	}
	,__class__: h3d_scene_Graphics
});
var h3d_scene_Box = function(color,bounds,depth,parent) {
	if(depth == null) {
		depth = true;
	}
	if(color == null) {
		color = -65536;
	}
	this.prevZMax = -1e9;
	this.prevYMax = -1e9;
	this.prevXMax = -1e9;
	this.prevZMin = 1e9;
	this.prevYMin = 1e9;
	this.prevXMin = 1e9;
	this.thickness = 1.0;
	h3d_scene_Graphics.call(this,parent);
	this.color = color;
	this.bounds = bounds;
	if(!depth) {
		this.material.passes.depth(true,h3d_mat_Compare.Always);
	}
};
$hxClasses["h3d.scene.Box"] = h3d_scene_Box;
h3d_scene_Box.__name__ = "h3d.scene.Box";
h3d_scene_Box.__super__ = h3d_scene_Graphics;
h3d_scene_Box.prototype = $extend(h3d_scene_Graphics.prototype,{
	clone: function(o) {
		var b;
		if(o == null) {
			var b1 = this.color;
			var _this = this.bounds;
			var b2 = new h3d_col_Bounds();
			b2.xMin = _this.xMin;
			b2.xMax = _this.xMax;
			b2.yMin = _this.yMin;
			b2.yMax = _this.yMax;
			b2.zMin = _this.zMin;
			b2.zMax = _this.zMax;
			b = new h3d_scene_Box(b1,b2,this.material.passes.depthWrite,null);
		} else {
			b = o;
		}
		h3d_scene_Graphics.prototype.clone.call(this,b);
		var _this = this.bounds;
		var b1 = new h3d_col_Bounds();
		b1.xMin = _this.xMin;
		b1.xMax = _this.xMax;
		b1.yMin = _this.yMin;
		b1.yMax = _this.yMax;
		b1.zMin = _this.zMin;
		b1.zMax = _this.zMax;
		b.bounds = b1;
		b.prevXMin = this.prevXMin;
		b.prevYMin = this.prevYMin;
		b.prevZMin = this.prevZMin;
		b.prevXMax = this.prevXMax;
		b.prevYMax = this.prevYMax;
		b.prevZMax = this.prevZMax;
		return b;
	}
	,getLocalCollider: function() {
		return null;
	}
	,sync: function(ctx) {
		if(this.bounds == null) {
			if(this.prevXMin == -0.5 && this.prevYMin == -0.5 && this.prevZMin == -0.5 && this.prevXMax == 0.5 && this.prevYMax == 0.5 && this.prevZMax == 0.5) {
				return;
			}
			this.prevXMin = -0.5;
			this.prevYMin = -0.5;
			this.prevZMin = -0.5;
			this.prevXMax = 0.5;
			this.prevYMax = 0.5;
			this.prevZMax = 0.5;
		} else {
			if(this.prevXMin == this.bounds.xMin && this.prevYMin == this.bounds.yMin && this.prevZMin == this.bounds.zMin && this.prevXMax == this.bounds.xMax && this.prevYMax == this.bounds.yMax && this.prevZMax == this.bounds.zMax) {
				return;
			}
			this.prevXMin = this.bounds.xMin;
			this.prevYMin = this.bounds.yMin;
			this.prevZMin = this.bounds.zMin;
			this.prevXMax = this.bounds.xMax;
			this.prevYMax = this.bounds.yMax;
			this.prevZMax = this.bounds.zMax;
		}
		this.clear();
		this.lineStyle(this.thickness,this.color);
		this.moveTo(this.prevXMin,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMin,this.prevZMax);
		this.lineTo(this.prevXMax,this.prevYMin,this.prevZMax);
		this.lineTo(this.prevXMax,this.prevYMax,this.prevZMax);
		this.lineTo(this.prevXMin,this.prevYMax,this.prevZMax);
		this.lineTo(this.prevXMin,this.prevYMin,this.prevZMax);
		this.moveTo(this.prevXMax,this.prevYMin,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMin,this.prevZMax);
		this.moveTo(this.prevXMin,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMin,this.prevYMax,this.prevZMax);
		this.moveTo(this.prevXMax,this.prevYMax,this.prevZMin);
		this.lineTo(this.prevXMax,this.prevYMax,this.prevZMax);
		h3d_scene_Graphics.prototype.sync.call(this,ctx);
	}
	,__class__: h3d_scene_Box
});
var h3d_scene__$Graphics_GPoint = function(x,y,z,r,g,b,a) {
	this.x = x;
	this.y = y;
	this.z = z;
	this.r = r;
	this.g = g;
	this.b = b;
	this.a = a;
};
$hxClasses["h3d.scene._Graphics.GPoint"] = h3d_scene__$Graphics_GPoint;
h3d_scene__$Graphics_GPoint.__name__ = "h3d.scene._Graphics.GPoint";
h3d_scene__$Graphics_GPoint.prototype = {
	__class__: h3d_scene__$Graphics_GPoint
};
var h3d_scene_Interactive = function(shape,parent) {
	this.hitPoint = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.lastClickFrame = -1;
	this.mouseDownButton = -1;
	this.isAbsoluteShape = false;
	this.allowMultiClick = false;
	this.enableRightButton = false;
	this.propagateEvents = false;
	this.cancelEvents = false;
	h3d_scene_Object.call(this,parent);
	this.shape = shape;
	this.set_cursor(hxd_Cursor.Button);
};
$hxClasses["h3d.scene.Interactive"] = h3d_scene_Interactive;
h3d_scene_Interactive.__name__ = "h3d.scene.Interactive";
h3d_scene_Interactive.__interfaces__ = [hxd_Interactive];
h3d_scene_Interactive.setupDebugMaterial = function(debugObj) {
	var materials = debugObj.getMaterials();
	var _g = 0;
	while(_g < materials.length) {
		var m = materials[_g];
		++_g;
		var engine = h3d_Engine.CURRENT;
		if(engine.driver.hasFeature(h3d_impl_Feature.Wireframe)) {
			m.passes.set_wireframe(true);
		}
		m.set_castShadows(false);
		m.set_receiveShadows(false);
		m.mshader.color__.w = 0.7;
		m.set_blendMode(h2d_BlendMode.Alpha);
	}
};
h3d_scene_Interactive.__super__ = h3d_scene_Object;
h3d_scene_Interactive.prototype = $extend(h3d_scene_Object.prototype,{
	getPoint: function(ray,bestMatch) {
		var rold_px = ray.px;
		var rold_py = ray.py;
		var rold_pz = ray.pz;
		var rold_lx = ray.lx;
		var rold_ly = ray.ly;
		var rold_lz = ray.lz;
		var m = this.getInvPos();
		var x = ray.px;
		var y = ray.py;
		var z = ray.pz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var p_x = x1;
		var p_y = y1;
		var p_z = z1;
		var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
		var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
		var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
		p_x = px;
		p_y = py;
		p_z = pz;
		ray.px = p_x;
		ray.py = p_y;
		ray.pz = p_z;
		var x = ray.lx;
		var y = ray.ly;
		var z = ray.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var x1 = x;
		var y1 = y;
		var z1 = z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		var _this_x = x1;
		var _this_y = y1;
		var _this_z = z1;
		var px = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
		var py = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
		var pz = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
		_this_x = px;
		_this_y = py;
		_this_z = pz;
		ray.lx = _this_x;
		ray.ly = _this_y;
		ray.lz = _this_z;
		ray.normalize();
		var d = this.shape.rayIntersection(ray,bestMatch);
		if(d < 0) {
			ray.px = rold_px;
			ray.py = rold_py;
			ray.pz = rold_pz;
			ray.lx = rold_lx;
			ray.ly = rold_ly;
			ray.lz = rold_lz;
			return null;
		}
		var x = ray.px + d * ray.lx;
		var y = ray.py + d * ray.ly;
		var z = ray.pz + d * ray.lz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var pt = new h3d_VectorImpl(x,y,z);
		var m = this.getAbsPos();
		var px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		var py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		var pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		ray.px = rold_px;
		ray.py = rold_py;
		ray.pz = rold_pz;
		ray.lx = rold_lx;
		ray.ly = rold_ly;
		ray.lz = rold_lz;
		return pt;
	}
	,get_showDebug: function() {
		return this.debugObj != null;
	}
	,set_showDebug: function(val) {
		if(!val) {
			if(this.debugObj != null) {
				var _this = this.debugObj;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
			}
			this.debugObj = null;
			return false;
		}
		if(this.debugObj != null) {
			return true;
		}
		this.debugObj = this.shape.makeDebugObj();
		if(this.debugObj != null) {
			h3d_scene_Interactive.setupDebugMaterial(this.debugObj);
			var _this = this.debugObj;
			var b = this.isAbsoluteShape;
			if(b != ((_this.flags & 2048) != 0)) {
				var f = 1;
				var b1 = true;
				if(b1) {
					_this.flags |= f;
				} else {
					_this.flags &= ~f;
				}
			}
			var f = 2048;
			if(b) {
				_this.flags |= f;
			} else {
				_this.flags &= ~f;
			}
			this.addChild(this.debugObj);
		}
		return this.debugObj != null;
	}
	,onAdd: function() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		h3d_scene_Object.prototype.onAdd.call(this);
	}
	,onRemove: function() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = null;
		}
		h3d_scene_Object.prototype.onRemove.call(this);
	}
	,preventClick: function() {
		this.mouseDownButton = -1;
	}
	,getInteractiveScene: function() {
		return this.scene;
	}
	,handleEvent: function(e) {
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				var frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	,set_cursor: function(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	,focus: function() {
		if(this.scene == null || this.scene.events == null) {
			return;
		}
		this.scene.events.focus(this);
	}
	,blur: function() {
		if(this.hasFocus()) {
			this.scene.events.blur();
		}
	}
	,isOver: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.overList.indexOf(this) != -1;
		} else {
			return false;
		}
	}
	,hasFocus: function() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.currentFocus == this;
		} else {
			return false;
		}
	}
	,onOver: function(e) {
	}
	,onOut: function(e) {
	}
	,onPush: function(e) {
	}
	,onRelease: function(e) {
	}
	,onReleaseOutside: function(e) {
	}
	,onClick: function(e) {
	}
	,onMove: function(e) {
	}
	,onWheel: function(e) {
	}
	,onFocus: function(e) {
	}
	,onFocusLost: function(e) {
	}
	,onKeyUp: function(e) {
	}
	,onKeyDown: function(e) {
	}
	,onCheck: function(e) {
	}
	,onTextInput: function(e) {
	}
	,__class__: h3d_scene_Interactive
});
var h3d_scene_Light = function(shader,parent) {
	h3d_scene_Object.call(this,parent);
	this.shader = shader;
};
$hxClasses["h3d.scene.Light"] = h3d_scene_Light;
h3d_scene_Light.__name__ = "h3d.scene.Light";
h3d_scene_Light.__super__ = h3d_scene_Object;
h3d_scene_Light.prototype = $extend(h3d_scene_Object.prototype,{
	get_color: function() {
		return new h3d_VectorImpl(0.,0.,0.);
	}
	,set_color: function(v) {
		return v;
	}
	,emit: function(ctx) {
		ctx.emitLight(this);
	}
	,getShadowDirection: function() {
		return null;
	}
	,__class__: h3d_scene_Light
});
var h3d_scene_LightSystem = function() {
	this.drawPasses = 0;
};
$hxClasses["h3d.scene.LightSystem"] = h3d_scene_LightSystem;
h3d_scene_LightSystem.__name__ = "h3d.scene.LightSystem";
h3d_scene_LightSystem.prototype = {
	initGlobals: function(globals) {
	}
	,initLights: function(ctx) {
		this.ctx = ctx;
		if(this.shadowLight == null || (this.shadowLight.flags & 32) == 0) {
			var l = ctx.lights;
			while(l != null) {
				var dir = l.getShadowDirection();
				if(dir != null) {
					this.shadowLight = l;
					break;
				}
				l = l.next;
			}
		}
	}
	,computeLight: function(obj,shaders) {
		return shaders;
	}
	,dispose: function() {
	}
	,__class__: h3d_scene_LightSystem
};
var h3d_scene_MultiMaterial = function(prim,mats,parent) {
	h3d_scene_Mesh.call(this,prim,mats == null ? null : mats[0],parent);
	this.materials = mats == null ? [this.material] : mats;
};
$hxClasses["h3d.scene.MultiMaterial"] = h3d_scene_MultiMaterial;
h3d_scene_MultiMaterial.__name__ = "h3d.scene.MultiMaterial";
h3d_scene_MultiMaterial.__super__ = h3d_scene_Mesh;
h3d_scene_MultiMaterial.prototype = $extend(h3d_scene_Mesh.prototype,{
	getMeshMaterials: function() {
		return this.materials.slice();
	}
	,clone: function(o) {
		var m = o == null ? new h3d_scene_MultiMaterial(null,this.materials) : o;
		m.materials = [];
		var _g = 0;
		var _g1 = this.materials;
		while(_g < _g1.length) {
			var mat = _g1[_g];
			++_g;
			m.materials.push(mat == null ? null : mat.clone());
		}
		h3d_scene_Mesh.prototype.clone.call(this,m);
		m.material = m.materials[0];
		return m;
	}
	,emit: function(ctx) {
		var _g = 0;
		var _g1 = this.materials.length;
		while(_g < _g1) {
			var i = _g++;
			var m = this.materials[i];
			if(m != null) {
				var index = i;
				if(index == null) {
					index = 0;
				}
				var p = m.passes;
				while(p != null) {
					if(!p.culled) {
						ctx.emitPass(p,this).index = index;
					}
					p = p.nextPass;
				}
			}
		}
	}
	,getMaterialByName: function(name) {
		var _g = 0;
		var _g1 = this.materials;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m != null && m.name == name) {
				return m;
			}
		}
		return h3d_scene_Mesh.prototype.getMaterialByName.call(this,name);
	}
	,getMaterials: function(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		var _g = 0;
		var _g1 = this.materials;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m != null && a.indexOf(m) < 0) {
				a.push(m);
			}
		}
		if(recursive) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var o = _g1[_g];
				++_g;
				o.getMaterials(a);
			}
		}
		return a;
	}
	,draw: function(ctx) {
		if(this.materials.length > 1) {
			this.primitive.selectMaterial(ctx.drawPass.index);
		}
		h3d_scene_Mesh.prototype.draw.call(this,ctx);
	}
	,__class__: h3d_scene_MultiMaterial
});
var h3d_scene_ObjectFlags = {};
h3d_scene_ObjectFlags._new = function(value) {
	return value;
};
h3d_scene_ObjectFlags.toInt = function(this1) {
	return this1;
};
h3d_scene_ObjectFlags.has = function(this1,f) {
	return (this1 & f) != 0;
};
h3d_scene_ObjectFlags.set = function(this1,f,b) {
	if(b) {
		this1 |= f;
	} else {
		this1 &= ~f;
	}
	return b;
};
var h3d_scene__$RenderContext_SharedGlobal = function(gid,value) {
	this.gid = gid;
	this.value = value;
};
$hxClasses["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__$RenderContext_SharedGlobal;
h3d_scene__$RenderContext_SharedGlobal.__name__ = "h3d.scene._RenderContext.SharedGlobal";
h3d_scene__$RenderContext_SharedGlobal.prototype = {
	__class__: h3d_scene__$RenderContext_SharedGlobal
};
var h3d_scene_RenderContext = function() {
	h3d_impl_RenderContext.call(this);
	this.cachedShaderList = [];
	this.cachedPassObjects = [];
	this.initGlobals();
};
$hxClasses["h3d.scene.RenderContext"] = h3d_scene_RenderContext;
h3d_scene_RenderContext.__name__ = "h3d.scene.RenderContext";
h3d_scene_RenderContext.__super__ = h3d_impl_RenderContext;
h3d_scene_RenderContext.prototype = $extend(h3d_impl_RenderContext.prototype,{
	setCamera: function(cam) {
		var v = cam.mcam;
		this.globals.map.h[this.cameraView_id] = v;
		var v = cam.zNear;
		this.globals.map.h[this.cameraNear_id] = v;
		var v = cam.zFar;
		this.globals.map.h[this.cameraFar_id] = v;
		var v = cam.mproj;
		this.globals.map.h[this.cameraProj_id] = v;
		var v = cam.pos;
		this.globals.map.h[this.cameraPos_id] = v;
		var x = cam.mproj._11;
		var y = cam.mproj._22;
		var z = cam.mproj._33;
		var w = cam.mproj._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var v = new h3d_Vector4Impl(x,y,z,w);
		this.globals.map.h[this.cameraProjDiag_id] = v;
		var v = cam.m;
		this.globals.map.h[this.cameraViewProj_id] = v;
		var v = this.camera.getInverseViewProj();
		this.globals.map.h[this.cameraInverseViewProj_id] = v;
	}
	,setupTarget: function() {
		var v = this.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.engine.getCurrentTarget() != null ? -1 : 1;
		this.globals.map.h[this.cameraProjFlip_id] = v;
	}
	,getCurrentPixelSize: function() {
		var t = this.engine.getCurrentTarget();
		var x = 2 / (t == null ? this.engine.width : t.width);
		var y = 2 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h3d_VectorImpl(x,y,0.);
	}
	,emit: function(mat,obj,index) {
		if(index == null) {
			index = 0;
		}
		var p = mat.passes;
		while(p != null) {
			if(!p.culled) {
				this.emitPass(p,obj).index = index;
			}
			p = p.nextPass;
		}
	}
	,start: function() {
		this.lights = null;
		this.drawPass = null;
		this.passes = [];
		this.lights = null;
		this.cachedPos = 0;
		this.visibleFlag = true;
		this.time += this.elapsedTime;
		this.frame++;
		this.setCurrent();
		var v = this.time;
		this.globals.map.h[this.globalTime_id] = v;
		var v = this.getCurrentPixelSize();
		this.globals.map.h[this.pixelSize_id] = v;
		this.setCamera(this.camera);
	}
	,nextPass: function() {
		this.cachedPos = 0;
		this.drawPass = null;
	}
	,getGlobal: function(name) {
		return this.globals.get(name);
	}
	,setGlobal: function(name,v) {
		this.globals.set(name,v);
	}
	,emitPass: function(pass,obj) {
		if((pass.rendererFlags & 1) == 0) {
			this.scene.renderer.setPassFlags(pass);
		}
		var o = this.allocPool;
		if(o == null) {
			o = new h3d_pass_PassObject();
			o.nextAlloc = this.allocFirst;
			this.allocFirst = o;
		} else {
			this.allocPool = o.nextAlloc;
		}
		o.pass = pass;
		o.obj = obj;
		if(this.passes.length <= pass.passId) {
			this.passes.length = pass.passId;
		}
		o.next = this.passes[pass.passId];
		this.passes[pass.passId] = o;
		return o;
	}
	,allocShaderList: function(s,next) {
		var sl = this.cachedShaderList[this.cachedPos++];
		if(sl == null) {
			sl = new hxsl_ShaderList(null);
			this.cachedShaderList[this.cachedPos - 1] = sl;
		}
		sl.s = s;
		sl.next = next;
		return sl;
	}
	,emitLight: function(l) {
		l.next = this.lights;
		this.lights = l;
	}
	,uploadParams: function() {
		this.fillParams(this.shaderBuffers,this.drawPass.shader,this.drawPass.shaders);
		this.engine.uploadShaderBuffers(this.shaderBuffers,1);
		this.engine.uploadShaderBuffers(this.shaderBuffers,2);
		this.engine.uploadShaderBuffers(this.shaderBuffers,3);
	}
	,done: function() {
		this.drawPass = null;
		var p = this.allocFirst;
		while(p != null && p != this.allocPool) {
			p.obj = null;
			p.pass = null;
			p.shader = null;
			p.shaders = null;
			p.next = null;
			p.index = 0;
			p.texture = 0;
			p = p.nextAlloc;
		}
		if(this.allocPool != null) {
			this.allocFirst = this.allocFirst.nextAlloc;
		}
		this.allocPool = this.allocFirst;
		var _g = 0;
		var _g1 = this.cachedShaderList;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.s = null;
			c.next = null;
		}
		this.passes = [];
		this.lights = null;
		this.clearCurrent();
	}
	,get_cameraView: function() {
		return this.globals.map.h[this.cameraView_id];
	}
	,set_cameraView: function(v) {
		this.globals.map.h[this.cameraView_id] = v;
		return v;
	}
	,get_cameraNear: function() {
		return this.globals.map.h[this.cameraNear_id];
	}
	,set_cameraNear: function(v) {
		this.globals.map.h[this.cameraNear_id] = v;
		return v;
	}
	,get_cameraFar: function() {
		return this.globals.map.h[this.cameraFar_id];
	}
	,set_cameraFar: function(v) {
		this.globals.map.h[this.cameraFar_id] = v;
		return v;
	}
	,get_cameraProj: function() {
		return this.globals.map.h[this.cameraProj_id];
	}
	,set_cameraProj: function(v) {
		this.globals.map.h[this.cameraProj_id] = v;
		return v;
	}
	,get_cameraPos: function() {
		return this.globals.map.h[this.cameraPos_id];
	}
	,set_cameraPos: function(v) {
		this.globals.map.h[this.cameraPos_id] = v;
		return v;
	}
	,get_cameraProjDiag: function() {
		return this.globals.map.h[this.cameraProjDiag_id];
	}
	,set_cameraProjDiag: function(v) {
		this.globals.map.h[this.cameraProjDiag_id] = v;
		return v;
	}
	,get_cameraProjFlip: function() {
		return this.globals.map.h[this.cameraProjFlip_id];
	}
	,set_cameraProjFlip: function(v) {
		this.globals.map.h[this.cameraProjFlip_id] = v;
		return v;
	}
	,get_cameraViewProj: function() {
		return this.globals.map.h[this.cameraViewProj_id];
	}
	,set_cameraViewProj: function(v) {
		this.globals.map.h[this.cameraViewProj_id] = v;
		return v;
	}
	,get_cameraInverseViewProj: function() {
		return this.globals.map.h[this.cameraInverseViewProj_id];
	}
	,set_cameraInverseViewProj: function(v) {
		this.globals.map.h[this.cameraInverseViewProj_id] = v;
		return v;
	}
	,get_globalTime: function() {
		return this.globals.map.h[this.globalTime_id];
	}
	,set_globalTime: function(v) {
		this.globals.map.h[this.globalTime_id] = v;
		return v;
	}
	,get_pixelSize: function() {
		return this.globals.map.h[this.pixelSize_id];
	}
	,set_pixelSize: function(v) {
		this.globals.map.h[this.pixelSize_id] = v;
		return v;
	}
	,get_globalModelView: function() {
		return this.globals.map.h[this.globalModelView_id];
	}
	,set_globalModelView: function(v) {
		this.globals.map.h[this.globalModelView_id] = v;
		return v;
	}
	,get_globalModelViewInverse: function() {
		return this.globals.map.h[this.globalModelViewInverse_id];
	}
	,set_globalModelViewInverse: function(v) {
		this.globals.map.h[this.globalModelViewInverse_id] = v;
		return v;
	}
	,initGlobals: function() {
		this.cameraView_id = hxsl_Globals.allocID("camera.view");
		this.cameraNear_id = hxsl_Globals.allocID("camera.zNear");
		this.cameraFar_id = hxsl_Globals.allocID("camera.zFar");
		this.cameraProj_id = hxsl_Globals.allocID("camera.proj");
		this.cameraPos_id = hxsl_Globals.allocID("camera.position");
		this.cameraProjDiag_id = hxsl_Globals.allocID("camera.projDiag");
		this.cameraProjFlip_id = hxsl_Globals.allocID("camera.projFlip");
		this.cameraViewProj_id = hxsl_Globals.allocID("camera.viewProj");
		this.cameraInverseViewProj_id = hxsl_Globals.allocID("camera.inverseViewProj");
		this.globalTime_id = hxsl_Globals.allocID("global.time");
		this.pixelSize_id = hxsl_Globals.allocID("global.pixelSize");
		this.globalModelView_id = hxsl_Globals.allocID("global.modelView");
		this.globalModelViewInverse_id = hxsl_Globals.allocID("global.modelViewInverse");
	}
	,__class__: h3d_scene_RenderContext
});
var h3d_scene_PassObjects = function() {
	this.passes = new h3d_pass_PassList();
};
$hxClasses["h3d.scene.PassObjects"] = h3d_scene_PassObjects;
h3d_scene_PassObjects.__name__ = "h3d.scene.PassObjects";
h3d_scene_PassObjects.prototype = {
	__class__: h3d_scene_PassObjects
};
var h3d_scene_RenderMode = $hxEnums["h3d.scene.RenderMode"] = { __ename__:"h3d.scene.RenderMode",__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"h3d.scene.RenderMode",toString:$estr}
	,LightProbe: {_hx_name:"LightProbe",_hx_index:1,__enum__:"h3d.scene.RenderMode",toString:$estr}
};
h3d_scene_RenderMode.__constructs__ = [h3d_scene_RenderMode.Default,h3d_scene_RenderMode.LightProbe];
h3d_scene_RenderMode.__empty_constructs__ = [h3d_scene_RenderMode.Default,h3d_scene_RenderMode.LightProbe];
var h3d_scene_Renderer = function() {
	this.shadows = true;
	this.renderMode = h3d_scene_RenderMode.Default;
	this.effects = [];
	this.debugging = false;
	this.hasSetTarget = false;
	this.emptyPasses = new h3d_pass_PassList();
	this.allPasses = [];
	this.passObjects = new haxe_ds_StringMap();
	this.set_props(this.getDefaultProps());
	var _g = this;
	var frontToBack = true;
	this.frontToBack = function(passes) {
		_g.depthSort(frontToBack,passes);
	};
	var _g1 = this;
	var frontToBack1 = false;
	this.backToFront = function(passes) {
		_g1.depthSort(frontToBack1,passes);
	};
};
$hxClasses["h3d.scene.Renderer"] = h3d_scene_Renderer;
h3d_scene_Renderer.__name__ = "h3d.scene.Renderer";
h3d_scene_Renderer.__super__ = hxd_impl_AnyProps;
h3d_scene_Renderer.prototype = $extend(hxd_impl_AnyProps.prototype,{
	getEffect: function(cl) {
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var f1 = js_Boot.__downcastCheck(f,cl) ? f : null;
			if(f1 != null) {
				return f1;
			}
		}
		return null;
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.dispose();
		}
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.dispose();
		}
		if(this.ctx.lightSystem != null) {
			this.ctx.lightSystem.dispose();
		}
		this.passObjects = new haxe_ds_StringMap();
	}
	,mark: function(id) {
	}
	,addShader: function(s) {
	}
	,getPass: function(c) {
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(js_Boot.__instanceof(p,c)) {
				return p;
			}
		}
		return null;
	}
	,getPassByName: function(name) {
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p.name == name) {
				return p;
			}
		}
		return null;
	}
	,hasFeature: function(f) {
		return h3d_Engine.CURRENT.driver.hasFeature(f);
	}
	,getLightSystem: function() {
		return this.ctx.scene.lightSystem;
	}
	,depthSort: function(frontToBack,passes) {
		var cam = this.ctx.camera.m;
		var _g_o = passes.current;
		while(_g_o != null) {
			var tmp = _g_o;
			_g_o = _g_o.next;
			var p = tmp;
			var z = p.obj.absPos._41 * cam._13 + p.obj.absPos._42 * cam._23 + p.obj.absPos._43 * cam._33 + cam._43;
			var w = p.obj.absPos._41 * cam._14 + p.obj.absPos._42 * cam._24 + p.obj.absPos._43 * cam._34 + cam._44;
			p.depth = z / w;
		}
		if(frontToBack) {
			var list = passes.current;
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer == q.pass.layer ? p.depth > q.depth ? 1 : -1 : p.pass.layer - q.pass.layer) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		} else {
			var list = passes.current;
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer == q.pass.layer ? p.depth > q.depth ? -1 : 1 : p.pass.layer - q.pass.layer) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		}
	}
	,clear: function(color,depth,stencil) {
		this.ctx.engine.clear(color,depth,stencil);
	}
	,allocTarget: function(name,depth,size,format) {
		if(size == null) {
			size = 1.;
		}
		if(depth == null) {
			depth = true;
		}
		return this.ctx.textures.allocTarget(name,Math.round(this.ctx.engine.width * size),Math.round(this.ctx.engine.height * size),depth,format);
	}
	,copy: function(from,to,blend) {
		h3d_pass_Copy.run(from,to,blend);
	}
	,setTarget: function(tex,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
		}
		this.ctx.engine.pushTarget(tex,null,null,depthBinding);
		this.hasSetTarget = true;
	}
	,setTargets: function(textures,depthBinding) {
		if(depthBinding == null) {
			depthBinding = h3d_DepthBinding.ReadWrite;
		}
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
		}
		this.ctx.engine.pushTargets(textures,depthBinding);
		this.hasSetTarget = true;
	}
	,setDepth: function(depthBuffer) {
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
		}
		this.ctx.engine.pushDepth(depthBuffer);
		this.hasSetTarget = true;
	}
	,resetTarget: function() {
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
			this.hasSetTarget = false;
		}
	}
	,has: function(name) {
		return this.passObjects.h[name] != null;
	}
	,setPassFlags: function(pass) {
		pass.rendererFlags |= 1;
	}
	,get: function(name) {
		var p = this.passObjects.h[name];
		if(p == null) {
			return this.emptyPasses;
		}
		p.rendered = true;
		return p.passes;
	}
	,draw: function(name) {
		this.defaultPass.draw(this.get(name));
	}
	,render: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,computeStatic: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,start: function() {
	}
	,process: function(passes) {
		this.hasSetTarget = false;
		var _g = 0;
		var _g1 = this.allPasses;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.setContext(this.ctx);
		}
		var _g = 0;
		while(_g < passes.length) {
			var p = passes[_g];
			++_g;
			this.passObjects.h[p.name] = p;
		}
		this.ctx.textures.begin();
		if(this.ctx.computingStatic) {
			this.computeStatic();
		} else {
			this.render();
		}
		this.resetTarget();
		var _g = 0;
		while(_g < passes.length) {
			var p = passes[_g];
			++_g;
			this.passObjects.h[p.name] = null;
		}
	}
	,__class__: h3d_scene_Renderer
});
var h3d_scene_Scene = function(createRenderer,createLightSystem) {
	if(createLightSystem == null) {
		createLightSystem = true;
	}
	if(createRenderer == null) {
		createRenderer = true;
	}
	this.prevEngine = null;
	h3d_scene_Object.call(this,null);
	this.window = hxd_Window.getInstance();
	this.eventListeners = [];
	this.hitInteractives = [];
	this.interactives = [];
	this.camera = new h3d_Camera();
	var engine = h3d_Engine.CURRENT;
	if(engine != null) {
		this.camera.screenRatio = engine.width / engine.height;
	}
	this.ctx = new h3d_scene_RenderContext();
	if(createRenderer) {
		this.set_renderer(h3d_mat_MaterialSetup.current.createRenderer());
	}
	if(createLightSystem) {
		this.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem();
	}
};
$hxClasses["h3d.scene.Scene"] = h3d_scene_Scene;
h3d_scene_Scene.__name__ = "h3d.scene.Scene";
h3d_scene_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h3d_scene_Scene.__super__ = h3d_scene_Object;
h3d_scene_Scene.prototype = $extend(h3d_scene_Object.prototype,{
	setEvents: function(events) {
		this.events = events;
	}
	,addEventListener: function(f) {
		this.eventListeners.push(f);
	}
	,removeEventListener: function(f) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e == f) {
				HxOverrides.remove(this.eventListeners,e);
				return true;
			}
		}
		return false;
	}
	,dispatchListeners: function(event) {
		var _g = 0;
		var _g1 = this.eventListeners;
		while(_g < _g1.length) {
			var l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	,set_renderer: function(r) {
		this.renderer = r;
		if(r != null) {
			r.ctx = this.ctx;
		}
		return r;
	}
	,sortHitPointByCameraDistance: function(i1,i2) {
		var z1 = i1.hitPoint.w;
		var z2 = i2.hitPoint.w;
		if(z1 > z2) {
			return -1;
		}
		return 1;
	}
	,dispatchEvent: function(event,to) {
		var i = to;
		i.handleEvent(event);
	}
	,isInteractiveVisible: function(i) {
		var o = i;
		while(o != this) {
			if(o == null || (o.flags & 2) == 0) {
				return false;
			}
			o = o.parent;
		}
		return true;
	}
	,handleEvent: function(event,last) {
		if(this.interactives.length == 0) {
			return null;
		}
		if(this.hitInteractives.length == 0) {
			var screenX = (event.relX / this.window.get_width() - 0.5) * 2;
			var screenY = -(event.relY / this.window.get_height() - 0.5) * 2;
			var p0 = this.camera.unproject(screenX,screenY,0);
			var p1 = this.camera.unproject(screenX,screenY,1);
			var x = p0.x;
			var y = p0.y;
			var z = p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p1_x = x1;
			var p1_y = y1;
			var p1_z = z1;
			var x = p1.x;
			var y = p1.y;
			var z = p1.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var p2_x = x1;
			var p2_y = y1;
			var p2_z = z1;
			var r = new h3d_col_Ray();
			r.px = p1_x;
			r.py = p1_y;
			r.pz = p1_z;
			r.lx = p2_x - p1_x;
			r.ly = p2_y - p1_y;
			r.lz = p2_z - p1_z;
			r.normalize();
			var r1 = r;
			var saveR_px = r1.px;
			var saveR_py = r1.py;
			var saveR_pz = r1.pz;
			var saveR_lx = r1.lx;
			var saveR_ly = r1.ly;
			var saveR_lz = r1.lz;
			var priority = -2147483648;
			var _g = 0;
			var _g1 = this.interactives;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i.priority < priority) {
					continue;
				}
				var p = i;
				while(p != null && (p.flags & 2) != 0) p = p.parent;
				if(p != null) {
					continue;
				}
				if(!i.isAbsoluteShape) {
					var minv = i.getInvPos();
					var x = r1.px;
					var y = r1.py;
					var z = r1.pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					var x1 = x;
					var y1 = y;
					var z1 = z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					var p_x = x1;
					var p_y = y1;
					var p_z = z1;
					var px = p_x * minv._11 + p_y * minv._21 + p_z * minv._31 + minv._41;
					var py = p_x * minv._12 + p_y * minv._22 + p_z * minv._32 + minv._42;
					var pz = p_x * minv._13 + p_y * minv._23 + p_z * minv._33 + minv._43;
					p_x = px;
					p_y = py;
					p_z = pz;
					r1.px = p_x;
					r1.py = p_y;
					r1.pz = p_z;
					var x2 = r1.lx;
					var y2 = r1.ly;
					var z2 = r1.lz;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					var x3 = x2;
					var y3 = y2;
					var z3 = z2;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					var _this_x = x3;
					var _this_y = y3;
					var _this_z = z3;
					var px1 = _this_x * minv._11 + _this_y * minv._21 + _this_z * minv._31;
					var py1 = _this_x * minv._12 + _this_y * minv._22 + _this_z * minv._32;
					var pz1 = _this_x * minv._13 + _this_y * minv._23 + _this_z * minv._33;
					_this_x = px1;
					_this_y = py1;
					_this_z = pz1;
					r1.lx = _this_x;
					r1.ly = _this_y;
					r1.lz = _this_z;
					r1.normalize();
				}
				if(r1.lx != r1.lx) {
					r1.px = saveR_px;
					r1.py = saveR_py;
					r1.pz = saveR_pz;
					r1.lx = saveR_lx;
					r1.ly = saveR_ly;
					r1.lz = saveR_lz;
					continue;
				}
				var hit = i.shape.rayIntersection(r1,i.bestMatch);
				if(hit < 0) {
					r1.px = saveR_px;
					r1.py = saveR_py;
					r1.pz = saveR_pz;
					r1.lx = saveR_lx;
					r1.ly = saveR_ly;
					r1.lz = saveR_lz;
					continue;
				}
				var x4 = r1.px + hit * r1.lx;
				var y4 = r1.py + hit * r1.ly;
				var z4 = r1.pz + hit * r1.lz;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				var x5 = x4;
				var y5 = y4;
				var z5 = z4;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				var hitPoint_x = x5;
				var hitPoint_y = y5;
				var hitPoint_z = z5;
				r1.px = saveR_px;
				r1.py = saveR_py;
				r1.pz = saveR_pz;
				r1.lx = saveR_lx;
				r1.ly = saveR_ly;
				r1.lz = saveR_lz;
				i.hitPoint.x = hitPoint_x;
				i.hitPoint.y = hitPoint_y;
				i.hitPoint.z = hitPoint_z;
				if(i.priority > priority) {
					while(this.hitInteractives.length > 0) this.hitInteractives.pop();
					priority = i.priority;
				}
				this.hitInteractives.push(i);
			}
			if(this.hitInteractives.length == 0) {
				return null;
			}
			if(this.hitInteractives.length > 1) {
				var _g = 0;
				var _g1 = this.hitInteractives;
				while(_g < _g1.length) {
					var i = _g1[_g];
					++_g;
					var m = i.invPos;
					var wfactor = 0.;
					if(i.preciseShape != null) {
						var x = r1.px;
						var y = r1.py;
						var z = r1.pz;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						var x1 = x;
						var y1 = y;
						var z1 = z;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						var p_x = x1;
						var p_y = y1;
						var p_z = z1;
						var px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
						var py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
						var pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
						p_x = px;
						p_y = py;
						p_z = pz;
						r1.px = p_x;
						r1.py = p_y;
						r1.pz = p_z;
						var x2 = r1.lx;
						var y2 = r1.ly;
						var z2 = r1.lz;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						var x3 = x2;
						var y3 = y2;
						var z3 = z2;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						var _this_x = x3;
						var _this_y = y3;
						var _this_z = z3;
						var px1 = _this_x * m._11 + _this_y * m._21 + _this_z * m._31;
						var py1 = _this_x * m._12 + _this_y * m._22 + _this_z * m._32;
						var pz1 = _this_x * m._13 + _this_y * m._23 + _this_z * m._33;
						_this_x = px1;
						_this_y = py1;
						_this_z = pz1;
						r1.lx = _this_x;
						r1.ly = _this_y;
						r1.lz = _this_z;
						r1.normalize();
						var hit = i.preciseShape.rayIntersection(r1,i.bestMatch);
						if(hit > 0) {
							var x4 = r1.px + hit * r1.lx;
							var y4 = r1.py + hit * r1.ly;
							var z4 = r1.pz + hit * r1.lz;
							if(z4 == null) {
								z4 = 0.;
							}
							if(y4 == null) {
								y4 = 0.;
							}
							if(x4 == null) {
								x4 = 0.;
							}
							var x5 = x4;
							var y5 = y4;
							var z5 = z4;
							if(z5 == null) {
								z5 = 0.;
							}
							if(y5 == null) {
								y5 = 0.;
							}
							if(x5 == null) {
								x5 = 0.;
							}
							var hitPoint_x = x5;
							var hitPoint_y = y5;
							var hitPoint_z = z5;
							i.hitPoint.x = hitPoint_x;
							i.hitPoint.y = hitPoint_y;
							i.hitPoint.z = hitPoint_z;
						} else {
							wfactor = 1.;
						}
						r1.px = saveR_px;
						r1.py = saveR_py;
						r1.pz = saveR_pz;
						r1.lx = saveR_lx;
						r1.ly = saveR_ly;
						r1.lz = saveR_lz;
					}
					var _this = i.hitPoint;
					var x6 = _this.x;
					var y6 = _this.y;
					var z6 = _this.z;
					var w = _this.w;
					if(w == null) {
						w = 1.;
					}
					if(z6 == null) {
						z6 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					var x7 = x6;
					var y7 = y6;
					var z7 = z6;
					var w1 = w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z7 == null) {
						z7 = 0.;
					}
					if(y7 == null) {
						y7 = 0.;
					}
					if(x7 == null) {
						x7 = 0.;
					}
					var _this_x1 = x7;
					var _this_y1 = y7;
					var _this_z1 = z7;
					var _this_w = w1;
					_this_w = 1;
					var m1 = i.absPos;
					var px2 = _this_x1 * m1._11 + _this_y1 * m1._21 + _this_z1 * m1._31 + _this_w * m1._41;
					var py2 = _this_x1 * m1._12 + _this_y1 * m1._22 + _this_z1 * m1._32 + _this_w * m1._42;
					var pz2 = _this_x1 * m1._13 + _this_y1 * m1._23 + _this_z1 * m1._33 + _this_w * m1._43;
					_this_x1 = px2;
					_this_y1 = py2;
					_this_z1 = pz2;
					var m2 = this.camera.m;
					var px3 = _this_x1 * m2._11 + _this_y1 * m2._21 + _this_z1 * m2._31 + _this_w * m2._41;
					var py3 = _this_x1 * m2._12 + _this_y1 * m2._22 + _this_z1 * m2._32 + _this_w * m2._42;
					var pz3 = _this_x1 * m2._13 + _this_y1 * m2._23 + _this_z1 * m2._33 + _this_w * m2._43;
					var iw = 1 / (_this_x1 * m2._14 + _this_y1 * m2._24 + _this_z1 * m2._34 + _this_w * m2._44);
					_this_x1 = px3 * iw;
					_this_y1 = py3 * iw;
					_this_z1 = pz3 * iw;
					_this_w = 1;
					i.hitPoint.w = _this_z1 + wfactor;
				}
				this.hitInteractives.sort($bind(this,this.sortHitPointByCameraDistance));
			}
			this.hitInteractives.unshift(null);
		}
		while(this.hitInteractives.length > 0) {
			var i = this.hitInteractives.pop();
			if(i == null) {
				return null;
			}
			event.relX = i.hitPoint.x;
			event.relY = i.hitPoint.y;
			event.relZ = i.hitPoint.z;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			if(!event.propagate) {
				while(this.hitInteractives.length > 0) this.hitInteractives.pop();
			}
			return i;
		}
		return null;
	}
	,clone: function(o) {
		var s = o == null ? new h3d_scene_Scene() : o;
		s.camera = this.camera.clone();
		h3d_scene_Object.prototype.clone.call(this,s);
		return s;
	}
	,dispose: function() {
		if((this.flags & 32) != 0) {
			this.onRemove();
		}
		this.ctx.dispose();
		if(this.renderer != null) {
			this.renderer.dispose();
			this.set_renderer(new h3d_scene_Renderer());
		}
	}
	,addEventTarget: function(i) {
		if(this.interactives.indexOf(i) >= 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.interactives.push(i);
	}
	,removeEventTarget: function(i) {
		if(HxOverrides.remove(this.interactives,i)) {
			if(this.events != null) {
				this.events.onRemove(i);
			}
			HxOverrides.remove(this.hitInteractives,i);
		}
	}
	,setElapsedTime: function(elapsedTime) {
		this.ctx.elapsedTime = elapsedTime;
	}
	,syncOnly: function(et) {
		var engine = h3d_Engine.CURRENT;
		this.setElapsedTime(et);
		var t = engine.getCurrentTarget();
		if(t == null) {
			this.camera.screenRatio = engine.width / engine.height;
		} else {
			this.camera.screenRatio = t.width / t.height;
		}
		this.camera.update();
		this.ctx.camera = this.camera;
		this.ctx.engine = engine;
		this.ctx.scene = this;
		this.ctx.start();
		this.syncRec(this.ctx);
		this.ctx.camera = null;
		this.ctx.engine = null;
		this.ctx.scene = null;
	}
	,computeStatic: function() {
		var old = this.ctx.elapsedTime;
		this.ctx.elapsedTime = 0;
		this.ctx.computingStatic = true;
		this.render(h3d_Engine.CURRENT);
		this.ctx.computingStatic = false;
		this.ctx.elapsedTime = old;
	}
	,onContextLost: function() {
		this.ctx.wasContextLost = true;
	}
	,render: function(engine) {
		if((this.flags & 32) == 0) {
			this.onAdd();
		}
		var t = engine.getCurrentTarget();
		if(t == null) {
			this.camera.screenRatio = engine.width / engine.height;
		} else {
			this.camera.screenRatio = t.width / t.height;
		}
		this.camera.update();
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1);
		}
		this.ctx.camera = this.camera;
		this.ctx.engine = engine;
		this.ctx.scene = this;
		this.ctx.start();
		this.renderer.start();
		this.syncRec(this.ctx);
		this.emitRec(this.ctx);
		var passes = [];
		var passIndex = -1;
		var _g = 0;
		var _g1 = this.ctx.passes.length;
		while(_g < _g1) {
			var passId = _g++;
			var curPass = this.ctx.passes[passId];
			if(curPass == null) {
				continue;
			}
			var pobjs = this.ctx.cachedPassObjects[++passIndex];
			if(pobjs == null) {
				pobjs = new h3d_scene_PassObjects();
				this.ctx.cachedPassObjects[passIndex] = pobjs;
			}
			pobjs.name = curPass.pass.name;
			var _this = pobjs.passes;
			_this.current = curPass;
			_this.discarded = _this.lastDisc = null;
			passes.push(pobjs);
		}
		if(this.lightSystem != null) {
			this.ctx.lightSystem = this.lightSystem;
			this.lightSystem.initLights(this.ctx);
		}
		this.renderer.process(passes);
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0);
		}
		this.ctx.done();
		this.ctx.wasContextLost = false;
		this.ctx.scene = null;
		this.ctx.camera = null;
		this.ctx.engine = null;
		var _g = 0;
		var _g1 = passIndex;
		while(_g < _g1) {
			var i = _g++;
			var p = this.ctx.cachedPassObjects[i];
			p.name = null;
			var _this = p.passes;
			_this.current = null;
			_this.discarded = _this.lastDisc = null;
		}
	}
	,setOutputTarget: function(engine,tex) {
		if(tex != null) {
			if(this.prevDB != null) {
				throw haxe_Exception.thrown("missing setOutputTarget()");
			}
			engine.pushTarget(tex);
			engine.width = tex.width;
			engine.height = tex.height;
			this.prevDB = this.ctx.textures.defaultDepthBuffer;
			this.prevEngine = engine;
			this.ctx.textures.defaultDepthBuffer = tex.depthBuffer;
		} else {
			this.prevEngine.popTarget();
			this.prevEngine.width = this.prevDB.width;
			this.prevEngine.height = this.prevDB.height;
			this.ctx.textures.defaultDepthBuffer = this.prevDB;
			this.prevDB = null;
			this.prevEngine = null;
		}
	}
	,__class__: h3d_scene_Scene
});
var h3d_scene_Joint = function(skin,j) {
	h3d_scene_Object.call(this,null);
	this.name = j.name;
	this.skin = skin;
	this.parent = skin;
	this.index = j.index;
};
$hxClasses["h3d.scene.Joint"] = h3d_scene_Joint;
h3d_scene_Joint.__name__ = "h3d.scene.Joint";
h3d_scene_Joint.__super__ = h3d_scene_Object;
h3d_scene_Joint.prototype = $extend(h3d_scene_Object.prototype,{
	getObjectByName: function(name) {
		var sk = this.skin.getSkinData();
		var j = sk.namedJoints.h[name];
		if(j == null) {
			return null;
		}
		var cur = sk.allJoints[this.index];
		if(cur.index != this.index) {
			throw haxe_Exception.thrown("assert");
		}
		var jp = j.parent;
		while(jp != null) {
			if(jp == cur) {
				var jo = new h3d_scene_Joint(this.skin,j);
				jo.parent = this;
				return jo;
			}
			jp = jp.parent;
		}
		return null;
	}
	,syncPos: function() {
		var p = this.parent;
		while(p != null) {
			if((p.flags & 1) != 0) {
				if(this.skin.jointsAbsPosInv == null) {
					var this1 = new h3d_MatrixImpl();
					this.skin.jointsAbsPosInv = this1;
					this.skin.jointsAbsPosInv.zero();
				}
				if(this.skin.jointsAbsPosInv._44 == 0) {
					this.skin.jointsAbsPosInv.inverse3x4(this.parent.absPos);
				}
				this.parent.syncPos();
				this.lastFrame = -1;
				break;
			}
			p = p.parent;
		}
		if(this.lastFrame != this.skin.lastFrame) {
			this.lastFrame = this.skin.lastFrame;
			this.absPos.load(this.skin.currentAbsPose[this.index]);
			if(this.skin.jointsAbsPosInv != null && this.skin.jointsAbsPosInv._44 != 0) {
				this.absPos.multiply3x4(this.absPos,this.skin.jointsAbsPosInv);
				this.absPos.multiply3x4(this.absPos,this.parent.absPos);
			}
		}
	}
	,__class__: h3d_scene_Joint
});
var h3d_scene_Skin = function(s,mat,parent) {
	this.enableRetargeting = true;
	h3d_scene_MultiMaterial.call(this,null,mat,parent);
	if(s != null) {
		this.setSkinData(s);
	}
};
$hxClasses["h3d.scene.Skin"] = h3d_scene_Skin;
h3d_scene_Skin.__name__ = "h3d.scene.Skin";
h3d_scene_Skin.__super__ = h3d_scene_MultiMaterial;
h3d_scene_Skin.prototype = $extend(h3d_scene_MultiMaterial.prototype,{
	clone: function(o) {
		var s = o == null ? new h3d_scene_Skin(null,this.materials.slice()) : o;
		h3d_scene_MultiMaterial.prototype.clone.call(this,s);
		s.setSkinData(this.skinData);
		s.currentRelPose = this.currentRelPose.slice();
		return s;
	}
	,addBoundsRec: function(b,relativeTo) {
		var old = this.primitive;
		this.set_primitive(null);
		h3d_scene_MultiMaterial.prototype.addBoundsRec.call(this,b,relativeTo);
		this.set_primitive(old);
		if((this.flags & 512) != 0) {
			return;
		}
		this.syncJoints();
		if(this.skinData.vertexWeights == null) {
			(js_Boot.__cast(this.primitive , h3d_prim_HMDModel)).loadSkin(this.skinData);
		}
		var _this = this.getAbsPos();
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var absScale_x = x;
		var absScale_y = y;
		var absScale_z = z;
		absScale_x = Math.sqrt(_this._11 * _this._11 + _this._12 * _this._12 + _this._13 * _this._13);
		absScale_y = Math.sqrt(_this._21 * _this._21 + _this._22 * _this._22 + _this._23 * _this._23);
		absScale_z = Math.sqrt(_this._31 * _this._31 + _this._32 * _this._32 + _this._33 * _this._33);
		if(_this._11 * (_this._22 * _this._33 - _this._23 * _this._32) + _this._12 * (_this._23 * _this._31 - _this._21 * _this._33) + _this._13 * (_this._21 * _this._32 - _this._22 * _this._31) < 0) {
			absScale_x *= -1;
			absScale_y *= -1;
			absScale_z *= -1;
		}
		var scale = Math.max(Math.max(absScale_x,absScale_y),absScale_z);
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.offsetRay < 0) {
				continue;
			}
			var m = this.currentPalette[j.bindIndex];
			var _this = j.offsets;
			var x = _this.xMin;
			var y = _this.yMin;
			var z = _this.zMin;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var pt_x = x1;
			var pt_y = y1;
			var pt_z = z1;
			if(m != null) {
				var px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
				var py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
				var pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
				pt_x = px;
				pt_y = py;
				pt_z = pz;
				var x2 = pt_x;
				var y2 = pt_y;
				var z2 = pt_z;
				var r = j.offsetRay * scale;
				if(x2 - r < b.xMin) {
					b.xMin = x2 - r;
				}
				if(x2 + r > b.xMax) {
					b.xMax = x2 + r;
				}
				if(y2 - r < b.yMin) {
					b.yMin = y2 - r;
				}
				if(y2 + r > b.yMax) {
					b.yMax = y2 + r;
				}
				if(z2 - r < b.zMin) {
					b.zMin = z2 - r;
				}
				if(z2 + r > b.zMax) {
					b.zMax = z2 + r;
				}
				var _this1 = j.offsets;
				var x3 = _this1.xMax;
				var y3 = _this1.yMax;
				var z3 = _this1.zMax;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				var x4 = x3;
				var y4 = y3;
				var z4 = z3;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				var pt_x1 = x4;
				var pt_y1 = y4;
				var pt_z1 = z4;
				var px1 = pt_x1 * m._11 + pt_y1 * m._21 + pt_z1 * m._31 + m._41;
				var py1 = pt_x1 * m._12 + pt_y1 * m._22 + pt_z1 * m._32 + m._42;
				var pz1 = pt_x1 * m._13 + pt_y1 * m._23 + pt_z1 * m._33 + m._43;
				pt_x1 = px1;
				pt_y1 = py1;
				pt_z1 = pz1;
				var x5 = pt_x1;
				var y5 = pt_y1;
				var z5 = pt_z1;
				var r1 = j.offsetRay * scale;
				if(x5 - r1 < b.xMin) {
					b.xMin = x5 - r1;
				}
				if(x5 + r1 > b.xMax) {
					b.xMax = x5 + r1;
				}
				if(y5 - r1 < b.yMin) {
					b.yMin = y5 - r1;
				}
				if(y5 + r1 > b.yMax) {
					b.yMax = y5 + r1;
				}
				if(z5 - r1 < b.zMin) {
					b.zMin = z5 - r1;
				}
				if(z5 + r1 > b.zMax) {
					b.zMax = z5 + r1;
				}
			}
		}
	}
	,getCurrentSkeletonBounds: function() {
		this.syncJoints();
		var b = new h3d_col_Bounds();
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.bindIndex < 0) {
				continue;
			}
			var r = this.currentAbsPose[j.index];
			var x = r._41;
			var y = r._42;
			var z = r._43;
			if(x < b.xMin) {
				b.xMin = x;
			}
			if(x > b.xMax) {
				b.xMax = x;
			}
			if(y < b.yMin) {
				b.yMin = y;
			}
			if(y > b.yMax) {
				b.yMax = y;
			}
			if(z < b.zMin) {
				b.zMin = z;
			}
			if(z > b.zMax) {
				b.zMax = z;
			}
		}
		return b;
	}
	,getObjectByName: function(name) {
		if(this.skinData != null && this.skinData.name == name) {
			return this;
		}
		var o = h3d_scene_MultiMaterial.prototype.getObjectByName.call(this,name);
		if(o != null) {
			return o;
		}
		if(this.skinData != null) {
			var j = this.skinData.namedJoints.h[name];
			if(j != null) {
				return new h3d_scene_Joint(this,j);
			}
		}
		return null;
	}
	,getLocalCollider: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getGlobalCollider: function() {
		var col = js_Boot.__cast(this.primitive.getCollider() , h3d_col_OptimizedCollider);
		(js_Boot.__cast(this.primitive , h3d_prim_HMDModel)).loadSkin(this.skinData);
		return new h3d_col_SkinCollider(this,js_Boot.__cast(col.b , h3d_col_PolygonBuffer));
	}
	,calcAbsPos: function() {
		h3d_scene_MultiMaterial.prototype.calcAbsPos.call(this);
		this.jointsUpdated = true;
	}
	,getSkinData: function() {
		return this.skinData;
	}
	,setSkinData: function(s,shaderInit) {
		if(shaderInit == null) {
			shaderInit = true;
		}
		this.skinData = s;
		this.jointsUpdated = true;
		this.set_primitive(s.primitive);
		if(shaderInit) {
			var hasNormalMap = false;
			var _g = 0;
			var _g1 = this.materials;
			while(_g < _g1.length) {
				var m = _g1[_g];
				++_g;
				if(m != null && m.get_normalMap() != null) {
					hasNormalMap = true;
					break;
				}
			}
			this.skinShader = hasNormalMap ? new h3d_shader_SkinTangent() : new h3d_shader_Skin();
			var _this = this.skinShader;
			_this.constModified = true;
			_this.fourBonesByVertex__ = this.skinData.bonesPerVertex == 4;
			var maxBones = 0;
			if(this.skinData.splitJoints != null) {
				var _g = 0;
				var _g1 = this.skinData.splitJoints;
				while(_g < _g1.length) {
					var s = _g1[_g];
					++_g;
					if(s.joints.length > maxBones) {
						maxBones = s.joints.length;
					}
				}
			} else {
				maxBones = this.skinData.boundJoints.length;
			}
			if(this.skinShader.MaxBones__ < maxBones) {
				var _this = this.skinShader;
				_this.constModified = true;
				_this.MaxBones__ = maxBones;
			}
			var _g = 0;
			var _g1 = this.materials;
			while(_g < _g1.length) {
				var m = _g1[_g];
				++_g;
				if(m != null) {
					var s = m.passes.getShader(h3d_shader_SkinTangent);
					if(s != null) {
						m.passes.removeShader(s);
					}
					if(m.get_normalMap() != null) {
						m.passes.addShaderAtIndex(this.skinShader,m.passes.getShaderIndex(m.normalShader) + 1);
					} else {
						m.passes.addShader(this.skinShader);
					}
					if(this.skinData.splitJoints != null) {
						m.passes.set_dynamicParameters(true);
					}
				}
			}
		}
		this.currentRelPose = [];
		this.currentAbsPose = [];
		this.currentPalette = [];
		this.paletteChanged = true;
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			this.currentAbsPose.push(h3d_Matrix.I());
		}
		var _g = 0;
		var _g1 = this.skinData.boundJoints.length;
		while(_g < _g1) {
			var i = _g++;
			this.currentPalette.push(h3d_Matrix.I());
		}
		if(this.skinData.splitJoints != null) {
			this.splitPalette = [];
			var _g = 0;
			var _g1 = this.skinData.splitJoints;
			while(_g < _g1.length) {
				var a = _g1[_g];
				++_g;
				var tmp = this.splitPalette;
				var _g2 = [];
				var _g3 = 0;
				var _g4 = a.joints;
				while(_g3 < _g4.length) {
					var j = _g4[_g3];
					++_g3;
					_g2.push(this.currentPalette[j.bindIndex]);
				}
				tmp.push(_g2);
			}
		} else {
			this.splitPalette = null;
		}
	}
	,sync: function(ctx) {
		if(!ctx.visibleFlag && (this.flags & 64) == 0) {
			return;
		}
		this.syncJoints();
	}
	,syncJoints: function() {
		if(!this.jointsUpdated) {
			return;
		}
		var tmpMat = h3d_scene_Skin.TMP_MAT;
		var _g = 0;
		var _g1 = this.skinData.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.follow != null) {
				continue;
			}
			var id = j.index;
			var m = this.currentAbsPose[id];
			var r = this.currentRelPose[id];
			var bid = j.bindIndex;
			if(r == null) {
				r = j.defMat;
			} else if(j.retargetAnim && this.enableRetargeting) {
				tmpMat.load(r);
				r = tmpMat;
				r._41 = j.defMat._41;
				r._42 = j.defMat._42;
				r._43 = j.defMat._43;
			}
			if(j.parent == null) {
				var _this = m;
				var b = this.absPos;
				var m11 = r._11;
				var m12 = r._12;
				var m13 = r._13;
				var m21 = r._21;
				var m22 = r._22;
				var m23 = r._23;
				var a31 = r._31;
				var a32 = r._32;
				var a33 = r._33;
				var a41 = r._41;
				var a42 = r._42;
				var a43 = r._43;
				var b11 = b._11;
				var b12 = b._12;
				var b13 = b._13;
				var b21 = b._21;
				var b22 = b._22;
				var b23 = b._23;
				var b31 = b._31;
				var b32 = b._32;
				var b33 = b._33;
				var b41 = b._41;
				var b42 = b._42;
				var b43 = b._43;
				_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
				_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
				_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
				_this._14 = 0;
				_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
				_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
				_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
				_this._24 = 0;
				_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
				_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
				_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
				_this._34 = 0;
				_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
				_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
				_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
				_this._44 = 1;
			} else {
				var _this1 = m;
				var b1 = this.currentAbsPose[j.parent.index];
				var m111 = r._11;
				var m121 = r._12;
				var m131 = r._13;
				var m211 = r._21;
				var m221 = r._22;
				var m231 = r._23;
				var a311 = r._31;
				var a321 = r._32;
				var a331 = r._33;
				var a411 = r._41;
				var a421 = r._42;
				var a431 = r._43;
				var b111 = b1._11;
				var b121 = b1._12;
				var b131 = b1._13;
				var b211 = b1._21;
				var b221 = b1._22;
				var b231 = b1._23;
				var b311 = b1._31;
				var b321 = b1._32;
				var b331 = b1._33;
				var b411 = b1._41;
				var b421 = b1._42;
				var b431 = b1._43;
				_this1._11 = m111 * b111 + m121 * b211 + m131 * b311;
				_this1._12 = m111 * b121 + m121 * b221 + m131 * b321;
				_this1._13 = m111 * b131 + m121 * b231 + m131 * b331;
				_this1._14 = 0;
				_this1._21 = m211 * b111 + m221 * b211 + m231 * b311;
				_this1._22 = m211 * b121 + m221 * b221 + m231 * b321;
				_this1._23 = m211 * b131 + m221 * b231 + m231 * b331;
				_this1._24 = 0;
				_this1._31 = a311 * b111 + a321 * b211 + a331 * b311;
				_this1._32 = a311 * b121 + a321 * b221 + a331 * b321;
				_this1._33 = a311 * b131 + a321 * b231 + a331 * b331;
				_this1._34 = 0;
				_this1._41 = a411 * b111 + a421 * b211 + a431 * b311 + b411;
				_this1._42 = a411 * b121 + a421 * b221 + a431 * b321 + b421;
				_this1._43 = a411 * b131 + a421 * b231 + a431 * b331 + b431;
				_this1._44 = 1;
			}
			if(bid >= 0) {
				var _this2 = this.currentPalette[bid];
				var a = j.transPos;
				var m112 = a._11;
				var m122 = a._12;
				var m132 = a._13;
				var m212 = a._21;
				var m222 = a._22;
				var m232 = a._23;
				var a312 = a._31;
				var a322 = a._32;
				var a332 = a._33;
				var a412 = a._41;
				var a422 = a._42;
				var a432 = a._43;
				var b112 = m._11;
				var b122 = m._12;
				var b132 = m._13;
				var b212 = m._21;
				var b222 = m._22;
				var b232 = m._23;
				var b312 = m._31;
				var b322 = m._32;
				var b332 = m._33;
				var b412 = m._41;
				var b422 = m._42;
				var b432 = m._43;
				_this2._11 = m112 * b112 + m122 * b212 + m132 * b312;
				_this2._12 = m112 * b122 + m122 * b222 + m132 * b322;
				_this2._13 = m112 * b132 + m122 * b232 + m132 * b332;
				_this2._14 = 0;
				_this2._21 = m212 * b112 + m222 * b212 + m232 * b312;
				_this2._22 = m212 * b122 + m222 * b222 + m232 * b322;
				_this2._23 = m212 * b132 + m222 * b232 + m232 * b332;
				_this2._24 = 0;
				_this2._31 = a312 * b112 + a322 * b212 + a332 * b312;
				_this2._32 = a312 * b122 + a322 * b222 + a332 * b322;
				_this2._33 = a312 * b132 + a322 * b232 + a332 * b332;
				_this2._34 = 0;
				_this2._41 = a412 * b112 + a422 * b212 + a432 * b312 + b412;
				_this2._42 = a412 * b122 + a422 * b222 + a432 * b322 + b422;
				_this2._43 = a412 * b132 + a422 * b232 + a432 * b332 + b432;
				_this2._44 = 1;
			}
		}
		this.skinShader.bonesMatrixes__ = this.currentPalette;
		if(this.jointsAbsPosInv != null) {
			this.jointsAbsPosInv._44 = 0;
		}
		this.jointsUpdated = false;
	}
	,emit: function(ctx) {
		this.syncJoints();
		if(this.splitPalette == null) {
			h3d_scene_MultiMaterial.prototype.emit.call(this,ctx);
		} else {
			var _g = 0;
			var _g1 = this.splitPalette.length;
			while(_g < _g1) {
				var i = _g++;
				var m = this.materials[this.skinData.splitJoints[i].material];
				if(m != null) {
					var index = i;
					if(index == null) {
						index = 0;
					}
					var p = m.passes;
					while(p != null) {
						if(!p.culled) {
							ctx.emitPass(p,this).index = index;
						}
						p = p.nextPass;
					}
				}
			}
		}
		if(this.showJoints) {
			if(this.jointsGraphics == null) {
				this.jointsGraphics = new h3d_scene_Graphics(this);
				this.jointsGraphics.material.passes.depth(false,h3d_mat_Compare.Always);
				this.jointsGraphics.material.passes.setPassName("alpha");
			}
			var topParent = this;
			while(topParent.parent != null) topParent = topParent.parent;
			this.jointsGraphics.set_follow(topParent);
			var g = this.jointsGraphics;
			g.clear();
			var _g = 0;
			var _g1 = this.skinData.allJoints;
			while(_g < _g1.length) {
				var j = _g1[_g];
				++_g;
				var m = this.currentAbsPose[j.index];
				var mp = j.parent == null ? this.absPos : this.currentAbsPose[j.parent.index];
				g.lineStyle(1,j.parent == null ? -16776961 : -256);
				g.moveTo(mp._41,mp._42,mp._43);
				g.lineTo(m._41,m._42,m._43);
			}
		} else if(this.jointsGraphics != null) {
			var _this = this.jointsGraphics;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.jointsGraphics = null;
		}
	}
	,draw: function(ctx) {
		if(this.splitPalette == null) {
			h3d_scene_MultiMaterial.prototype.draw.call(this,ctx);
		} else {
			var i = ctx.drawPass.index;
			this.skinShader.bonesMatrixes__ = this.splitPalette[i];
			this.primitive.selectMaterial(i);
			ctx.uploadParams();
			this.primitive.render(ctx.engine);
		}
	}
	,__class__: h3d_scene_Skin
});
var h3d_scene_fwd_Light = function(shader,parent) {
	this.priority = 0;
	this.cullingDistance = -1;
	h3d_scene_Light.call(this,shader,parent);
};
$hxClasses["h3d.scene.fwd.Light"] = h3d_scene_fwd_Light;
h3d_scene_fwd_Light.__name__ = "h3d.scene.fwd.Light";
h3d_scene_fwd_Light.__super__ = h3d_scene_Light;
h3d_scene_fwd_Light.prototype = $extend(h3d_scene_Light.prototype,{
	get_enableSpecular: function() {
		return false;
	}
	,set_enableSpecular: function(b) {
		if(b) {
			throw haxe_Exception.thrown("Not implemented for this light");
		}
		return false;
	}
	,__class__: h3d_scene_fwd_Light
});
var h3d_scene_fwd_LightSystem = function() {
	this.perPixelLighting = true;
	this.maxLightsPerObject = 6;
	h3d_scene_LightSystem.call(this);
	var x = 0.5;
	var y = 0.5;
	var z = 0.5;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.ambientLight = new h3d_VectorImpl(x,y,z);
	this.ambientShader = new h3d_shader_AmbientLight();
	this.set_additiveLighting(true);
};
$hxClasses["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem;
h3d_scene_fwd_LightSystem.__name__ = "h3d.scene.fwd.LightSystem";
h3d_scene_fwd_LightSystem.__super__ = h3d_scene_LightSystem;
h3d_scene_fwd_LightSystem.prototype = $extend(h3d_scene_LightSystem.prototype,{
	get_additiveLighting: function() {
		var value = this.ambientShader;
		return (((value) instanceof h3d_shader_AmbientLight) ? value : null).additive__;
	}
	,set_additiveLighting: function(b) {
		var value = this.ambientShader;
		var _this = ((value) instanceof h3d_shader_AmbientLight) ? value : null;
		_this.constModified = true;
		return _this.additive__ = b;
	}
	,initLights: function(ctx) {
		this.lightCount = 0;
		this.ctx = ctx;
		this.cullLights();
		h3d_scene_LightSystem.prototype.initLights.call(this,ctx);
		if(this.lightCount <= this.maxLightsPerObject) {
			var list = ctx.lights;
			var cmp = $bind(this,this.sortLight);
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			ctx.lights = tmp;
		}
	}
	,initGlobals: function(globals) {
		globals.set("global.ambientLight",this.ambientLight);
		globals.set("global.perPixelLighting",this.perPixelLighting);
	}
	,cullLights: function() {
		var ll = this.ctx.lights;
		var prev = null;
		var s = new h3d_col_Sphere();
		while(ll != null) {
			var l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
			if(l != null) {
				s.x = l.absPos._41;
				s.y = l.absPos._42;
				s.z = l.absPos._43;
				s.r = l.cullingDistance;
			}
			if(l == null || l.cullingDistance > 0 && !this.ctx.computingStatic && !this.ctx.camera.frustum.hasSphere(s)) {
				if(prev == null) {
					this.ctx.lights = ll.next;
				} else {
					prev.next = ll.next;
				}
				ll = ll.next;
				continue;
			}
			this.lightCount++;
			l.objectDistance = 0.;
			prev = ll;
			ll = ll.next;
		}
	}
	,sortLight: function(l1,l2) {
		var p = l1.priority - l2.priority;
		if(p != 0) {
			return -p;
		}
		if(l1.objectDistance < l2.objectDistance) {
			return -1;
		} else {
			return 1;
		}
	}
	,computeLight: function(obj,shaders) {
		var _gthis = this;
		if(this.lightCount > this.maxLightsPerObject) {
			var ll = this.ctx.lights;
			while(ll != null) {
				var l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
				if((obj.flags & 16) != 0) {
					var dx = l.absPos._41 - this.ctx.camera.target.x;
					var dy = l.absPos._42 - this.ctx.camera.target.y;
					var dz = l.absPos._43 - this.ctx.camera.target.z;
					if(dz == null) {
						dz = 0.;
					}
					l.objectDistance = dx * dx + dy * dy + dz * dz;
				} else {
					var dx1 = l.absPos._41 - obj.absPos._41;
					var dy1 = l.absPos._42 - obj.absPos._42;
					var dz1 = l.absPos._43 - obj.absPos._43;
					if(dz1 == null) {
						dz1 = 0.;
					}
					l.objectDistance = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;
				}
				ll = ll.next;
			}
			var list = this.ctx.lights;
			var cmp = $bind(this,this.sortLight);
			var tmp;
			if(list == null) {
				tmp = null;
			} else {
				var insize = 1;
				var nmerges;
				var psize = 0;
				var qsize = 0;
				var p;
				var q;
				var e;
				var tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						var _g = 0;
						var _g1 = insize;
						while(_g < _g1) {
							var i = _g++;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			this.ctx.lights = tmp;
		}
		shaders = _gthis.ctx.allocShaderList(this.ambientShader,shaders);
		var l = this.ctx.lights;
		var i = 0;
		while(l != null) {
			if(i++ == this.maxLightsPerObject) {
				break;
			}
			shaders = _gthis.ctx.allocShaderList(l.shader,shaders);
			l = l.next;
		}
		return shaders;
	}
	,__class__: h3d_scene_fwd_LightSystem
});
var h3d_scene_fwd_DepthPass = function() {
	this.enableSky = false;
	h3d_pass_Output.call(this,"depth",[hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]);
	this.depthMapId = hxsl_Globals.allocID("depthMap");
};
$hxClasses["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass;
h3d_scene_fwd_DepthPass.__name__ = "h3d.scene.fwd.DepthPass";
h3d_scene_fwd_DepthPass.__super__ = h3d_pass_Output;
h3d_scene_fwd_DepthPass.prototype = $extend(h3d_pass_Output.prototype,{
	draw: function(passes,sort) {
		var texture = this.ctx.textures.allocTarget("depthMap",this.ctx.engine.width,this.ctx.engine.height,true);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(this.enableSky ? 0 : 16711680,1);
		h3d_pass_Output.prototype.draw.call(this,passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.globals.map.h[this.depthMapId] = { texture : texture};
	}
	,__class__: h3d_scene_fwd_DepthPass
});
var h3d_scene_fwd_NormalPass = function() {
	h3d_pass_Output.call(this,"normal",[hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))]);
	this.normalMapId = hxsl_Globals.allocID("normalMap");
};
$hxClasses["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass;
h3d_scene_fwd_NormalPass.__name__ = "h3d.scene.fwd.NormalPass";
h3d_scene_fwd_NormalPass.__super__ = h3d_pass_Output;
h3d_scene_fwd_NormalPass.prototype = $extend(h3d_pass_Output.prototype,{
	draw: function(passes,sort) {
		var texture = this.ctx.textures.allocTarget("normalMap",this.ctx.engine.width,this.ctx.engine.height);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(8421504,1);
		h3d_pass_Output.prototype.draw.call(this,passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.globals.map.h[this.normalMapId] = texture;
	}
	,__class__: h3d_scene_fwd_NormalPass
});
var h3d_scene_fwd_Renderer = function() {
	this.shadow = new h3d_pass_DefaultShadowMap(1024);
	this.normal = new h3d_scene_fwd_NormalPass();
	this.depth = new h3d_scene_fwd_DepthPass();
	h3d_scene_Renderer.call(this);
	this.defaultPass = new h3d_pass_Output("default");
	this.allPasses = [this.defaultPass,this.depth,this.normal,this.shadow];
};
$hxClasses["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer;
h3d_scene_fwd_Renderer.__name__ = "h3d.scene.fwd.Renderer";
h3d_scene_fwd_Renderer.__super__ = h3d_scene_Renderer;
h3d_scene_fwd_Renderer.prototype = $extend(h3d_scene_Renderer.prototype,{
	get_def: function() {
		return this.defaultPass;
	}
	,renderPass: function(p,passes,sort) {
		p.draw(passes,sort);
	}
	,getPassByName: function(name) {
		if(name == "alpha" || name == "additive") {
			return this.defaultPass;
		}
		return h3d_scene_Renderer.prototype.getPassByName.call(this,name);
	}
	,render: function() {
		if(this.has("shadow")) {
			this.renderPass(this.shadow,this.get("shadow"));
		}
		if(this.has("depth")) {
			this.renderPass(this.depth,this.get("depth"));
		}
		if(this.has("normal")) {
			this.renderPass(this.normal,this.get("normal"));
		}
		this.renderPass(this.defaultPass,this.get("default"));
		this.renderPass(this.defaultPass,this.get("alpha"),this.backToFront);
		this.renderPass(this.defaultPass,this.get("additive"));
	}
	,__class__: h3d_scene_fwd_Renderer
});
var h3d_shader_AmbientLight = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight;
h3d_shader_AmbientLight.__name__ = "h3d.shader.AmbientLight";
h3d_shader_AmbientLight.__super__ = hxsl_Shader;
h3d_shader_AmbientLight.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 2;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.additive__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_AmbientLight.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		return s;
	}
	,__class__: h3d_shader_AmbientLight
});
var h3d_shader_Base2d = function() {
	this.viewportB__ = new h3d_VectorImpl(0.,0.,0.);
	this.viewportA__ = new h3d_VectorImpl(0.,0.,0.);
	this.halfPixelInverse__ = new h3d_VectorImpl(0.,0.,0.);
	this.uvPos__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.filterMatrixB__ = new h3d_VectorImpl(0.,0.,0.);
	this.filterMatrixA__ = new h3d_VectorImpl(0.,0.,0.);
	this.absoluteMatrixB__ = new h3d_VectorImpl(0.,0.,0.);
	this.absoluteMatrixA__ = new h3d_VectorImpl(0.,0.,0.);
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.zValue__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Base2d"] = h3d_shader_Base2d;
h3d_shader_Base2d.__name__ = "h3d.shader.Base2d";
h3d_shader_Base2d.__super__ = hxsl_Shader;
h3d_shader_Base2d.prototype = $extend(hxsl_Shader.prototype,{
	get_zValue: function() {
		return this.zValue__;
	}
	,set_zValue: function(_v) {
		return this.zValue__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_isRelative: function() {
		return this.isRelative__;
	}
	,set_isRelative: function(_v) {
		this.constModified = true;
		return this.isRelative__ = _v;
	}
	,get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,get_absoluteMatrixA: function() {
		return this.absoluteMatrixA__;
	}
	,set_absoluteMatrixA: function(_v) {
		return this.absoluteMatrixA__ = _v;
	}
	,get_absoluteMatrixB: function() {
		return this.absoluteMatrixB__;
	}
	,set_absoluteMatrixB: function(_v) {
		return this.absoluteMatrixB__ = _v;
	}
	,get_filterMatrixA: function() {
		return this.filterMatrixA__;
	}
	,set_filterMatrixA: function(_v) {
		return this.filterMatrixA__ = _v;
	}
	,get_filterMatrixB: function() {
		return this.filterMatrixB__;
	}
	,set_filterMatrixB: function(_v) {
		return this.filterMatrixB__ = _v;
	}
	,get_hasUVPos: function() {
		return this.hasUVPos__;
	}
	,set_hasUVPos: function(_v) {
		this.constModified = true;
		return this.hasUVPos__ = _v;
	}
	,get_uvPos: function() {
		return this.uvPos__;
	}
	,set_uvPos: function(_v) {
		return this.uvPos__ = _v;
	}
	,get_killAlpha: function() {
		return this.killAlpha__;
	}
	,set_killAlpha: function(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	,get_pixelAlign: function() {
		return this.pixelAlign__;
	}
	,set_pixelAlign: function(_v) {
		this.constModified = true;
		return this.pixelAlign__ = _v;
	}
	,get_halfPixelInverse: function() {
		return this.halfPixelInverse__;
	}
	,set_halfPixelInverse: function(_v) {
		return this.halfPixelInverse__ = _v;
	}
	,get_viewportA: function() {
		return this.viewportA__;
	}
	,set_viewportA: function(_v) {
		return this.viewportA__ = _v;
	}
	,get_viewportB: function() {
		return this.viewportB__;
	}
	,set_viewportB: function(_v) {
		return this.viewportB__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isRelative__) {
			this.constBits |= 1;
		}
		if(this.hasUVPos__) {
			this.constBits |= 2;
		}
		if(this.killAlpha__) {
			this.constBits |= 4;
		}
		if(this.pixelAlign__) {
			this.constBits |= 8;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.zValue__;
		case 1:
			return this.texture__;
		case 2:
			return this.isRelative__;
		case 3:
			return this.color__;
		case 4:
			return this.absoluteMatrixA__;
		case 5:
			return this.absoluteMatrixB__;
		case 6:
			return this.filterMatrixA__;
		case 7:
			return this.filterMatrixB__;
		case 8:
			return this.hasUVPos__;
		case 9:
			return this.uvPos__;
		case 10:
			return this.killAlpha__;
		case 11:
			return this.pixelAlign__;
		case 12:
			return this.halfPixelInverse__;
		case 13:
			return this.viewportA__;
		case 14:
			return this.viewportB__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.zValue__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.zValue__ = val;
			break;
		case 1:
			this.texture__ = val;
			break;
		case 2:
			this.isRelative__ = val;
			break;
		case 3:
			this.color__ = val;
			break;
		case 4:
			this.absoluteMatrixA__ = val;
			break;
		case 5:
			this.absoluteMatrixB__ = val;
			break;
		case 6:
			this.filterMatrixA__ = val;
			break;
		case 7:
			this.filterMatrixB__ = val;
			break;
		case 8:
			this.hasUVPos__ = val;
			break;
		case 9:
			this.uvPos__ = val;
			break;
		case 10:
			this.killAlpha__ = val;
			break;
		case 11:
			this.pixelAlign__ = val;
			break;
		case 12:
			this.halfPixelInverse__ = val;
			break;
		case 13:
			this.viewportA__ = val;
			break;
		case 14:
			this.viewportB__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		if(index == 0) {
			this.zValue__ = val;
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Base2d.prototype);
		s.shader = this.shader;
		s.zValue__ = this.zValue__;
		s.texture__ = this.texture__;
		s.isRelative__ = this.isRelative__;
		s.color__ = this.color__;
		s.absoluteMatrixA__ = this.absoluteMatrixA__;
		s.absoluteMatrixB__ = this.absoluteMatrixB__;
		s.filterMatrixA__ = this.filterMatrixA__;
		s.filterMatrixB__ = this.filterMatrixB__;
		s.hasUVPos__ = this.hasUVPos__;
		s.uvPos__ = this.uvPos__;
		s.killAlpha__ = this.killAlpha__;
		s.pixelAlign__ = this.pixelAlign__;
		s.halfPixelInverse__ = this.halfPixelInverse__;
		s.viewportA__ = this.viewportA__;
		s.viewportB__ = this.viewportB__;
		return s;
	}
	,__class__: h3d_shader_Base2d
});
var h3d_shader_BaseMesh = function() {
	this.specularColor__ = new h3d_VectorImpl(0.,0.,0.);
	this.specularAmount__ = 0;
	this.specularPower__ = 0;
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	hxsl_Shader.call(this);
	var _this = this.color__;
	var x = 1;
	var y = 1;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	_this.w = 1.;
	var _this = this.specularColor__;
	var x = 1;
	var y = 1;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	this.specularPower__ = 50;
	this.specularAmount__ = 1;
};
$hxClasses["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh;
h3d_shader_BaseMesh.__name__ = "h3d.shader.BaseMesh";
h3d_shader_BaseMesh.__super__ = hxsl_Shader;
h3d_shader_BaseMesh.prototype = $extend(hxsl_Shader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,get_specularPower: function() {
		return this.specularPower__;
	}
	,set_specularPower: function(_v) {
		return this.specularPower__ = _v;
	}
	,get_specularAmount: function() {
		return this.specularAmount__;
	}
	,set_specularAmount: function(_v) {
		return this.specularAmount__ = _v;
	}
	,get_specularColor: function() {
		return this.specularColor__;
	}
	,set_specularColor: function(_v) {
		return this.specularColor__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.color__;
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		case 3:
			return this.specularColor__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.color__ = val;
			break;
		case 1:
			this.specularPower__ = val;
			break;
		case 2:
			this.specularAmount__ = val;
			break;
		case 3:
			this.specularColor__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 1:
			this.specularPower__ = val;
			break;
		case 2:
			this.specularAmount__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_BaseMesh.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		s.specularPower__ = this.specularPower__;
		s.specularAmount__ = this.specularAmount__;
		s.specularColor__ = this.specularColor__;
		return s;
	}
	,__class__: h3d_shader_BaseMesh
});
var h3d_shader_Blur = function() {
	this.cubeDir__ = new h3d_MatrixImpl();
	this.fixedColor__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.pixel__ = new h3d_VectorImpl(0.,0.,0.);
	this.offsets__ = [];
	this.values__ = [];
	this.Quality__ = 0;
	this.cameraInverseViewProj__ = new h3d_MatrixImpl();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.Blur"] = h3d_shader_Blur;
h3d_shader_Blur.__name__ = "h3d.shader.Blur";
h3d_shader_Blur.__super__ = h3d_shader_ScreenShader;
h3d_shader_Blur.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_cameraInverseViewProj: function() {
		return this.cameraInverseViewProj__;
	}
	,set_cameraInverseViewProj: function(_v) {
		return this.cameraInverseViewProj__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,get_depthTexture: function() {
		return this.depthTexture__;
	}
	,set_depthTexture: function(_v) {
		return this.depthTexture__ = _v;
	}
	,get_Quality: function() {
		return this.Quality__;
	}
	,set_Quality: function(_v) {
		this.constModified = true;
		return this.Quality__ = _v;
	}
	,get_isDepth: function() {
		return this.isDepth__;
	}
	,set_isDepth: function(_v) {
		this.constModified = true;
		return this.isDepth__ = _v;
	}
	,get_values: function() {
		return this.values__;
	}
	,set_values: function(_v) {
		return this.values__ = _v;
	}
	,get_offsets: function() {
		return this.offsets__;
	}
	,set_offsets: function(_v) {
		return this.offsets__ = _v;
	}
	,get_pixel: function() {
		return this.pixel__;
	}
	,set_pixel: function(_v) {
		return this.pixel__ = _v;
	}
	,get_hasFixedColor: function() {
		return this.hasFixedColor__;
	}
	,set_hasFixedColor: function(_v) {
		this.constModified = true;
		return this.hasFixedColor__ = _v;
	}
	,get_smoothFixedColor: function() {
		return this.smoothFixedColor__;
	}
	,set_smoothFixedColor: function(_v) {
		this.constModified = true;
		return this.smoothFixedColor__ = _v;
	}
	,get_fixedColor: function() {
		return this.fixedColor__;
	}
	,set_fixedColor: function(_v) {
		return this.fixedColor__ = _v;
	}
	,get_isDepthDependant: function() {
		return this.isDepthDependant__;
	}
	,set_isDepthDependant: function(_v) {
		this.constModified = true;
		return this.isDepthDependant__ = _v;
	}
	,get_hasNormal: function() {
		return this.hasNormal__;
	}
	,set_hasNormal: function(_v) {
		this.constModified = true;
		return this.hasNormal__ = _v;
	}
	,get_normalTexture: function() {
		return this.normalTexture__;
	}
	,set_normalTexture: function(_v) {
		return this.normalTexture__ = _v;
	}
	,get_isCube: function() {
		return this.isCube__;
	}
	,set_isCube: function(_v) {
		this.constModified = true;
		return this.isCube__ = _v;
	}
	,get_cubeTexture: function() {
		return this.cubeTexture__;
	}
	,set_cubeTexture: function(_v) {
		return this.cubeTexture__ = _v;
	}
	,get_cubeDir: function() {
		return this.cubeDir__;
	}
	,set_cubeDir: function(_v) {
		return this.cubeDir__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.Quality__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("Quality" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.isDepth__) {
			this.constBits |= 256;
		}
		if(this.hasFixedColor__) {
			this.constBits |= 512;
		}
		if(this.smoothFixedColor__) {
			this.constBits |= 1024;
		}
		if(this.isDepthDependant__) {
			this.constBits |= 2048;
		}
		if(this.hasNormal__) {
			this.constBits |= 4096;
		}
		if(this.isCube__) {
			this.constBits |= 8192;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.cameraInverseViewProj__;
		case 2:
			return this.texture__;
		case 3:
			return this.depthTexture__;
		case 4:
			return this.Quality__;
		case 5:
			return this.isDepth__;
		case 6:
			return this.values__;
		case 7:
			return this.offsets__;
		case 8:
			return this.pixel__;
		case 9:
			return this.hasFixedColor__;
		case 10:
			return this.smoothFixedColor__;
		case 11:
			return this.fixedColor__;
		case 12:
			return this.isDepthDependant__;
		case 13:
			return this.hasNormal__;
		case 14:
			return this.normalTexture__;
		case 15:
			return this.isCube__;
		case 16:
			return this.cubeTexture__;
		case 17:
			return this.cubeDir__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Blur.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.cameraInverseViewProj__ = this.cameraInverseViewProj__;
		s.texture__ = this.texture__;
		s.depthTexture__ = this.depthTexture__;
		s.Quality__ = this.Quality__;
		s.isDepth__ = this.isDepth__;
		s.values__ = this.values__;
		s.offsets__ = this.offsets__;
		s.pixel__ = this.pixel__;
		s.hasFixedColor__ = this.hasFixedColor__;
		s.smoothFixedColor__ = this.smoothFixedColor__;
		s.fixedColor__ = this.fixedColor__;
		s.isDepthDependant__ = this.isDepthDependant__;
		s.hasNormal__ = this.hasNormal__;
		s.normalTexture__ = this.normalTexture__;
		s.isCube__ = this.isCube__;
		s.cubeTexture__ = this.cubeTexture__;
		s.cubeDir__ = this.cubeDir__;
		return s;
	}
	,__class__: h3d_shader_Blur
});
var h3d_shader_ShaderBuffers = function(s) {
	this.globals = new Float32Array(s.globalsSize << 2);
	this.params = new Float32Array(s.paramsSize << 2);
	this.tex = new Array(s.texturesCount);
	this.buffers = s.bufferCount > 0 ? new Array(s.bufferCount) : null;
};
$hxClasses["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers;
h3d_shader_ShaderBuffers.__name__ = "h3d.shader.ShaderBuffers";
h3d_shader_ShaderBuffers.prototype = {
	grow: function(s) {
		var ng = s.globalsSize << 2;
		var np = s.paramsSize << 2;
		var nt = s.texturesCount;
		var nb = s.bufferCount;
		if(this.globals.length < ng) {
			this.globals = new Float32Array(ng);
		}
		if(this.params.length < np) {
			this.params = new Float32Array(np);
		}
		if(this.tex.length < nt) {
			this.tex = new Array(nt);
		}
		if(nb > 0 && (this.buffers == null || this.buffers.length < nb)) {
			this.buffers = new Array(nb);
		}
	}
	,__class__: h3d_shader_ShaderBuffers
};
var h3d_shader_Buffers = function(s) {
	this.vertex = new h3d_shader_ShaderBuffers(s.vertex);
	this.fragment = new h3d_shader_ShaderBuffers(s.fragment);
};
$hxClasses["h3d.shader.Buffers"] = h3d_shader_Buffers;
h3d_shader_Buffers.__name__ = "h3d.shader.Buffers";
h3d_shader_Buffers.prototype = {
	grow: function(s) {
		this.vertex.grow(s.vertex);
		this.fragment.grow(s.fragment);
	}
	,__class__: h3d_shader_Buffers
};
var h3d_shader_ColorAdd = function(color) {
	if(color == null) {
		color = 0;
	}
	this.color__ = new h3d_VectorImpl(0.,0.,0.);
	hxsl_Shader.call(this);
	var _this = this.color__;
	_this.x = (color >> 16 & 255) / 255;
	_this.y = (color >> 8 & 255) / 255;
	_this.z = (color & 255) / 255;
};
$hxClasses["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd;
h3d_shader_ColorAdd.__name__ = "h3d.shader.ColorAdd";
h3d_shader_ColorAdd.__super__ = hxsl_Shader;
h3d_shader_ColorAdd.prototype = $extend(hxsl_Shader.prototype,{
	get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.color__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.color__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ColorAdd.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		return s;
	}
	,__class__: h3d_shader_ColorAdd
});
var h3d_shader_ColorKey = function(v) {
	if(v == null) {
		v = 0;
	}
	this.colorKey__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	hxsl_Shader.call(this);
	var _this = this.colorKey__;
	_this.x = (v >> 16 & 255) / 255;
	_this.y = (v >> 8 & 255) / 255;
	_this.z = (v & 255) / 255;
	_this.w = (v >>> 24) / 255;
};
$hxClasses["h3d.shader.ColorKey"] = h3d_shader_ColorKey;
h3d_shader_ColorKey.__name__ = "h3d.shader.ColorKey";
h3d_shader_ColorKey.__super__ = hxsl_Shader;
h3d_shader_ColorKey.prototype = $extend(hxsl_Shader.prototype,{
	get_colorKey: function() {
		return this.colorKey__;
	}
	,set_colorKey: function(_v) {
		return this.colorKey__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.colorKey__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.colorKey__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ColorKey.prototype);
		s.shader = this.shader;
		s.colorKey__ = this.colorKey__;
		return s;
	}
	,__class__: h3d_shader_ColorKey
});
var h3d_shader_ColorMatrix = function(m) {
	this.enabled__ = true;
	this.matrix__ = new h3d_MatrixImpl();
	hxsl_Shader.call(this);
	if(m != null) {
		this.matrix__.loadValues(m);
	} else {
		this.matrix__.identity();
	}
};
$hxClasses["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix;
h3d_shader_ColorMatrix.__name__ = "h3d.shader.ColorMatrix";
h3d_shader_ColorMatrix.__super__ = hxsl_Shader;
h3d_shader_ColorMatrix.prototype = $extend(hxsl_Shader.prototype,{
	get_matrix: function() {
		return this.matrix__;
	}
	,set_matrix: function(_v) {
		return this.matrix__ = _v;
	}
	,get_enabled: function() {
		return this.enabled__;
	}
	,set_enabled: function(_v) {
		this.constModified = true;
		return this.enabled__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.enabled__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.matrix__;
		case 1:
			return this.enabled__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.matrix__ = val;
			break;
		case 1:
			this.enabled__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_ColorMatrix.prototype);
		s.shader = this.shader;
		s.matrix__ = this.matrix__;
		s.enabled__ = this.enabled__;
		return s;
	}
	,__class__: h3d_shader_ColorMatrix
});
var h3d_shader_DirShadow = function() {
	this.poissonDisk__ = [];
	this.shadowBias__ = 0;
	this.shadowProj__ = new h3d_MatrixImpl();
	this.shadowMapChannel__ = hxsl_Channel.Unknown;
	this.shadowRes__ = new h3d_VectorImpl(0.,0.,0.);
	this.pcfScale__ = 0;
	this.PCF_SAMPLES__ = 0;
	this.shadowPower__ = 0;
	hxsl_Shader.call(this);
	this.set_pcfQuality(1);
};
$hxClasses["h3d.shader.DirShadow"] = h3d_shader_DirShadow;
h3d_shader_DirShadow.__name__ = "h3d.shader.DirShadow";
h3d_shader_DirShadow.__super__ = hxsl_Shader;
h3d_shader_DirShadow.prototype = $extend(hxsl_Shader.prototype,{
	set_pcfQuality: function(q) {
		var _v;
		switch(q) {
		case 2:
			var x = -0.326;
			var y = -0.406;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this1 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.840;
			var y = -0.074;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this2 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.696;
			var y = 0.457;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this3 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.203;
			var y = 0.621;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this4 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.962;
			var y = -0.195;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this5 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.473;
			var y = -0.480;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this6 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.519;
			var y = 0.767;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this7 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.185;
			var y = -0.893;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this8 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.507;
			var y = 0.064;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this9 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.896;
			var y = 0.412;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this10 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.322;
			var y = -0.933;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this11 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.792;
			var y = -0.598;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_v = [this1,this2,this3,this4,this5,this6,this7,this8,this9,this10,this11,new h3d_Vector4Impl(x,y,0.,1.)];
			break;
		case 3:
			var x = -0.613392;
			var y = 0.617481;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this1 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.170019;
			var y = -0.040254;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this2 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.299417;
			var y = 0.791925;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this3 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.645680;
			var y = 0.493210;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this4 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.651784;
			var y = 0.717887;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this5 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.421003;
			var y = 0.027070;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this6 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.817194;
			var y = -0.271096;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this7 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.705374;
			var y = -0.668203;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this8 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.977050;
			var y = -0.108615;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this9 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.063326;
			var y = 0.142369;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this10 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.203528;
			var y = 0.214331;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this11 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.667531;
			var y = 0.326090;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this12 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.098422;
			var y = -0.295755;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this13 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.885922;
			var y = 0.215369;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this14 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.566637;
			var y = 0.605213;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this15 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.039766;
			var y = -0.396100;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this16 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.751946;
			var y = 0.453352;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this17 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.078707;
			var y = -0.715323;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this18 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.075838;
			var y = -0.529344;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this19 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.724479;
			var y = -0.580798;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this20 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.222999;
			var y = -0.215125;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this21 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.467574;
			var y = -0.405438;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this22 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.248268;
			var y = -0.814753;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this23 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.354411;
			var y = -0.887570;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this24 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.175817;
			var y = 0.382366;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this25 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.487472;
			var y = -0.063082;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this26 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.084078;
			var y = 0.898312;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this27 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.488876;
			var y = -0.783441;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this28 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.470016;
			var y = 0.217933;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this29 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.696890;
			var y = -0.549791;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this30 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.149693;
			var y = 0.605762;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this31 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.034211;
			var y = 0.979980;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this32 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.503098;
			var y = -0.308878;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this33 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.016205;
			var y = -0.872921;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this34 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.385784;
			var y = -0.393902;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this35 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.146886;
			var y = -0.859249;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this36 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.643361;
			var y = 0.164098;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this37 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.634388;
			var y = -0.049471;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this38 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.688894;
			var y = 0.007843;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this39 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.464034;
			var y = -0.188818;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this40 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.440840;
			var y = 0.137486;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this41 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.364483;
			var y = 0.511704;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this42 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.034028;
			var y = 0.325968;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this43 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.099094;
			var y = -0.308023;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this44 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.693960;
			var y = -0.366253;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this45 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.678884;
			var y = -0.204688;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this46 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.001801;
			var y = 0.780328;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this47 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.145177;
			var y = -0.898984;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this48 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.062655;
			var y = -0.611866;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this49 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.315226;
			var y = -0.604297;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this50 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.780145;
			var y = 0.486251;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this51 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.371868;
			var y = 0.882138;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this52 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.200476;
			var y = 0.494430;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this53 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.494552;
			var y = -0.711051;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this54 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.612476;
			var y = 0.705252;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this55 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.578845;
			var y = -0.768792;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this56 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.772454;
			var y = -0.090976;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this57 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.504440;
			var y = 0.372295;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this58 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.155736;
			var y = 0.065157;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this59 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.391522;
			var y = 0.849605;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this60 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.620106;
			var y = -0.328104;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this61 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.789239;
			var y = -0.419965;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this62 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.545396;
			var y = 0.538133;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this63 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.178564;
			var y = -0.596057;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_v = [this1,this2,this3,this4,this5,this6,this7,this8,this9,this10,this11,this12,this13,this14,this15,this16,this17,this18,this19,this20,this21,this22,this23,this24,this25,this26,this27,this28,this29,this30,this31,this32,this33,this34,this35,this36,this37,this38,this39,this40,this41,this42,this43,this44,this45,this46,this47,this48,this49,this50,this51,this52,this53,this54,this55,this56,this57,this58,this59,this60,this61,this62,this63,new h3d_Vector4Impl(x,y,0.,1.)];
			break;
		default:
			var x = -0.942;
			var y = -0.399;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this1 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.945;
			var y = -0.768;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this2 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = -0.094;
			var y = -0.929;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var this3 = new h3d_Vector4Impl(x,y,0.,1.);
			var x = 0.344;
			var y = 0.293;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_v = [this1,this2,this3,new h3d_Vector4Impl(x,y,0.,1.)];
		}
		this.poissonDisk__ = _v;
		this.constModified = true;
		this.PCF_SAMPLES__ = this.poissonDisk__.length;
		return q;
	}
	,get_enable: function() {
		return this.enable__;
	}
	,set_enable: function(_v) {
		this.constModified = true;
		return this.enable__ = _v;
	}
	,get_USE_ESM: function() {
		return this.USE_ESM__;
	}
	,set_USE_ESM: function(_v) {
		this.constModified = true;
		return this.USE_ESM__ = _v;
	}
	,get_shadowPower: function() {
		return this.shadowPower__;
	}
	,set_shadowPower: function(_v) {
		return this.shadowPower__ = _v;
	}
	,get_USE_PCF: function() {
		return this.USE_PCF__;
	}
	,set_USE_PCF: function(_v) {
		this.constModified = true;
		return this.USE_PCF__ = _v;
	}
	,get_PCF_SAMPLES: function() {
		return this.PCF_SAMPLES__;
	}
	,set_PCF_SAMPLES: function(_v) {
		this.constModified = true;
		return this.PCF_SAMPLES__ = _v;
	}
	,get_pcfScale: function() {
		return this.pcfScale__;
	}
	,set_pcfScale: function(_v) {
		return this.pcfScale__ = _v;
	}
	,get_shadowRes: function() {
		return this.shadowRes__;
	}
	,set_shadowRes: function(_v) {
		return this.shadowRes__ = _v;
	}
	,get_shadowMap: function() {
		return this.shadowMap__;
	}
	,set_shadowMap: function(_v) {
		this.constModified = true;
		return this.shadowMap__ = _v;
	}
	,get_shadowMapChannel: function() {
		return this.shadowMapChannel__;
	}
	,set_shadowMapChannel: function(v) {
		this.constModified = true;
		return this.shadowMapChannel__ = v;
	}
	,get_shadowProj: function() {
		return this.shadowProj__;
	}
	,set_shadowProj: function(_v) {
		return this.shadowProj__ = _v;
	}
	,get_shadowBias: function() {
		return this.shadowBias__;
	}
	,set_shadowBias: function(_v) {
		return this.shadowBias__ = _v;
	}
	,get_poissonDisk: function() {
		return this.poissonDisk__;
	}
	,set_poissonDisk: function(_v) {
		return this.poissonDisk__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.enable__) {
			this.constBits |= 1;
		}
		if(this.USE_ESM__) {
			this.constBits |= 2;
		}
		if(this.USE_PCF__) {
			this.constBits |= 4;
		}
		var v = this.PCF_SAMPLES__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("PCF_SAMPLES" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v << 3;
		if(this.shadowMap__ == null) {
			this.shadowMapChannel__ = hxsl_Channel.Unknown;
		} else if(this.shadowMapChannel__ == hxsl_Channel.Unknown) {
			if(this.shadowMap__.format == h3d_mat_Texture.nativeFormat) {
				this.shadowMapChannel__ = hxsl_Channel.PackedFloat;
			} else {
				throw haxe_Exception.thrown("shadowMap" + "Channel is not set");
			}
		}
		this.constBits |= (globals.allocChannelID(this.shadowMap__) << 3 | this.shadowMapChannel__._hx_index) << 11;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.enable__;
		case 1:
			return this.USE_ESM__;
		case 2:
			return this.shadowPower__;
		case 3:
			return this.USE_PCF__;
		case 4:
			return this.PCF_SAMPLES__;
		case 5:
			return this.pcfScale__;
		case 6:
			return this.shadowRes__;
		case 7:
			return this.shadowMap__;
		case 8:
			return this.shadowProj__;
		case 9:
			return this.shadowBias__;
		case 10:
			return this.poissonDisk__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 2:
			return this.shadowPower__;
		case 5:
			return this.pcfScale__;
		case 9:
			return this.shadowBias__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.enable__ = val;
			break;
		case 1:
			this.USE_ESM__ = val;
			break;
		case 2:
			this.shadowPower__ = val;
			break;
		case 3:
			this.USE_PCF__ = val;
			break;
		case 4:
			this.PCF_SAMPLES__ = val;
			break;
		case 5:
			this.pcfScale__ = val;
			break;
		case 6:
			this.shadowRes__ = val;
			break;
		case 7:
			this.shadowMap__ = val;
			break;
		case 8:
			this.shadowProj__ = val;
			break;
		case 9:
			this.shadowBias__ = val;
			break;
		case 10:
			this.poissonDisk__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 2:
			this.shadowPower__ = val;
			break;
		case 5:
			this.pcfScale__ = val;
			break;
		case 9:
			this.shadowBias__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_DirShadow.prototype);
		s.shader = this.shader;
		s.enable__ = this.enable__;
		s.USE_ESM__ = this.USE_ESM__;
		s.shadowPower__ = this.shadowPower__;
		s.USE_PCF__ = this.USE_PCF__;
		s.PCF_SAMPLES__ = this.PCF_SAMPLES__;
		s.pcfScale__ = this.pcfScale__;
		s.shadowRes__ = this.shadowRes__;
		s.shadowMap__ = this.shadowMap__;
		s.shadowProj__ = this.shadowProj__;
		s.shadowBias__ = this.shadowBias__;
		s.poissonDisk__ = this.poissonDisk__;
		return s;
	}
	,__class__: h3d_shader_DirShadow
});
var h3d_shader_GenTexture = function() {
	this.color__ = new h3d_Vector4Impl(0.,0.,0.,1.);
	this.mode__ = 0;
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.GenTexture"] = h3d_shader_GenTexture;
h3d_shader_GenTexture.__name__ = "h3d.shader.GenTexture";
h3d_shader_GenTexture.__super__ = h3d_shader_ScreenShader;
h3d_shader_GenTexture.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_mode: function() {
		return this.mode__;
	}
	,set_mode: function(_v) {
		this.constModified = true;
		return this.mode__ = _v;
	}
	,get_color: function() {
		return this.color__;
	}
	,set_color: function(_v) {
		return this.color__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.mode__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("mode" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.mode__;
		case 2:
			return this.color__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_GenTexture.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.mode__ = this.mode__;
		s.color__ = this.color__;
		return s;
	}
	,__class__: h3d_shader_GenTexture
});
var h3d_shader_LineShader = function(width,lengthScale) {
	if(lengthScale == null) {
		lengthScale = 1.;
	}
	if(width == null) {
		width = 1.5;
	}
	this.width__ = 0;
	this.lengthScale__ = 0;
	hxsl_Shader.call(this);
	this.width__ = width;
	this.lengthScale__ = lengthScale;
};
$hxClasses["h3d.shader.LineShader"] = h3d_shader_LineShader;
h3d_shader_LineShader.__name__ = "h3d.shader.LineShader";
h3d_shader_LineShader.__super__ = hxsl_Shader;
h3d_shader_LineShader.prototype = $extend(hxsl_Shader.prototype,{
	get_lengthScale: function() {
		return this.lengthScale__;
	}
	,set_lengthScale: function(_v) {
		return this.lengthScale__ = _v;
	}
	,get_width: function() {
		return this.width__;
	}
	,set_width: function(_v) {
		return this.width__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.lengthScale__ = val;
			break;
		case 1:
			this.width__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 0:
			this.lengthScale__ = val;
			break;
		case 1:
			this.width__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_LineShader.prototype);
		s.shader = this.shader;
		s.lengthScale__ = this.lengthScale__;
		s.width__ = this.width__;
		return s;
	}
	,__class__: h3d_shader_LineShader
});
var h3d_shader_MinMaxShader = function() {
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader;
h3d_shader_MinMaxShader.__name__ = "h3d.shader.MinMaxShader";
h3d_shader_MinMaxShader.__super__ = h3d_shader_ScreenShader;
h3d_shader_MinMaxShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texA: function() {
		return this.texA__;
	}
	,set_texA: function(_v) {
		return this.texA__ = _v;
	}
	,get_texB: function() {
		return this.texB__;
	}
	,set_texB: function(_v) {
		return this.texB__ = _v;
	}
	,get_isMax: function() {
		return this.isMax__;
	}
	,set_isMax: function(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_MinMaxShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texA__ = this.texA__;
		s.texB__ = this.texB__;
		s.isMax__ = this.isMax__;
		return s;
	}
	,__class__: h3d_shader_MinMaxShader
});
var h3d_shader_CubeMinMaxShader = function() {
	this.mat__ = new h3d_MatrixImpl();
	h3d_shader_ScreenShader.call(this);
};
$hxClasses["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader;
h3d_shader_CubeMinMaxShader.__name__ = "h3d.shader.CubeMinMaxShader";
h3d_shader_CubeMinMaxShader.__super__ = h3d_shader_ScreenShader;
h3d_shader_CubeMinMaxShader.prototype = $extend(h3d_shader_ScreenShader.prototype,{
	get_texA: function() {
		return this.texA__;
	}
	,set_texA: function(_v) {
		return this.texA__ = _v;
	}
	,get_texB: function() {
		return this.texB__;
	}
	,set_texB: function(_v) {
		return this.texB__ = _v;
	}
	,get_isMax: function() {
		return this.isMax__;
	}
	,set_isMax: function(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	,get_mat: function() {
		return this.mat__;
	}
	,set_mat: function(_v) {
		return this.mat__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		case 4:
			return this.mat__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_CubeMinMaxShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texA__ = this.texA__;
		s.texB__ = this.texB__;
		s.isMax__ = this.isMax__;
		s.mat__ = this.mat__;
		return s;
	}
	,__class__: h3d_shader_CubeMinMaxShader
});
var h3d_shader_NormalMap = function(texture) {
	hxsl_Shader.call(this);
	this.texture__ = texture;
};
$hxClasses["h3d.shader.NormalMap"] = h3d_shader_NormalMap;
h3d_shader_NormalMap.__name__ = "h3d.shader.NormalMap";
h3d_shader_NormalMap.__super__ = hxsl_Shader;
h3d_shader_NormalMap.prototype = $extend(hxsl_Shader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.texture__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_NormalMap.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_shader_NormalMap
});
var h3d_shader_Shadow = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.Shadow"] = h3d_shader_Shadow;
h3d_shader_Shadow.__name__ = "h3d.shader.Shadow";
h3d_shader_Shadow.__super__ = hxsl_Shader;
h3d_shader_Shadow.prototype = $extend(hxsl_Shader.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,__class__: h3d_shader_Shadow
});
var h3d_shader_SignedDistanceField = function() {
	this.smoothing__ = 0.0416666666666666644;
	this.alphaCutoff__ = 0.5;
	this.autoSmoothing__ = false;
	this.channel__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.SignedDistanceField"] = h3d_shader_SignedDistanceField;
h3d_shader_SignedDistanceField.__name__ = "h3d.shader.SignedDistanceField";
h3d_shader_SignedDistanceField.__super__ = hxsl_Shader;
h3d_shader_SignedDistanceField.prototype = $extend(hxsl_Shader.prototype,{
	get_channel: function() {
		return this.channel__;
	}
	,set_channel: function(_v) {
		this.constModified = true;
		return this.channel__ = _v;
	}
	,get_autoSmoothing: function() {
		return this.autoSmoothing__;
	}
	,set_autoSmoothing: function(_v) {
		this.constModified = true;
		return this.autoSmoothing__ = _v;
	}
	,get_alphaCutoff: function() {
		return this.alphaCutoff__;
	}
	,set_alphaCutoff: function(_v) {
		return this.alphaCutoff__ = _v;
	}
	,get_smoothing: function() {
		return this.smoothing__;
	}
	,set_smoothing: function(_v) {
		return this.smoothing__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.channel__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("channel" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.autoSmoothing__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.channel__;
		case 1:
			return this.autoSmoothing__;
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		switch(index) {
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.channel__ = val;
			break;
		case 1:
			this.autoSmoothing__ = val;
			break;
		case 2:
			this.alphaCutoff__ = val;
			break;
		case 3:
			this.smoothing__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		switch(index) {
		case 2:
			this.alphaCutoff__ = val;
			break;
		case 3:
			this.smoothing__ = val;
			break;
		default:
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SignedDistanceField.prototype);
		s.shader = this.shader;
		s.channel__ = this.channel__;
		s.autoSmoothing__ = this.autoSmoothing__;
		s.alphaCutoff__ = this.alphaCutoff__;
		s.smoothing__ = this.smoothing__;
		return s;
	}
	,__class__: h3d_shader_SignedDistanceField
});
var h3d_shader_SkinBase = function() {
	this.bonesMatrixes__ = [];
	this.fourBonesByVertex__ = false;
	this.MaxBones__ = 0;
	hxsl_Shader.call(this);
	this.constModified = true;
	this.MaxBones__ = 34;
};
$hxClasses["h3d.shader.SkinBase"] = h3d_shader_SkinBase;
h3d_shader_SkinBase.__name__ = "h3d.shader.SkinBase";
h3d_shader_SkinBase.__super__ = hxsl_Shader;
h3d_shader_SkinBase.prototype = $extend(hxsl_Shader.prototype,{
	get_MaxBones: function() {
		return this.MaxBones__;
	}
	,set_MaxBones: function(_v) {
		this.constModified = true;
		return this.MaxBones__ = _v;
	}
	,get_fourBonesByVertex: function() {
		return this.fourBonesByVertex__;
	}
	,set_fourBonesByVertex: function(_v) {
		this.constModified = true;
		return this.fourBonesByVertex__ = _v;
	}
	,get_bonesMatrixes: function() {
		return this.bonesMatrixes__;
	}
	,set_bonesMatrixes: function(_v) {
		return this.bonesMatrixes__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.MaxBones__ = val;
			break;
		case 1:
			this.fourBonesByVertex__ = val;
			break;
		case 2:
			this.bonesMatrixes__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SkinBase.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
	,__class__: h3d_shader_SkinBase
});
var h3d_shader_Skin = function() {
	h3d_shader_SkinBase.call(this);
};
$hxClasses["h3d.shader.Skin"] = h3d_shader_Skin;
h3d_shader_Skin.__name__ = "h3d.shader.Skin";
h3d_shader_Skin.__super__ = h3d_shader_SkinBase;
h3d_shader_Skin.prototype = $extend(h3d_shader_SkinBase.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Skin.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
	,__class__: h3d_shader_Skin
});
var h3d_shader_SkinTangent = function() {
	h3d_shader_SkinBase.call(this);
};
$hxClasses["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent;
h3d_shader_SkinTangent.__name__ = "h3d.shader.SkinTangent";
h3d_shader_SkinTangent.__super__ = h3d_shader_SkinBase;
h3d_shader_SkinTangent.prototype = $extend(h3d_shader_SkinBase.prototype,{
	updateConstants: function(globals) {
		this.constBits = 0;
		var v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SkinTangent.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
	,__class__: h3d_shader_SkinTangent
});
var h3d_shader_SpecularTexture = function(tex) {
	hxsl_Shader.call(this);
	this.texture__ = tex;
};
$hxClasses["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture;
h3d_shader_SpecularTexture.__name__ = "h3d.shader.SpecularTexture";
h3d_shader_SpecularTexture.__super__ = hxsl_Shader;
h3d_shader_SpecularTexture.prototype = $extend(hxsl_Shader.prototype,{
	get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.texture__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_SpecularTexture.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_shader_SpecularTexture
});
var h3d_shader_Texture = function(tex) {
	this.killAlphaThreshold__ = 0;
	hxsl_Shader.call(this);
	this.texture__ = tex;
	this.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold;
};
$hxClasses["h3d.shader.Texture"] = h3d_shader_Texture;
h3d_shader_Texture.__name__ = "h3d.shader.Texture";
h3d_shader_Texture.__super__ = hxsl_Shader;
h3d_shader_Texture.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,get_killAlpha: function() {
		return this.killAlpha__;
	}
	,set_killAlpha: function(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	,get_specularAlpha: function() {
		return this.specularAlpha__;
	}
	,set_specularAlpha: function(_v) {
		this.constModified = true;
		return this.specularAlpha__ = _v;
	}
	,get_killAlphaThreshold: function() {
		return this.killAlphaThreshold__;
	}
	,set_killAlphaThreshold: function(_v) {
		return this.killAlphaThreshold__ = _v;
	}
	,get_texture: function() {
		return this.texture__;
	}
	,set_texture: function(_v) {
		return this.texture__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		if(this.killAlpha__) {
			this.constBits |= 2;
		}
		if(this.specularAlpha__) {
			this.constBits |= 4;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.additive__;
		case 1:
			return this.killAlpha__;
		case 2:
			return this.specularAlpha__;
		case 3:
			return this.killAlphaThreshold__;
		case 4:
			return this.texture__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		if(index == 3) {
			return this.killAlphaThreshold__;
		}
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.additive__ = val;
			break;
		case 1:
			this.killAlpha__ = val;
			break;
		case 2:
			this.specularAlpha__ = val;
			break;
		case 3:
			this.killAlphaThreshold__ = val;
			break;
		case 4:
			this.texture__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
		if(index == 3) {
			this.killAlphaThreshold__ = val;
		}
	}
	,clone: function() {
		var s = Object.create(h3d_shader_Texture.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		s.killAlpha__ = this.killAlpha__;
		s.specularAlpha__ = this.specularAlpha__;
		s.killAlphaThreshold__ = this.killAlphaThreshold__;
		s.texture__ = this.texture__;
		return s;
	}
	,__class__: h3d_shader_Texture
});
var h3d_shader_UVDelta = function(dx,dy,sx,sy) {
	if(sy == null) {
		sy = 1.;
	}
	if(sx == null) {
		sx = 1.;
	}
	if(dy == null) {
		dy = 0.;
	}
	if(dx == null) {
		dx = 0.;
	}
	this.uvScale__ = new h3d_VectorImpl(0.,0.,0.);
	this.uvDelta__ = new h3d_VectorImpl(0.,0.,0.);
	hxsl_Shader.call(this);
	var _this = this.uvDelta__;
	var x = dx;
	var y = dy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
	var _this = this.uvScale__;
	var x = sx;
	var y = sy;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
};
$hxClasses["h3d.shader.UVDelta"] = h3d_shader_UVDelta;
h3d_shader_UVDelta.__name__ = "h3d.shader.UVDelta";
h3d_shader_UVDelta.__super__ = hxsl_Shader;
h3d_shader_UVDelta.prototype = $extend(hxsl_Shader.prototype,{
	get_uvDelta: function() {
		return this.uvDelta__;
	}
	,set_uvDelta: function(_v) {
		return this.uvDelta__ = _v;
	}
	,get_uvScale: function() {
		return this.uvScale__;
	}
	,set_uvScale: function(_v) {
		return this.uvScale__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.uvDelta__;
		case 1:
			return this.uvScale__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.uvDelta__ = val;
			break;
		case 1:
			this.uvScale__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_UVDelta.prototype);
		s.shader = this.shader;
		s.uvDelta__ = this.uvDelta__;
		s.uvScale__ = this.uvScale__;
		return s;
	}
	,__class__: h3d_shader_UVDelta
});
var h3d_shader_VertexColorAlpha = function() {
	hxsl_Shader.call(this);
};
$hxClasses["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha;
h3d_shader_VertexColorAlpha.__name__ = "h3d.shader.VertexColorAlpha";
h3d_shader_VertexColorAlpha.__super__ = hxsl_Shader;
h3d_shader_VertexColorAlpha.prototype = $extend(hxsl_Shader.prototype,{
	get_additive: function() {
		return this.additive__;
	}
	,set_additive: function(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		if(index == 0) {
			this.additive__ = val;
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_VertexColorAlpha.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		return s;
	}
	,__class__: h3d_shader_VertexColorAlpha
});
var h3d_shader_VolumeDecal = function(objectWidth,objectHeight) {
	this.isCentered__ = true;
	this.tangent__ = new h3d_VectorImpl(0.,0.,0.);
	this.normal__ = new h3d_VectorImpl(0.,0.,0.);
	this.scale__ = new h3d_VectorImpl(0.,0.,0.);
	hxsl_Shader.call(this);
	var _this = this.normal__;
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	var _this = this.tangent__;
	var x = 1;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = z;
	var _this = this.scale__;
	var x = 1 / objectWidth;
	var y = 1 / objectHeight;
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	_this.x = x;
	_this.y = y;
	_this.z = 0.;
};
$hxClasses["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal;
h3d_shader_VolumeDecal.__name__ = "h3d.shader.VolumeDecal";
h3d_shader_VolumeDecal.__super__ = hxsl_Shader;
h3d_shader_VolumeDecal.prototype = $extend(hxsl_Shader.prototype,{
	get_scale: function() {
		return this.scale__;
	}
	,set_scale: function(_v) {
		return this.scale__ = _v;
	}
	,get_normal: function() {
		return this.normal__;
	}
	,set_normal: function(_v) {
		return this.normal__ = _v;
	}
	,get_tangent: function() {
		return this.tangent__;
	}
	,set_tangent: function(_v) {
		return this.tangent__ = _v;
	}
	,get_isCentered: function() {
		return this.isCentered__;
	}
	,set_isCentered: function(_v) {
		this.constModified = true;
		return this.isCentered__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.isCentered__) {
			this.constBits |= 64;
		}
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.scale__;
		case 1:
			return this.normal__;
		case 2:
			return this.tangent__;
		case 3:
			return this.isCentered__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.scale__ = val;
			break;
		case 1:
			this.normal__ = val;
			break;
		case 2:
			this.tangent__ = val;
			break;
		case 3:
			this.isCentered__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(h3d_shader_VolumeDecal.prototype);
		s.shader = this.shader;
		s.scale__ = this.scale__;
		s.normal__ = this.normal__;
		s.tangent__ = this.tangent__;
		s.isCentered__ = this.isCentered__;
		return s;
	}
	,__class__: h3d_shader_VolumeDecal
});
var haxe_EntryPoint = function() { };
$hxClasses["haxe.EntryPoint"] = haxe_EntryPoint;
haxe_EntryPoint.__name__ = "haxe.EntryPoint";
haxe_EntryPoint.processEvents = function() {
	while(true) {
		var f = haxe_EntryPoint.pending.shift();
		if(f == null) {
			break;
		}
		f();
	}
	var time = haxe_MainLoop.tick();
	if(!haxe_MainLoop.hasEvents() && haxe_EntryPoint.threadCount == 0) {
		return -1;
	}
	return time;
};
haxe_EntryPoint.run = function() {
	var nextTick = haxe_EntryPoint.processEvents();
	if(typeof(window) != "undefined") {
		var $window = window;
		var rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
		if(rqf != null) {
			rqf(haxe_EntryPoint.run);
		} else if(nextTick >= 0) {
			setTimeout(haxe_EntryPoint.run,nextTick * 1000);
		}
	} else if(nextTick >= 0) {
		setTimeout(haxe_EntryPoint.run,nextTick * 1000);
	}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Int32 = {};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_MainEvent = function(f,p) {
	this.isBlocking = true;
	this.f = f;
	this.priority = p;
	this.nextRun = -Infinity;
};
$hxClasses["haxe.MainEvent"] = haxe_MainEvent;
haxe_MainEvent.__name__ = "haxe.MainEvent";
haxe_MainEvent.prototype = {
	stop: function() {
		if(this.f == null) {
			return;
		}
		this.f = null;
		this.nextRun = -Infinity;
		if(this.prev == null) {
			haxe_MainLoop.pending = this.next;
		} else {
			this.prev.next = this.next;
		}
		if(this.next != null) {
			this.next.prev = this.prev;
		}
	}
	,__class__: haxe_MainEvent
};
var haxe_MainLoop = function() { };
$hxClasses["haxe.MainLoop"] = haxe_MainLoop;
haxe_MainLoop.__name__ = "haxe.MainLoop";
haxe_MainLoop.hasEvents = function() {
	var p = haxe_MainLoop.pending;
	while(p != null) {
		if(p.isBlocking) {
			return true;
		}
		p = p.next;
	}
	return false;
};
haxe_MainLoop.add = function(f,priority) {
	if(priority == null) {
		priority = 0;
	}
	if(f == null) {
		throw haxe_Exception.thrown("Event function is null");
	}
	var e = new haxe_MainEvent(f,priority);
	var head = haxe_MainLoop.pending;
	if(head != null) {
		head.prev = e;
	}
	e.next = head;
	haxe_MainLoop.pending = e;
	return e;
};
haxe_MainLoop.sortEvents = function() {
	var list = haxe_MainLoop.pending;
	if(list == null) {
		return;
	}
	var insize = 1;
	var nmerges;
	var psize = 0;
	var qsize = 0;
	var p;
	var q;
	var e;
	var tail;
	while(true) {
		p = list;
		list = null;
		tail = null;
		nmerges = 0;
		while(p != null) {
			++nmerges;
			q = p;
			psize = 0;
			var _g = 0;
			var _g1 = insize;
			while(_g < _g1) {
				var i = _g++;
				++psize;
				q = q.next;
				if(q == null) {
					break;
				}
			}
			qsize = insize;
			while(psize > 0 || qsize > 0 && q != null) {
				if(psize == 0) {
					e = q;
					q = q.next;
					--qsize;
				} else if(qsize == 0 || q == null || (p.priority > q.priority || p.priority == q.priority && p.nextRun <= q.nextRun)) {
					e = p;
					p = p.next;
					--psize;
				} else {
					e = q;
					q = q.next;
					--qsize;
				}
				if(tail != null) {
					tail.next = e;
				} else {
					list = e;
				}
				e.prev = tail;
				tail = e;
			}
			p = q;
		}
		tail.next = null;
		if(nmerges <= 1) {
			break;
		}
		insize *= 2;
	}
	list.prev = null;
	haxe_MainLoop.pending = list;
};
haxe_MainLoop.tick = function() {
	haxe_MainLoop.sortEvents();
	var e = haxe_MainLoop.pending;
	var now = HxOverrides.now() / 1000;
	var wait = 1e9;
	while(e != null) {
		var next = e.next;
		var wt = e.nextRun - now;
		if(wt <= 0) {
			wait = 0;
			if(e.f != null) {
				e.f();
			}
		} else if(wait > wt) {
			wait = wt;
		}
		e = next;
	}
	return wait;
};
var haxe_Resource = function() { };
$hxClasses["haxe.Resource"] = haxe_Resource;
haxe_Resource.__name__ = "haxe.Resource";
haxe_Resource.getBytes = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return haxe_io_Bytes.ofString(x.str);
			}
			return haxe_crypto_Base64.decode(x.data);
		}
	}
	return null;
};
var haxe_Serializer = function() {
	this.buf = new StringBuf();
	this.cache = [];
	this.useCache = haxe_Serializer.USE_CACHE;
	this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
	this.shash = new haxe_ds_StringMap();
	this.scount = 0;
};
$hxClasses["haxe.Serializer"] = haxe_Serializer;
haxe_Serializer.__name__ = "haxe.Serializer";
haxe_Serializer.run = function(v) {
	var s = new haxe_Serializer();
	s.serialize(v);
	return s.toString();
};
haxe_Serializer.prototype = {
	toString: function() {
		return this.buf.b;
	}
	,serializeString: function(s) {
		var x = this.shash.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		this.shash.h[s] = this.scount++;
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	,serializeRef: function(v) {
		var vt = typeof(v);
		var _g = 0;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	,serializeFields: function(v) {
		var _g = 0;
		var _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	,serialize: function(v) {
		var _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			var v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			var v1 = v;
			if(isNaN(v1)) {
				this.buf.b += "k";
			} else if(!isFinite(v1)) {
				this.buf.b += v1 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v1 == null ? "null" : "" + v1;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				var className = v.__name__;
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(v.__ename__);
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw haxe_Exception.thrown("Cannot serialize function");
		case 6:
			var c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				var ucount = 0;
				this.buf.b += "a";
				var l = v["length"];
				var _g1 = 0;
				var _g2 = l;
				while(_g1 < _g2) {
					var i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				var d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v1.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_List:
				this.buf.b += "l";
				var v1 = v;
				var _g_head = v1.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var i = val;
					this.serialize(i);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					var id = Reflect.field(k1,"__id__");
					Reflect.deleteField(k1,"__id__");
					this.serialize(k1);
					k1["__id__"] = id;
					this.serialize(v1.h[k1.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				var v1 = v;
				var h = v1.h;
				var _g_h = h;
				var _g_keys = Object.keys(h);
				var _g_length = _g_keys.length;
				var _g_current = 0;
				while(_g_current < _g_length) {
					var k = _g_keys[_g_current++];
					this.serializeString(k);
					this.serialize(v1.h[k]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				var v1 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v1.length * 8 / 6));
				this.buf.b += ":";
				var i = 0;
				var max = v1.length - 2;
				var b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					b64 = new Array(haxe_Serializer.BASE64.length);
					var _g1 = 0;
					var _g2 = haxe_Serializer.BASE64.length;
					while(_g1 < _g2) {
						var i1 = _g1++;
						b64[i1] = HxOverrides.cca(haxe_Serializer.BASE64,i1);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i < max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					var b3 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCodePoint(b64[b3 & 63]);
				}
				if(i == max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[b2 << 2 & 63]);
				} else if(i == max + 1) {
					var b1 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[b1 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			var e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(e.__ename__);
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v._hx_index);
			} else {
				var e = v;
				this.serializeString($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
			}
			this.buf.b += ":";
			var params = Type.enumParameters(v);
			this.buf.b += Std.string(params.length);
			var _g = 0;
			while(_g < params.length) {
				var p = params[_g];
				++_g;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot serialize " + Std.string(v));
		}
	}
	,__class__: haxe_Serializer
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
$hxClasses["haxe.Timer"] = haxe_Timer;
haxe_Timer.__name__ = "haxe.Timer";
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return $hxClasses[name];
	}
	,resolveEnum: function(name) {
		return $hxEnums[name];
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = this.buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g = 0;
	var _g1 = haxe_Unserializer.BASE64.length;
	while(_g < _g1) {
		var i = _g++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.run = function(v) {
	return new haxe_Unserializer(v).unserialize();
};
haxe_Unserializer.prototype = {
	readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			var name = this.unserialize();
			var e = this.resolver.resolveEnum(name);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			return e;
		case 67:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h = new haxe_ds_StringMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				var value = this.unserialize();
				h.h[s] = value;
			}
			this.pos++;
			return h;
		case 99:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			var o = Object.create(cl.prototype);
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			this.pos++;
			var index = this.readDigits();
			var _this = edecl.__constructs__;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i]._hx_name;
			}
			var tag = result[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name + "@" + index);
			}
			var e = this.unserializeEnum(edecl,tag);
			this.cache.push(e);
			return e;
		case 107:
			return NaN;
		case 108:
			var l = new haxe_ds_List();
			this.cache.push(l);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o = { };
			this.cache.push(o);
			this.unserializeObject(o);
			return o;
		case 112:
			return Infinity;
		case 113:
			var h = new haxe_ds_IntMap();
			this.cache.push(h);
			var buf = this.buf;
			var c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				var i = this.readDigits();
				var value = this.unserialize();
				h.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h;
		case 114:
			var n = this.readDigits();
			if(n < 0 || n >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n];
		case 115:
			var len = this.readDigits();
			var buf = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i < max) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				var c3 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				var c4 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				var c1 = codes[buf.charCodeAt(i++)];
				var c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					var c3 = codes[buf.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			var name = this.unserialize();
			var edecl = this.resolver.resolveEnum(name);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name);
			}
			var e = this.unserializeEnum(edecl,this.unserialize());
			this.cache.push(e);
			return e;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			var len = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			var s = HxOverrides.substr(this.buf,this.pos,len);
			this.pos += len;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
$hxClasses["haxe.crypto.Adler32"] = haxe_crypto_Adler32;
haxe_crypto_Adler32.__name__ = "haxe.crypto.Adler32";
haxe_crypto_Adler32.read = function(i) {
	var a = new haxe_crypto_Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
};
haxe_crypto_Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
	,__class__: haxe_crypto_Adler32
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getFloat: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	,setFloat: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	,getUInt16: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	,setUInt16: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:"haxe.io.Encoding",__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
haxe_io_Encoding.__empty_constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
$hxClasses["haxe.crypto.Base64"] = haxe_crypto_Base64;
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
$hxClasses["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode;
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
haxe_crypto_BaseCode.prototype = {
	encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	,initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
	,__class__: haxe_crypto_BaseCode
};
var haxe_crypto_Md5 = function() {
};
$hxClasses["haxe.crypto.Md5"] = haxe_crypto_Md5;
haxe_crypto_Md5.__name__ = "haxe.crypto.Md5";
haxe_crypto_Md5.encode = function(s) {
	var m = new haxe_crypto_Md5();
	var h = m.doEncode(haxe_crypto_Md5.str2blks(s));
	return m.hex(h);
};
haxe_crypto_Md5.str2blks = function(str) {
	var str1 = haxe_io_Bytes.ofString(str);
	var nblk = (str1.length + 8 >> 6) + 1;
	var blks = [];
	var blksSize = nblk * 16;
	var _g = 0;
	var _g1 = blksSize;
	while(_g < _g1) {
		var i = _g++;
		blks[i] = 0;
	}
	var i = 0;
	var max = str1.length;
	var l = max * 8;
	while(i < max) {
		blks[i >> 2] |= str1.b[i] << (l + i) % 4 * 8;
		++i;
	}
	blks[i >> 2] |= 128 << (l + i) % 4 * 8;
	var k = nblk * 16 - 2;
	blks[k] = l & 255;
	blks[k] |= (l >>> 8 & 255) << 8;
	blks[k] |= (l >>> 16 & 255) << 16;
	blks[k] |= (l >>> 24 & 255) << 24;
	return blks;
};
haxe_crypto_Md5.prototype = {
	bitOR: function(a,b) {
		var lsb = a & 1 | b & 1;
		var msb31 = a >>> 1 | b >>> 1;
		return msb31 << 1 | lsb;
	}
	,bitXOR: function(a,b) {
		var lsb = a & 1 ^ b & 1;
		var msb31 = a >>> 1 ^ b >>> 1;
		return msb31 << 1 | lsb;
	}
	,bitAND: function(a,b) {
		var lsb = a & 1 & (b & 1);
		var msb31 = a >>> 1 & b >>> 1;
		return msb31 << 1 | lsb;
	}
	,addme: function(x,y) {
		var lsw = (x & 65535) + (y & 65535);
		var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return msw << 16 | lsw & 65535;
	}
	,hex: function(a) {
		var str = "";
		var hex_chr = "0123456789abcdef";
		var _g = 0;
		while(_g < a.length) {
			var num = a[_g];
			++_g;
			str += hex_chr.charAt(num >> 4 & 15) + hex_chr.charAt(num & 15);
			str += hex_chr.charAt(num >> 12 & 15) + hex_chr.charAt(num >> 8 & 15);
			str += hex_chr.charAt(num >> 20 & 15) + hex_chr.charAt(num >> 16 & 15);
			str += hex_chr.charAt(num >> 28 & 15) + hex_chr.charAt(num >> 24 & 15);
		}
		return str;
	}
	,rol: function(num,cnt) {
		return num << cnt | num >>> 32 - cnt;
	}
	,cmn: function(q,a,b,x,s,t) {
		return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b);
	}
	,ff: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t);
	}
	,gg: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t);
	}
	,hh: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t);
	}
	,ii: function(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t);
	}
	,doEncode: function(x) {
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var step;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			step = 0;
			a = this.ff(a,b,c,d,x[i],7,-680876936);
			d = this.ff(d,a,b,c,x[i + 1],12,-389564586);
			c = this.ff(c,d,a,b,x[i + 2],17,606105819);
			b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);
			a = this.ff(a,b,c,d,x[i + 4],7,-176418897);
			d = this.ff(d,a,b,c,x[i + 5],12,1200080426);
			c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);
			b = this.ff(b,c,d,a,x[i + 7],22,-45705983);
			a = this.ff(a,b,c,d,x[i + 8],7,1770035416);
			d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);
			c = this.ff(c,d,a,b,x[i + 10],17,-42063);
			b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);
			a = this.ff(a,b,c,d,x[i + 12],7,1804603682);
			d = this.ff(d,a,b,c,x[i + 13],12,-40341101);
			c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);
			b = this.ff(b,c,d,a,x[i + 15],22,1236535329);
			a = this.gg(a,b,c,d,x[i + 1],5,-165796510);
			d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);
			c = this.gg(c,d,a,b,x[i + 11],14,643717713);
			b = this.gg(b,c,d,a,x[i],20,-373897302);
			a = this.gg(a,b,c,d,x[i + 5],5,-701558691);
			d = this.gg(d,a,b,c,x[i + 10],9,38016083);
			c = this.gg(c,d,a,b,x[i + 15],14,-660478335);
			b = this.gg(b,c,d,a,x[i + 4],20,-405537848);
			a = this.gg(a,b,c,d,x[i + 9],5,568446438);
			d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);
			c = this.gg(c,d,a,b,x[i + 3],14,-187363961);
			b = this.gg(b,c,d,a,x[i + 8],20,1163531501);
			a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);
			d = this.gg(d,a,b,c,x[i + 2],9,-51403784);
			c = this.gg(c,d,a,b,x[i + 7],14,1735328473);
			b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);
			a = this.hh(a,b,c,d,x[i + 5],4,-378558);
			d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);
			c = this.hh(c,d,a,b,x[i + 11],16,1839030562);
			b = this.hh(b,c,d,a,x[i + 14],23,-35309556);
			a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);
			d = this.hh(d,a,b,c,x[i + 4],11,1272893353);
			c = this.hh(c,d,a,b,x[i + 7],16,-155497632);
			b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);
			a = this.hh(a,b,c,d,x[i + 13],4,681279174);
			d = this.hh(d,a,b,c,x[i],11,-358537222);
			c = this.hh(c,d,a,b,x[i + 3],16,-722521979);
			b = this.hh(b,c,d,a,x[i + 6],23,76029189);
			a = this.hh(a,b,c,d,x[i + 9],4,-640364487);
			d = this.hh(d,a,b,c,x[i + 12],11,-421815835);
			c = this.hh(c,d,a,b,x[i + 15],16,530742520);
			b = this.hh(b,c,d,a,x[i + 2],23,-995338651);
			a = this.ii(a,b,c,d,x[i],6,-198630844);
			d = this.ii(d,a,b,c,x[i + 7],10,1126891415);
			c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);
			b = this.ii(b,c,d,a,x[i + 5],21,-57434055);
			a = this.ii(a,b,c,d,x[i + 12],6,1700485571);
			d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);
			c = this.ii(c,d,a,b,x[i + 10],15,-1051523);
			b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);
			a = this.ii(a,b,c,d,x[i + 8],6,1873313359);
			d = this.ii(d,a,b,c,x[i + 15],10,-30611744);
			c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);
			b = this.ii(b,c,d,a,x[i + 13],21,1309151649);
			a = this.ii(a,b,c,d,x[i + 4],6,-145523070);
			d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);
			c = this.ii(c,d,a,b,x[i + 2],15,718787259);
			b = this.ii(b,c,d,a,x[i + 9],21,-343485551);
			a = this.addme(a,olda);
			b = this.addme(b,oldb);
			c = this.addme(c,oldc);
			d = this.addme(d,oldd);
			i += 16;
		}
		return [a,b,c,d];
	}
	,__class__: haxe_crypto_Md5
};
var haxe_crypto_Sha1 = function() {
};
$hxClasses["haxe.crypto.Sha1"] = haxe_crypto_Sha1;
haxe_crypto_Sha1.__name__ = "haxe.crypto.Sha1";
haxe_crypto_Sha1.encode = function(s) {
	var sh = new haxe_crypto_Sha1();
	var h = sh.doEncode(haxe_crypto_Sha1.str2blks(s));
	return sh.hex(h);
};
haxe_crypto_Sha1.str2blks = function(s) {
	var s1 = haxe_io_Bytes.ofString(s);
	var nblk = (s1.length + 8 >> 6) + 1;
	var blks = [];
	var _g = 0;
	var _g1 = nblk * 16;
	while(_g < _g1) {
		var i = _g++;
		blks[i] = 0;
	}
	var _g = 0;
	var _g1 = s1.length;
	while(_g < _g1) {
		var i = _g++;
		var p = i >> 2;
		blks[p] |= s1.b[i] << 24 - ((i & 3) << 3);
	}
	var i = s1.length;
	var p = i >> 2;
	blks[p] |= 128 << 24 - ((i & 3) << 3);
	blks[nblk * 16 - 1] = s1.length * 8;
	return blks;
};
haxe_crypto_Sha1.prototype = {
	doEncode: function(x) {
		var w = [];
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var e = -1009589776;
		var i = 0;
		while(i < x.length) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;
			var j = 0;
			while(j < 80) {
				if(j < 16) {
					w[j] = x[i + j];
				} else {
					var num = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
					w[j] = num << 1 | num >>> 31;
				}
				var t = (a << 5 | a >>> 27) + this.ft(j,b,c,d) + e + w[j] + this.kt(j);
				e = d;
				d = c;
				c = b << 30 | b >>> 2;
				b = a;
				a = t;
				++j;
			}
			a += olda;
			b += oldb;
			c += oldc;
			d += oldd;
			e += olde;
			i += 16;
		}
		return [a,b,c,d,e];
	}
	,ft: function(t,b,c,d) {
		if(t < 20) {
			return b & c | ~b & d;
		}
		if(t < 40) {
			return b ^ c ^ d;
		}
		if(t < 60) {
			return b & c | b & d | c & d;
		}
		return b ^ c ^ d;
	}
	,kt: function(t) {
		if(t < 20) {
			return 1518500249;
		}
		if(t < 40) {
			return 1859775393;
		}
		if(t < 60) {
			return -1894007588;
		}
		return -899497514;
	}
	,hex: function(a) {
		var str = "";
		var _g = 0;
		while(_g < a.length) {
			var num = a[_g];
			++_g;
			str += StringTools.hex(num,8);
		}
		return str.toLowerCase();
	}
	,__class__: haxe_crypto_Sha1
};
var haxe_ds_ArraySort = function() { };
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
haxe_ds_ArraySort.sort = function(a,cmp) {
	haxe_ds_ArraySort.rec(a,cmp,0,a.length);
};
haxe_ds_ArraySort.rec = function(a,cmp,from,to) {
	var middle = from + to >> 1;
	if(to - from < 12) {
		if(to <= from) {
			return;
		}
		var _g = from + 1;
		var _g1 = to;
		while(_g < _g1) {
			var i = _g++;
			var j = i;
			while(j > from) {
				if(cmp(a[j],a[j - 1]) < 0) {
					haxe_ds_ArraySort.swap(a,j - 1,j);
				} else {
					break;
				}
				--j;
			}
		}
		return;
	}
	haxe_ds_ArraySort.rec(a,cmp,from,middle);
	haxe_ds_ArraySort.rec(a,cmp,middle,to);
	haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
};
haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) {
	var first_cut;
	var second_cut;
	var len11;
	var len22;
	if(len1 == 0 || len2 == 0) {
		return;
	}
	if(len1 + len2 == 2) {
		if(cmp(a[pivot],a[from]) < 0) {
			haxe_ds_ArraySort.swap(a,pivot,from);
		}
		return;
	}
	if(len1 > len2) {
		len11 = len1 >> 1;
		first_cut = from + len11;
		second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
		len22 = second_cut - pivot;
	} else {
		len22 = len2 >> 1;
		second_cut = pivot + len22;
		first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
		len11 = first_cut - from;
	}
	haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
	var new_mid = first_cut + len22;
	haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
	haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,len1 - len11,len2 - len22);
};
haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) {
	if(from == mid || mid == to) {
		return;
	}
	var n = haxe_ds_ArraySort.gcd(to - from,mid - from);
	while(n-- != 0) {
		var val = a[from + n];
		var shift = mid - from;
		var p1 = from + n;
		var p2 = from + n + shift;
		while(p2 != from + n) {
			a[p1] = a[p2];
			p1 = p2;
			if(to - p2 > shift) {
				p2 += shift;
			} else {
				p2 = from + (shift - (to - p2));
			}
		}
		a[p1] = val;
	}
};
haxe_ds_ArraySort.gcd = function(m,n) {
	while(n != 0) {
		var t = m % n;
		m = n;
		n = t;
	}
	return m;
};
haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[val],a[mid]) < 0) {
			len = half;
		} else {
			from = mid + 1;
			len = len - half - 1;
		}
	}
	return from;
};
haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) {
	var len = to - from;
	var half;
	var mid;
	while(len > 0) {
		half = len >> 1;
		mid = from + half;
		if(cmp(a[mid],a[val]) < 0) {
			from = mid + 1;
			len = len - half - 1;
		} else {
			len = half;
		}
	}
	return from;
};
haxe_ds_ArraySort.swap = function(a,i,j) {
	var tmp = a[i];
	a[i] = a[j];
	a[j] = tmp;
};
var haxe_ds_BalancedTree = function() {
};
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
haxe_ds_BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	,__class__: haxe_ds_BalancedTree
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
haxe_ds_TreeNode.prototype = {
	__class__: haxe_ds_TreeNode
};
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
	,__class__: haxe_ds_EnumValueMap
});
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds_Vector = {};
haxe_ds_Vector.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var k = _g++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i = srcPos;
			var j = destPos;
			var _g = 0;
			var _g1 = len;
			while(_g < _g1) {
				var k = _g++;
				src[j] = src[i];
				++i;
				++j;
			}
		}
	} else {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			dest[destPos + i] = src[srcPos + i];
		}
	}
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
$hxClasses["haxe.exceptions.PosException"] = haxe_exceptions_PosException;
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
$hxClasses["haxe.exceptions.NotImplementedException"] = haxe_exceptions_NotImplementedException;
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,add: function(src) {
		if(this.pos + src.length > this.size) {
			this.grow(src.length);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.length);
		this.u8.set(sub,this.pos);
		this.pos += src.length;
	}
	,addInt32: function(v) {
		if(this.pos + 4 > this.size) {
			this.grow(4);
		}
		this.view.setInt32(this.pos,v,true);
		this.pos += 4;
	}
	,addFloat: function(v) {
		if(this.pos + 4 > this.size) {
			this.grow(4);
		}
		this.view.setFloat32(this.pos,v,true);
		this.pos += 4;
	}
	,addDouble: function(v) {
		if(this.pos + 8 > this.size) {
			this.grow(8);
		}
		this.view.setFloat64(this.pos,v,true);
		this.pos += 8;
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Input = function() { };
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = "haxe.io.Input";
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readUntil: function(end) {
		var buf = new haxe_io_BytesBuffer();
		var last;
		while(true) {
			last = this.readByte();
			if(!(last != end)) {
				break;
			}
			buf.addByte(last);
		}
		return buf.getBytes().toString();
	}
	,readLine: function() {
		var buf = new haxe_io_BytesBuffer();
		var last;
		var s;
		try {
			while(true) {
				last = this.readByte();
				if(!(last != 10)) {
					break;
				}
				buf.addByte(last);
			}
			s = buf.getBytes().toString();
			if(HxOverrides.cca(s,s.length - 1) == 13) {
				s = HxOverrides.substr(s,0,-1);
			}
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof haxe_io_Eof)) {
				var e = _g1;
				s = buf.getBytes().toString();
				if(s.length == 0) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				throw _g;
			}
		}
		return s;
	}
	,readFloat: function() {
		return haxe_io_FPHelper.i32ToFloat(this.readInt32());
	}
	,readDouble: function() {
		var i1 = this.readInt32();
		var i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	,readInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readUInt24: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		if(this.bigEndian) {
			return ch3 | ch2 << 8 | ch1 << 16;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
	,__class__: haxe_io_Input
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
$hxClasses["haxe.io.BytesInput"] = haxe_io_BytesInput;
haxe_io_BytesInput.__name__ = "haxe.io.BytesInput";
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	set_position: function(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	,readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Output = function() { };
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = "haxe.io.Output";
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,flush: function() {
	}
	,close: function() {
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
$hxClasses["haxe.io.BytesOutput"] = haxe_io_BytesOutput;
haxe_io_BytesOutput.__name__ = "haxe.io.BytesOutput";
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
	,__class__: haxe_io_BytesOutput
});
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:"haxe.io.Error",__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
haxe_io_Error.__empty_constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds];
var haxe_io_FPHelper = function() { };
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = "haxe.io.FPHelper";
haxe_io_FPHelper.i32ToFloat = function(i) {
	haxe_io_FPHelper.helper.setInt32(0,i,true);
	return haxe_io_FPHelper.helper.getFloat32(0,true);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
haxe_io_FPHelper.i64ToDouble = function(low,high) {
	haxe_io_FPHelper.helper.setInt32(0,low,true);
	haxe_io_FPHelper.helper.setInt32(4,high,true);
	return haxe_io_FPHelper.helper.getFloat64(0,true);
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.withExtension = function(path,ext) {
	var s = new haxe_io_Path(path);
	s.ext = ext;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g_offset = 0;
	var _g_s = tmp;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:"haxe.macro.Binop",__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNullCoal: {_hx_name:"OpNullCoal",_hx_index:24,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
haxe_macro_Binop.__empty_constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:"haxe.macro.Unop",__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
haxe_macro_Unop.__empty_constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
var haxe_xml__$Access_NodeAccess = {};
haxe_xml__$Access_NodeAccess.resolve = function(this1,name) {
	var x = this1.elementsNamed(name).next();
	if(x == null) {
		var xname;
		if(this1.nodeType == Xml.Document) {
			xname = "Document";
		} else {
			if(this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
			}
			xname = this1.nodeName;
		}
		throw haxe_Exception.thrown(xname + " is missing element " + name);
	}
	if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
		throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
	}
	return x;
};
var haxe_xml__$Access_AttribAccess = {};
haxe_xml__$Access_AttribAccess.resolve = function(this1,name) {
	if(this1.nodeType == Xml.Document) {
		throw haxe_Exception.thrown("Cannot access document attribute " + name);
	}
	var v = this1.get(name);
	if(v == null) {
		if(this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		throw haxe_Exception.thrown(this1.nodeName + " is missing attribute " + name);
	}
	return v;
};
var haxe_xml__$Access_HasNodeAccess = {};
haxe_xml__$Access_HasNodeAccess.resolve = function(this1,name) {
	return this1.elementsNamed(name).hasNext();
};
var haxe_xml_XmlParserException = function(message,xml,position) {
	this.xml = xml;
	this.message = message;
	this.position = position;
	this.lineNumber = 1;
	this.positionAtLine = 0;
	var _g = 0;
	var _g1 = position;
	while(_g < _g1) {
		var i = _g++;
		var c = xml.charCodeAt(i);
		if(c == 10) {
			this.lineNumber++;
			this.positionAtLine = 0;
		} else if(c != 13) {
			this.positionAtLine++;
		}
	}
};
$hxClasses["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException;
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
haxe_xml_XmlParserException.prototype = {
	toString: function() {
		var c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
	,__class__: haxe_xml_XmlParserException
};
var haxe_xml_Parser = function() { };
$hxClasses["haxe.xml.Parser"] = haxe_xml_Parser;
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
haxe_xml_Parser.parse = function(str,strict) {
	if(strict == null) {
		strict = false;
	}
	var doc = Xml.createDocument();
	haxe_xml_Parser.doParse(str,strict,0,doc);
	return doc;
};
haxe_xml_Parser.doParse = function(str,strict,p,parent) {
	if(p == null) {
		p = 0;
	}
	var xml = null;
	var state = 1;
	var next = 1;
	var aname = null;
	var start = 0;
	var nsubs = 0;
	var nbrackets = 0;
	var buf = new StringBuf();
	var escapeNext = 1;
	var attrValQuote = -1;
	while(p < str.length) {
		var c = str.charCodeAt(p);
		switch(state) {
		case 0:
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				state = next;
				continue;
			}
			break;
		case 1:
			if(c == 60) {
				state = 0;
				next = 2;
			} else {
				start = p;
				state = 13;
				continue;
			}
			break;
		case 2:
			switch(c) {
			case 33:
				if(str.charCodeAt(p + 1) == 91) {
					p += 2;
					if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
					}
					p += 5;
					state = 17;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
					if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
					}
					p += 8;
					state = 16;
					start = p + 1;
				} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
				} else {
					p += 2;
					state = 15;
					start = p + 1;
				}
				break;
			case 47:
				if(parent == null) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				start = p + 1;
				state = 0;
				next = 10;
				break;
			case 63:
				state = 14;
				start = p;
				break;
			default:
				state = 3;
				start = p;
				continue;
			}
			break;
		case 3:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(p == start) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
				parent.addChild(xml);
				++nsubs;
				state = 0;
				next = 4;
				continue;
			}
			break;
		case 4:
			switch(c) {
			case 47:
				state = 11;
				break;
			case 62:
				state = 9;
				break;
			default:
				state = 5;
				start = p;
				continue;
			}
			break;
		case 5:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
				}
				var tmp = HxOverrides.substr(str,start,p - start);
				aname = tmp;
				if(xml.exists(aname)) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
				}
				state = 0;
				next = 6;
				continue;
			}
			break;
		case 6:
			if(c == 61) {
				state = 0;
				next = 7;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
			}
			break;
		case 7:
			switch(c) {
			case 34:case 39:
				buf = new StringBuf();
				state = 8;
				start = p + 1;
				attrValQuote = c;
				break;
			default:
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
			}
			break;
		case 8:
			switch(c) {
			case 38:
				var len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				state = 18;
				escapeNext = 8;
				start = p + 1;
				break;
			case 60:case 62:
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
				} else if(c == attrValQuote) {
					var len1 = p - start;
					buf.b += len1 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len1);
					var val = buf.b;
					buf = new StringBuf();
					xml.set(aname,val);
					state = 0;
					next = 4;
				}
				break;
			default:
				if(c == attrValQuote) {
					var len2 = p - start;
					buf.b += len2 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len2);
					var val1 = buf.b;
					buf = new StringBuf();
					xml.set(aname,val1);
					state = 0;
					next = 4;
				}
			}
			break;
		case 9:
			p = haxe_xml_Parser.doParse(str,strict,p,xml);
			start = p;
			state = 1;
			break;
		case 10:
			if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
				if(start == p) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
				}
				var v = HxOverrides.substr(str,start,p - start);
				if(parent == null || parent.nodeType != 0) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
				}
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				if(v != parent.nodeName) {
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
				}
				state = 0;
				next = 12;
				continue;
			}
			break;
		case 11:
			if(c == 62) {
				state = 1;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 12:
			if(c == 62) {
				if(nsubs == 0) {
					parent.addChild(Xml.createPCData(""));
				}
				return p;
			} else {
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
			}
			break;
		case 13:
			if(c == 60) {
				var len3 = p - start;
				buf.b += len3 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len3);
				var child = Xml.createPCData(buf.b);
				buf = new StringBuf();
				parent.addChild(child);
				++nsubs;
				state = 0;
				next = 2;
			} else if(c == 38) {
				var len4 = p - start;
				buf.b += len4 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len4);
				state = 18;
				escapeNext = 13;
				start = p + 1;
			}
			break;
		case 14:
			if(c == 63 && str.charCodeAt(p + 1) == 62) {
				++p;
				var str1 = HxOverrides.substr(str,start + 1,p - start - 2);
				parent.addChild(Xml.createProcessingInstruction(str1));
				++nsubs;
				state = 1;
			}
			break;
		case 15:
			if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
				parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 16:
			if(c == 91) {
				++nbrackets;
			} else if(c == 93) {
				--nbrackets;
			} else if(c == 62 && nbrackets == 0) {
				parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
				++nsubs;
				state = 1;
			}
			break;
		case 17:
			if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
				var child1 = Xml.createCData(HxOverrides.substr(str,start,p - start));
				parent.addChild(child1);
				++nsubs;
				p += 2;
				state = 1;
			}
			break;
		case 18:
			if(c == 59) {
				var s = HxOverrides.substr(str,start,p - start);
				if(s.charCodeAt(0) == 35) {
					var c1 = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
					buf.b += String.fromCodePoint(c1);
				} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
					}
					buf.b += Std.string("&" + s + ";");
				} else {
					buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
				}
				start = p + 1;
				state = escapeNext;
			} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
				if(strict) {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
				}
				buf.b += String.fromCodePoint(38);
				var len5 = p - start;
				buf.b += len5 == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len5);
				--p;
				start = p + 1;
				state = escapeNext;
			}
			break;
		}
		++p;
	}
	if(state == 1) {
		start = p;
		state = 13;
	}
	if(state == 13) {
		if(parent.nodeType == 0) {
			if(parent.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
			}
			throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
		}
		if(p != start || nsubs == 0) {
			var len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
		}
		return p;
	}
	if(!strict && state == 18 && escapeNext == 13) {
		buf.b += String.fromCodePoint(38);
		var len = p - start;
		buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
		parent.addChild(Xml.createPCData(buf.b));
		++nsubs;
		return p;
	}
	throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				var _g_current = 0;
				var _g_array = value.children;
				while(_g_current < _g_array.length) {
					var child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			var _g_current = 0;
			var _g_array = value.children;
			while(_g_current < _g_array.length) {
				var child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		var _g_current = 0;
		var _g_array = value.children;
		while(_g_current < _g_array.length) {
			var child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var haxe_zip_Compress = function() { };
$hxClasses["haxe.zip.Compress"] = haxe_zip_Compress;
haxe_zip_Compress.__name__ = "haxe.zip.Compress";
haxe_zip_Compress.run = function(s,level) {
	throw new haxe_exceptions_NotImplementedException("Not implemented for this platform",null,{ fileName : "haxe/zip/Compress.hx", lineNumber : 39, className : "haxe.zip.Compress", methodName : "run"});
};
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__:"haxe.zip.Huffman",__constructs__:null
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBit",$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBits",$_.__params__ = ["n","table"],$_)
};
haxe_zip_Huffman.__constructs__ = [haxe_zip_Huffman.Found,haxe_zip_Huffman.NeedBit,haxe_zip_Huffman.NeedBits];
haxe_zip_Huffman.__empty_constructs__ = [];
var haxe_zip_HuffTools = function() {
};
$hxClasses["haxe.zip.HuffTools"] = haxe_zip_HuffTools;
haxe_zip_HuffTools.__name__ = "haxe.zip.HuffTools";
haxe_zip_HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var a = t.left;
			var b = t.right;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g = t.n;
			var _g = t.table;
			throw haxe_Exception.thrown("assert");
		}
	}
	,treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var a = t.left;
				var b = t.right;
				return haxe_zip_Huffman.NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	,treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var a = t.left;
			var b = t.right;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	,treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	,make: function(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0));
		}
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var p = lengths[i + pos];
			if(p >= maxbits) {
				throw haxe_Exception.thrown("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g = 1;
		var _g1 = maxbits - 1;
		while(_g < _g1) {
			var i = _g++;
			code = code + counts[i] << 1;
			tmp[i] = code;
		}
		var bits = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = nlengths;
		while(_g < _g1) {
			var i = _g++;
			var l = lengths[i + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
	,__class__: haxe_zip_HuffTools
};
var haxe_zip__$InflateImpl_Window = function(hasCrc) {
	this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
	this.pos = 0;
	if(hasCrc) {
		this.crc = new haxe_crypto_Adler32();
	}
};
$hxClasses["haxe.zip._InflateImpl.Window"] = haxe_zip__$InflateImpl_Window;
haxe_zip__$InflateImpl_Window.__name__ = "haxe.zip._InflateImpl.Window";
haxe_zip__$InflateImpl_Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	,addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	,addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	,getLastChar: function() {
		return this.buffer.b[this.pos - 1];
	}
	,available: function() {
		return this.pos;
	}
	,checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
	,__class__: haxe_zip__$InflateImpl_Window
};
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__:"haxe.zip._InflateImpl.State",__constructs__:null
	,Head: {_hx_name:"Head",_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_name:"Block",_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_name:"CData",_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_name:"Flat",_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_name:"Crc",_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_name:"Dist",_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_name:"DistOne",_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_name:"Done",_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
haxe_zip__$InflateImpl_State.__constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
haxe_zip__$InflateImpl_State.__empty_constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
var haxe_zip_InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new haxe_zip_HuffTools();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new haxe_zip__$InflateImpl_Window(crc);
};
$hxClasses["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl;
haxe_zip_InflateImpl.__name__ = "haxe.zip.InflateImpl";
haxe_zip_InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
	var output = new haxe_io_BytesBuffer();
	var inflate = new haxe_zip_InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
};
haxe_zip_InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	,readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	,getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	,getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	,getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	,resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	}
	,addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	,addByte: function(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	,addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	}
	,addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	,applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var a = h.left;
			var b = h.right;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var n = h.n;
			var tbl = h.table;
			return this.applyHuffman(tbl[this.getBits(n)]);
		}
	}
	,inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
		}
	}
	,inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw haxe_Exception.thrown("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw haxe_Exception.thrown("Invalid data");
			}
			if(fdict) {
				throw haxe_Exception.thrown("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g = hclen;
				var _g1 = 19;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g = 0;
				var _g1 = hlit + hdist;
				while(_g < _g1) {
					var i = _g++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			var crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw haxe_Exception.thrown("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen);
				this.len -= rlen;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			var rlen = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen);
			this.len -= rlen;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
	,__class__: haxe_zip_InflateImpl
};
var haxe_zip_Uncompress = function() { };
$hxClasses["haxe.zip.Uncompress"] = haxe_zip_Uncompress;
haxe_zip_Uncompress.__name__ = "haxe.zip.Uncompress";
haxe_zip_Uncompress.run = function(src,bufsize) {
	return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
};
var hxd_BitmapData = function(width,height) {
	if(!(width == -101 && height == -102)) {
		var canvas = window.document.createElement("canvas");
		canvas.width = width;
		canvas.height = height;
		this.ctx = canvas.getContext("2d",null);
	}
};
$hxClasses["hxd.BitmapData"] = hxd_BitmapData;
hxd_BitmapData.__name__ = "hxd.BitmapData";
hxd_BitmapData.notImplemented = function() {
	throw haxe_Exception.thrown("Not implemented");
};
hxd_BitmapData.fromNative = function(data) {
	var b = new hxd_BitmapData(-101,-102);
	b.ctx = data;
	return b;
};
hxd_BitmapData.prototype = {
	clear: function(color) {
		this.fill(0,0,this.ctx.canvas.width,this.ctx.canvas.height,color);
	}
	,fill: function(x,y,width,height,color) {
		this.ctx.fillStyle = "rgba(" + (color >> 16 & 255) + ", " + (color >> 8 & 255) + ", " + (color & 255) + ", " + (color >>> 24) / 255 + ")";
		this.ctx.fillRect(x,y,width,height);
	}
	,draw: function(x,y,src,srcX,srcY,width,height,blendMode) {
		this.drawScaled(x,y,width,height,src,srcX,srcY,width,height,blendMode);
	}
	,drawScaled: function(x,y,width,height,src,srcX,srcY,srcWidth,srcHeight,blendMode,smooth) {
		if(smooth == null) {
			smooth = true;
		}
		if(blendMode == null) {
			blendMode = h2d_BlendMode.Alpha;
		}
		throw haxe_Exception.thrown("Not implemented");
	}
	,line: function(x0,y0,x1,y1,color) {
		var dx = x1 - x0;
		var dy = y1 - y0;
		if(dx == 0) {
			if(y1 < y0) {
				var tmp = y0;
				y0 = y1;
				y1 = tmp;
			}
			if(y0 < 0) {
				y0 = 0;
			}
			if(y1 > this.ctx.canvas.height - 1) {
				y1 = this.ctx.canvas.height - 1;
			}
			var _g = y0;
			var _g1 = y1 + 1;
			while(_g < _g1) {
				var y = _g++;
				this.setPixel(x0,y,color);
			}
		} else if(dy == 0) {
			if(x1 < x0) {
				var tmp = x0;
				x0 = x1;
				x1 = tmp;
			}
			if(x0 < 0) {
				x0 = 0;
			}
			if(x1 > this.ctx.canvas.width - 1) {
				x1 = this.ctx.canvas.width - 1;
			}
			var _g = x0;
			var _g1 = x1 + 1;
			while(_g < _g1) {
				var x = _g++;
				this.setPixel(x,y0,color);
			}
		} else {
			var sx;
			var sy;
			var clip_x0;
			var clip_y0;
			var clip_x1;
			var clip_y1;
			if(x0 < x1) {
				if(x0 >= this.ctx.canvas.width || x1 < 0) {
					return;
				}
				sx = 1;
				clip_x0 = 0;
				clip_x1 = this.ctx.canvas.width - 1;
			} else {
				if(x1 >= this.ctx.canvas.width || x0 < 0) {
					return;
				}
				sx = -1;
				x1 = -x1;
				x0 = -x0;
				clip_x0 = 1 - this.ctx.canvas.width;
				clip_x1 = 0;
			}
			if(y0 < y1) {
				if(y0 >= this.ctx.canvas.height || y1 < 0) {
					return;
				}
				sy = 1;
				clip_y0 = 0;
				clip_y1 = this.ctx.canvas.height - 1;
			} else {
				if(y1 >= this.ctx.canvas.width || y0 < 0) {
					return;
				}
				sy = -1;
				y1 = -y1;
				y0 = -y0;
				clip_y0 = 1 - this.ctx.canvas.height;
				clip_y1 = 0;
			}
			dx = x1 - x0;
			dy = y1 - y0;
			var d2x = dx << 1;
			var d2y = dy << 1;
			var x = x0;
			var y = y0;
			if(dx >= dy) {
				var delta = d2y - dx;
				var tracing_can_start = false;
				if(y0 < clip_y0) {
					var temp = d2x;
					temp = temp * (clip_y0 - y0) - dx;
					var xinc = temp / d2y;
					x += xinc | 0;
					if(x > clip_x1) {
						return;
					}
					if(x >= clip_x0) {
						temp -= xinc * d2y;
						delta -= (temp | 0) + dx;
						y = clip_y0;
						if(temp > 0) {
							++x;
							delta += d2y;
						}
						tracing_can_start = true;
					}
				}
				if(!tracing_can_start && x0 < clip_x0) {
					var temp = d2y;
					temp *= clip_x0 - x0;
					var yinc = temp / d2x;
					y += yinc | 0;
					temp %= d2x;
					if(y > clip_y1 || y == clip_y1 && temp > dx) {
						return;
					}
					x = clip_x0;
					delta += temp | 0;
					if(temp >= dx) {
						++y;
						delta -= d2x;
					}
				}
				var xend = x1;
				if(y1 > clip_y1) {
					var temp = d2x;
					temp = temp * (clip_y1 - y1) + dx;
					var xinc = temp / d2y;
					xend += xinc | 0;
					if(temp - xinc * d2y == 0) {
						--xend;
					}
				}
				if(xend > clip_x1) {
					xend = clip_x1 + 1;
				} else {
					++xend;
				}
				if(sx == -1) {
					x = -x;
					xend = -xend;
				}
				if(sy == -1) {
					y = -y;
				}
				d2x -= d2y;
				while(x != xend) {
					this.setPixel(x,y,color);
					if(delta >= 0) {
						y += sy;
						delta -= d2x;
					} else {
						delta += d2y;
					}
					x += sx;
				}
			} else {
				var delta = d2x - dy;
				var tracing_can_start = false;
				if(x0 < clip_x0) {
					var temp = d2y;
					temp = temp * (clip_x0 - x0) - dy;
					var yinc = temp / d2x;
					y += yinc | 0;
					if(y > clip_y1) {
						return;
					}
					if(y >= clip_y0) {
						temp -= yinc * d2x;
						delta -= (temp | 0) + dy;
						x = clip_x0;
						if(temp > 0) {
							++y;
							delta += d2x;
						}
						tracing_can_start = true;
					}
				}
				if(!tracing_can_start && y0 < clip_y0) {
					var temp = d2x;
					temp *= clip_y0 - y0;
					var xinc = temp / d2y;
					x += xinc | 0;
					temp %= d2y;
					if(x > clip_x1 || x == clip_x1 && temp > dy) {
						return;
					}
					y = clip_y0;
					delta += temp | 0;
					if(temp >= dy) {
						++x;
						delta -= d2y;
					}
				}
				var yend = y1;
				if(x1 > clip_x1) {
					var temp = d2y;
					temp = temp * (clip_x1 - x1) + dy;
					var yinc = temp / d2x;
					yend += yinc | 0;
					if(temp - yinc * d2x == 0) {
						--yend;
					}
				}
				if(yend > clip_y1) {
					yend = clip_y1 + 1;
				} else {
					++yend;
				}
				if(sx == -1) {
					x = -x;
				}
				if(sy == -1) {
					y = -y;
					yend = -yend;
				}
				d2y -= d2x;
				while(y != yend) {
					this.setPixel(x,y,color);
					if(delta >= 0) {
						x += sx;
						delta -= d2y;
					} else {
						delta += d2x;
					}
					y += sy;
				}
			}
		}
	}
	,dispose: function() {
		this.ctx = null;
		this.pixel = null;
	}
	,clone: function() {
		return this.sub(0,0,this.ctx.canvas.width,this.ctx.canvas.height);
	}
	,sub: function(x,y,w,h) {
		var canvas = window.document.createElement("canvas");
		canvas.width = w;
		canvas.height = h;
		var ctx = canvas.getContext("2d",null);
		ctx.drawImage(this.ctx.canvas,x,y,w,h,0,0,w,h);
		return hxd_BitmapData.fromNative(ctx);
	}
	,lock: function() {
		if(this.lockImage == null) {
			this.lockImage = this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height);
		}
	}
	,unlock: function() {
		if(this.lockImage != null) {
			this.ctx.putImageData(this.lockImage,0,0);
			this.lockImage = null;
		}
	}
	,getPixel: function(x,y) {
		var i = this.lockImage;
		var a;
		if(i != null) {
			a = x + y * i.width << 2;
		} else {
			a = 0;
			i = this.ctx.getImageData(x,y,1,1);
		}
		return i.data[a] << 16 | i.data[a | 1] << 8 | i.data[a | 2] | i.data[a | 3] << 24;
	}
	,setPixel: function(x,y,c) {
		var i = this.lockImage;
		if(i != null) {
			var a = x + y * i.width << 2;
			i.data[a] = c >> 16 & 255;
			i.data[a | 1] = c >> 8 & 255;
			i.data[a | 2] = c & 255;
			i.data[a | 3] = c >>> 24 & 255;
			return;
		}
		var i = this.pixel;
		if(i == null) {
			i = this.ctx.createImageData(1,1);
			this.pixel = i;
		}
		i.data[0] = c >> 16 & 255;
		i.data[1] = c >> 8 & 255;
		i.data[2] = c & 255;
		i.data[3] = c >>> 24 & 255;
		this.ctx.putImageData(i,x,y);
	}
	,get_width: function() {
		return this.ctx.canvas.width;
	}
	,get_height: function() {
		return this.ctx.canvas.height;
	}
	,getPixels: function() {
		var w = this.ctx.canvas.width;
		var h = this.ctx.canvas.height;
		var data = this.ctx.getImageData(0,0,w,h).data;
		var pixels = data.buffer;
		return new hxd_Pixels(w,h,haxe_io_Bytes.ofData(pixels),hxd_PixelFormat.RGBA);
	}
	,setPixels: function(pixels) {
		if(pixels.width != this.ctx.canvas.width || pixels.height != this.ctx.canvas.height) {
			throw haxe_Exception.thrown("Invalid pixels size");
		}
		var img = this.ctx.createImageData(pixels.width,pixels.height);
		pixels.convert(hxd_PixelFormat.RGBA);
		var _g = 0;
		var _g1 = pixels.width * pixels.height * 4;
		while(_g < _g1) {
			var i = _g++;
			img.data[i] = pixels.bytes.b[i];
		}
		this.ctx.putImageData(img,0,0);
	}
	,toNative: function() {
		return this.ctx;
	}
	,toPNG: function() {
		var pixels = this.getPixels();
		var png = pixels.toPNG();
		pixels.dispose();
		return png;
	}
	,__class__: hxd_BitmapData
};
var hxd_Precision = {};
hxd_Precision._new = function(v) {
	return v;
};
hxd_Precision.getSize = function(this1) {
	return hxd_Precision.SIZES[this1];
};
hxd_Precision.toInt = function(this1) {
	return this1;
};
hxd_Precision.fromInt = function(v) {
	return v;
};
hxd_Precision.toString = function(this1) {
	switch(this1) {
	case 0:
		return "F32";
	case 1:
		return "F16";
	case 2:
		return "U8";
	case 3:
		return "S8";
	}
};
var hxd_InputFormat = {};
hxd_InputFormat._new = function(v) {
	return v;
};
hxd_InputFormat.getSize = function(this1) {
	return this1 & 7;
};
hxd_InputFormat.toInt = function(this1) {
	return this1;
};
hxd_InputFormat.toString = function(this1) {
	switch(this1) {
	case 1:
		return "DFloat";
	case 2:
		return "DVec2";
	case 3:
		return "DVec3";
	case 4:
		return "DVec4";
	case 9:
		return "DBytes4";
	}
};
hxd_InputFormat.fromInt = function(v) {
	return v;
};
hxd_InputFormat.fromHXSL = function(t) {
	switch(t._hx_index) {
	case 3:
		return 1;
	case 5:
		var _g = t.t;
		switch(t.size) {
		case 2:
			if(_g._hx_index == 1) {
				return 2;
			} else {
				throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
			}
			break;
		case 3:
			if(_g._hx_index == 1) {
				return 3;
			} else {
				throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
			}
			break;
		case 4:
			if(_g._hx_index == 1) {
				return 4;
			} else {
				throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
		}
		break;
	case 9:
		if(t.size == 4) {
			return 9;
		} else {
			throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
		}
		break;
	default:
		throw haxe_Exception.thrown("Unsupported buffer type " + Std.string(t));
	}
};
var hxd_BufferInput = function(name,type,precision) {
	if(precision == null) {
		precision = 0;
	}
	this.name = name;
	this.type = type;
	this.precision = precision;
};
$hxClasses["hxd.BufferInput"] = hxd_BufferInput;
hxd_BufferInput.__name__ = "hxd.BufferInput";
hxd_BufferInput.prototype = {
	getBytesSize: function() {
		return (this.type & 7) * hxd_Precision.SIZES[this.precision];
	}
	,equals: function(b) {
		if(this.type == b.type && this.name == b.name) {
			return this.precision == b.precision;
		} else {
			return false;
		}
	}
	,__class__: hxd_BufferInput
};
var hxd_BufferMapping = {};
hxd_BufferMapping._new = function(index,offset,prec) {
	return index << 3 | prec | offset << 16;
};
hxd_BufferMapping.get_bufferIndex = function(this1) {
	return this1 >> 3 & 255;
};
hxd_BufferMapping.get_precision = function(this1) {
	return this1 & 7;
};
hxd_BufferMapping.get_offset = function(this1) {
	return this1 >> 16;
};
var hxd_BufferFormat = function(inputs) {
	this.uid = hxd_BufferFormat._UID++;
	this.stride = this.strideBytes = 0;
	this.inputs = inputs.slice();
	this.hasLowPrecision = false;
	var _g = 0;
	while(_g < inputs.length) {
		var i = inputs[_g];
		++_g;
		this.stride += i.type & 7;
		this.strideBytes += (i.type & 7) * hxd_Precision.SIZES[i.precision];
		if((this.strideBytes & 3) != 0) {
			this.strideBytes += 4 - (this.strideBytes & 3);
		}
		if(i.precision != 0) {
			this.hasLowPrecision = true;
		}
	}
};
$hxClasses["hxd.BufferFormat"] = hxd_BufferFormat;
hxd_BufferFormat.__name__ = "hxd.BufferFormat";
hxd_BufferFormat.get_H2D = function() {
	return hxd_BufferFormat.get_XY_UV_RGBA();
};
hxd_BufferFormat.get_XY_UV_RGBA = function() {
	if(hxd_BufferFormat.XY_UV_RGBA == null) {
		hxd_BufferFormat.XY_UV_RGBA = hxd_BufferFormat.make([new hxd_BufferInput("position",2,0),new hxd_BufferInput("uv",2,0),new hxd_BufferInput("color",4,0)]);
	}
	return hxd_BufferFormat.XY_UV_RGBA;
};
hxd_BufferFormat.get_XY_UV = function() {
	if(hxd_BufferFormat.XY_UV == null) {
		hxd_BufferFormat.XY_UV = hxd_BufferFormat.make([new hxd_BufferInput("position",2,0),new hxd_BufferInput("uv",2,0)]);
	}
	return hxd_BufferFormat.XY_UV;
};
hxd_BufferFormat.get_POS3D = function() {
	if(hxd_BufferFormat.POS3D == null) {
		hxd_BufferFormat.POS3D = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0)]);
	}
	return hxd_BufferFormat.POS3D;
};
hxd_BufferFormat.get_POS3D_NORMAL = function() {
	if(hxd_BufferFormat.POS3D_NORMAL == null) {
		hxd_BufferFormat.POS3D_NORMAL = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0),new hxd_BufferInput("normal",3,0)]);
	}
	return hxd_BufferFormat.POS3D_NORMAL;
};
hxd_BufferFormat.get_POS3D_NORMAL_UV = function() {
	if(hxd_BufferFormat.POS3D_NORMAL_UV == null) {
		hxd_BufferFormat.POS3D_NORMAL_UV = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0),new hxd_BufferInput("normal",3,0),new hxd_BufferInput("uv",2,0)]);
	}
	return hxd_BufferFormat.POS3D_NORMAL_UV;
};
hxd_BufferFormat.get_POS3D_NORMAL_UV_RGBA = function() {
	if(hxd_BufferFormat.POS3D_NORMAL_UV_RGBA == null) {
		hxd_BufferFormat.POS3D_NORMAL_UV_RGBA = hxd_BufferFormat.get_POS3D_NORMAL_UV().append("color",4);
	}
	return hxd_BufferFormat.POS3D_NORMAL_UV_RGBA;
};
hxd_BufferFormat.get_POS3D_UV = function() {
	if(hxd_BufferFormat.POS3D_UV == null) {
		hxd_BufferFormat.POS3D_UV = hxd_BufferFormat.make([new hxd_BufferInput("position",3,0),new hxd_BufferInput("uv",2,0)]);
	}
	return hxd_BufferFormat.POS3D_UV;
};
hxd_BufferFormat.get_VEC4_DATA = function() {
	if(hxd_BufferFormat.VEC4_DATA == null) {
		hxd_BufferFormat.VEC4_DATA = hxd_BufferFormat.make([new hxd_BufferInput("data",4,0)]);
	}
	return hxd_BufferFormat.VEC4_DATA;
};
hxd_BufferFormat.get_INDEX16 = function() {
	if(hxd_BufferFormat.INDEX16 == null) {
		hxd_BufferFormat.INDEX16 = hxd_BufferFormat.make([new hxd_BufferInput("index",1,1)]);
		hxd_BufferFormat.INDEX16.strideBytes = 2;
	}
	return hxd_BufferFormat.INDEX16;
};
hxd_BufferFormat.get_INDEX32 = function() {
	if(hxd_BufferFormat.INDEX32 == null) {
		hxd_BufferFormat.INDEX32 = hxd_BufferFormat.make([new hxd_BufferInput("index",1,0)]);
	}
	return hxd_BufferFormat.INDEX32;
};
hxd_BufferFormat.make = function(inputs) {
	var names = [];
	var _g = 0;
	while(_g < inputs.length) {
		var b = inputs[_g];
		++_g;
		names.push(b.name);
	}
	var key = names.join("|");
	var arr = hxd_BufferFormat.ALL_FORMATS.h[key];
	if(arr == null) {
		arr = [];
		hxd_BufferFormat.ALL_FORMATS.h[key] = arr;
	}
	var _g = 0;
	while(_g < arr.length) {
		var fmt = arr[_g];
		++_g;
		var found = true;
		var _g1 = 0;
		var _g2 = inputs.length;
		while(_g1 < _g2) {
			var i = _g1++;
			var _this = inputs[i];
			var b = fmt.inputs[i];
			if(!(_this.type == b.type && _this.name == b.name && _this.precision == b.precision)) {
				found = false;
				break;
			}
		}
		if(found) {
			return fmt;
		}
	}
	var fmt = new hxd_BufferFormat(inputs);
	arr.push(fmt);
	return fmt;
};
hxd_BufferFormat.float32to16 = function(v,denormalsAreZero) {
	if(denormalsAreZero == null) {
		denormalsAreZero = false;
	}
	var i = haxe_io_FPHelper.floatToI32(v);
	var sign = (i & -2147483648) >>> 16;
	var exp = (i & 2139095040) >>> 23;
	var bits = i & 8388607;
	if(exp > 112) {
		return sign | exp - 112 << 10 & 31744 | bits >> 13;
	}
	if(exp < 113 && exp > 101 && !denormalsAreZero) {
		return sign | (8384512 + bits >> 125 - exp) + 1 >> 1;
	}
	if(exp > 143) {
		return sign | 32767;
	}
	return 0;
};
hxd_BufferFormat.float16to32 = function(v) {
	var sign = (v & 32768) << 16;
	var bits = (v & 1023) << 13;
	var exp = (v & 31744) >> 10;
	if(exp != 0) {
		return haxe_io_FPHelper.i32ToFloat(sign | exp + 112 << 23 | bits);
	}
	if(bits == 0) {
		return 0;
	}
	var bitcount = haxe_io_FPHelper.floatToI32(bits) >> 23;
	return haxe_io_FPHelper.i32ToFloat(sign | bitcount - 37 << 23 | bits << 150 - bitcount & 8380416);
};
hxd_BufferFormat.float32toS8 = function(v) {
	var i = Math.floor(v * 128);
	if(i >= 127) {
		return 127;
	}
	if(i <= -127) {
		return 128;
	}
	if(i >= 0) {
		return i;
	} else {
		return 127 + i | 128;
	}
};
hxd_BufferFormat.floatS8to32 = function(v) {
	return ((v & 128) != 0 ? -1 : 1) * ((v & 127) / 127);
};
hxd_BufferFormat.float32toU8 = function(v) {
	if(v < 0) {
		return 0;
	}
	if(v >= 1) {
		return 255;
	}
	return Math.floor(v * 256);
};
hxd_BufferFormat.floatU8to32 = function(v) {
	return (v & 255) / 255;
};
hxd_BufferFormat.prototype = {
	getInput: function(name) {
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.name == name) {
				return i;
			}
		}
		return null;
	}
	,calculateInputOffset: function(name) {
		var offset = 0;
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.name == name) {
				return offset;
			}
			offset += (i.type & 7) * hxd_Precision.SIZES[i.precision];
			if((offset & 3) != 0) {
				offset += 4 - (offset & 3);
			}
		}
		throw haxe_Exception.thrown("Input not found : " + name);
	}
	,hasInput: function(name,type) {
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.name == name) {
				if(type != null) {
					return type == i.type;
				} else {
					return true;
				}
			}
		}
		return false;
	}
	,append: function(name,type) {
		var inputs = this.inputs.slice();
		inputs.push(new hxd_BufferInput(name,type,0));
		return hxd_BufferFormat.make(inputs);
	}
	,pop: function() {
		var inputs = this.inputs.slice();
		inputs.pop();
		return hxd_BufferFormat.make(inputs);
	}
	,isSubSet: function(fmt) {
		if(fmt == this) {
			return true;
		}
		if(this.inputs.length >= fmt.inputs.length) {
			return false;
		}
		var _g = 0;
		var _g1 = this.inputs.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = this.inputs[i];
			var i2 = fmt.inputs[i];
			if(i1.name != i2.name || i1.type != i2.type) {
				return false;
			}
		}
		return true;
	}
	,resolveMapping: function(target) {
		var m = this.mappings == null ? null : this.mappings[target.uid];
		if(m != null) {
			return m;
		}
		m = [];
		var _g = 0;
		var _g1 = target.inputs;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			var found = false;
			var _g2 = 0;
			var _g3 = this.inputs;
			while(_g2 < _g3.length) {
				var i2 = _g3[_g2];
				++_g2;
				if(i2.name == i.name && i2.type == i.type) {
					m.push(hxd_BufferMapping._new(0,this.calculateInputOffset(i2.name),i2.precision));
					found = true;
					break;
				}
			}
			if(!found) {
				throw haxe_Exception.thrown("Missing buffer input '" + i.name + "'");
			}
		}
		if(this.mappings == null) {
			this.mappings = [];
		}
		this.mappings[target.uid] = m;
		return m;
	}
	,getInputs: function() {
		return new haxe_iterators_ArrayIterator(this.inputs);
	}
	,toString: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.inputs;
		while(_g1 < _g2.length) {
			var i = _g2[_g1];
			++_g1;
			_g.push(i.name + ":" + hxd_InputFormat.toString(i.type) + (i.precision == 0 ? "" : "." + hxd_Precision.toString(i.precision).toLowerCase()));
		}
		return _g.toString();
	}
	,__class__: hxd_BufferFormat
};
var hxd_MultiFormat = function(formats) {
	this.mappings = [];
	this.uid = hxd_MultiFormat._UID++;
	this.formats = formats;
};
$hxClasses["hxd.MultiFormat"] = hxd_MultiFormat;
hxd_MultiFormat.__name__ = "hxd.MultiFormat";
hxd_MultiFormat.make = function(formats) {
	if(formats.length > hxd_MultiFormat.MAX_FORMATS) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < formats.length) {
			var f = formats[_g1];
			++_g1;
			_g.push(f.toString());
		}
		throw haxe_Exception.thrown("Too many formats (addBuffer leak?) " + Std.string(_g));
	}
	var c = { found : null, nexts : hxd_MultiFormat.CACHE};
	var _g = 0;
	while(_g < formats.length) {
		var f = formats[_g];
		++_g;
		var c2 = c.nexts.h[f.uid];
		if(c2 == null) {
			c2 = { found : null, nexts : new haxe_ds_IntMap()};
			c.nexts.h[f.uid] = c2;
		}
		c = c2;
	}
	if(c.found == null) {
		c.found = new hxd_MultiFormat(formats);
	}
	return c.found;
};
hxd_MultiFormat.prototype = {
	resolveMapping: function(format) {
		var m = this.mappings[format.uid];
		if(m == null) {
			m = this.makeMapping(format);
		}
		return m;
	}
	,makeMapping: function(format) {
		var m = [];
		var _g_current = 0;
		var _g_array = format.inputs;
		while(_g_current < _g_array.length) {
			var input = _g_array[_g_current++];
			var found = false;
			var match = null;
			var _g_current1 = 0;
			var _g_array1 = this.formats;
			while(_g_current1 < _g_array1.length) {
				var _g_value = _g_array1[_g_current1];
				var _g_key = _g_current1++;
				var idx = _g_key;
				var f = _g_value;
				var i = f.getInput(input.name);
				if(i != null) {
					match = i;
					if(i.type != input.type) {
						continue;
					}
					var offset = f.calculateInputOffset(i.name);
					m.push(hxd_BufferMapping._new(idx,offset,i.precision));
					found = true;
					break;
				}
			}
			if(!found) {
				if(match != null) {
					throw haxe_Exception.thrown("Shader buffer " + input.name + " was requested with " + (input.type == null ? "null" : hxd_InputFormat.toString(input.type)) + " but found with " + (match.type == null ? "null" : hxd_InputFormat.toString(match.type)));
				}
				throw haxe_Exception.thrown("Missing shader buffer " + input.name);
			}
		}
		this.mappings[format.uid] = m;
		return m;
	}
	,__class__: hxd_MultiFormat
};
var hxd_Charset = function() {
	var _gthis = this;
	this.map = new haxe_ds_IntMap();
	var _g = 0;
	while(_g < 94) {
		var i = _g++;
		_gthis.map.h[65281 + i] = 33 + i;
	}
	var _g = 192;
	var _g1 = 199;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 65;
	}
	var _g = 224;
	var _g1 = 231;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 97;
	}
	var _g = 200;
	var _g1 = 204;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 69;
	}
	var _g = 232;
	var _g1 = 236;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 101;
	}
	var _g = 204;
	var _g1 = 208;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 73;
	}
	var _g = 236;
	var _g1 = 240;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 105;
	}
	var _g = 210;
	var _g1 = 215;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 79;
	}
	var _g = 242;
	var _g1 = 247;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 111;
	}
	var _g = 217;
	var _g1 = 221;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 85;
	}
	var _g = 249;
	var _g1 = 253;
	while(_g < _g1) {
		var i = _g++;
		_gthis.map.h[i] = 117;
	}
	_gthis.map.h[199] = 67;
	_gthis.map.h[231] = 67;
	_gthis.map.h[208] = 68;
	_gthis.map.h[222] = 100;
	_gthis.map.h[209] = 78;
	_gthis.map.h[241] = 110;
	_gthis.map.h[221] = 89;
	_gthis.map.h[253] = 121;
	_gthis.map.h[255] = 121;
	_gthis.map.h[8364] = 69;
	_gthis.map.h[12288] = 32;
	_gthis.map.h[160] = 32;
	_gthis.map.h[171] = 34;
	_gthis.map.h[187] = 34;
	_gthis.map.h[8220] = 34;
	_gthis.map.h[8221] = 34;
	_gthis.map.h[8222] = 34;
	_gthis.map.h[8216] = 39;
	_gthis.map.h[8217] = 39;
	_gthis.map.h[180] = 39;
	_gthis.map.h[8216] = 39;
	_gthis.map.h[8249] = 60;
	_gthis.map.h[8250] = 62;
	_gthis.map.h[8211] = 45;
};
$hxClasses["hxd.Charset"] = hxd_Charset;
hxd_Charset.__name__ = "hxd.Charset";
hxd_Charset.getDefault = function() {
	if(hxd_Charset.inst == null) {
		hxd_Charset.inst = new hxd_Charset();
	}
	return hxd_Charset.inst;
};
hxd_Charset.prototype = {
	resolveChar: function(code,glyphs) {
		var c = code;
		while(c != null) {
			var g = glyphs.h[c];
			if(g != null) {
				return g;
			}
			c = this.map.h[c];
		}
		return null;
	}
	,isCJK: function(code) {
		if(!(code >= 11904 && code <= 42191 || code >= 63744 && code <= 64255)) {
			if(code >= 131072) {
				return code <= 262141;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,isSpace: function(code) {
		if(code != 32) {
			return code == 12288;
		} else {
			return true;
		}
	}
	,isBreakChar: function(code) {
		if(!this.isSpace(code)) {
			return this.isCJK(code);
		} else {
			return true;
		}
	}
	,isComplementChar: function(code) {
		return hxd_Charset.complementChars.h.hasOwnProperty(code);
	}
	,__class__: hxd_Charset
};
var hxd_Cursor = $hxEnums["hxd.Cursor"] = { __ename__:"hxd.Cursor",__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"hxd.Cursor",toString:$estr}
	,Button: {_hx_name:"Button",_hx_index:1,__enum__:"hxd.Cursor",toString:$estr}
	,Move: {_hx_name:"Move",_hx_index:2,__enum__:"hxd.Cursor",toString:$estr}
	,TextInput: {_hx_name:"TextInput",_hx_index:3,__enum__:"hxd.Cursor",toString:$estr}
	,Hide: {_hx_name:"Hide",_hx_index:4,__enum__:"hxd.Cursor",toString:$estr}
	,Custom: ($_=function(custom) { return {_hx_index:5,custom:custom,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["custom"],$_)
	,Callback: ($_=function(f) { return {_hx_index:6,f:f,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Callback",$_.__params__ = ["f"],$_)
};
hxd_Cursor.__constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide,hxd_Cursor.Custom,hxd_Cursor.Callback];
hxd_Cursor.__empty_constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide];
var hxd_CustomCursor = function(frames,speed,offsetX,offsetY) {
	this.frames = frames;
	this.speed = speed;
	this.offsetX = offsetX;
	this.offsetY = offsetY;
	this.frameDelay = 1 / speed;
	this.frameTime = 0;
	this.frameIndex = 0;
};
$hxClasses["hxd.CustomCursor"] = hxd_CustomCursor;
hxd_CustomCursor.__name__ = "hxd.CustomCursor";
hxd_CustomCursor.getNativeCursor = function(name) {
	var c = new hxd_CustomCursor([],0,0,0);
	c.alloc = [name];
	return hxd_Cursor.Custom(c);
};
hxd_CustomCursor.prototype = {
	reset: function() {
		this.frameTime = 0;
		this.frameIndex = 0;
	}
	,update: function(dt) {
		var newTime = this.frameTime + dt;
		var delay = this.frameDelay;
		var index = this.frameIndex;
		while(newTime >= delay) {
			newTime -= delay;
			++index;
		}
		this.frameTime = newTime;
		if(index >= this.frames.length) {
			index %= this.frames.length;
		}
		if(index != this.frameIndex) {
			this.frameIndex = index;
			return index;
		}
		return -1;
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.frames;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.ctx = null;
			f.pixel = null;
		}
		this.frames = [];
		if(this.alloc != null) {
			this.alloc = null;
		}
	}
	,__class__: hxd_CustomCursor
};
var hxd_DroppedFile = function(file) {
	this.file = file;
};
$hxClasses["hxd.DroppedFile"] = hxd_DroppedFile;
hxd_DroppedFile.__name__ = "hxd.DroppedFile";
hxd_DroppedFile.prototype = {
	__class__: hxd_DroppedFile
};
var hxd_DropFileEvent = function(files,dx,dy) {
	this.files = files;
	this.dropX = dx;
	this.dropY = dy;
};
$hxClasses["hxd.DropFileEvent"] = hxd_DropFileEvent;
hxd_DropFileEvent.__name__ = "hxd.DropFileEvent";
hxd_DropFileEvent.prototype = {
	get_file: function() {
		return this.files[0];
	}
	,__class__: hxd_DropFileEvent
};
var hxd_EventKind = $hxEnums["hxd.EventKind"] = { __ename__:"hxd.EventKind",__constructs__:null
	,EPush: {_hx_name:"EPush",_hx_index:0,__enum__:"hxd.EventKind",toString:$estr}
	,ERelease: {_hx_name:"ERelease",_hx_index:1,__enum__:"hxd.EventKind",toString:$estr}
	,EMove: {_hx_name:"EMove",_hx_index:2,__enum__:"hxd.EventKind",toString:$estr}
	,EOver: {_hx_name:"EOver",_hx_index:3,__enum__:"hxd.EventKind",toString:$estr}
	,EOut: {_hx_name:"EOut",_hx_index:4,__enum__:"hxd.EventKind",toString:$estr}
	,EWheel: {_hx_name:"EWheel",_hx_index:5,__enum__:"hxd.EventKind",toString:$estr}
	,EFocus: {_hx_name:"EFocus",_hx_index:6,__enum__:"hxd.EventKind",toString:$estr}
	,EFocusLost: {_hx_name:"EFocusLost",_hx_index:7,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyDown: {_hx_name:"EKeyDown",_hx_index:8,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyUp: {_hx_name:"EKeyUp",_hx_index:9,__enum__:"hxd.EventKind",toString:$estr}
	,EReleaseOutside: {_hx_name:"EReleaseOutside",_hx_index:10,__enum__:"hxd.EventKind",toString:$estr}
	,ETextInput: {_hx_name:"ETextInput",_hx_index:11,__enum__:"hxd.EventKind",toString:$estr}
	,ECheck: {_hx_name:"ECheck",_hx_index:12,__enum__:"hxd.EventKind",toString:$estr}
};
hxd_EventKind.__constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
hxd_EventKind.__empty_constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
var hxd_Event = function(k,x,y) {
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.button = 0;
	this.kind = k;
	this.relX = x;
	this.relY = y;
};
$hxClasses["hxd.Event"] = hxd_Event;
hxd_Event.__name__ = "hxd.Event";
hxd_Event.prototype = {
	toString: function() {
		var tmp = Std.string(this.kind) + "[" + (this.relX | 0) + "," + (this.relY | 0) + "]";
		var tmp1;
		switch(this.kind._hx_index) {
		case 5:
			tmp1 = ",wheelDelta=" + this.wheelDelta;
			break;
		case 8:case 9:
			tmp1 = ",keyCode=" + this.keyCode;
			break;
		case 0:case 1:case 10:
			tmp1 = ",button=" + this.button;
			break;
		case 11:
			tmp1 = ",charCode=" + this.charCode;
			break;
		case 2:case 3:case 4:case 6:case 7:case 12:
			tmp1 = "";
			break;
		}
		return tmp + tmp1;
	}
	,__class__: hxd_Event
};
var hxd__$FloatBuffer_Float32Expand = {};
hxd__$FloatBuffer_Float32Expand._new = function(length) {
	return { pos : length, array : new Float32Array(new ArrayBuffer(length << 2))};
};
hxd__$FloatBuffer_Float32Expand.get_length = function(this1) {
	return this1.pos;
};
hxd__$FloatBuffer_Float32Expand.set_length = function(this1,v) {
	if(this1.pos != v) {
		var newArray = new Float32Array(v);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.pos = v;
	return v;
};
hxd__$FloatBuffer_Float32Expand.push = function(this1,v) {
	if(this1.pos == this1.array.length) {
		var newSize = this1.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.array[this1.pos++] = v;
};
hxd__$FloatBuffer_Float32Expand.get = function(this1,index) {
	return this1.array[index];
};
hxd__$FloatBuffer_Float32Expand.set = function(this1,index,v) {
	return this1.array[index] = v;
};
hxd__$FloatBuffer_Float32Expand.toF32Array = function(this1) {
	return this1.array;
};
hxd__$FloatBuffer_Float32Expand.toArray = function(this1) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1.pos;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(this1.array[i]);
	}
	return _g;
};
var hxd__$FloatBuffer_InnerIterator = function(b) {
	this.b = b;
	this.len = this.b.pos;
	this.pos = 0;
};
$hxClasses["hxd._FloatBuffer.InnerIterator"] = hxd__$FloatBuffer_InnerIterator;
hxd__$FloatBuffer_InnerIterator.__name__ = "hxd._FloatBuffer.InnerIterator";
hxd__$FloatBuffer_InnerIterator.prototype = {
	hasNext: function() {
		return this.pos < this.len;
	}
	,next: function() {
		return this.b.array[this.pos++];
	}
	,__class__: hxd__$FloatBuffer_InnerIterator
};
var hxd_FloatBuffer = {};
hxd_FloatBuffer._new = function(length) {
	if(length == null) {
		length = 0;
	}
	return hxd__$FloatBuffer_Float32Expand._new(length);
};
hxd_FloatBuffer.push = function(this1,v) {
	if(this1.pos == this1.array.length) {
		var newSize = this1.array.length << 1;
		if(newSize < 128) {
			newSize = 128;
		}
		var newArray = new Float32Array(newSize);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.array[this1.pos++] = v;
};
hxd_FloatBuffer.grow = function(this1,v) {
	var _g = this1.pos;
	var _g1 = v;
	while(_g < _g1) {
		var i = _g++;
		if(this1.pos == this1.array.length) {
			var newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			var newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = 0.;
	}
};
hxd_FloatBuffer.resize = function(this1,v) {
	if(this1.pos != v) {
		var newArray = new Float32Array(v);
		newArray.set(this1.array);
		this1.array = newArray;
	}
	this1.pos = v;
};
hxd_FloatBuffer.arrayRead = function(this1,key) {
	return this1.array[key];
};
hxd_FloatBuffer.arrayWrite = function(this1,key,value) {
	return this1.array[key] = value;
};
hxd_FloatBuffer.getNative = function(this1) {
	return this1;
};
hxd_FloatBuffer.iterator = function(this1) {
	return new hxd__$FloatBuffer_InnerIterator(this1);
};
hxd_FloatBuffer.get_length = function(this1) {
	return this1.pos;
};
var hxd__$IndexBuffer_InnerIterator = function(b) {
	this.b = b;
	this.len = this.b.length;
	this.pos = 0;
};
$hxClasses["hxd._IndexBuffer.InnerIterator"] = hxd__$IndexBuffer_InnerIterator;
hxd__$IndexBuffer_InnerIterator.__name__ = "hxd._IndexBuffer.InnerIterator";
hxd__$IndexBuffer_InnerIterator.prototype = {
	hasNext: function() {
		return this.pos < this.len;
	}
	,next: function() {
		return this.b[this.pos++];
	}
	,__class__: hxd__$IndexBuffer_InnerIterator
};
var hxd_IndexBuffer = {};
hxd_IndexBuffer._new = function(length) {
	if(length == null) {
		length = 0;
	}
	return new Array(length);
};
hxd_IndexBuffer.push = function(this1,v) {
	this1.push(v);
};
hxd_IndexBuffer.grow = function(this1,v) {
	while(this1.length < v) this1.push(0);
};
hxd_IndexBuffer.arrayRead = function(this1,key) {
	return this1[key];
};
hxd_IndexBuffer.arrayWrite = function(this1,key,value) {
	return this1[key] = value;
};
hxd_IndexBuffer.getNative = function(this1) {
	return this1;
};
hxd_IndexBuffer.iterator = function(this1) {
	return new hxd__$IndexBuffer_InnerIterator(this1);
};
hxd_IndexBuffer.get_length = function(this1) {
	return this1.length;
};
var hxd_Key = function() { };
$hxClasses["hxd.Key"] = hxd_Key;
hxd_Key.__name__ = "hxd.Key";
hxd_Key.isDown = function(code) {
	return hxd_Key.keyPressed[code] > 0;
};
hxd_Key.getFrame = function() {
	return hxd_Timer.frameCount + 2;
};
hxd_Key.isPressed = function(code) {
	return hxd_Key.keyPressed[code] == hxd_Timer.frameCount + 2 - 1;
};
hxd_Key.isReleased = function(code) {
	return hxd_Key.keyPressed[code] == -(hxd_Timer.frameCount + 2) + 1;
};
hxd_Key.initialize = function() {
	if(hxd_Key.initDone) {
		hxd_Key.dispose();
	}
	hxd_Key.initDone = true;
	hxd_Key.keyPressed = [];
	hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent);
};
hxd_Key.dispose = function() {
	if(hxd_Key.initDone) {
		hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent);
		hxd_Key.initDone = false;
		hxd_Key.keyPressed = [];
	}
};
hxd_Key.onEvent = function(e) {
	switch(e.kind._hx_index) {
	case 0:
		if(e.button < 5) {
			hxd_Key.keyPressed[e.button] = hxd_Timer.frameCount + 2;
		}
		break;
	case 1:
		if(e.button < 5) {
			hxd_Key.keyPressed[e.button] = -(hxd_Timer.frameCount + 2);
		}
		break;
	case 5:
		hxd_Key.keyPressed[e.wheelDelta > 0 ? 6 : 5] = hxd_Timer.frameCount + 2;
		break;
	case 8:
		if(!hxd_Key.ALLOW_KEY_REPEAT && hxd_Key.keyPressed[e.keyCode] > 0) {
			return;
		}
		hxd_Key.keyPressed[e.keyCode] = hxd_Timer.frameCount + 2;
		break;
	case 9:
		hxd_Key.keyPressed[e.keyCode] = -(hxd_Timer.frameCount + 2);
		break;
	case 10:
		hxd_Key.keyPressed = [];
		break;
	default:
	}
};
hxd_Key.getKeyName = function(keyCode) {
	var c = keyCode;
	switch(c) {
	case 0:
		return "MouseLeft";
	case 1:
		return "MouseRight";
	case 2:
		return "MouseMiddle";
	case 3:
		return "Mouse3";
	case 4:
		return "Mouse4";
	case 8:
		return "Backspace";
	case 9:
		return "Tab";
	case 13:
		return "Enter";
	case 16:
		return "Shift";
	case 17:
		return "Ctrl";
	case 18:
		return "Alt";
	case 19:
		return "PauseBreak";
	case 20:
		return "CapsLock";
	case 27:
		return "Escape";
	case 32:
		return "Space";
	case 33:
		return "PageUp";
	case 34:
		return "PageDown";
	case 35:
		return "End";
	case 36:
		return "Home";
	case 37:
		return "Left";
	case 38:
		return "Up";
	case 39:
		return "Right";
	case 40:
		return "Down";
	case 45:
		return "Insert";
	case 46:
		return "Delete";
	case 91:
		return "LeftWindowKey";
	case 92:
		return "RightWindowKey";
	case 93:
		return "ContextMenu";
	case 106:
		return "NumPad*";
	case 107:
		return "NumPad+";
	case 108:
		return "NumPadEnter";
	case 109:
		return "NumPad-";
	case 110:
		return "NumPad.";
	case 111:
		return "NumPad/";
	case 144:
		return "NumLock";
	case 145:
		return "ScrollLock";
	case 186:
		return "Semicolon";
	case 187:
		return "Equals";
	case 188:
		return "Comma";
	case 189:
		return "Minus";
	case 190:
		return "Period";
	case 191:
		return "Slash";
	case 192:
		return "Tilde";
	case 219:
		return "BracketLeft";
	case 220:
		return "Backslash";
	case 221:
		return "BracketRight";
	case 222:
		return "Quote";
	case 226:
		return "IntlBackslash";
	case 272:
		return "LShift";
	case 273:
		return "LCtrl";
	case 274:
		return "LAlt";
	case 528:
		return "RShift";
	case 529:
		return "RCtrl";
	case 530:
		return "RAlt";
	default:
		if(c >= 48 && c <= 57) {
			return "" + (c - 48);
		} else if(c >= 96 && c <= 105) {
			return "NumPad" + (c - 96);
		} else if(c >= 65 && c <= 90) {
			return String.fromCodePoint((65 + c - 65));
		} else if(c >= 112 && c <= 135) {
			return "F" + (c - 112 + 1);
		} else {
			return null;
		}
	}
};
var hxd_Math = function() { };
$hxClasses["hxd.Math"] = hxd_Math;
hxd_Math.__name__ = "hxd.Math";
hxd_Math.get_POSITIVE_INFINITY = function() {
	return Infinity;
};
hxd_Math.get_NEGATIVE_INFINITY = function() {
	return -Infinity;
};
hxd_Math.get_NaN = function() {
	return NaN;
};
hxd_Math.isNaN = function(v) {
	return isNaN(v);
};
hxd_Math.fmt = function(v) {
	var neg;
	if(v < 0) {
		neg = -1.0;
		v = -v;
	} else {
		neg = 1.0;
	}
	if(isNaN(v) || !isFinite(v)) {
		return v;
	}
	var digits = 4 - Math.log(v) / Math.log(10) | 0;
	if(digits < 1) {
		digits = 1;
	} else if(digits >= 10) {
		return 0.;
	}
	var exp = Math.pow(10,digits);
	return Math.floor(v * exp + .49999) * neg / exp;
};
hxd_Math.floor = function(f) {
	return Math.floor(f);
};
hxd_Math.ceil = function(f) {
	return Math.ceil(f);
};
hxd_Math.round = function(f) {
	return Math.round(f);
};
hxd_Math.clamp = function(f,min,max) {
	if(max == null) {
		max = 1.;
	}
	if(min == null) {
		min = 0.;
	}
	if(f < min) {
		return min;
	} else if(f > max) {
		return max;
	} else {
		return f;
	}
};
hxd_Math.pow = function(v,p) {
	return Math.pow(v,p);
};
hxd_Math.cos = function(f) {
	return Math.cos(f);
};
hxd_Math.sin = function(f) {
	return Math.sin(f);
};
hxd_Math.tan = function(f) {
	return Math.tan(f);
};
hxd_Math.acos = function(f) {
	return Math.acos(f);
};
hxd_Math.asin = function(f) {
	return Math.asin(f);
};
hxd_Math.atan = function(f) {
	return Math.atan(f);
};
hxd_Math.sqrt = function(f) {
	return Math.sqrt(f);
};
hxd_Math.invSqrt = function(f) {
	return 1. / Math.sqrt(f);
};
hxd_Math.atan2 = function(dy,dx) {
	return Math.atan2(dy,dx);
};
hxd_Math.abs = function(f) {
	if(f < 0) {
		return -f;
	} else {
		return f;
	}
};
hxd_Math.max = function(a,b) {
	if(a < b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.min = function(a,b) {
	if(a > b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.iabs = function(i) {
	if(i < 0) {
		return -i;
	} else {
		return i;
	}
};
hxd_Math.imax = function(a,b) {
	if(a < b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.imin = function(a,b) {
	if(a > b) {
		return b;
	} else {
		return a;
	}
};
hxd_Math.iclamp = function(v,min,max) {
	if(v < min) {
		return min;
	} else if(v > max) {
		return max;
	} else {
		return v;
	}
};
hxd_Math.lerp = function(a,b,k) {
	return a + k * (b - a);
};
hxd_Math.inverseLerp = function(a,b,val) {
	return (val - a) / (b - a);
};
hxd_Math.ease = function(a,b,k,easing) {
	var p = Math.pow(k,1 + easing);
	return a + p / (p + Math.pow(1 - k,easing + 1)) * (b - a);
};
hxd_Math.easeFactor = function(k,easing) {
	var p = Math.pow(k,1 + easing);
	return p / (p + Math.pow(1 - k,easing + 1));
};
hxd_Math.lerpTime = function(a,b,k,dt) {
	return a + (1 - Math.pow(1 - k,dt * hxd_Timer.wantedFPS)) * (b - a);
};
hxd_Math.bitCount = function(v) {
	v -= v >> 1 & 1431655765;
	v = (v & 858993459) + (v >> 2 & 858993459);
	return (v + (v >> 4) & 252645135) * 16843009 >> 24;
};
hxd_Math.isPOT = function(v) {
	return (v & v - 1) == 0;
};
hxd_Math.nextPOT = function(v) {
	--v;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	return ++v;
};
hxd_Math.distanceSq = function(dx,dy,dz) {
	if(dz == null) {
		dz = 0.;
	}
	return dx * dx + dy * dy + dz * dz;
};
hxd_Math.distance = function(dx,dy,dz) {
	if(dz == null) {
		dz = 0.;
	}
	var dz1 = dz;
	if(dz1 == null) {
		dz1 = 0.;
	}
	return Math.sqrt(dx * dx + dy * dy + dz1 * dz1);
};
hxd_Math.colorLerp = function(c1,c2,k) {
	var a1 = c1 >>> 24;
	var r1 = c1 >> 16 & 255;
	var g1 = c1 >> 8 & 255;
	var b1 = c1 & 255;
	var a2 = c2 >>> 24;
	var r2 = c2 >> 16 & 255;
	var g2 = c2 >> 8 & 255;
	var b2 = c2 & 255;
	var a = a1 * (1 - k) + a2 * k | 0;
	var r = r1 * (1 - k) + r2 * k | 0;
	var g = g1 * (1 - k) + g2 * k | 0;
	var b = b1 * (1 - k) + b2 * k | 0;
	return a << 24 | r << 16 | g << 8 | b;
};
hxd_Math.angle = function(da) {
	da %= 6.28318530717958623;
	if(da > 3.14159265358979323) {
		da -= 6.28318530717958623;
	} else if(da <= -3.14159265358979312) {
		da += 6.28318530717958623;
	}
	return da;
};
hxd_Math.angleLerp = function(a,b,k) {
	var da = b - a;
	da %= 6.28318530717958623;
	if(da > 3.14159265358979323) {
		da -= 6.28318530717958623;
	} else if(da <= -3.14159265358979312) {
		da += 6.28318530717958623;
	}
	return a + da * k;
};
hxd_Math.angleMove = function(a,b,max) {
	var da = b - a;
	da %= 6.28318530717958623;
	if(da > 3.14159265358979323) {
		da -= 6.28318530717958623;
	} else if(da <= -3.14159265358979312) {
		da += 6.28318530717958623;
	}
	var da1 = da;
	if(da1 > -max && da1 < max) {
		return b;
	} else {
		return a + (da1 < 0 ? -max : max);
	}
};
hxd_Math.valueMove = function(v,target,max) {
	if(v < target) {
		v += max;
		if(v > target) {
			v = target;
		}
	} else if(v > target) {
		v -= max;
		if(v < target) {
			v = target;
		}
	}
	return v;
};
hxd_Math.shuffle = function(a) {
	var len = a.length;
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		var x = Std.random(len);
		var y = Std.random(len);
		var tmp = a[x];
		a[x] = a[y];
		a[y] = tmp;
	}
};
hxd_Math.random = function(max) {
	if(max == null) {
		max = 1.0;
	}
	return Math.random() * max;
};
hxd_Math.srand = function(max) {
	if(max == null) {
		max = 1.0;
	}
	return (Math.random() - 0.5) * (max * 2);
};
hxd_Math.b2f = function(v) {
	return (v & 255) * 0.0039215686274509803921568627451;
};
hxd_Math.f2b = function(v) {
	return (v < 0. ? 0. : v > 1. ? 1. : v) * 255.0 | 0;
};
hxd_Math.umod = function(value,modulo) {
	var r = value % modulo;
	if(r >= 0) {
		return r;
	} else {
		return r + modulo;
	}
};
hxd_Math.ufmod = function(value,modulo) {
	var r = value % modulo;
	if(r >= 0) {
		return r;
	} else {
		return r + modulo;
	}
};
hxd_Math.degToRad = function(deg) {
	return deg * 3.14159265358979323 / 180.0;
};
hxd_Math.radToDeg = function(rad) {
	return rad * 180.0 / 3.14159265358979323;
};
var hxd_Flags = $hxEnums["hxd.Flags"] = { __ename__:"hxd.Flags",__constructs__:null
	,ReadOnly: {_hx_name:"ReadOnly",_hx_index:0,__enum__:"hxd.Flags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:1,__enum__:"hxd.Flags",toString:$estr}
};
hxd_Flags.__constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied];
hxd_Flags.__empty_constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied];
var hxd_PixelsARGB = {};
hxd_PixelsARGB.getPixel = function(this1,x,y) {
	var v = this1.bytes.getInt32((x + y * this1.width << 2) + this1.offset);
	return v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
};
hxd_PixelsARGB.setPixel = function(this1,x,y,v) {
	this1.bytes.setInt32((x + y * this1.width << 2) + this1.offset,v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24);
};
hxd_PixelsARGB.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.ARGB);
	return p;
};
var hxd_PixelsFloat = {};
hxd_PixelsFloat.getPixelF = function(this1,x,y,v) {
	if(v == null) {
		v = new h3d_Vector4Impl(0.,0.,0.,1.);
	}
	var pix = (x + y * this1.width << 2) + this1.offset;
	v.x = this1.bytes.getFloat(pix);
	return v;
};
hxd_PixelsFloat.setPixelF = function(this1,x,y,v) {
	var pix = (x + y * this1.width << 2) + this1.offset;
	this1.bytes.setFloat(pix,v.x);
};
hxd_PixelsFloat.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.R32F);
	return p;
};
var hxd_PixelsFloatRGBA = {};
hxd_PixelsFloatRGBA.getPixelF = function(this1,x,y,v) {
	if(v == null) {
		v = new h3d_Vector4Impl(0.,0.,0.,1.);
	}
	var pix = (x + y * this1.width << 4) + this1.offset;
	v.x = this1.bytes.getFloat(pix);
	v.y = this1.bytes.getFloat(pix + 4);
	v.z = this1.bytes.getFloat(pix + 8);
	v.w = this1.bytes.getFloat(pix + 12);
	return v;
};
hxd_PixelsFloatRGBA.setPixelF = function(this1,x,y,v) {
	var pix = (x + y * this1.width << 4) + this1.offset;
	this1.bytes.setFloat(pix,v.x);
	this1.bytes.setFloat(pix + 4,v.y);
	this1.bytes.setFloat(pix + 8,v.z);
	this1.bytes.setFloat(pix + 12,v.w);
};
hxd_PixelsFloatRGBA.fromPixels = function(p) {
	p.convert(hxd_PixelFormat.RGBA32F);
	return p;
};
var hxd_Channel = {};
hxd_Channel.toInt = function(this1) {
	return this1;
};
hxd_Channel.fromInt = function(v) {
	return v;
};
var hxd_Pixels = function(width,height,bytes,format,offset) {
	if(offset == null) {
		offset = 0;
	}
	this.width = width;
	this.height = height;
	this.bytes = bytes;
	this.set_innerFormat(format);
	this.offset = offset;
	var i = 0;
	if(i == null) {
		i = 0;
	}
	this.flags = i;
};
$hxClasses["hxd.Pixels"] = hxd_Pixels;
hxd_Pixels.__name__ = "hxd.Pixels";
hxd_Pixels.switchEndian = function(v) {
	return v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
};
hxd_Pixels.switchBR = function(v) {
	return v & -16711936 | v << 16 & 16711680 | v >> 16 & 255;
};
hxd_Pixels.calcDataSize = function(width,height,format) {
	if(format._hx_index == 22) {
		var _g = format.v;
		return (height + 3 >> 2 << 2) * hxd_Pixels.calcStride(width,format);
	} else {
		return height * hxd_Pixels.calcStride(width,format);
	}
};
hxd_Pixels.calcStride = function(width,format) {
	var tmp;
	switch(format._hx_index) {
	case 3:case 21:
		tmp = 8;
		break;
	case 4:
		tmp = 16;
		break;
	case 5:
		tmp = 1;
		break;
	case 6:case 18:
		tmp = 2;
		break;
	case 7:
		tmp = 4;
		break;
	case 8:
		tmp = 2;
		break;
	case 9:case 19:
		tmp = 4;
		break;
	case 10:
		tmp = 8;
		break;
	case 11:
		tmp = 3;
		break;
	case 12:case 20:
		tmp = 6;
		break;
	case 13:
		tmp = 12;
		break;
	case 0:case 1:case 2:case 14:case 15:
		tmp = 4;
		break;
	case 16:
		tmp = 4;
		break;
	case 17:
		tmp = 4;
		break;
	case 22:
		var n = format.v;
		var blocks = width + 3 >> 2;
		if(n == 1 || n == 4) {
			return blocks << 1;
		}
		return blocks << 2;
	case 23:case 24:case 25:
		throw haxe_Exception.thrown("Not a pixel format");
	}
	return width * tmp;
};
hxd_Pixels.isFloatFormat = function(format) {
	switch(format._hx_index) {
	case 3:case 6:case 9:case 12:
		return true;
	case 4:case 7:case 10:case 13:
		return true;
	case 22:
		if(format.v == 6) {
			return true;
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
};
hxd_Pixels.getChannelOffset = function(format,channel) {
	switch(format._hx_index) {
	case 0:
		return [1,2,3,0][channel];
	case 1:
		return [2,1,0,3][channel];
	case 4:
		return channel * 4;
	case 8:case 9:case 10:case 19:
		var p = hxd_Pixels.calcStride(1,format);
		return [0,p,-1,-1][channel];
	case 2:case 14:case 15:
		return channel;
	case 16:case 17:
		throw haxe_Exception.thrown("Bit packed format");
	case 5:case 6:case 7:case 18:
		if(channel == 0) {
			return 0;
		} else {
			return -1;
		}
		break;
	case 11:case 12:case 13:case 20:
		var p = hxd_Pixels.calcStride(1,format);
		return [0,p,p << 1,-1][channel];
	case 3:case 21:
		return channel * 2;
	case 22:
		var _g = format.v;
		throw haxe_Exception.thrown("Not supported");
	case 23:case 24:case 25:
		throw haxe_Exception.thrown("Not supported");
	}
};
hxd_Pixels.alloc = function(width,height,format) {
	return new hxd_Pixels(width,height,new haxe_io_Bytes(new ArrayBuffer(hxd_Pixels.calcDataSize(width,height,format))),format);
};
hxd_Pixels.toDDSLayers = function(pixels,isCubeMap) {
	if(isCubeMap == null) {
		isCubeMap = false;
	}
	if(pixels.length == 0) {
		throw haxe_Exception.thrown("Must contain at least one image");
	}
	var ref = pixels[0];
	var fmt = ref.innerFormat;
	var levels = [];
	var outSize = 0;
	var _g = 0;
	while(_g < pixels.length) {
		var p = pixels[_g];
		++_g;
		if(!Type.enumEq(p.innerFormat,fmt)) {
			throw haxe_Exception.thrown("All images must be of the same pixel format");
		}
		outSize += p.dataSize;
		var found = false;
		var _g1 = 0;
		while(_g1 < levels.length) {
			var sz = levels[_g1];
			++_g1;
			if(sz[0].width == p.width && sz[0].height == p.height) {
				sz.push(p);
				found = true;
				break;
			}
		}
		if(!found) {
			levels.push([p]);
		}
	}
	levels.sort(function(a1,a2) {
		return a2[0].width * a2[0].height - a1[0].width * a1[0].height;
	});
	var layerCount = levels[0].length;
	var width = levels[0][0].width;
	var height = levels[0][0].height;
	var _g = 1;
	var _g1 = levels.length;
	while(_g < _g1) {
		var i = _g++;
		var level = levels[i];
		if(level.length != layerCount) {
			throw haxe_Exception.thrown("Invalid number of mipmaps at level " + i + ": " + level.length + " should be " + layerCount);
		}
		var w = width >> i;
		if(w == 0) {
			w = 1;
		}
		var h = height >> i;
		if(h == 0) {
			h = 1;
		}
		var lw = level[0].width;
		var lh = level[0].height;
		if(lw != w || lh != h) {
			throw haxe_Exception.thrown("Invalid mip level size " + i + ": " + lw + "x" + lh + " should be " + w + "x" + h);
		}
	}
	outSize += 128;
	var dx10h = layerCount > 1 && !isCubeMap;
	if(dx10h) {
		outSize += 20;
	}
	var ddsOut = new haxe_io_Bytes(new ArrayBuffer(outSize));
	var outPos = 0;
	ddsOut.setInt32(outPos,542327876);
	outPos += 4;
	ddsOut.setInt32(outPos,124);
	outPos += 4;
	ddsOut.setInt32(outPos,135183);
	outPos += 4;
	ddsOut.setInt32(outPos,height);
	outPos += 4;
	ddsOut.setInt32(outPos,width);
	outPos += 4;
	ddsOut.setInt32(outPos,ref.stride);
	outPos += 4;
	ddsOut.setInt32(outPos,1);
	outPos += 4;
	ddsOut.setInt32(outPos,levels.length);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,32);
	outPos += 4;
	if(dx10h) {
		ddsOut.setInt32(outPos,4);
		outPos += 4;
		ddsOut.setInt32(outPos,808540228);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
	} else {
		switch(fmt._hx_index) {
		case 0:case 1:case 2:
			ddsOut.setInt32(outPos,65);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,32);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,0);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,1);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,2);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			var byte = hxd_Pixels.getChannelOffset(fmt,3);
			ddsOut.setInt32(outPos,255 << byte * 8);
			outPos += 4;
			break;
		default:
			ddsOut.setInt32(outPos,4);
			outPos += 4;
			var v;
			switch(fmt._hx_index) {
			case 3:
				v = 113;
				break;
			case 4:
				v = 116;
				break;
			case 6:
				v = 111;
				break;
			case 7:
				v = 114;
				break;
			case 9:
				v = 112;
				break;
			case 10:
				v = 115;
				break;
			default:
				throw haxe_Exception.thrown("Unsupported format " + Std.string(fmt));
			}
			ddsOut.setInt32(outPos,v);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
			ddsOut.setInt32(outPos,0);
			outPos += 4;
		}
	}
	ddsOut.setInt32(outPos,dx10h ? 4096 : (pixels.length == 1 ? 0 : 8) | 4096 | (levels.length == 1 ? 0 : 4194304));
	outPos += 4;
	var cubebits = 1536 | (layerCount > 1 ? 2048 : 0) | (layerCount > 2 ? 4096 : 0) | (layerCount > 3 ? 8192 : 0) | (layerCount > 4 ? 16384 : 0) | (layerCount > 5 ? 32768 : 0);
	ddsOut.setInt32(outPos,isCubeMap ? cubebits : 0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	ddsOut.setInt32(outPos,0);
	outPos += 4;
	if(dx10h) {
		switch(fmt._hx_index) {
		case 2:
			ddsOut.setInt32(outPos,28);
			outPos += 4;
			break;
		case 22:
			var n = fmt.v;
			var v;
			switch(n) {
			case 1:
				v = 71;
				break;
			case 2:
				v = 74;
				break;
			case 3:
				v = 77;
				break;
			default:
				throw haxe_Exception.thrown("Unnsupported format " + Std.string(fmt));
			}
			ddsOut.setInt32(outPos,v);
			outPos += 4;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported DXT10 format " + Std.string(fmt));
		}
		ddsOut.setInt32(outPos,3);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
		ddsOut.setInt32(outPos,layerCount);
		outPos += 4;
		ddsOut.setInt32(outPos,0);
		outPos += 4;
	}
	var _g = 0;
	var _g1 = layerCount;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = levels.length;
		while(_g2 < _g3) {
			var l = _g2++;
			var p = levels[l][i];
			ddsOut.blit(outPos,p.bytes,p.offset,p.dataSize);
			outPos += p.dataSize;
		}
	}
	return ddsOut;
};
hxd_Pixels.prototype = {
	get_format: function() {
		return this.innerFormat;
	}
	,set_innerFormat: function(fmt) {
		this.innerFormat = fmt;
		this.stride = hxd_Pixels.calcStride(this.width,fmt);
		this.dataSize = hxd_Pixels.calcDataSize(this.width,this.height,fmt);
		this.bytesPerPixel = hxd_Pixels.calcStride(1,fmt);
		return fmt;
	}
	,invalidFormat: function() {
		throw haxe_Exception.thrown("Unsupported format for this operation : " + Std.string(this.innerFormat));
	}
	,sub: function(x,y,width,height) {
		if(x < 0 || y < 0 || x + width > this.width || y + height > this.height) {
			throw haxe_Exception.thrown("Pixels.sub() outside bounds");
		}
		var out = new haxe_io_Bytes(new ArrayBuffer(height * this.stride));
		var stride = hxd_Pixels.calcStride(width,this.innerFormat);
		var outP = 0;
		var _g = 0;
		var _g1 = height;
		while(_g < _g1) {
			var dy = _g++;
			var p = (x + (y + dy) * this.width) * this.bytesPerPixel + this.offset;
			out.blit(outP,this.bytes,p,stride);
			outP += stride;
		}
		return new hxd_Pixels(width,height,out,this.innerFormat);
	}
	,blit: function(x,y,src,srcX,srcY,width,height) {
		if(x < 0 || y < 0 || x + width > this.width || y + height > this.height) {
			throw haxe_Exception.thrown("Pixels.blit() outside bounds");
		}
		if(srcX < 0 || srcX < 0 || srcX + width > src.width || srcY + height > src.height) {
			throw haxe_Exception.thrown("Pixels.blit() outside src bounds");
		}
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		src.convert(this.innerFormat);
		var bpp = this.bytesPerPixel;
		if(bpp == 0) {
			throw haxe_Exception.thrown("assert");
		}
		var stride = hxd_Pixels.calcStride(width,this.innerFormat);
		var _g = 0;
		var _g1 = height;
		while(_g < _g1) {
			var dy = _g++;
			var srcP = (srcX + (dy + srcY) * src.width) * bpp + src.offset;
			var dstP = (x + (dy + y) * this.width) * bpp + this.offset;
			this.bytes.blit(dstP,src.bytes,srcP,stride);
		}
	}
	,clear: function(color,preserveMask) {
		if(preserveMask == null) {
			preserveMask = 0;
		}
		var mask = preserveMask;
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		if((color & 255) == (color >> 8 & 255) && (color & 65535) == color >>> 16 && mask == 0) {
			this.bytes.fill(this.offset,this.width * this.height * this.bytesPerPixel,color & 255);
			return;
		}
		switch(this.innerFormat._hx_index) {
		case 0:
			color = color >>> 24 | color >> 8 & 65280 | color << 8 & 16711680 | color << 24;
			mask = mask >>> 24 | mask >> 8 & 65280 | mask << 8 & 16711680 | mask << 24;
			break;
		case 1:
			break;
		case 2:
			color = color & -16711936 | color << 16 & 16711680 | color >> 16 & 255;
			mask = mask & -16711936 | mask << 16 & 16711680 | mask >> 16 & 255;
			break;
		default:
			this.invalidFormat();
		}
		var p = this.offset;
		if(mask == 0) {
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				this.bytes.setInt32(p,color);
				p += 4;
			}
		} else {
			var _g = 0;
			var _g1 = this.width * this.height;
			while(_g < _g1) {
				var i = _g++;
				this.bytes.setInt32(p,color | this.bytes.getInt32(p) & mask);
				p += 4;
			}
		}
	}
	,toVector: function() {
		var vec = new Array(this.width * this.height);
		var idx = 0;
		var p = this.offset;
		var dl = 0;
		switch(this.innerFormat._hx_index) {
		case 0:
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = this.bytes.getInt32(p);
					vec[idx++] = v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
					p += 4;
				}
				p += dl;
			}
			break;
		case 1:
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					vec[idx++] = this.bytes.getInt32(p);
					p += 4;
				}
				p += dl;
			}
			break;
		case 2:
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var y = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var v = this.bytes.getInt32(p);
					vec[idx++] = v & -16711936 | v << 16 & 16711680 | v >> 16 & 255;
					p += 4;
				}
				p += dl;
			}
			break;
		default:
			this.invalidFormat();
		}
		return vec;
	}
	,makeSquare: function(copy) {
		var w = this.width;
		var h = this.height;
		var tw = w == 0 ? 0 : 1;
		var th = h == 0 ? 0 : 1;
		while(tw < w) tw <<= 1;
		while(th < h) th <<= 1;
		if(w == tw && h == th) {
			return this;
		}
		var bpp = this.bytesPerPixel;
		var out = new haxe_io_Bytes(new ArrayBuffer(tw * th * bpp));
		var p = 0;
		var b = this.offset;
		var _g = 0;
		var _g1 = h;
		while(_g < _g1) {
			var y = _g++;
			out.blit(p,this.bytes,b,w * bpp);
			p += w * bpp;
			b += w * bpp;
			var _g2 = 0;
			var _g3 = (tw - w) * bpp >> 2;
			while(_g2 < _g3) {
				var i = _g2++;
				out.setInt32(p,0);
				p += 4;
			}
		}
		var _g = 0;
		var _g1 = (th - h) * tw * bpp >> 2;
		while(_g < _g1) {
			var i = _g++;
			out.setInt32(p,0);
			p += 4;
		}
		if(copy) {
			return new hxd_Pixels(tw,th,out,this.innerFormat);
		}
		this.bytes = out;
		this.width = tw;
		this.height = th;
		return this;
	}
	,copyInner: function() {
		var old = this.bytes;
		this.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
		this.bytes.blit(0,old,this.offset,this.dataSize);
		this.offset = 0;
		this.flags &= -1 - (1 << hxd_Flags.ReadOnly._hx_index);
	}
	,willChange: function() {
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
	}
	,flipY: function() {
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		if(this.stride % 4 != 0) {
			this.invalidFormat();
		}
		var _g = 0;
		var _g1 = this.height >> 1;
		while(_g < _g1) {
			var y = _g++;
			var p1 = y * this.stride + this.offset;
			var p2 = (this.height - 1 - y) * this.stride + this.offset;
			var _g2 = 0;
			var _g3 = this.stride >> 2;
			while(_g2 < _g3) {
				var x = _g2++;
				var a = this.bytes.getInt32(p1);
				var b = this.bytes.getInt32(p2);
				this.bytes.setInt32(p1,b);
				this.bytes.setInt32(p2,a);
				p1 += 4;
				p2 += 4;
			}
		}
	}
	,convert: function(target) {
		if(this.innerFormat == target || Type.enumEq(this.innerFormat,target)) {
			return;
		}
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		var bytes = this.bytes.b;
		var _g = this.innerFormat;
		switch(_g._hx_index) {
		case 0:
			switch(target._hx_index) {
			case 1:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var r = bytes[p + 1];
					var g = bytes[p + 2];
					var b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var v = bytes[p + 1];
					bytes[p] = v;
					var v1 = bytes[p + 2];
					bytes[p + 1] = v1;
					var v2 = bytes[p + 3];
					bytes[p + 2] = v2;
					bytes[p + 3] = a;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 1:
			switch(target._hx_index) {
			case 0:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p];
					var r = bytes[p + 1];
					var g = bytes[p + 2];
					var b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var b = bytes[p];
					var r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 2:
			switch(target._hx_index) {
			case 0:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var a = bytes[p + 3];
					var v = bytes[p + 2];
					bytes[p + 3] = v;
					var v1 = bytes[p + 1];
					bytes[p + 2] = v1;
					var v2 = bytes[p];
					bytes[p + 1] = v2;
					bytes[p] = a;
				}
				break;
			case 1:
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var p = (i << 2) + this.offset;
					var b = bytes[p];
					var r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			case 5:
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height));
				var out = nbytes.b;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var v = bytes[i << 2];
					out[i] = v;
				}
				this.bytes = nbytes;
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 4:
			if(target._hx_index == 7) {
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.height * this.width * 4));
				var out = nbytes.b;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					nbytes.setFloat(i << 2,this.bytes.getFloat(i << 4));
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 7:
			switch(target._hx_index) {
			case 1:case 2:
				var fbytes = this.bytes;
				var p = 0;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var v = fbytes.getFloat(p) * 255 | 0;
					if(v < 0) {
						v = 0;
					} else if(v > 255) {
						v = 255;
					}
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = 255;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 18:
			if(target._hx_index == 7) {
				var nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
				var fbytes = this.bytes;
				var _g1 = 0;
				var _g2 = this.width * this.height;
				while(_g1 < _g2) {
					var i = _g1++;
					var nv = fbytes.getUInt16(i << 1);
					nbytes.setFloat(i << 2,nv / 65535.0);
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 22:
			if(target._hx_index == 22) {
				var b = target.v;
				var a = _g.v;
				if(a != b) {
					throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
				}
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
		}
		this.set_innerFormat(target);
	}
	,getPixel: function(x,y) {
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		switch(this.innerFormat._hx_index) {
		case 0:
			var v = this.bytes.getInt32(p);
			return v >>> 24 | v >> 8 & 65280 | v << 8 & 16711680 | v << 24;
		case 1:
			return this.bytes.getInt32(p);
		case 2:
			var v = this.bytes.getInt32(p);
			return v & -16711936 | v << 16 & 16711680 | v >> 16 & 255;
		case 5:
			return this.bytes.b[p];
		case 8:
			var b = this.bytes.getUInt16(p);
			return (b & 255) << 8 | b >> 8;
		default:
			this.invalidFormat();
			return 0;
		}
	}
	,setPixel: function(x,y,color) {
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		switch(this.innerFormat._hx_index) {
		case 0:
			this.bytes.setInt32(p,color >>> 24 | color >> 8 & 65280 | color << 8 & 16711680 | color << 24);
			break;
		case 1:
			this.bytes.setInt32(p,color);
			break;
		case 2:
			this.bytes.setInt32(p,color & -16711936 | color << 16 & 16711680 | color >> 16 & 255);
			break;
		case 5:
			this.bytes.b[p] = color;
			break;
		case 8:
			this.bytes.setUInt16(p,(color & 255) << 8 | (color & 65280) >> 8);
			break;
		default:
			this.invalidFormat();
		}
	}
	,getPixelF: function(x,y,v) {
		if(v == null) {
			v = new h3d_Vector4Impl(0.,0.,0.,1.);
		}
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		switch(this.innerFormat._hx_index) {
		case 4:
			var _this = v;
			var x1 = this.bytes.getFloat(p);
			var y1 = this.bytes.getFloat(p + 4);
			var z = this.bytes.getFloat(p + 8);
			var w = this.bytes.getFloat(p + 12);
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		case 7:
			var _this = v;
			var x1 = this.bytes.getFloat(p);
			var y1 = 0;
			var z = 0;
			var w = 0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		case 10:
			var _this = v;
			var x1 = this.bytes.getFloat(p);
			var y1 = this.bytes.getFloat(p + 4);
			var z = 0;
			var w = 0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		case 18:
			var _this = v;
			var x1 = this.bytes.getUInt16(p) / 65535.0;
			var y1 = 0;
			var z = 0;
			var w = 0;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this.x = x1;
			_this.y = y1;
			_this.z = z;
			_this.w = w;
			return v;
		default:
			var _this = v;
			var c = this.getPixel(x,y);
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
			return v;
		}
	}
	,setPixelF: function(x,y,v) {
		if((this.flags & 1 << hxd_Flags.ReadOnly._hx_index) != 0) {
			this.copyInner();
		}
		var p = (x + y * this.width) * this.bytesPerPixel + this.offset;
		switch(this.innerFormat._hx_index) {
		case 4:
			this.bytes.setFloat(p,v.x);
			this.bytes.setFloat(p + 4,v.y);
			this.bytes.setFloat(p + 8,v.z);
			this.bytes.setFloat(p + 12,v.w);
			break;
		case 7:
			this.bytes.setFloat(p,v.x);
			break;
		default:
			var _this = v;
			var f = _this.w;
			var f1 = _this.x;
			var f2 = _this.y;
			var f3 = _this.z;
			this.setPixel(x,y,((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 24 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 16 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0) << 8 | ((f3 < 0. ? 0. : f3 > 1. ? 1. : f3) * 255 + 0.499 | 0));
		}
	}
	,dispose: function() {
		this.bytes = null;
	}
	,toString: function() {
		return "Pixels(" + this.width + "x" + this.height + " " + Std.string(this.innerFormat) + ")";
	}
	,toPNG: function(level) {
		if(level == null) {
			level = 9;
		}
		var png;
		if(this.offset != 0) {
			this.bytes = this.bytes.sub(this.offset,hxd_Pixels.calcDataSize(this.width,this.height,this.innerFormat));
			this.offset = 0;
		}
		switch(this.innerFormat._hx_index) {
		case 0:
			png = format_png_Tools.build32ARGB(this.width,this.height,this.bytes,level);
			break;
		case 5:
			png = format_png_Tools.buildGrey(this.width,this.height,this.bytes,level);
			break;
		default:
			this.convert(hxd_PixelFormat.BGRA);
			png = format_png_Tools.build32BGRA(this.width,this.height,this.bytes,level);
		}
		var o = new haxe_io_BytesOutput();
		new format_png_Writer(o).write(png);
		return o.getBytes();
	}
	,toDDS: function() {
		return hxd_Pixels.toDDSLayers([this]);
	}
	,clone: function() {
		var p = new hxd_Pixels(this.width,this.height,null,this.innerFormat);
		p.flags = this.flags;
		p.flags &= -1 - (1 << hxd_Flags.ReadOnly._hx_index);
		if(this.bytes != null) {
			p.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
			p.bytes.blit(0,this.bytes,this.offset,this.dataSize);
		}
		return p;
	}
	,__class__: hxd_Pixels
};
var hxd_Rand = function(seed) {
	this.init(seed);
};
$hxClasses["hxd.Rand"] = hxd_Rand;
hxd_Rand.__name__ = "hxd.Rand";
hxd_Rand.hash = function(n,seed) {
	if(seed == null) {
		seed = 5381;
	}
	var n1 = n;
	n1 = haxe_Int32._mul(n1,-862048943);
	n1 = n1 << 15 | n1 >>> 17;
	n1 = haxe_Int32._mul(n1,461845907);
	var h = seed;
	h ^= n1;
	h = h << 13 | h >>> 19;
	h = haxe_Int32._mul(h,5) + (-430675100) | 0;
	h ^= h >> 16;
	h = haxe_Int32._mul(h,-2048144789);
	h ^= h >> 13;
	h = haxe_Int32._mul(h,-1028477387);
	return h ^= h >> 16;
};
hxd_Rand.inlineHash = function(n,seed) {
	var n1 = n;
	n1 = haxe_Int32._mul(n1,-862048943);
	n1 = n1 << 15 | n1 >>> 17;
	n1 = haxe_Int32._mul(n1,461845907);
	var h = seed;
	h ^= n1;
	h = h << 13 | h >>> 19;
	h = haxe_Int32._mul(h,5) + (-430675100) | 0;
	h ^= h >> 16;
	h = haxe_Int32._mul(h,-2048144789);
	h ^= h >> 13;
	h = haxe_Int32._mul(h,-1028477387);
	h ^= h >> 16;
	return h;
};
hxd_Rand.create = function() {
	return new hxd_Rand(Std.random(2147483647));
};
hxd_Rand.prototype = {
	init: function(seed) {
		this.seed = seed;
		this.seed2 = hxd_Rand.hash(seed);
		if(this.seed == 0) {
			this.seed = 1;
		}
		if(this.seed2 == 0) {
			this.seed2 = 1;
		}
	}
	,random: function(n) {
		this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
		this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
		return (((this.seed << 16) + this.seed2 | 0) & 1073741823) % n;
	}
	,shuffle: function(a) {
		var len = a.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
			this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
			var x = (((this.seed << 16) + this.seed2 | 0) & 1073741823) % len;
			this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
			this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
			var y = (((this.seed << 16) + this.seed2 | 0) & 1073741823) % len;
			var tmp = a[x];
			a[x] = a[y];
			a[y] = tmp;
		}
	}
	,rand: function() {
		this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
		this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
		return (((this.seed << 16) + this.seed2 | 0) & 1073741823) % 10007 / 10007.0;
	}
	,srand: function(scale) {
		if(scale == null) {
			scale = 1.0;
		}
		this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
		this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
		return ((this.seed << 16) + this.seed2 | 0) % 10007 / 10007.0 * scale;
	}
	,int: function() {
		this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
		this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
		return (this.seed << 16) + this.seed2 | 0;
	}
	,uint: function() {
		this.seed = 36969 * (this.seed & 65535) + (this.seed >> 16);
		this.seed2 = 18000 * (this.seed2 & 65535) + (this.seed2 >> 16);
		return ((this.seed << 16) + this.seed2 | 0) & 1073741823;
	}
	,__class__: hxd_Rand
};
var hxd_Res = function() { };
$hxClasses["hxd.Res"] = hxd_Res;
hxd_Res.__name__ = "hxd.Res";
hxd_Res.load = function(name) {
	return hxd_Res.get_loader().load(name);
};
hxd_Res.get_loader = function() {
	var l = hxd_res_Loader.currentInstance;
	if(l == null) {
		throw haxe_Exception.thrown("Resource loader not initialized: call to hxd.Res.initXXX() required");
	}
	return l;
};
hxd_Res.set_loader = function(l) {
	return hxd_res_Loader.currentInstance = l;
};
var hxd_Save = function() { };
$hxClasses["hxd.Save"] = hxd_Save;
hxd_Save.__name__ = "hxd.Save";
hxd_Save.makeCRC = function(data) {
	return HxOverrides.substr(haxe_crypto_Sha1.encode(data + haxe_crypto_Sha1.encode(data + hxd_Save.SALT)),4,32);
};
hxd_Save.loadData = function(data,checkSum,defValue) {
	if(checkSum) {
		if(HxOverrides.cca(data,data.length - 33) != 35) {
			throw haxe_Exception.thrown("Missing CRC");
		}
		var crc = HxOverrides.substr(data,data.length - 32,null);
		data = HxOverrides.substr(data,0,-33);
		if(hxd_Save.makeCRC(data) != crc) {
			throw haxe_Exception.thrown("Invalid CRC");
		}
	}
	var obj = haxe_Unserializer.run(data);
	if(defValue != null && Reflect.isObject(obj) && Reflect.isObject(defValue)) {
		var _g = 0;
		var _g1 = Reflect.fields(defValue);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(Object.prototype.hasOwnProperty.call(obj,f)) {
				continue;
			}
			obj[f] = Reflect.field(defValue,f);
		}
	}
	return obj;
};
hxd_Save.saveData = function(value,checkSum) {
	var data = haxe_Serializer.run(value);
	if(checkSum) {
		return data + "#" + hxd_Save.makeCRC(data);
	} else {
		return data;
	}
};
hxd_Save.load = function(defValue,name,checkSum) {
	if(checkSum == null) {
		checkSum = false;
	}
	if(name == null) {
		name = "save";
	}
	try {
		return hxd_Save.loadData(hxd_Save.readSaveData(name),checkSum,defValue);
	} catch( _g ) {
		return defValue;
	}
};
hxd_Save.readSaveData = function(name) {
	return window.localStorage.getItem(name);
};
hxd_Save.writeSaveData = function(name,data) {
	window.localStorage.setItem(name,data);
};
hxd_Save.delete = function(name) {
	if(name == null) {
		name = "save";
	}
	try {
		window.localStorage.removeItem(name);
	} catch( _g ) {
	}
};
hxd_Save.save = function(val,name,checkSum) {
	if(checkSum == null) {
		checkSum = false;
	}
	if(name == null) {
		name = "save";
	}
	var data = hxd_Save.saveData(val,checkSum);
	try {
		if(hxd_Save.readSaveData(name) == data) {
			return false;
		}
	} catch( _g ) {
	}
	hxd_Save.writeSaveData(name,data);
	return true;
};
var hxd_SceneEvents = function($window) {
	this.defaultCursor = hxd_Cursor.Default;
	this.mouseCheckMove = true;
	this.enablePhysicalMouse = true;
	this.isOut = false;
	this.onOver = new hxd_Event(hxd_EventKind.EOver);
	this.onOut = new hxd_Event(hxd_EventKind.EOut);
	this.checkPos = new hxd_Event(hxd_EventKind.ECheck);
	this.focusLost = new hxd_Event(hxd_EventKind.EFocusLost);
	this.lastTouch = 0;
	this.mouseY = -1.;
	this.mouseX = -1.;
	this.overIndex = -1;
	this.scenes = [];
	this.pendingEvents = [];
	this.pushList = [];
	this.overList = [];
	this.overCandidates = [];
	if($window == null) {
		$window = hxd_Window.getInstance();
	}
	this.window = $window;
	$window.addEventTarget($bind(this,this.onEvent));
};
$hxClasses["hxd.SceneEvents"] = hxd_SceneEvents;
hxd_SceneEvents.__name__ = "hxd.SceneEvents";
hxd_SceneEvents.prototype = {
	setMousePos: function(xPos,yPos) {
		this.mouseX = xPos;
		this.mouseY = yPos;
	}
	,onRemove: function(i) {
		if(i == this.currentFocus) {
			this.currentFocus = null;
		}
		if(this.overIndex >= 0) {
			var index = this.overList.indexOf(i);
			if(index >= 0) {
				HxOverrides.remove(this.overList,i);
				if(index < this.overIndex) {
					this.overIndex--;
				}
			}
		} else {
			HxOverrides.remove(this.overList,i);
			this.selectCursor();
		}
		HxOverrides.remove(this.pushList,i);
	}
	,addScene: function(s,index) {
		s.setEvents(this);
		if(index == null) {
			this.scenes.push(s);
		} else {
			this.scenes.splice(index,0,s);
		}
	}
	,removeScene: function(s) {
		if(HxOverrides.remove(this.scenes,s)) {
			s.setEvents(null);
		}
	}
	,dispose: function() {
		this.window.removeEventTarget($bind(this,this.onEvent));
	}
	,focus: function(i) {
		if(this.currentFocus == i) {
			return;
		}
		if(i == null) {
			this.blur();
			return;
		}
		if(this.currentFocus != null) {
			this.blur();
			if(this.currentFocus != null) {
				return;
			}
		}
		var e = new hxd_Event(hxd_EventKind.EFocus);
		i.handleEvent(e);
		if(!e.cancel) {
			this.currentFocus = i;
		}
	}
	,blur: function() {
		if(this.currentFocus == null) {
			return;
		}
		this.focusLost.cancel = false;
		this.currentFocus.handleEvent(this.focusLost);
		if(!this.focusLost.cancel) {
			this.currentFocus = null;
		}
	}
	,checkFocus: function() {
		if(this.currentFocus == null) {
			return;
		}
		var s = this.currentFocus.getInteractiveScene();
		if(s == null) {
			this.currentFocus = null;
			return;
		}
		if(!s.isInteractiveVisible(this.currentFocus)) {
			this.blur();
		}
	}
	,emitEvent: function(event) {
		var oldX = event.relX;
		var oldY = event.relY;
		var overCandidateCount = 0;
		var handled = false;
		var checkOver = false;
		var fillOver = false;
		var checkPush = false;
		var cancelFocus = false;
		var updateCursor = false;
		this.overIndex = 0;
		switch(event.kind._hx_index) {
		case 0:
			cancelFocus = true;
			checkPush = true;
			break;
		case 1:
			checkPush = true;
			break;
		case 5:case 8:case 9:case 11:
			if(this.currentFocus != null) {
				event.relX = event.relY = 0;
				this.currentFocus.handleEvent(event);
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					return;
				}
			}
			break;
		case 2:case 12:
			checkOver = true;
			fillOver = true;
			break;
		default:
		}
		var _g = 0;
		var _g1 = this.scenes;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var last = null;
			while(true) {
				var i = s.handleEvent(event,last);
				if(i == null) {
					event.relX = oldX;
					event.relY = oldY;
					break;
				}
				if(checkOver) {
					if(fillOver) {
						var idx = this.overList.indexOf(i);
						if(idx == -1) {
							if(this.overCandidates.length == overCandidateCount) {
								this.overCandidates[overCandidateCount] = { i : i, s : s, x : event.relX, y : event.relY, z : event.relZ};
							} else {
								var info = this.overCandidates[overCandidateCount];
								info.i = i;
								info.s = s;
								info.x = event.relX;
								info.y = event.relY;
								info.z = event.relZ;
							}
							++overCandidateCount;
							this.overList.splice(this.overIndex++,0,i);
							updateCursor = true;
						} else {
							if(idx < this.overIndex) {
								do {
									this.overList[idx] = this.overList[idx + 1];
									++idx;
								} while(idx < this.overIndex);
								this.overList[this.overIndex] = i;
								updateCursor = true;
							} else if(idx > this.overIndex) {
								do {
									this.overList[idx] = this.overList[idx - 1];
									--idx;
								} while(idx > this.overIndex);
								this.overList[this.overIndex] = i;
								updateCursor = true;
							}
							this.overIndex++;
						}
						fillOver = event.propagate;
					}
				} else {
					if(checkPush) {
						if(event.kind == hxd_EventKind.EPush) {
							this.pushList.push(i);
						} else {
							HxOverrides.remove(this.pushList,i);
						}
					}
					if(cancelFocus && i == this.currentFocus) {
						cancelFocus = false;
					}
				}
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					handled = true;
					break;
				}
				last = i;
				event.propagate = false;
			}
			if(handled) {
				break;
			}
		}
		if(cancelFocus && this.currentFocus != null) {
			this.blur();
		}
		if(checkOver) {
			if(this.overIndex < this.overList.length) {
				while(this.overIndex < this.overList.length) {
					var e = this.overList.pop();
					e.handleEvent(this.onOut);
				}
				updateCursor = true;
			}
			if(overCandidateCount != 0) {
				var i = 0;
				var ev = this.onOver;
				do {
					var info = this.overCandidates[i++];
					ev.relX = info.x;
					ev.relY = info.y;
					ev.relZ = info.z;
					if(info.s.isInteractiveVisible(info.i)) {
						info.i.handleEvent(ev);
					} else {
						HxOverrides.remove(this.overList,info.i);
					}
					info.i = null;
					info.s = null;
				} while(i < overCandidateCount);
			}
		}
		this.overIndex = -1;
		if(updateCursor) {
			this.selectCursor();
		}
		if(!handled && event != this.checkPos) {
			if(event.kind == hxd_EventKind.EPush) {
				this.pushList.push(null);
			} else if(event.kind == hxd_EventKind.ERelease) {
				HxOverrides.remove(this.pushList,null);
			}
			this.dispatchListeners(event);
		}
		if(event.kind == hxd_EventKind.ERelease && this.pushList.length > 0) {
			var _g = 0;
			var _g1 = this.pushList;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i == null) {
					event.kind = hxd_EventKind.EReleaseOutside;
					this.dispatchListeners(event);
					event.kind = hxd_EventKind.ERelease;
				} else {
					var s = i.getInteractiveScene();
					if(s == null) {
						continue;
					}
					event.kind = hxd_EventKind.EReleaseOutside;
					s.dispatchEvent(event,i);
					event.kind = hxd_EventKind.ERelease;
					event.relX = oldX;
					event.relY = oldY;
				}
			}
			this.pushList = [];
		}
	}
	,checkEvents: function() {
		var old = this.pendingEvents;
		var checkMoved = !this.mouseCheckMove;
		var checkFocused = this.currentFocus == null;
		if(old.length > 0) {
			this.pendingEvents = [];
			var _g = 0;
			while(_g < old.length) {
				var e = old[_g];
				++_g;
				var ox = e.relX;
				var oy = e.relY;
				switch(e.kind._hx_index) {
				case 0:case 1:
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 2:
					checkMoved = true;
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 3:
					this.isOut = false;
					this.selectCursor();
					continue;
				case 4:
					this.isOut = true;
					if(this.overList.length > 0) {
						var i = this.overList.length - 1;
						while(i >= 0) {
							this.onOut.cancel = false;
							this.overList[i].handleEvent(this.onOut);
							HxOverrides.remove(this.overList,this.overList[i]);
							--i;
						}
						this.selectCursor();
					}
					continue;
				case 5:case 8:case 9:case 11:
					if(!checkFocused) {
						checkFocused = true;
						this.checkFocus();
					}
					break;
				default:
				}
				if(this.currentDrag != null && (this.currentDrag.ref == null || this.currentDrag.ref == e.touchId)) {
					e.propagate = true;
					e.cancel = false;
					this.currentDrag.f(e);
					e.relX = ox;
					e.relY = oy;
					if(!e.propagate) {
						continue;
					}
				}
				this.emitEvent(e);
			}
		}
		if(!checkFocused) {
			this.checkFocus();
		}
		if(!checkMoved && !this.isOut && this.currentDrag == null) {
			this.checkPos.relX = this.mouseX;
			this.checkPos.relY = this.mouseY;
			this.checkPos.touchId = this.lastTouch;
			this.checkPos.cancel = false;
			this.checkPos.propagate = false;
			this.emitEvent(this.checkPos);
		}
	}
	,startCapture: function(f,onCancel,touchId) {
		if(this.currentDrag != null && this.currentDrag.onCancel != null) {
			this.currentDrag.onCancel();
		}
		this.currentDrag = { f : f, ref : touchId, onCancel : onCancel};
	}
	,stopCapture: function() {
		if(this.currentDrag != null && this.currentDrag.onCancel != null) {
			this.currentDrag.onCancel();
		}
		this.currentDrag = null;
	}
	,startDrag: function(f,onCancel,refEvent) {
		this.startCapture(f,onCancel,refEvent != null ? refEvent.touchId : null);
	}
	,stopDrag: function() {
		this.stopCapture();
	}
	,getFocus: function() {
		return this.currentFocus;
	}
	,updateCursor: function(i) {
		if(this.overList.indexOf(i) != -1) {
			this.selectCursor();
		}
	}
	,set_defaultCursor: function(c) {
		if(Type.enumEq(c,this.defaultCursor)) {
			return c;
		}
		this.defaultCursor = c;
		this.selectCursor();
		return c;
	}
	,selectCursor: function() {
		var cur = this.defaultCursor;
		var _g = 0;
		var _g1 = this.overList;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o.cursor != null) {
				cur = o.cursor;
				break;
			}
		}
		if(cur._hx_index == 6) {
			var f = cur.f;
			f();
		} else {
			hxd_System.setCursor(cur);
		}
	}
	,onEvent: function(e) {
		if(!this.enablePhysicalMouse && e.kind == hxd_EventKind.EMove) {
			return;
		}
		this.pendingEvents.push(e);
	}
	,dispatchListeners: function(event) {
		var ox = event.relX;
		var oy = event.relY;
		event.propagate = true;
		var _g = 0;
		var _g1 = this.scenes;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			event.cancel = false;
			s.dispatchListeners(event);
			event.relX = ox;
			event.relY = oy;
			if(!event.propagate) {
				break;
			}
		}
	}
	,__class__: hxd_SceneEvents
};
var hxd_Platform = $hxEnums["hxd.Platform"] = { __ename__:"hxd.Platform",__constructs__:null
	,IOS: {_hx_name:"IOS",_hx_index:0,__enum__:"hxd.Platform",toString:$estr}
	,Android: {_hx_name:"Android",_hx_index:1,__enum__:"hxd.Platform",toString:$estr}
	,WebGL: {_hx_name:"WebGL",_hx_index:2,__enum__:"hxd.Platform",toString:$estr}
	,PC: {_hx_name:"PC",_hx_index:3,__enum__:"hxd.Platform",toString:$estr}
	,Console: {_hx_name:"Console",_hx_index:4,__enum__:"hxd.Platform",toString:$estr}
	,FlashPlayer: {_hx_name:"FlashPlayer",_hx_index:5,__enum__:"hxd.Platform",toString:$estr}
};
hxd_Platform.__constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
hxd_Platform.__empty_constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
var hxd_SystemValue = $hxEnums["hxd.SystemValue"] = { __ename__:"hxd.SystemValue",__constructs__:null
	,IsTouch: {_hx_name:"IsTouch",_hx_index:0,__enum__:"hxd.SystemValue",toString:$estr}
	,IsWindowed: {_hx_name:"IsWindowed",_hx_index:1,__enum__:"hxd.SystemValue",toString:$estr}
	,IsMobile: {_hx_name:"IsMobile",_hx_index:2,__enum__:"hxd.SystemValue",toString:$estr}
};
hxd_SystemValue.__constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
hxd_SystemValue.__empty_constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
var hxd_Timer = function() { };
$hxClasses["hxd.Timer"] = hxd_Timer;
hxd_Timer.__name__ = "hxd.Timer";
hxd_Timer.update = function() {
	hxd_Timer.frameCount++;
	var newTime = HxOverrides.now() / 1000;
	hxd_Timer.elapsedTime = newTime - hxd_Timer.lastTimeStamp;
	hxd_Timer.lastTimeStamp = newTime;
	if(hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime) {
		var a = hxd_Timer.elapsedTime;
		hxd_Timer.currentDT = a + hxd_Timer.smoothFactor * (hxd_Timer.currentDT - a);
	} else {
		hxd_Timer.elapsedTime = 1 / hxd_Timer.wantedFPS;
	}
	hxd_Timer.dt = hxd_Timer.currentDT;
};
hxd_Timer.get_tmod = function() {
	return hxd_Timer.dt * hxd_Timer.wantedFPS;
};
hxd_Timer.set_tmod = function(v) {
	hxd_Timer.dt = v / hxd_Timer.wantedFPS;
	return v;
};
hxd_Timer.fps = function() {
	return 1. / hxd_Timer.currentDT;
};
hxd_Timer.skip = function() {
	hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
};
hxd_Timer.reset = function() {
	hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
	hxd_Timer.dt = hxd_Timer.currentDT = 1. / hxd_Timer.wantedFPS;
};
var hxd_Window = function(canvas,globalEvents) {
	this.canLockMouse = true;
	this.discardMouseUp = -1;
	this.discardMouseCaptureEvent = true;
	this.useScreenPixels = js_Browser.get_supported();
	this.curMouseY = 0.;
	this.curMouseX = 0.;
	this.mouseMode = hxd_impl_MouseMode.Absolute;
	var _gthis = this;
	var customCanvas = canvas != null;
	this.eventTargets = new haxe_ds_List();
	this.resizeEvents = new haxe_ds_List();
	this.dropTargets = new haxe_ds_List();
	if(!js_Browser.get_supported()) {
		this.canvasPos = { "width" : 0, "top" : 0, "left" : 0, "height" : 0};
		return;
	}
	if(canvas == null) {
		canvas = window.document.getElementById("webgl");
		if(canvas == null) {
			throw haxe_Exception.thrown("Missing canvas #webgl");
		}
		if(canvas.getAttribute("globalEvents") == "1") {
			globalEvents = true;
		}
	}
	this.canvas = canvas;
	this.propagateKeyEvents = globalEvents;
	var propagate = canvas.getAttribute("propagateKeyEvents");
	if(propagate != null) {
		this.propagateKeyEvents = propagate != "0" && propagate != "false";
	}
	this.focused = globalEvents;
	this.element = globalEvents ? window : canvas;
	this.canvasPos = canvas.getBoundingClientRect();
	if(customCanvas) {
		canvas.addEventListener("mousemove",$bind(this,this.onMouseMove));
	} else {
		window.addEventListener("mousemove",$bind(this,this.onMouseMove));
	}
	this.element.addEventListener("mousedown",$bind(this,this.onMouseDown));
	this.element.addEventListener("mouseup",$bind(this,this.onMouseUp));
	this.element.addEventListener("mouseleave",$bind(this,this.onMouseLeave));
	this.element.addEventListener("wheel",$bind(this,this.onMouseWheel));
	this.element.addEventListener("touchstart",$bind(this,this.onTouchStart));
	this.element.addEventListener("touchmove",$bind(this,this.onTouchMove));
	this.element.addEventListener("touchend",$bind(this,this.onTouchEnd));
	this.element.addEventListener("keydown",$bind(this,this.onKeyDown));
	this.element.addEventListener("keyup",$bind(this,this.onKeyUp));
	this.element.addEventListener("keypress",$bind(this,this.onKeyPress));
	var _g = this;
	var b = false;
	var tmp = function() {
		_g.onFocus(b);
	};
	this.element.addEventListener("blur",tmp);
	var _g1 = this;
	var b1 = true;
	var tmp = function() {
		_g1.onFocus(b1);
	};
	this.element.addEventListener("focus",tmp);
	if(window.ResizeObserver != null) {
		this.observer = new ResizeObserver(function(e) {
			_gthis.checkResize();
		});
		this.observer.observe(canvas);
	}
	window.addEventListener("resize",$bind(this,this.checkResize));
	window.document.addEventListener("pointerlockchange",$bind(this,this.onPointerLockChange));
	canvas.addEventListener("contextmenu",function(e) {
		e.stopPropagation();
		if(e.button == 2) {
			e.preventDefault();
		}
		return false;
	});
	if(globalEvents) {
		canvas.addEventListener("mousedown",function(e) {
			_gthis.onMouseDown(e);
			e.stopPropagation();
			e.preventDefault();
		});
		this.element.addEventListener("contextmenu",function(e) {
			e.stopPropagation();
			e.preventDefault();
			return false;
		});
	} else {
		if(canvas.getAttribute("tabindex") == null) {
			canvas.setAttribute("tabindex","1");
		}
		canvas.style.outline = "none";
	}
	this.curW = this.get_width();
	this.curH = this.get_height();
};
$hxClasses["hxd.Window"] = hxd_Window;
hxd_Window.__name__ = "hxd.Window";
hxd_Window.getInstance = function() {
	if(hxd_Window.inst == null) {
		hxd_Window.inst = new hxd_Window();
	}
	return hxd_Window.inst;
};
hxd_Window.prototype = {
	checkResize: function() {
		this.canvasPos = this.canvas.getBoundingClientRect();
		var cw = this.get_width();
		var ch = this.get_height();
		if(this.curW != cw || this.curH != ch) {
			this.curW = cw;
			this.curH = ch;
			this.onResize(null);
		}
	}
	,dispose: function() {
		if(hxd_Window.inst == this) {
			hxd_Window.inst = null;
		}
		if(window.ResizeObserver != null) {
			this.observer.disconnect();
			this.observer = null;
		}
	}
	,onClose: function() {
		return true;
	}
	,onMouseModeChange: function(from,to) {
		return null;
	}
	,event: function(e) {
		var _g_head = this.eventTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var et = val;
			et(e);
		}
	}
	,addEventTarget: function(et) {
		this.eventTargets.add(et);
	}
	,removeEventTarget: function(et) {
		var _g_head = this.eventTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e == et) {
				this.eventTargets.remove(e);
				break;
			}
		}
	}
	,addResizeEvent: function(f) {
		this.resizeEvents.push(f);
	}
	,removeResizeEvent: function(f) {
		var _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e == f) {
				this.resizeEvents.remove(f);
				break;
			}
		}
	}
	,onResize: function(e) {
		var _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var r = val;
			r();
		}
	}
	,resize: function(width,height) {
	}
	,addDragAndDropTarget: function(f) {
		if(this.dropTargets.length == 0) {
			var element = this.canvas;
			element.addEventListener("dragover",$bind(this,this.handleDragAndDropEvent));
			element.addEventListener("drop",$bind(this,this.handleDragAndDropEvent));
		}
		this.dropTargets.add(f);
	}
	,removeDragAndDropTarget: function(f) {
		var _g_head = this.dropTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var e = val;
			if(e == f) {
				this.dropTargets.remove(f);
				break;
			}
		}
		if(this.dropTargets.length == 0) {
			var element = this.canvas;
			element.removeEventListener("dragover",$bind(this,this.handleDragAndDropEvent));
			element.removeEventListener("drop",$bind(this,this.handleDragAndDropEvent));
		}
	}
	,handleDragAndDropEvent: function(e) {
		e.preventDefault();
		if(e.type == "dragover" || e.dataTransfer == null || e.dataTransfer.files.length == 0) {
			return;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = e.dataTransfer.files;
		while(_g1 < _g2.length) {
			var file = _g2[_g1];
			++_g1;
			_g.push(new hxd__$Window_NativeDroppedFile(file));
		}
		var ev = new hxd_DropFileEvent(_g,Math.round((e.clientX - this.canvasPos.left) * this.getPixelRatio()),Math.round((e.clientY - this.canvasPos.top) * this.getPixelRatio()));
		var _g_head = this.dropTargets.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var dt = val;
			dt(ev);
		}
	}
	,setFullScreen: function(v) {
		var doc = window.document;
		var elt = doc.documentElement;
		if(doc.fullscreenElement == elt == v) {
			return;
		}
		if(v) {
			elt.requestFullscreen();
		} else {
			doc.exitFullscreen();
		}
	}
	,setCursorPos: function(x,y,emitEvent) {
		if(emitEvent == null) {
			emitEvent = false;
		}
		if(this.mouseMode == hxd_impl_MouseMode.Absolute) {
			throw haxe_Exception.thrown("setCursorPos only allowed in relative mouse modes on this platform.");
		}
		this.curMouseX = x + this.canvasPos.left;
		this.curMouseY = y + this.canvasPos.top;
		if(emitEvent) {
			this.event(new hxd_Event(hxd_EventKind.EMove,x,y));
		}
	}
	,setCurrent: function() {
		hxd_Window.inst = this;
	}
	,getPixelRatio: function() {
		if(this.useScreenPixels) {
			return window.devicePixelRatio;
		} else {
			return 1;
		}
	}
	,get_width: function() {
		return Math.round(this.canvasPos.width * this.getPixelRatio());
	}
	,get_height: function() {
		return Math.round(this.canvasPos.height * this.getPixelRatio());
	}
	,get_mouseX: function() {
		return Math.round((this.curMouseX - this.canvasPos.left) * this.getPixelRatio());
	}
	,get_mouseY: function() {
		return Math.round((this.curMouseY - this.canvasPos.top) * this.getPixelRatio());
	}
	,get_mouseLock: function() {
		var _g = this.mouseMode;
		if(_g._hx_index == 2) {
			var _g1 = _g.restorePos;
			return true;
		} else {
			return false;
		}
	}
	,set_mouseLock: function(v) {
		return Type.enumEq(this.set_mouseMode(v ? hxd_impl_MouseMode.AbsoluteUnbound(true) : hxd_impl_MouseMode.Absolute),hxd_impl_MouseMode.AbsoluteUnbound(true));
	}
	,get_mouseClip: function() {
		return false;
	}
	,set_mouseClip: function(v) {
		if(v) {
			throw haxe_Exception.thrown("Can't clip cursor on this platform.");
		}
		return false;
	}
	,set_mouseMode: function(v) {
		if(Type.enumEq(v,this.mouseMode)) {
			return v;
		}
		var forced = this.onMouseModeChange(this.mouseMode,v);
		if(forced != null) {
			v = forced;
		}
		var target = this.pointerLockTarget = this.canvas != null ? this.canvas : window.document.documentElement;
		if(v == hxd_impl_MouseMode.Absolute) {
			if(target.ownerDocument.pointerLockElement == target) {
				target.ownerDocument.exitPointerLock();
			}
		} else if(this.canLockMouse) {
			if(target.ownerDocument.pointerLockElement != target) {
				target.requestPointerLock();
			}
		}
		return this.mouseMode = v;
	}
	,get_vsync: function() {
		return true;
	}
	,set_vsync: function(b) {
		if(!b) {
			throw haxe_Exception.thrown("Can't disable vsync on this platform");
		}
		return true;
	}
	,onPointerLockChange: function(e) {
		if(this.mouseMode != hxd_impl_MouseMode.Absolute && this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
			this.canLockMouse = false;
			this.set_mouseMode(hxd_impl_MouseMode.Absolute);
			this.canLockMouse = true;
		}
	}
	,onMouseDown: function(e) {
		if(this.mouseMode == hxd_impl_MouseMode.Absolute) {
			if(e.clientX != this.curMouseX || e.clientY != this.curMouseY) {
				this.onMouseMove(e);
			}
		} else {
			if(this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
				this.pointerLockTarget.requestPointerLock();
				if(this.discardMouseCaptureEvent) {
					this.discardMouseUp = e.button;
					return;
				}
			}
			if(e.movementX != 0 || e.movementY != 0) {
				this.onMouseMove(e);
			}
		}
		var ev = new hxd_Event(hxd_EventKind.EPush,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseUp: function(e) {
		if(this.discardMouseUp == e.button) {
			this.discardMouseUp = -1;
			return;
		}
		if(this.mouseMode == hxd_impl_MouseMode.Absolute ? e.clientX != this.curMouseX || e.clientY != this.curMouseY : e.movementX != 0 || e.movementY != 0) {
			this.onMouseMove(e);
		}
		var ev = new hxd_Event(hxd_EventKind.ERelease,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseLeave: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EReleaseOutside,this.get_mouseX(),this.get_mouseY());
		var _g = e.button;
		var tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			var x = _g;
			tmp = x;
		}
		ev.button = tmp;
		this.event(ev);
	}
	,onMouseMove: function(e) {
		var _g = this.mouseMode;
		switch(_g._hx_index) {
		case 0:
			this.curMouseX = e.clientX;
			this.curMouseY = e.clientY;
			this.event(new hxd_Event(hxd_EventKind.EMove,this.get_mouseX(),this.get_mouseY()));
			break;
		case 1:
			var _g1 = _g.restorePos;
			var callback = _g.callback;
			if(this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
				return;
			}
			var ev = new hxd_Event(hxd_EventKind.EMove,e.movementX,e.movementY);
			callback(ev);
			if(!ev.cancel && ev.propagate) {
				ev.cancel = false;
				ev.propagate = false;
				ev.relX = this.curMouseX;
				ev.relY = this.curMouseY;
				this.event(ev);
			}
			break;
		case 2:
			var _g1 = _g.restorePos;
			if(this.pointerLockTarget.ownerDocument.pointerLockElement != this.pointerLockTarget) {
				return;
			}
			this.curMouseX += e.movementX;
			this.curMouseY += e.movementY;
			this.event(new hxd_Event(hxd_EventKind.EMove,this.get_mouseX(),this.get_mouseY()));
			break;
		}
	}
	,onMouseWheel: function(e) {
		e.preventDefault();
		var ev = new hxd_Event(hxd_EventKind.EWheel,this.get_mouseX(),this.get_mouseY());
		ev.wheelDelta = e.deltaY / 120;
		this.event(ev);
	}
	,onTouchStart: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EPush,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onTouchMove: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EMove,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onTouchEnd: function(e) {
		e.preventDefault();
		var x;
		var y;
		var ev;
		var _g = 0;
		var _g1 = e.changedTouches;
		while(_g < _g1.length) {
			var touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.ERelease,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	,onKeyUp: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EKeyUp,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	,onKeyDown: function(e) {
		var ev = new hxd_Event(hxd_EventKind.EKeyDown,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			switch(ev.keyCode) {
			case 8:case 9:case 16:case 17:case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:
				e.preventDefault();
				break;
			default:
			}
			e.stopPropagation();
		}
	}
	,onKeyPress: function(e) {
		var ev = new hxd_Event(hxd_EventKind.ETextInput,this.get_mouseX(),this.get_mouseY());
		ev.charCode = e.charCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	,onFocus: function(b) {
		this.event(new hxd_Event(b ? hxd_EventKind.EFocus : hxd_EventKind.EFocusLost));
		this.focused = b;
	}
	,get_isFocused: function() {
		return this.focused;
	}
	,get_displayMode: function() {
		var doc = window.document;
		if(doc.fullscreenElement != null) {
			return hxd_DisplayMode.Borderless;
		}
		return hxd_DisplayMode.Windowed;
	}
	,set_displayMode: function(m) {
		if(!js_Browser.get_supported()) {
			return m;
		}
		var doc = window.document;
		var elt = doc.documentElement;
		var fullscreen = m != hxd_DisplayMode.Windowed;
		if(doc.fullscreenElement == elt == fullscreen) {
			return hxd_DisplayMode.Windowed;
		}
		if(m != hxd_DisplayMode.Windowed) {
			elt.requestFullscreen();
		} else {
			doc.exitFullscreen();
		}
		return m;
	}
	,get_title: function() {
		return window.document.title;
	}
	,set_title: function(t) {
		return window.document.title = t;
	}
	,__class__: hxd_Window
};
var js_Browser = function() { };
$hxClasses["js.Browser"] = js_Browser;
js_Browser.__name__ = "js.Browser";
js_Browser.get_supported = function() {
	if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
		return typeof(window.location.protocol) == "string";
	} else {
		return false;
	}
};
var hxd_System = function() { };
$hxClasses["hxd.System"] = hxd_System;
hxd_System.__name__ = "hxd.System";
hxd_System.timeoutTick = function() {
};
hxd_System.getCurrentLoop = function() {
	return hxd_System.loopFunc;
};
hxd_System.setLoop = function(f) {
	if(!hxd_System.loopInit) {
		hxd_System.loopInit = true;
		hxd_System.browserLoop();
	}
	hxd_System.loopFunc = f;
};
hxd_System.browserLoop = function() {
	if(js_Browser.get_supported()) {
		var $window = window;
		var rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
		if(hxd_System.fpsLimit > 0) {
			window.setTimeout(function() {
				return rqf(hxd_System.browserLoop);
			},1000 / hxd_System.fpsLimit);
		} else {
			rqf(hxd_System.browserLoop);
		}
	} else {
		throw haxe_Exception.thrown("Cannot use browserLoop without Browser support nor defining nodejs + hxnodejs");
	}
	if(hxd_System.loopFunc != null) {
		hxd_System.loopFunc();
	}
};
hxd_System.start = function(callb) {
	callb();
};
hxd_System.setNativeCursor = function(c) {
	if(hxd_System.currentNativeCursor != null && Type.enumEq(c,hxd_System.currentNativeCursor)) {
		return;
	}
	hxd_System.currentNativeCursor = c;
	hxd_System.currentCustomCursor = null;
	var canvas = hxd_Window.getInstance().canvas;
	if(canvas != null) {
		var tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "default";
			break;
		case 1:
			tmp = "pointer";
			break;
		case 2:
			tmp = "move";
			break;
		case 3:
			tmp = "text";
			break;
		case 4:
			tmp = "none";
			break;
		case 5:
			var cur = c.custom;
			if(cur.alloc == null) {
				cur.alloc = [];
				var _g = 0;
				var _g1 = cur.frames;
				while(_g < _g1.length) {
					var frame = _g1[_g];
					++_g;
					cur.alloc.push("url(\"" + frame.ctx.canvas.toDataURL("image/png") + "\") " + cur.offsetX + " " + cur.offsetY + ", default");
				}
			}
			if(cur.frames.length > 1) {
				hxd_System.currentCustomCursor = cur;
				cur.reset();
			}
			tmp = cur.alloc[cur.frameIndex];
			break;
		case 6:
			var _g = c.f;
			throw haxe_Exception.thrown("assert");
		}
		canvas.style.cursor = tmp;
	}
};
hxd_System.getDeviceName = function() {
	return "Unknown";
};
hxd_System.getDefaultFrameRate = function() {
	return 60.;
};
hxd_System.getValue = function(s) {
	switch(s._hx_index) {
	case 0:
		if(hxd_System.get_platform() != hxd_Platform.Android) {
			return hxd_System.get_platform() == hxd_Platform.IOS;
		} else {
			return true;
		}
		break;
	case 1:
		return true;
	case 2:
		if(hxd_System.get_platform() != hxd_Platform.Android) {
			return hxd_System.get_platform() == hxd_Platform.IOS;
		} else {
			return true;
		}
		break;
	}
};
hxd_System.exit = function() {
};
hxd_System.openURL = function(url) {
	window.open(url,"_blank");
};
hxd_System.updateCursor = function() {
	if(hxd_System.currentCustomCursor != null) {
		var change = hxd_System.currentCustomCursor.update(hxd_Timer.elapsedTime);
		if(change != -1) {
			var canvas = hxd_Window.getInstance().canvas;
			if(canvas != null) {
				canvas.style.cursor = hxd_System.currentCustomCursor.alloc[change];
			}
		}
	}
};
hxd_System.getClipboardText = function() {
	return null;
};
hxd_System.setClipboardText = function(text) {
	return false;
};
hxd_System.getLocale = function() {
	return $global.navigator.language + "_" + $global.navigator.language.toUpperCase();
};
hxd_System.get_width = function() {
	return Math.round(window.document.body.clientWidth * window.devicePixelRatio);
};
hxd_System.get_height = function() {
	return Math.round(window.document.body.clientHeight * window.devicePixelRatio);
};
hxd_System.get_lang = function() {
	return $global.navigator.language;
};
hxd_System.get_platform = function() {
	var ua = $global.navigator.userAgent.toLowerCase();
	if(ua.indexOf("android") >= 0) {
		return hxd_Platform.Android;
	} else if(ua.indexOf("ipad") >= 0 || ua.indexOf("iphone") >= 0 || ua.indexOf("ipod") >= 0) {
		return hxd_Platform.IOS;
	} else {
		return hxd_Platform.PC;
	}
};
hxd_System.get_screenDPI = function() {
	return 72;
};
hxd_System.get_allowTimeout = function() {
	return false;
};
hxd_System.set_allowTimeout = function(b) {
	return false;
};
var hxd_DisplayMode = $hxEnums["hxd.DisplayMode"] = { __ename__:"hxd.DisplayMode",__constructs__:null
	,Windowed: {_hx_name:"Windowed",_hx_index:0,__enum__:"hxd.DisplayMode",toString:$estr}
	,Borderless: {_hx_name:"Borderless",_hx_index:1,__enum__:"hxd.DisplayMode",toString:$estr}
	,Fullscreen: {_hx_name:"Fullscreen",_hx_index:2,__enum__:"hxd.DisplayMode",toString:$estr}
	,FullscreenResize: {_hx_name:"FullscreenResize",_hx_index:3,__enum__:"hxd.DisplayMode",toString:$estr}
};
hxd_DisplayMode.__constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
hxd_DisplayMode.__empty_constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
var hxd__$Window_NativeDroppedFile = function(native) {
	hxd_DroppedFile.call(this,native.name);
	this.native = native;
};
$hxClasses["hxd._Window.NativeDroppedFile"] = hxd__$Window_NativeDroppedFile;
hxd__$Window_NativeDroppedFile.__name__ = "hxd._Window.NativeDroppedFile";
hxd__$Window_NativeDroppedFile.__super__ = hxd_DroppedFile;
hxd__$Window_NativeDroppedFile.prototype = $extend(hxd_DroppedFile.prototype,{
	getBytes: function(callback) {
		var reader = new FileReader();
		reader.onload = function(_) {
			callback(haxe_io_Bytes.ofData(reader.result));
		};
		reader.onerror = function(_) {
			callback(null);
		};
		reader.readAsArrayBuffer(this.native);
	}
	,__class__: hxd__$Window_NativeDroppedFile
});
var hxd_res_Embed = function() { };
$hxClasses["hxd.res.Embed"] = hxd_res_Embed;
hxd_res_Embed.__name__ = "hxd.res.Embed";
var hxd__$res_R_$fonts_$nokiafc22_$ttf = function() { };
$hxClasses["hxd._res.R_fonts_nokiafc22_ttf"] = hxd__$res_R_$fonts_$nokiafc22_$ttf;
hxd__$res_R_$fonts_$nokiafc22_$ttf.__name__ = "hxd._res.R_fonts_nokiafc22_ttf";
hxd__$res_R_$fonts_$nokiafc22_$ttf.__super__ = hxd_res_Embed;
hxd__$res_R_$fonts_$nokiafc22_$ttf.prototype = $extend(hxd_res_Embed.prototype,{
	__class__: hxd__$res_R_$fonts_$nokiafc22_$ttf
});
var hxd__$res_R_$fonts_$upheavtt_$ttf = function() { };
$hxClasses["hxd._res.R_fonts_upheavtt_ttf"] = hxd__$res_R_$fonts_$upheavtt_$ttf;
hxd__$res_R_$fonts_$upheavtt_$ttf.__name__ = "hxd._res.R_fonts_upheavtt_ttf";
hxd__$res_R_$fonts_$upheavtt_$ttf.__super__ = hxd_res_Embed;
hxd__$res_R_$fonts_$upheavtt_$ttf.prototype = $extend(hxd_res_Embed.prototype,{
	__class__: hxd__$res_R_$fonts_$upheavtt_$ttf
});
var hxd_clipper_ClipType = $hxEnums["hxd.clipper.ClipType"] = { __ename__:"hxd.clipper.ClipType",__constructs__:null
	,Intersection: {_hx_name:"Intersection",_hx_index:0,__enum__:"hxd.clipper.ClipType",toString:$estr}
	,Union: {_hx_name:"Union",_hx_index:1,__enum__:"hxd.clipper.ClipType",toString:$estr}
	,Difference: {_hx_name:"Difference",_hx_index:2,__enum__:"hxd.clipper.ClipType",toString:$estr}
	,Xor: {_hx_name:"Xor",_hx_index:3,__enum__:"hxd.clipper.ClipType",toString:$estr}
};
hxd_clipper_ClipType.__constructs__ = [hxd_clipper_ClipType.Intersection,hxd_clipper_ClipType.Union,hxd_clipper_ClipType.Difference,hxd_clipper_ClipType.Xor];
hxd_clipper_ClipType.__empty_constructs__ = [hxd_clipper_ClipType.Intersection,hxd_clipper_ClipType.Union,hxd_clipper_ClipType.Difference,hxd_clipper_ClipType.Xor];
var hxd_clipper__$Clipper_EdgeSide = $hxEnums["hxd.clipper._Clipper.EdgeSide"] = { __ename__:"hxd.clipper._Clipper.EdgeSide",__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"hxd.clipper._Clipper.EdgeSide",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"hxd.clipper._Clipper.EdgeSide",toString:$estr}
};
hxd_clipper__$Clipper_EdgeSide.__constructs__ = [hxd_clipper__$Clipper_EdgeSide.Left,hxd_clipper__$Clipper_EdgeSide.Right];
hxd_clipper__$Clipper_EdgeSide.__empty_constructs__ = [hxd_clipper__$Clipper_EdgeSide.Left,hxd_clipper__$Clipper_EdgeSide.Right];
var hxd_clipper__$Clipper_Direction = $hxEnums["hxd.clipper._Clipper.Direction"] = { __ename__:"hxd.clipper._Clipper.Direction",__constructs__:null
	,RightToLeft: {_hx_name:"RightToLeft",_hx_index:0,__enum__:"hxd.clipper._Clipper.Direction",toString:$estr}
	,LeftToRight: {_hx_name:"LeftToRight",_hx_index:1,__enum__:"hxd.clipper._Clipper.Direction",toString:$estr}
};
hxd_clipper__$Clipper_Direction.__constructs__ = [hxd_clipper__$Clipper_Direction.RightToLeft,hxd_clipper__$Clipper_Direction.LeftToRight];
hxd_clipper__$Clipper_Direction.__empty_constructs__ = [hxd_clipper__$Clipper_Direction.RightToLeft,hxd_clipper__$Clipper_Direction.LeftToRight];
var hxd_clipper__$Clipper_PolyNode = function() {
	var points = [];
	this.polygon = points == null ? [] : points;
	this.childs = [];
};
$hxClasses["hxd.clipper._Clipper.PolyNode"] = hxd_clipper__$Clipper_PolyNode;
hxd_clipper__$Clipper_PolyNode.__name__ = "hxd.clipper._Clipper.PolyNode";
hxd_clipper__$Clipper_PolyNode.prototype = {
	isHoleNode: function() {
		var result = true;
		var node = this.parent;
		while(node != null) {
			result = !result;
			node = node.parent;
		}
		return result;
	}
	,get_childCount: function() {
		return this.childs.length;
	}
	,get_contour: function() {
		return this.polygon;
	}
	,addChild: function(child) {
		var cnt = this.childs.length;
		this.childs.push(child);
		child.parent = this;
		child.index = cnt;
	}
	,getNext: function() {
		if(this.childs.length > 0) {
			return this.childs[0];
		} else {
			return this.getNextSiblingUp();
		}
	}
	,getNextSiblingUp: function() {
		if(this.parent == null) {
			return null;
		} else if(this.index == this.parent.childs.length - 1) {
			return this.parent.getNextSiblingUp();
		} else {
			return this.parent.childs[this.index + 1];
		}
	}
	,isHole: function() {
		return this.isHoleNode();
	}
	,__class__: hxd_clipper__$Clipper_PolyNode
};
var hxd_clipper__$Clipper_PolyTree = function() {
	hxd_clipper__$Clipper_PolyNode.call(this);
	this.allPolys = [];
};
$hxClasses["hxd.clipper._Clipper.PolyTree"] = hxd_clipper__$Clipper_PolyTree;
hxd_clipper__$Clipper_PolyTree.__name__ = "hxd.clipper._Clipper.PolyTree";
hxd_clipper__$Clipper_PolyTree.__super__ = hxd_clipper__$Clipper_PolyNode;
hxd_clipper__$Clipper_PolyTree.prototype = $extend(hxd_clipper__$Clipper_PolyNode.prototype,{
	toPolygons: function(polygons) {
		polygons = [];
		this.addRec(this,polygons);
	}
	,addRec: function(polynode,polygons) {
		if(polynode.polygon.length > 0) {
			polygons.push(polynode.polygon);
		}
		var _g = 0;
		var _g1 = polynode.childs;
		while(_g < _g1.length) {
			var pn = _g1[_g];
			++_g;
			this.addRec(pn,polygons);
		}
	}
	,clear: function() {
		this.allPolys = [];
		this.childs = [];
	}
	,getFirst: function() {
		if(this.childs.length > 0) {
			return this.childs[0];
		}
		return null;
	}
	,get_total: function() {
		var result = this.allPolys.length;
		if(result > 0 && this.childs[0] != this.allPolys[0]) {
			--result;
		}
		return result;
	}
	,__class__: hxd_clipper__$Clipper_PolyTree
});
var hxd_clipper__$Clipper_Ref = function(v) {
	this.val = v;
};
$hxClasses["hxd.clipper._Clipper.Ref"] = hxd_clipper__$Clipper_Ref;
hxd_clipper__$Clipper_Ref.__name__ = "hxd.clipper._Clipper.Ref";
hxd_clipper__$Clipper_Ref.prototype = {
	__class__: hxd_clipper__$Clipper_Ref
};
var hxd_clipper__$Clipper_TEdge = function() {
};
$hxClasses["hxd.clipper._Clipper.TEdge"] = hxd_clipper__$Clipper_TEdge;
hxd_clipper__$Clipper_TEdge.__name__ = "hxd.clipper._Clipper.TEdge";
hxd_clipper__$Clipper_TEdge.prototype = {
	get_top: function() {
		return new h2d_col_IPoint(this.topX,this.topY);
	}
	,get_bot: function() {
		return new h2d_col_IPoint(this.botX,this.botY);
	}
	,get_curr: function() {
		return new h2d_col_IPoint(this.currX,this.currY);
	}
	,set_top: function(p) {
		this.topX = p.x;
		this.topY = p.y;
		return p;
	}
	,set_bot: function(p) {
		this.botX = p.x;
		this.botY = p.y;
		return p;
	}
	,set_curr: function(p) {
		this.currX = p.x;
		this.currY = p.y;
		return p;
	}
	,__class__: hxd_clipper__$Clipper_TEdge
};
var hxd_clipper__$Clipper_IntersectNode = function() {
};
$hxClasses["hxd.clipper._Clipper.IntersectNode"] = hxd_clipper__$Clipper_IntersectNode;
hxd_clipper__$Clipper_IntersectNode.__name__ = "hxd.clipper._Clipper.IntersectNode";
hxd_clipper__$Clipper_IntersectNode.prototype = {
	__class__: hxd_clipper__$Clipper_IntersectNode
};
var hxd_clipper__$Clipper_LocalMinima = function() {
};
$hxClasses["hxd.clipper._Clipper.LocalMinima"] = hxd_clipper__$Clipper_LocalMinima;
hxd_clipper__$Clipper_LocalMinima.__name__ = "hxd.clipper._Clipper.LocalMinima";
hxd_clipper__$Clipper_LocalMinima.prototype = {
	__class__: hxd_clipper__$Clipper_LocalMinima
};
var hxd_clipper__$Clipper_Scanbeam = function() {
};
$hxClasses["hxd.clipper._Clipper.Scanbeam"] = hxd_clipper__$Clipper_Scanbeam;
hxd_clipper__$Clipper_Scanbeam.__name__ = "hxd.clipper._Clipper.Scanbeam";
hxd_clipper__$Clipper_Scanbeam.prototype = {
	__class__: hxd_clipper__$Clipper_Scanbeam
};
var hxd_clipper__$Clipper_OutRec = function() {
};
$hxClasses["hxd.clipper._Clipper.OutRec"] = hxd_clipper__$Clipper_OutRec;
hxd_clipper__$Clipper_OutRec.__name__ = "hxd.clipper._Clipper.OutRec";
hxd_clipper__$Clipper_OutRec.prototype = {
	__class__: hxd_clipper__$Clipper_OutRec
};
var hxd_clipper__$Clipper_OutPt = function() {
};
$hxClasses["hxd.clipper._Clipper.OutPt"] = hxd_clipper__$Clipper_OutPt;
hxd_clipper__$Clipper_OutPt.__name__ = "hxd.clipper._Clipper.OutPt";
hxd_clipper__$Clipper_OutPt.prototype = {
	__class__: hxd_clipper__$Clipper_OutPt
};
var hxd_clipper__$Clipper_Join = function() {
};
$hxClasses["hxd.clipper._Clipper.Join"] = hxd_clipper__$Clipper_Join;
hxd_clipper__$Clipper_Join.__name__ = "hxd.clipper._Clipper.Join";
hxd_clipper__$Clipper_Join.prototype = {
	__class__: hxd_clipper__$Clipper_Join
};
var hxd_clipper__$Clipper_ClipperBase = function() {
	this.m_edges = [];
	this.m_MinimaList = null;
	this.m_CurrentLM = null;
};
$hxClasses["hxd.clipper._Clipper.ClipperBase"] = hxd_clipper__$Clipper_ClipperBase;
hxd_clipper__$Clipper_ClipperBase.__name__ = "hxd.clipper._Clipper.ClipperBase";
hxd_clipper__$Clipper_ClipperBase.nearZero = function(v) {
	if(v > -1e-20) {
		return v < 1E-20;
	} else {
		return false;
	}
};
hxd_clipper__$Clipper_ClipperBase.getBounds = function(pols) {
	var result = new hxd_clipper_Rect();
	var i = 0;
	var count = pols.length;
	while(i < count && pols[i].length == 0) ++i;
	var tmp = i == count;
	result.left = result.right = pols[i][0].x;
	result.top = result.bottom = pols[i][0].y;
	var _g = 0;
	var _g1 = count;
	while(_g < _g1) {
		var i = _g++;
		var _g_i = 0;
		var _g_a = pols[i];
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			if(p.x < result.left) {
				result.left = p.x;
			} else if(p.x > result.right) {
				result.right = p.x;
			}
			if(p.y < result.top) {
				result.top = p.y;
			} else if(p.y > result.bottom) {
				result.bottom = p.y;
			}
		}
	}
	return result;
};
hxd_clipper__$Clipper_ClipperBase.prototype = {
	isHorizontal: function(e) {
		return e.deltaY == 0;
	}
	,abs: function(i) {
		if(i < 0) {
			return -i;
		} else {
			return i;
		}
	}
	,PointIsVertex: function(pt,pp) {
		var pp2 = pp;
		do {
			var pt1 = pp2.pt;
			if(pt1.x == pt.x && pt1.y == pt.y) {
				return true;
			}
			pp2 = pp2.next;
		} while(pp2 != pp);
		return false;
	}
	,PointOnLineSegment: function(pt,linePt1,linePt2) {
		if(!(pt.x == linePt1.x && pt.y == linePt1.y || pt.x == linePt2.x && pt.y == linePt2.y)) {
			if(pt.x > linePt1.x == pt.x < linePt2.x && pt.y > linePt1.y == pt.y < linePt2.y) {
				return (pt.x - linePt1.x) * (linePt2.y - linePt1.y) == (linePt2.x - linePt1.x) * (pt.y - linePt1.y);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,PointOnPolygon: function(pt,pp) {
		var pp2 = pp;
		do {
			if(this.PointOnLineSegment(pt,pp2.pt,pp2.next.pt)) {
				return true;
			}
			pp2 = pp2.next;
		} while(pp2 != pp);
		return false;
	}
	,SlopesEqual: function(e1,e2) {
		return e1.deltaY * e2.deltaX == e1.deltaX * e2.deltaY;
	}
	,SlopesEqual3: function(pt1,pt2,pt3) {
		return (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) == 0;
	}
	,clear: function() {
		this.disposeLocalMinimaList();
		this.m_edges = [];
	}
	,disposeLocalMinimaList: function() {
		while(this.m_MinimaList != null) {
			var tmpLm = this.m_MinimaList.next;
			this.m_MinimaList = null;
			this.m_MinimaList = tmpLm;
		}
		this.m_CurrentLM = null;
	}
	,addPolygons: function(ppg,polyType) {
		var result = false;
		var _g_i = 0;
		var _g_a = ppg;
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			if(this.addPolygon(p,polyType)) {
				result = true;
			}
		}
		return result;
	}
	,addPolygon: function(pg,polyType) {
		var highI = pg.length - 1;
		while(highI > 0 && pg[highI] == pg[0]) --highI;
		while(highI > 0 && pg[highI] == pg[highI - 1]) --highI;
		if(highI < 2) {
			return false;
		}
		var edges = [];
		var _g = 0;
		var _g1 = highI + 1;
		while(_g < _g1) {
			var i = _g++;
			edges.push(new hxd_clipper__$Clipper_TEdge());
		}
		var isFlat = true;
		var _this = edges[1];
		var p = pg[1];
		_this.currX = p.x;
		_this.currY = p.y;
		var e = edges[0];
		var pt = pg[0];
		e.next = edges[1];
		e.prev = edges[highI];
		e.currX = pt.x;
		e.currY = pt.y;
		e.outIdx = -1;
		var e = edges[highI];
		var pt = pg[highI];
		e.next = edges[0];
		e.prev = edges[highI - 1];
		e.currX = pt.x;
		e.currY = pt.y;
		e.outIdx = -1;
		var i = highI - 1;
		while(i > 0) {
			var e = edges[i];
			var pt = pg[i];
			e.next = edges[i + 1];
			e.prev = edges[i - 1];
			e.currX = pt.x;
			e.currY = pt.y;
			e.outIdx = -1;
			--i;
		}
		var eStart = edges[0];
		var eStop = eStart;
		var e = eStart;
		while(true) {
			if(e.currX == e.next.currX && e.currY == e.next.currY) {
				if(e == e.next) {
					break;
				}
				if(e == eStart) {
					eStart = e.next;
				}
				e = this.RemoveEdge(e);
				eStop = e;
				continue;
			}
			if(e.prev == e.next) {
				break;
			}
			var tmp;
			var _this = e.prev;
			var x = _this.currX;
			var y = _this.currY;
			if(y == null) {
				y = 0;
			}
			if(x == null) {
				x = 0;
			}
			var pt1_x = x;
			var pt1_y = y;
			var x1 = e.currX;
			var y1 = e.currY;
			if(y1 == null) {
				y1 = 0;
			}
			if(x1 == null) {
				x1 = 0;
			}
			var pt2_x = x1;
			var pt2_y = y1;
			var _this1 = e.next;
			var x2 = _this1.currX;
			var y2 = _this1.currY;
			if(y2 == null) {
				y2 = 0;
			}
			if(x2 == null) {
				x2 = 0;
			}
			var pt3_x = x2;
			var pt3_y = y2;
			if((pt1_y - pt2_y) * (pt2_x - pt3_x) - (pt1_x - pt2_x) * (pt2_y - pt3_y) == 0) {
				if(this.preserveCollinear) {
					var _this2 = e.prev;
					var tmp1 = new h2d_col_IPoint(_this2.currX,_this2.currY);
					var tmp2 = new h2d_col_IPoint(e.currX,e.currY);
					var _this3 = e.next;
					tmp = !this.Pt2IsBetweenPt1AndPt3(tmp1,tmp2,new h2d_col_IPoint(_this3.currX,_this3.currY));
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				if(e == eStart) {
					eStart = e.next;
				}
				e = this.RemoveEdge(e);
				e = e.prev;
				eStop = e;
				continue;
			}
			e = e.next;
			if(e == eStop) {
				break;
			}
		}
		if(e.prev == e.next) {
			return false;
		}
		e = eStart;
		do {
			if(e.currY >= e.next.currY) {
				e.botX = e.currX;
				e.botY = e.currY;
				e.topX = e.next.currX;
				e.topY = e.next.currY;
			} else {
				e.topX = e.currX;
				e.topY = e.currY;
				e.botX = e.next.currX;
				e.botY = e.next.currY;
			}
			this.SetDx(e);
			e.polyType = polyType;
			e = e.next;
			if(e.currY != eStart.currY) {
				isFlat = false;
			}
		} while(e != eStart);
		if(isFlat) {
			return false;
		}
		this.m_edges.push(edges);
		var leftBoundIsForward;
		var eMin = null;
		if(e.prev.botX == e.prev.topX && e.prev.botY == e.prev.topY) {
			e = e.next;
		}
		var old = null;
		while(true) {
			e = this.FindNextLocMin(e);
			if(e == eMin) {
				break;
			} else if(eMin == null) {
				eMin = e;
			}
			if(e == old) {
				throw haxe_Exception.thrown("!");
			}
			old = e;
			var locMin = new hxd_clipper__$Clipper_LocalMinima();
			locMin.next = null;
			locMin.y = e.botY;
			if(e.dx < e.prev.dx) {
				locMin.leftBound = e.prev;
				locMin.rightBound = e;
				leftBoundIsForward = false;
			} else {
				locMin.leftBound = e;
				locMin.rightBound = e.prev;
				leftBoundIsForward = true;
			}
			locMin.leftBound.side = hxd_clipper__$Clipper_EdgeSide.Left;
			locMin.rightBound.side = hxd_clipper__$Clipper_EdgeSide.Right;
			if(locMin.leftBound.next == locMin.rightBound) {
				locMin.leftBound.windDelta = -1;
			} else {
				locMin.leftBound.windDelta = 1;
			}
			locMin.rightBound.windDelta = -locMin.leftBound.windDelta;
			e = this.ProcessBound(locMin.leftBound,leftBoundIsForward);
			if(e.outIdx == -2) {
				e = this.ProcessBound(e,leftBoundIsForward);
			}
			var e2 = this.ProcessBound(locMin.rightBound,!leftBoundIsForward);
			if(e2.outIdx == -2) {
				e2 = this.ProcessBound(e2,!leftBoundIsForward);
			}
			if(locMin.leftBound.outIdx == -2) {
				locMin.leftBound = null;
			} else if(locMin.rightBound.outIdx == -2) {
				locMin.rightBound = null;
			}
			this.InsertLocalMinima(locMin);
			if(!leftBoundIsForward) {
				e = e2;
			}
		}
		return true;
	}
	,InitEdge: function(e,eNext,ePrev,pt) {
		e.next = eNext;
		e.prev = ePrev;
		e.currX = pt.x;
		e.currY = pt.y;
		e.outIdx = -1;
	}
	,InitEdge2: function(e,polyType) {
		if(e.currY >= e.next.currY) {
			e.botX = e.currX;
			e.botY = e.currY;
			e.topX = e.next.currX;
			e.topY = e.next.currY;
		} else {
			e.topX = e.currX;
			e.topY = e.currY;
			e.botX = e.next.currX;
			e.botY = e.next.currY;
		}
		this.SetDx(e);
		e.polyType = polyType;
	}
	,RemoveEdge: function(e) {
		e.prev.next = e.next;
		e.next.prev = e.prev;
		var result = e.next;
		e.prev = null;
		return result;
	}
	,FindNextLocMin: function(e) {
		var e2;
		while(true) {
			while(e.botX != e.prev.botX || e.botY != e.prev.botY || e.currX == e.topX && e.currY == e.topY) e = e.next;
			if(e.dx != -9007199254740992. && e.prev.dx != -9007199254740992.) {
				break;
			}
			while(e.prev.dx == -9007199254740992.) e = e.prev;
			e2 = e;
			while(e.dx == -9007199254740992.) e = e.next;
			if(e.topY == e.prev.botY) {
				continue;
			}
			if(e2.prev.botX < e.botX) {
				e = e2;
			}
			break;
		}
		return e;
	}
	,ProcessBound: function(E,LeftBoundIsForward) {
		var EStart;
		var Horz;
		var Result = E;
		if(Result.outIdx == -2) {
			E = Result;
			if(LeftBoundIsForward) {
				while(E.topY == E.next.botY) E = E.next;
				while(E != Result && E.dx == -9007199254740992.) E = E.prev;
			} else {
				while(E.topY == E.prev.botY) E = E.prev;
				while(E != Result && E.dx == -9007199254740992.) E = E.next;
			}
			if(E == Result) {
				if(LeftBoundIsForward) {
					Result = E.next;
				} else {
					Result = E.prev;
				}
			} else {
				if(LeftBoundIsForward) {
					E = Result.next;
				} else {
					E = Result.prev;
				}
				var locMin = new hxd_clipper__$Clipper_LocalMinima();
				locMin.next = null;
				locMin.y = E.botY;
				locMin.leftBound = null;
				locMin.rightBound = E;
				E.windDelta = 0;
				Result = this.ProcessBound(E,LeftBoundIsForward);
				this.InsertLocalMinima(locMin);
			}
			return Result;
		}
		if(E.dx == -9007199254740992.) {
			if(LeftBoundIsForward) {
				EStart = E.prev;
			} else {
				EStart = E.next;
			}
			if(EStart.outIdx != -2) {
				if(EStart.dx == -9007199254740992.) {
					if(EStart.botX != E.botX && EStart.topX != E.botX) {
						this.ReverseHorizontal(E);
					}
				} else if(EStart.botX != E.botX) {
					this.ReverseHorizontal(E);
				}
			}
		}
		EStart = E;
		if(LeftBoundIsForward) {
			while(Result.topY == Result.next.botY && Result.next.outIdx != -2) Result = Result.next;
			if(Result.dx == -9007199254740992. && Result.next.outIdx != -2) {
				Horz = Result;
				while(Horz.prev.dx == -9007199254740992.) Horz = Horz.prev;
				if(Horz.prev.topX == Result.next.topX) {
					if(!LeftBoundIsForward) {
						Result = Horz.prev;
					}
				} else if(Horz.prev.topX > Result.next.topX) {
					Result = Horz.prev;
				}
			}
			while(E != Result) {
				E.nextInLML = E.next;
				if(E.dx == -9007199254740992. && E != EStart && E.botX != E.prev.topX) {
					this.ReverseHorizontal(E);
				}
				E = E.next;
			}
			if(E.dx == -9007199254740992. && E != EStart && E.botX != E.prev.topX) {
				this.ReverseHorizontal(E);
			}
			Result = Result.next;
		} else {
			while(Result.topY == Result.prev.botY && Result.prev.outIdx != -2) Result = Result.prev;
			if(Result.dx == -9007199254740992. && Result.prev.outIdx != -2) {
				Horz = Result;
				while(Horz.next.dx == -9007199254740992.) Horz = Horz.next;
				if(Horz.next.topX == Result.prev.topX) {
					if(!LeftBoundIsForward) {
						Result = Horz.next;
					}
				} else if(Horz.next.topX > Result.prev.topX) {
					Result = Horz.next;
				}
			}
			while(E != Result) {
				E.nextInLML = E.prev;
				if(E.dx == -9007199254740992. && E != EStart && E.botX != E.next.topX) {
					this.ReverseHorizontal(E);
				}
				E = E.prev;
			}
			if(E.dx == -9007199254740992. && E != EStart && E.botX != E.next.topX) {
				this.ReverseHorizontal(E);
			}
			Result = Result.prev;
		}
		return Result;
	}
	,ReverseHorizontal: function(e) {
		var tmp = e.topX;
		e.topX = e.botX;
		e.botX = tmp;
	}
	,Pt2IsBetweenPt1AndPt3: function(pt1,pt2,pt3) {
		if(pt1.x == pt3.x && pt1.y == pt3.y || pt1.x == pt2.x && pt1.y == pt2.y || pt3.x == pt2.x && pt3.y == pt2.y) {
			return false;
		} else if(pt1.x != pt3.x) {
			return pt2.x > pt1.x == pt2.x < pt3.x;
		} else {
			return pt2.y > pt1.y == pt2.y < pt3.y;
		}
	}
	,SetDx: function(e) {
		e.deltaX = e.topX - e.botX;
		e.deltaY = e.topY - e.botY;
		if(e.deltaY == 0) {
			e.dx = -9007199254740992.;
		} else {
			e.dx = e.deltaX / e.deltaY;
		}
	}
	,InsertLocalMinima: function(newLm) {
		if(this.m_MinimaList == null) {
			this.m_MinimaList = newLm;
		} else if(newLm.y >= this.m_MinimaList.y) {
			newLm.next = this.m_MinimaList;
			this.m_MinimaList = newLm;
		} else {
			var tmpLm = this.m_MinimaList;
			while(tmpLm.next != null && newLm.y < tmpLm.next.y) tmpLm = tmpLm.next;
			newLm.next = tmpLm.next;
			tmpLm.next = newLm;
		}
	}
	,PopLocalMinima: function() {
		if(this.m_CurrentLM == null) {
			return;
		}
		this.m_CurrentLM = this.m_CurrentLM.next;
	}
	,SwapX: function(e) {
		e.currX = e.topX;
		e.topX = e.botX;
		e.botX = e.currX;
	}
	,equals: function(pt1,pt2) {
		if(pt1.x == pt2.x) {
			return pt1.y == pt2.y;
		} else {
			return false;
		}
	}
	,Reset: function() {
		this.m_CurrentLM = this.m_MinimaList;
		var lm = this.m_MinimaList;
		while(lm != null) {
			var e = lm.leftBound;
			if(e != null) {
				e.currX = e.botX;
				e.currY = e.botY;
				e.side = hxd_clipper__$Clipper_EdgeSide.Left;
				e.outIdx = -1;
				e = e.nextInLML;
			}
			e = lm.rightBound;
			if(e != null) {
				e.currX = e.botX;
				e.currY = e.botY;
				e.side = hxd_clipper__$Clipper_EdgeSide.Right;
				e.outIdx = -1;
				e = e.nextInLML;
			}
			lm = lm.next;
		}
	}
	,__class__: hxd_clipper__$Clipper_ClipperBase
};
var hxd_clipper_NodeType = $hxEnums["hxd.clipper.NodeType"] = { __ename__:"hxd.clipper.NodeType",__constructs__:null
	,Any: {_hx_name:"Any",_hx_index:0,__enum__:"hxd.clipper.NodeType",toString:$estr}
	,Open: {_hx_name:"Open",_hx_index:1,__enum__:"hxd.clipper.NodeType",toString:$estr}
	,Closed: {_hx_name:"Closed",_hx_index:2,__enum__:"hxd.clipper.NodeType",toString:$estr}
};
hxd_clipper_NodeType.__constructs__ = [hxd_clipper_NodeType.Any,hxd_clipper_NodeType.Open,hxd_clipper_NodeType.Closed];
hxd_clipper_NodeType.__empty_constructs__ = [hxd_clipper_NodeType.Any,hxd_clipper_NodeType.Open,hxd_clipper_NodeType.Closed];
var hxd_clipper_ResultKind = $hxEnums["hxd.clipper.ResultKind"] = { __ename__:"hxd.clipper.ResultKind",__constructs__:null
	,All: {_hx_name:"All",_hx_index:0,__enum__:"hxd.clipper.ResultKind",toString:$estr}
	,NoHoles: {_hx_name:"NoHoles",_hx_index:1,__enum__:"hxd.clipper.ResultKind",toString:$estr}
	,HolesOnly: {_hx_name:"HolesOnly",_hx_index:2,__enum__:"hxd.clipper.ResultKind",toString:$estr}
};
hxd_clipper_ResultKind.__constructs__ = [hxd_clipper_ResultKind.All,hxd_clipper_ResultKind.NoHoles,hxd_clipper_ResultKind.HolesOnly];
hxd_clipper_ResultKind.__empty_constructs__ = [hxd_clipper_ResultKind.All,hxd_clipper_ResultKind.NoHoles,hxd_clipper_ResultKind.HolesOnly];
var hxd_clipper_Clipper = function() {
	hxd_clipper__$Clipper_ClipperBase.call(this);
	this.m_Scanbeam = null;
	this.m_ActiveEdges = null;
	this.m_SortedEdges = null;
	this.m_IntersectList = [];
	this.m_ExecuteLocked = false;
	this.m_UsingPolyTree = false;
	this.m_PolyOuts = [];
	this.m_Joins = [];
	this.m_GhostJoins = [];
	this.reverseSolution = false;
	this.strictlySimple = false;
	this.preserveCollinear = false;
	this.resultKind = hxd_clipper_ResultKind.All;
};
$hxClasses["hxd.clipper.Clipper"] = hxd_clipper_Clipper;
hxd_clipper_Clipper.__name__ = "hxd.clipper.Clipper";
hxd_clipper_Clipper.compareY = function(n1,n2) {
	if(n2.pt.y - n1.pt.y >= 0) {
		return 1;
	} else {
		return -1;
	}
};
hxd_clipper_Clipper.Orientation = function(poly) {
	return hxd_clipper_Clipper.polArea(poly) >= 0;
};
hxd_clipper_Clipper.polArea = function(poly) {
	var cnt = poly.length;
	if(cnt < 3) {
		return 0.;
	}
	var a = 0.;
	var j = cnt - 1;
	var _g = 0;
	var _g1 = cnt;
	while(_g < _g1) {
		var i = _g++;
		a += (poly[j].x + poly[i].x) * (poly[j].y - poly[i].y);
		j = i;
	}
	return -a * 0.5;
};
hxd_clipper_Clipper.SimplifyPolygon = function(poly,fillType) {
	if(fillType == null) {
		fillType = hxd_clipper_PolyFillType.EvenOdd;
	}
	var c = new hxd_clipper_Clipper();
	c.strictlySimple = true;
	c.addPolygon(poly,hxd_clipper_PolyType.Subject);
	return c.execute(hxd_clipper_ClipType.Union,fillType,fillType);
};
hxd_clipper_Clipper.SimplifyPolygons = function(polys,fillType) {
	if(fillType == null) {
		fillType = hxd_clipper_PolyFillType.EvenOdd;
	}
	var c = new hxd_clipper_Clipper();
	c.strictlySimple = true;
	c.addPolygons(polys,hxd_clipper_PolyType.Subject);
	return c.execute(hxd_clipper_ClipType.Union,fillType,fillType);
};
hxd_clipper_Clipper.MinkowskiSums = function(pattern,pols,kind) {
	var c = new hxd_clipper_Clipper();
	c.resultKind = kind == null ? hxd_clipper_ResultKind.All : kind;
	var _g = 0;
	var _g1 = pols.length;
	while(_g < _g1) {
		var i = _g++;
		var tmp = c.Minkowski(pattern,pols[i],true);
		c.addPolygons(tmp,hxd_clipper_PolyType.Subject);
		var path = c.TranslatePath(pols[i],pattern[0]);
		c.addPolygon(path,hxd_clipper_PolyType.Clip);
	}
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
hxd_clipper_Clipper.MinkowskiDiff = function(pattern,pol,kind) {
	var c = new hxd_clipper_Clipper();
	var paths = c.Minkowski(pattern,pol,false);
	c.resultKind = kind == null ? hxd_clipper_ResultKind.All : kind;
	c.addPolygons(paths,hxd_clipper_PolyType.Subject);
	return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
};
hxd_clipper_Clipper.__super__ = hxd_clipper__$Clipper_ClipperBase;
hxd_clipper_Clipper.prototype = $extend(hxd_clipper__$Clipper_ClipperBase.prototype,{
	xor: function(a,b) {
		if(a) {
			return !b;
		} else {
			return b;
		}
	}
	,DisposeScanbeamList: function() {
		while(this.m_Scanbeam != null) {
			var sb2 = this.m_Scanbeam.next;
			this.m_Scanbeam = null;
			this.m_Scanbeam = sb2;
		}
	}
	,Reset: function() {
		hxd_clipper__$Clipper_ClipperBase.prototype.Reset.call(this);
		this.m_Scanbeam = null;
		this.m_ActiveEdges = null;
		this.m_SortedEdges = null;
		var lm = this.m_MinimaList;
		while(lm != null) {
			this.InsertScanbeam(lm.y);
			lm = lm.next;
		}
	}
	,InsertScanbeam: function(y) {
		if(this.m_Scanbeam == null) {
			this.m_Scanbeam = new hxd_clipper__$Clipper_Scanbeam();
			this.m_Scanbeam.next = null;
			this.m_Scanbeam.y = y;
		} else if(y > this.m_Scanbeam.y) {
			var newSb = new hxd_clipper__$Clipper_Scanbeam();
			newSb.y = y;
			newSb.next = this.m_Scanbeam;
			this.m_Scanbeam = newSb;
		} else {
			var sb2 = this.m_Scanbeam;
			while(sb2.next != null && y <= sb2.next.y) sb2 = sb2.next;
			if(y == sb2.y) {
				return;
			}
			var newSb = new hxd_clipper__$Clipper_Scanbeam();
			newSb.y = y;
			newSb.next = sb2.next;
			sb2.next = newSb;
		}
	}
	,execute: function(clipType,subjFillType,clipFillType) {
		if(subjFillType == null) {
			subjFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(clipFillType == null) {
			clipFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(this.m_ExecuteLocked) {
			return [];
		}
		this.m_ExecuteLocked = true;
		var solution = [];
		this.m_SubjFillType = subjFillType;
		this.m_ClipFillType = clipFillType;
		this.m_ClipType = clipType;
		this.m_UsingPolyTree = false;
		var succeeded = this.ExecuteInternal();
		if(succeeded) {
			solution = this.BuildResult();
		}
		this.DisposeAllPolyPts();
		this.m_ExecuteLocked = false;
		return solution;
	}
	,ExecuteTree: function(clipType,polytree,subjFillType,clipFillType) {
		if(subjFillType == null) {
			subjFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(clipFillType == null) {
			clipFillType = hxd_clipper_PolyFillType.EvenOdd;
		}
		if(this.m_ExecuteLocked) {
			return false;
		}
		this.m_ExecuteLocked = true;
		this.m_SubjFillType = subjFillType;
		this.m_ClipFillType = clipFillType;
		this.m_ClipType = clipType;
		this.m_UsingPolyTree = true;
		var succeeded = this.ExecuteInternal();
		if(succeeded) {
			this.BuildResult2(polytree);
		}
		this.m_ExecuteLocked = false;
		return succeeded;
	}
	,FixHoleLinkage: function(outRec) {
		if(outRec.firstLeft == null || outRec.isHole != outRec.firstLeft.isHole && outRec.firstLeft.pts != null) {
			return;
		}
		var orfl = outRec.firstLeft;
		while(orfl != null && (orfl.isHole == outRec.isHole || orfl.pts == null)) orfl = orfl.firstLeft;
		outRec.firstLeft = orfl;
	}
	,ExecuteInternal: function() {
		this.Reset();
		if(this.m_CurrentLM == null) {
			return false;
		}
		var botY = this.PopScanbeam();
		do {
			this.InsertLocalMinimaIntoAEL(botY);
			if(this.m_GhostJoins.length > 0) {
				this.m_GhostJoins = [];
			}
			this.ProcessHorizontals(false);
			if(this.m_Scanbeam == null) {
				break;
			}
			var topY = this.PopScanbeam();
			if(!this.ProcessIntersections(topY)) {
				return false;
			}
			this.ProcessEdgesAtTopOfScanbeam(topY);
			botY = topY;
		} while(this.m_Scanbeam != null || this.m_CurrentLM != null);
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts == null) {
				continue;
			}
			var b = this.reverseSolution;
			if((outRec.isHole ? !b : b) == this.Area(outRec) > 0) {
				this.ReversePolyPtLinks(outRec.pts);
			}
		}
		this.JoinCommonEdges();
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts != null) {
				this.FixupOutPolygon(outRec);
			}
		}
		if(this.strictlySimple) {
			this.DoSimplePolygons();
		}
		this.m_Joins = [];
		this.m_GhostJoins = [];
		return true;
	}
	,PopScanbeam: function() {
		var y = this.m_Scanbeam.y;
		this.m_Scanbeam = this.m_Scanbeam.next;
		return y;
	}
	,DisposeAllPolyPts: function() {
		var _g = 0;
		var _g1 = this.m_PolyOuts.length;
		while(_g < _g1) {
			var i = _g++;
			this.DisposeOutRec(i);
		}
		this.m_PolyOuts = [];
	}
	,DisposeOutRec: function(index) {
		var outRec = this.m_PolyOuts[index];
		outRec.pts = null;
		outRec = null;
		this.m_PolyOuts[index] = null;
	}
	,AddJoin: function(op1,op2,offPt) {
		var j = new hxd_clipper__$Clipper_Join();
		j.outPt1 = op1;
		j.outPt2 = op2;
		j.offPt = offPt;
		this.m_Joins.push(j);
	}
	,AddGhostJoin: function(op,offPt) {
		var j = new hxd_clipper__$Clipper_Join();
		j.outPt1 = op;
		j.offPt = offPt;
		this.m_GhostJoins.push(j);
	}
	,InsertLocalMinimaIntoAEL: function(botY) {
		while(this.m_CurrentLM != null && this.m_CurrentLM.y == botY) {
			var lb = this.m_CurrentLM.leftBound;
			var rb = this.m_CurrentLM.rightBound;
			this.PopLocalMinima();
			var op1 = null;
			if(lb == null) {
				this.InsertEdgeIntoAEL(rb);
				this.SetWindingCount(rb);
				if(this.IsContributing(rb)) {
					op1 = this.AddOutPt(rb,new h2d_col_IPoint(rb.botX,rb.botY));
				}
			} else if(rb == null) {
				this.InsertEdgeIntoAEL(lb);
				this.SetWindingCount(lb);
				if(this.IsContributing(lb)) {
					op1 = this.AddOutPt(lb,new h2d_col_IPoint(lb.botX,lb.botY));
				}
				this.InsertScanbeam(lb.topY);
			} else {
				this.InsertEdgeIntoAEL(lb);
				this.InsertEdgeIntoAEL(rb,lb);
				this.SetWindingCount(lb);
				rb.windCnt = lb.windCnt;
				rb.windCnt2 = lb.windCnt2;
				if(this.IsContributing(lb)) {
					op1 = this.AddLocalMinPoly(lb,rb,new h2d_col_IPoint(lb.botX,lb.botY));
				}
				this.InsertScanbeam(lb.topY);
			}
			if(rb != null) {
				if(rb.deltaY == 0) {
					this.AddEdgeToSEL(rb);
				} else {
					this.InsertScanbeam(rb.topY);
				}
			}
			if(lb == null || rb == null) {
				continue;
			}
			if(op1 != null && rb.deltaY == 0 && this.m_GhostJoins.length > 0 && rb.windDelta != 0) {
				var _g = 0;
				var _g1 = this.m_GhostJoins;
				while(_g < _g1.length) {
					var j = _g1[_g];
					++_g;
					if(this.HorzSegmentsOverlap(j.outPt1.pt.x,j.offPt.x,rb.botX,rb.topX)) {
						this.AddJoin(j.outPt1,op1,j.offPt);
					}
				}
			}
			var tmp;
			if(lb.outIdx >= 0 && lb.prevInAEL != null && lb.prevInAEL.currX == lb.botX && lb.prevInAEL.outIdx >= 0) {
				var e1 = lb.prevInAEL;
				tmp = e1.deltaY * lb.deltaX == e1.deltaX * lb.deltaY;
			} else {
				tmp = false;
			}
			if(tmp && lb.windDelta != 0 && lb.prevInAEL.windDelta != 0) {
				var op2 = this.AddOutPt(lb.prevInAEL,new h2d_col_IPoint(lb.botX,lb.botY));
				this.AddJoin(op1,op2,new h2d_col_IPoint(lb.topX,lb.topY));
			}
			if(lb.nextInAEL != rb) {
				var tmp1;
				if(rb.outIdx >= 0 && rb.prevInAEL.outIdx >= 0) {
					var e11 = rb.prevInAEL;
					tmp1 = e11.deltaY * rb.deltaX == e11.deltaX * rb.deltaY;
				} else {
					tmp1 = false;
				}
				if(tmp1 && rb.windDelta != 0 && rb.prevInAEL.windDelta != 0) {
					var op21 = this.AddOutPt(rb.prevInAEL,new h2d_col_IPoint(rb.botX,rb.botY));
					this.AddJoin(op1,op21,new h2d_col_IPoint(rb.topX,rb.topY));
				}
				var e = lb.nextInAEL;
				if(e != null) {
					while(e != rb) {
						this.IntersectEdges(rb,e,new h2d_col_IPoint(lb.currX,lb.currY));
						e = e.nextInAEL;
					}
				}
			}
		}
	}
	,InsertEdgeIntoAEL: function(edge,startEdge) {
		if(this.m_ActiveEdges == null) {
			edge.prevInAEL = null;
			edge.nextInAEL = null;
			this.m_ActiveEdges = edge;
		} else if(startEdge == null && this.E2InsertsBeforeE1(this.m_ActiveEdges,edge)) {
			edge.prevInAEL = null;
			edge.nextInAEL = this.m_ActiveEdges;
			this.m_ActiveEdges.prevInAEL = edge;
			this.m_ActiveEdges = edge;
		} else {
			if(startEdge == null) {
				startEdge = this.m_ActiveEdges;
			}
			while(startEdge.nextInAEL != null && !this.E2InsertsBeforeE1(startEdge.nextInAEL,edge)) startEdge = startEdge.nextInAEL;
			edge.nextInAEL = startEdge.nextInAEL;
			if(startEdge.nextInAEL != null) {
				startEdge.nextInAEL.prevInAEL = edge;
			}
			edge.prevInAEL = startEdge;
			startEdge.nextInAEL = edge;
		}
	}
	,E2InsertsBeforeE1: function(e1,e2) {
		if(e2.currX == e1.currX) {
			if(e2.topY > e1.topY) {
				var currentY = e2.topY;
				var tmp;
				if(currentY == e1.topY) {
					tmp = e1.topX;
				} else {
					var value = e1.dx * (currentY - e1.botY);
					tmp = e1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
				return e2.topX < tmp;
			} else {
				var currentY = e1.topY;
				var tmp;
				if(currentY == e2.topY) {
					tmp = e2.topX;
				} else {
					var value = e2.dx * (currentY - e2.botY);
					tmp = e2.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
				return e1.topX > tmp;
			}
		} else {
			return e2.currX < e1.currX;
		}
	}
	,IsEvenOddFillType: function(edge) {
		if(edge.polyType == hxd_clipper_PolyType.Subject) {
			return this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd;
		} else {
			return this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd;
		}
	}
	,IsEvenOddAltFillType: function(edge) {
		if(edge.polyType == hxd_clipper_PolyType.Subject) {
			return this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd;
		} else {
			return this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd;
		}
	}
	,IsContributing: function(edge) {
		var pft;
		var pft2;
		if(edge.polyType == hxd_clipper_PolyType.Subject) {
			pft = this.m_SubjFillType;
			pft2 = this.m_ClipFillType;
		} else {
			pft = this.m_ClipFillType;
			pft2 = this.m_SubjFillType;
		}
		switch(pft._hx_index) {
		case 0:
			if(edge.windDelta == 0 && edge.windCnt != 1) {
				return false;
			}
			break;
		case 1:
			var f = edge.windCnt;
			if((f < 0 ? -f : f) != 1) {
				return false;
			}
			break;
		case 2:
			if(edge.windCnt != 1) {
				return false;
			}
			break;
		default:
			if(edge.windCnt != -1) {
				return false;
			}
		}
		switch(this.m_ClipType._hx_index) {
		case 0:
			switch(pft2._hx_index) {
			case 0:case 1:
				return edge.windCnt2 != 0;
			case 2:
				return edge.windCnt2 > 0;
			default:
				return edge.windCnt2 < 0;
			}
			break;
		case 1:
			switch(pft2._hx_index) {
			case 0:case 1:
				return edge.windCnt2 == 0;
			case 2:
				return edge.windCnt2 <= 0;
			default:
				return edge.windCnt2 >= 0;
			}
			break;
		case 2:
			if(edge.polyType == hxd_clipper_PolyType.Subject) {
				switch(pft2._hx_index) {
				case 0:case 1:
					return edge.windCnt2 == 0;
				case 2:
					return edge.windCnt2 <= 0;
				default:
					return edge.windCnt2 >= 0;
				}
			} else {
				switch(pft2._hx_index) {
				case 0:case 1:
					return edge.windCnt2 != 0;
				case 2:
					return edge.windCnt2 > 0;
				default:
					return edge.windCnt2 < 0;
				}
			}
			break;
		case 3:
			if(edge.windDelta == 0) {
				switch(pft2._hx_index) {
				case 0:case 1:
					return edge.windCnt2 == 0;
				case 2:
					return edge.windCnt2 <= 0;
				default:
					return edge.windCnt2 >= 0;
				}
			} else {
				return true;
			}
			break;
		}
	}
	,SetWindingCount: function(edge) {
		var e = edge.prevInAEL;
		while(e != null && (e.polyType != edge.polyType || e.windDelta == 0)) e = e.prevInAEL;
		if(e == null) {
			edge.windCnt = edge.windDelta == 0 ? 1 : edge.windDelta;
			edge.windCnt2 = 0;
			e = this.m_ActiveEdges;
		} else if(edge.windDelta == 0 && this.m_ClipType != hxd_clipper_ClipType.Union) {
			edge.windCnt = 1;
			edge.windCnt2 = e.windCnt2;
			e = e.nextInAEL;
		} else if(edge.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd) {
			if(edge.windDelta == 0) {
				var Inside = true;
				var e2 = e.prevInAEL;
				while(e2 != null) {
					if(e2.polyType == e.polyType && e2.windDelta != 0) {
						Inside = !Inside;
					}
					e2 = e2.prevInAEL;
				}
				edge.windCnt = Inside ? 0 : 1;
			} else {
				edge.windCnt = edge.windDelta;
			}
			edge.windCnt2 = e.windCnt2;
			e = e.nextInAEL;
		} else {
			if(e.windCnt * e.windDelta < 0) {
				if(e.windCnt > 1 || e.windCnt < -1) {
					if(e.windDelta * edge.windDelta < 0) {
						edge.windCnt = e.windCnt;
					} else {
						edge.windCnt = e.windCnt + edge.windDelta;
					}
				} else {
					edge.windCnt = edge.windDelta == 0 ? 1 : edge.windDelta;
				}
			} else if(edge.windDelta == 0) {
				edge.windCnt = e.windCnt < 0 ? e.windCnt - 1 : e.windCnt + 1;
			} else if(e.windDelta * edge.windDelta < 0) {
				edge.windCnt = e.windCnt;
			} else {
				edge.windCnt = e.windCnt + edge.windDelta;
			}
			edge.windCnt2 = e.windCnt2;
			e = e.nextInAEL;
		}
		if(edge.polyType == hxd_clipper_PolyType.Subject ? this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd) {
			while(e != edge) {
				if(e.windDelta != 0) {
					edge.windCnt2 = edge.windCnt2 == 0 ? 1 : 0;
				}
				e = e.nextInAEL;
			}
		} else {
			while(e != edge) {
				edge.windCnt2 += e.windDelta;
				e = e.nextInAEL;
			}
		}
	}
	,AddEdgeToSEL: function(edge) {
		if(this.m_SortedEdges == null) {
			this.m_SortedEdges = edge;
			edge.prevInSEL = null;
			edge.nextInSEL = null;
		} else {
			edge.nextInSEL = this.m_SortedEdges;
			edge.prevInSEL = null;
			this.m_SortedEdges.prevInSEL = edge;
			this.m_SortedEdges = edge;
		}
	}
	,CopyAELToSEL: function() {
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while(e != null) {
			e.prevInSEL = e.prevInAEL;
			e.nextInSEL = e.nextInAEL;
			e = e.nextInAEL;
		}
	}
	,SwapPositionsInAEL: function(edge1,edge2) {
		if(edge1.nextInAEL == edge1.prevInAEL || edge2.nextInAEL == edge2.prevInAEL) {
			return;
		}
		if(edge1.nextInAEL == edge2) {
			var next = edge2.nextInAEL;
			if(next != null) {
				next.prevInAEL = edge1;
			}
			var prev = edge1.prevInAEL;
			if(prev != null) {
				prev.nextInAEL = edge2;
			}
			edge2.prevInAEL = prev;
			edge2.nextInAEL = edge1;
			edge1.prevInAEL = edge2;
			edge1.nextInAEL = next;
		} else if(edge2.nextInAEL == edge1) {
			var next = edge1.nextInAEL;
			if(next != null) {
				next.prevInAEL = edge2;
			}
			var prev = edge2.prevInAEL;
			if(prev != null) {
				prev.nextInAEL = edge1;
			}
			edge1.prevInAEL = prev;
			edge1.nextInAEL = edge2;
			edge2.prevInAEL = edge1;
			edge2.nextInAEL = next;
		} else {
			var next = edge1.nextInAEL;
			var prev = edge1.prevInAEL;
			edge1.nextInAEL = edge2.nextInAEL;
			if(edge1.nextInAEL != null) {
				edge1.nextInAEL.prevInAEL = edge1;
			}
			edge1.prevInAEL = edge2.prevInAEL;
			if(edge1.prevInAEL != null) {
				edge1.prevInAEL.nextInAEL = edge1;
			}
			edge2.nextInAEL = next;
			if(edge2.nextInAEL != null) {
				edge2.nextInAEL.prevInAEL = edge2;
			}
			edge2.prevInAEL = prev;
			if(edge2.prevInAEL != null) {
				edge2.prevInAEL.nextInAEL = edge2;
			}
		}
		if(edge1.prevInAEL == null) {
			this.m_ActiveEdges = edge1;
		} else if(edge2.prevInAEL == null) {
			this.m_ActiveEdges = edge2;
		}
	}
	,SwapPositionsInSEL: function(edge1,edge2) {
		if(edge1.nextInSEL == null && edge1.prevInSEL == null) {
			return;
		}
		if(edge2.nextInSEL == null && edge2.prevInSEL == null) {
			return;
		}
		if(edge1.nextInSEL == edge2) {
			var next = edge2.nextInSEL;
			if(next != null) {
				next.prevInSEL = edge1;
			}
			var prev = edge1.prevInSEL;
			if(prev != null) {
				prev.nextInSEL = edge2;
			}
			edge2.prevInSEL = prev;
			edge2.nextInSEL = edge1;
			edge1.prevInSEL = edge2;
			edge1.nextInSEL = next;
		} else if(edge2.nextInSEL == edge1) {
			var next = edge1.nextInSEL;
			if(next != null) {
				next.prevInSEL = edge2;
			}
			var prev = edge2.prevInSEL;
			if(prev != null) {
				prev.nextInSEL = edge1;
			}
			edge1.prevInSEL = prev;
			edge1.nextInSEL = edge2;
			edge2.prevInSEL = edge1;
			edge2.nextInSEL = next;
		} else {
			var next = edge1.nextInSEL;
			var prev = edge1.prevInSEL;
			edge1.nextInSEL = edge2.nextInSEL;
			if(edge1.nextInSEL != null) {
				edge1.nextInSEL.prevInSEL = edge1;
			}
			edge1.prevInSEL = edge2.prevInSEL;
			if(edge1.prevInSEL != null) {
				edge1.prevInSEL.nextInSEL = edge1;
			}
			edge2.nextInSEL = next;
			if(edge2.nextInSEL != null) {
				edge2.nextInSEL.prevInSEL = edge2;
			}
			edge2.prevInSEL = prev;
			if(edge2.prevInSEL != null) {
				edge2.prevInSEL.nextInSEL = edge2;
			}
		}
		if(edge1.prevInSEL == null) {
			this.m_SortedEdges = edge1;
		} else if(edge2.prevInSEL == null) {
			this.m_SortedEdges = edge2;
		}
	}
	,AddLocalMaxPoly: function(e1,e2,pt) {
		this.AddOutPt(e1,pt);
		if(e2.windDelta == 0) {
			this.AddOutPt(e2,pt);
		}
		if(e1.outIdx == e2.outIdx) {
			e1.outIdx = -1;
			e2.outIdx = -1;
		} else if(e1.outIdx < e2.outIdx) {
			this.AppendPolygon(e1,e2);
		} else {
			this.AppendPolygon(e2,e1);
		}
	}
	,AddLocalMinPoly: function(e1,e2,pt) {
		var result;
		var e;
		var prevE;
		if(e2.deltaY == 0 || e1.dx > e2.dx) {
			result = this.AddOutPt(e1,pt);
			e2.outIdx = e1.outIdx;
			e1.side = hxd_clipper__$Clipper_EdgeSide.Left;
			e2.side = hxd_clipper__$Clipper_EdgeSide.Right;
			e = e1;
			if(e.prevInAEL == e2) {
				prevE = e2.prevInAEL;
			} else {
				prevE = e.prevInAEL;
			}
		} else {
			result = this.AddOutPt(e2,pt);
			e1.outIdx = e2.outIdx;
			e1.side = hxd_clipper__$Clipper_EdgeSide.Right;
			e2.side = hxd_clipper__$Clipper_EdgeSide.Left;
			e = e2;
			if(e.prevInAEL == e1) {
				prevE = e1.prevInAEL;
			} else {
				prevE = e.prevInAEL;
			}
		}
		var tmp;
		if(prevE != null && prevE.outIdx >= 0) {
			var currentY = pt.y;
			var tmp1;
			if(currentY == prevE.topY) {
				tmp1 = prevE.topX;
			} else {
				var value = prevE.dx * (currentY - prevE.botY);
				tmp1 = prevE.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			var currentY = pt.y;
			var tmp2;
			if(currentY == e.topY) {
				tmp2 = e.topX;
			} else {
				var value = e.dx * (currentY - e.botY);
				tmp2 = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			tmp = tmp1 == tmp2;
		} else {
			tmp = false;
		}
		if(tmp && e.deltaY * prevE.deltaX == e.deltaX * prevE.deltaY && e.windDelta != 0 && prevE.windDelta != 0) {
			var out = this.AddOutPt(prevE,pt);
			this.AddJoin(result,out,new h2d_col_IPoint(e.topX,e.topY));
		}
		return result;
	}
	,CreateOutRec: function() {
		var result = new hxd_clipper__$Clipper_OutRec();
		result.idx = -1;
		result.isHole = false;
		result.firstLeft = null;
		result.pts = null;
		result.bottomPt = null;
		result.polyNode = null;
		this.m_PolyOuts.push(result);
		result.idx = this.m_PolyOuts.length - 1;
		return result;
	}
	,AddOutPt: function(e,pt) {
		var ToFront = e.side == hxd_clipper__$Clipper_EdgeSide.Left;
		if(e.outIdx < 0) {
			var outRec = this.CreateOutRec();
			var op = new hxd_clipper__$Clipper_OutPt();
			outRec.pts = op;
			op.idx = outRec.idx;
			op.pt = new h2d_col_IPoint(pt.x,pt.y);
			op.next = op;
			op.prev = op;
			this.SetHoleState(e,outRec);
			e.outIdx = outRec.idx;
			return op;
		} else {
			var outRec = this.m_PolyOuts[e.outIdx];
			var op = outRec.pts;
			var tmp;
			if(ToFront) {
				var pt2 = op.pt;
				tmp = pt.x == pt2.x && pt.y == pt2.y;
			} else {
				tmp = false;
			}
			if(tmp) {
				return op;
			} else {
				var tmp;
				if(!ToFront) {
					var pt2 = op.prev.pt;
					tmp = pt.x == pt2.x && pt.y == pt2.y;
				} else {
					tmp = false;
				}
				if(tmp) {
					return op.prev;
				}
			}
			var op2 = new hxd_clipper__$Clipper_OutPt();
			op2.idx = outRec.idx;
			op2.pt = new h2d_col_IPoint(pt.x,pt.y);
			op2.next = op;
			op2.prev = op.prev;
			op2.prev.next = op2;
			op.prev = op2;
			if(ToFront) {
				outRec.pts = op2;
			}
			return op2;
		}
	}
	,HorzSegmentsOverlap: function(seg1a,seg1b,seg2a,seg2b) {
		if(seg1a > seg1b) {
			var tmp = seg1a;
			seg1a = seg1b;
			seg1b = tmp;
		}
		if(seg2a > seg2b) {
			var tmp = seg2a;
			seg2a = seg2b;
			seg2b = tmp;
		}
		if(seg1a < seg2b) {
			return seg2a < seg1b;
		} else {
			return false;
		}
	}
	,SetHoleState: function(e,outRec) {
		var isHole = false;
		var e2 = e.prevInAEL;
		while(e2 != null) {
			if(e2.outIdx >= 0 && e2.windDelta != 0) {
				isHole = !isHole;
				if(outRec.firstLeft == null) {
					outRec.firstLeft = this.m_PolyOuts[e2.outIdx];
				}
			}
			e2 = e2.prevInAEL;
		}
		if(isHole) {
			outRec.isHole = true;
		}
	}
	,GetDx: function(pt1,pt2) {
		if(pt1.y == pt2.y) {
			return -9007199254740992.;
		} else {
			return (pt2.x - pt1.x) / (pt2.y - pt1.y);
		}
	}
	,FirstIsBottomPt: function(btmPt1,btmPt2) {
		var p = btmPt1.prev;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt1.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt1)) {
				break;
			}
			p = p.prev;
		}
		var f = this.GetDx(btmPt1.pt,p.pt);
		var dx1p = f < 0 ? -f : f;
		p = btmPt1.next;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt1.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt1)) {
				break;
			}
			p = p.next;
		}
		var f = this.GetDx(btmPt1.pt,p.pt);
		var dx1n = f < 0 ? -f : f;
		p = btmPt2.prev;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt2.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt2)) {
				break;
			}
			p = p.prev;
		}
		var f = this.GetDx(btmPt2.pt,p.pt);
		var dx2p = f < 0 ? -f : f;
		p = btmPt2.next;
		while(true) {
			var pt1 = p.pt;
			var pt2 = btmPt2.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y && p != btmPt2)) {
				break;
			}
			p = p.next;
		}
		var f = this.GetDx(btmPt2.pt,p.pt);
		var dx2n = f < 0 ? -f : f;
		if(!(dx1p >= dx2p && dx1p >= dx2n)) {
			if(dx1n >= dx2p) {
				return dx1n >= dx2n;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,GetBottomPt: function(pp) {
		var dups = null;
		var p = pp.next;
		while(p != pp) {
			if(p.pt.y > pp.pt.y) {
				pp = p;
				dups = null;
			} else if(p.pt.y == pp.pt.y && p.pt.x <= pp.pt.x) {
				if(p.pt.x < pp.pt.x) {
					dups = null;
					pp = p;
				} else if(p.next != pp && p.prev != pp) {
					dups = p;
				}
			}
			p = p.next;
		}
		if(dups != null) {
			var n = 0;
			while(dups != p) {
				if(!this.FirstIsBottomPt(p,dups)) {
					pp = dups;
				}
				dups = dups.next;
				while(true) {
					var pt1 = dups.pt;
					var pt2 = pp.pt;
					if(pt1.x == pt2.x && pt1.y == pt2.y) {
						break;
					}
					dups = dups.next;
				}
			}
		}
		return pp;
	}
	,GetLowermostRec: function(outRec1,outRec2) {
		if(outRec1.bottomPt == null) {
			outRec1.bottomPt = this.GetBottomPt(outRec1.pts);
		}
		if(outRec2.bottomPt == null) {
			outRec2.bottomPt = this.GetBottomPt(outRec2.pts);
		}
		var bPt1 = outRec1.bottomPt;
		var bPt2 = outRec2.bottomPt;
		if(bPt1.pt.y > bPt2.pt.y) {
			return outRec1;
		} else if(bPt1.pt.y < bPt2.pt.y) {
			return outRec2;
		} else if(bPt1.pt.x < bPt2.pt.x) {
			return outRec1;
		} else if(bPt1.pt.x > bPt2.pt.x) {
			return outRec2;
		} else if(bPt1.next == bPt1) {
			return outRec2;
		} else if(bPt2.next == bPt2) {
			return outRec1;
		} else if(this.FirstIsBottomPt(bPt1,bPt2)) {
			return outRec1;
		} else {
			return outRec2;
		}
	}
	,Param1RightOfParam2: function(outRec1,outRec2) {
		do {
			outRec1 = outRec1.firstLeft;
			if(outRec1 == outRec2) {
				return true;
			}
		} while(outRec1 != null);
		return false;
	}
	,GetOutRec: function(idx) {
		var outrec = this.m_PolyOuts[idx];
		while(outrec != this.m_PolyOuts[outrec.idx]) outrec = this.m_PolyOuts[outrec.idx];
		return outrec;
	}
	,AppendPolygon: function(e1,e2) {
		var outRec1 = this.m_PolyOuts[e1.outIdx];
		var outRec2 = this.m_PolyOuts[e2.outIdx];
		var holeStateRec;
		if(this.Param1RightOfParam2(outRec1,outRec2)) {
			holeStateRec = outRec2;
		} else if(this.Param1RightOfParam2(outRec2,outRec1)) {
			holeStateRec = outRec1;
		} else {
			holeStateRec = this.GetLowermostRec(outRec1,outRec2);
		}
		var p1_lft = outRec1.pts;
		var p1_rt = p1_lft.prev;
		var p2_lft = outRec2.pts;
		var p2_rt = p2_lft.prev;
		var side;
		if(e1.side == hxd_clipper__$Clipper_EdgeSide.Left) {
			if(e2.side == hxd_clipper__$Clipper_EdgeSide.Left) {
				this.ReversePolyPtLinks(p2_lft);
				p2_lft.next = p1_lft;
				p1_lft.prev = p2_lft;
				p1_rt.next = p2_rt;
				p2_rt.prev = p1_rt;
				outRec1.pts = p2_rt;
			} else {
				p2_rt.next = p1_lft;
				p1_lft.prev = p2_rt;
				p2_lft.prev = p1_rt;
				p1_rt.next = p2_lft;
				outRec1.pts = p2_lft;
			}
			side = hxd_clipper__$Clipper_EdgeSide.Left;
		} else {
			if(e2.side == hxd_clipper__$Clipper_EdgeSide.Right) {
				this.ReversePolyPtLinks(p2_lft);
				p1_rt.next = p2_rt;
				p2_rt.prev = p1_rt;
				p2_lft.next = p1_lft;
				p1_lft.prev = p2_lft;
			} else {
				p1_rt.next = p2_lft;
				p2_lft.prev = p1_rt;
				p1_lft.prev = p2_rt;
				p2_rt.next = p1_lft;
			}
			side = hxd_clipper__$Clipper_EdgeSide.Right;
		}
		outRec1.bottomPt = null;
		if(holeStateRec == outRec2) {
			if(outRec2.firstLeft != outRec1) {
				outRec1.firstLeft = outRec2.firstLeft;
			}
			outRec1.isHole = outRec2.isHole;
		}
		outRec2.pts = null;
		outRec2.bottomPt = null;
		outRec2.firstLeft = outRec1;
		var OKIdx = e1.outIdx;
		var ObsoleteIdx = e2.outIdx;
		e1.outIdx = -1;
		e2.outIdx = -1;
		var e = this.m_ActiveEdges;
		while(e != null) {
			if(e.outIdx == ObsoleteIdx) {
				e.outIdx = OKIdx;
				e.side = side;
				break;
			}
			e = e.nextInAEL;
		}
		outRec2.idx = outRec1.idx;
	}
	,ReversePolyPtLinks: function(pp) {
		if(pp == null) {
			return;
		}
		var pp2;
		var pp1 = pp;
		do {
			pp2 = pp1.next;
			pp1.next = pp1.prev;
			pp1.prev = pp2;
			pp1 = pp2;
		} while(pp1 != pp);
	}
	,SwapSides: function(edge1,edge2) {
		var side = edge1.side;
		edge1.side = edge2.side;
		edge2.side = side;
	}
	,SwapPolyIndexes: function(edge1,edge2) {
		var outIdx = edge1.outIdx;
		edge1.outIdx = edge2.outIdx;
		edge2.outIdx = outIdx;
	}
	,IntersectEdges: function(e1,e2,pt) {
		var e1Contributing = e1.outIdx >= 0;
		var e2Contributing = e2.outIdx >= 0;
		if(e1.polyType == e2.polyType) {
			if(e1.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd) {
				var oldE1WindCnt = e1.windCnt;
				e1.windCnt = e2.windCnt;
				e2.windCnt = oldE1WindCnt;
			} else {
				if(e1.windCnt + e2.windDelta == 0) {
					e1.windCnt = -e1.windCnt;
				} else {
					e1.windCnt += e2.windDelta;
				}
				if(e2.windCnt - e1.windDelta == 0) {
					e2.windCnt = -e2.windCnt;
				} else {
					e2.windCnt -= e1.windDelta;
				}
			}
		} else {
			if(!(e2.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)) {
				e1.windCnt2 += e2.windDelta;
			} else {
				e1.windCnt2 = e1.windCnt2 == 0 ? 1 : 0;
			}
			if(!(e1.polyType == hxd_clipper_PolyType.Subject ? this.m_SubjFillType == hxd_clipper_PolyFillType.EvenOdd : this.m_ClipFillType == hxd_clipper_PolyFillType.EvenOdd)) {
				e2.windCnt2 -= e1.windDelta;
			} else {
				e2.windCnt2 = e2.windCnt2 == 0 ? 1 : 0;
			}
		}
		var e1FillType;
		var e2FillType;
		var e1FillType2;
		var e2FillType2;
		if(e1.polyType == hxd_clipper_PolyType.Subject) {
			e1FillType = this.m_SubjFillType;
			e1FillType2 = this.m_ClipFillType;
		} else {
			e1FillType = this.m_ClipFillType;
			e1FillType2 = this.m_SubjFillType;
		}
		if(e2.polyType == hxd_clipper_PolyType.Subject) {
			e2FillType = this.m_SubjFillType;
			e2FillType2 = this.m_ClipFillType;
		} else {
			e2FillType = this.m_ClipFillType;
			e2FillType2 = this.m_SubjFillType;
		}
		var e1Wc;
		var e2Wc;
		switch(e1FillType._hx_index) {
		case 2:
			e1Wc = e1.windCnt;
			break;
		case 3:
			e1Wc = -e1.windCnt;
			break;
		default:
			var i = e1.windCnt;
			e1Wc = i < 0 ? -i : i;
		}
		switch(e2FillType._hx_index) {
		case 2:
			e2Wc = e2.windCnt;
			break;
		case 3:
			e2Wc = -e2.windCnt;
			break;
		default:
			var i = e2.windCnt;
			e2Wc = i < 0 ? -i : i;
		}
		if(e1Contributing && e2Contributing) {
			if(e1Wc != 0 && e1Wc != 1 || e2Wc != 0 && e2Wc != 1 || e1.polyType != e2.polyType && this.m_ClipType != hxd_clipper_ClipType.Xor) {
				this.AddLocalMaxPoly(e1,e2,pt);
			} else {
				this.AddOutPt(e1,pt);
				this.AddOutPt(e2,pt);
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
				this.SwapPolyIndexes(e1,e2);
			}
		} else if(e1Contributing) {
			if(e2Wc == 0 || e2Wc == 1) {
				this.AddOutPt(e1,pt);
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
				this.SwapPolyIndexes(e1,e2);
			}
		} else if(e2Contributing) {
			if(e1Wc == 0 || e1Wc == 1) {
				this.AddOutPt(e2,pt);
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
				this.SwapPolyIndexes(e1,e2);
			}
		} else if((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)) {
			var e1Wc2;
			var e2Wc2;
			switch(e1FillType2._hx_index) {
			case 2:
				e1Wc2 = e1.windCnt2;
				break;
			case 3:
				e1Wc2 = -e1.windCnt2;
				break;
			default:
				var i = e1.windCnt2;
				e1Wc2 = i < 0 ? -i : i;
			}
			switch(e2FillType2._hx_index) {
			case 2:
				e2Wc2 = e2.windCnt2;
				break;
			case 3:
				e2Wc2 = -e2.windCnt2;
				break;
			default:
				var i = e2.windCnt2;
				e2Wc2 = i < 0 ? -i : i;
			}
			if(e1.polyType != e2.polyType) {
				this.AddLocalMinPoly(e1,e2,pt);
			} else if(e1Wc == 1 && e2Wc == 1) {
				switch(this.m_ClipType._hx_index) {
				case 0:
					if(e1Wc2 > 0 && e2Wc2 > 0) {
						this.AddLocalMinPoly(e1,e2,pt);
					}
					break;
				case 1:
					if(e1Wc2 <= 0 && e2Wc2 <= 0) {
						this.AddLocalMinPoly(e1,e2,pt);
					}
					break;
				case 2:
					if(e1.polyType == hxd_clipper_PolyType.Clip && e1Wc2 > 0 && e2Wc2 > 0 || e1.polyType == hxd_clipper_PolyType.Subject && e1Wc2 <= 0 && e2Wc2 <= 0) {
						this.AddLocalMinPoly(e1,e2,pt);
					}
					break;
				case 3:
					this.AddLocalMinPoly(e1,e2,pt);
					break;
				}
			} else {
				var side = e1.side;
				e1.side = e2.side;
				e2.side = side;
			}
		}
	}
	,DeleteFromAEL: function(e) {
		var AelPrev = e.prevInAEL;
		var AelNext = e.nextInAEL;
		if(AelPrev == null && AelNext == null && e != this.m_ActiveEdges) {
			return;
		}
		if(AelPrev != null) {
			AelPrev.nextInAEL = AelNext;
		} else {
			this.m_ActiveEdges = AelNext;
		}
		if(AelNext != null) {
			AelNext.prevInAEL = AelPrev;
		}
		e.nextInAEL = null;
		e.prevInAEL = null;
	}
	,DeleteFromSEL: function(e) {
		var SelPrev = e.prevInSEL;
		var SelNext = e.nextInSEL;
		if(SelPrev == null && SelNext == null && e != this.m_SortedEdges) {
			return;
		}
		if(SelPrev != null) {
			SelPrev.nextInSEL = SelNext;
		} else {
			this.m_SortedEdges = SelNext;
		}
		if(SelNext != null) {
			SelNext.prevInSEL = SelPrev;
		}
		e.nextInSEL = null;
		e.prevInSEL = null;
	}
	,UpdateEdgeIntoAEL: function(e) {
		if(e.nextInLML == null) {
			throw haxe_Exception.thrown("UpdateEdgeIntoAEL: invalid call");
		}
		var AelPrev = e.prevInAEL;
		var AelNext = e.nextInAEL;
		e.nextInLML.outIdx = e.outIdx;
		if(AelPrev != null) {
			AelPrev.nextInAEL = e.nextInLML;
		} else {
			this.m_ActiveEdges = e.nextInLML;
		}
		if(AelNext != null) {
			AelNext.prevInAEL = e.nextInLML;
		}
		e.nextInLML.side = e.side;
		e.nextInLML.windDelta = e.windDelta;
		e.nextInLML.windCnt = e.windCnt;
		e.nextInLML.windCnt2 = e.windCnt2;
		e = e.nextInLML;
		e.currX = e.botX;
		e.currY = e.botY;
		e.prevInAEL = AelPrev;
		e.nextInAEL = AelNext;
		if(e.deltaY != 0) {
			this.InsertScanbeam(e.topY);
		}
		return e;
	}
	,GetHorzDirection: function(HorzEdge) {
		if(HorzEdge.botX < HorzEdge.topX) {
			return { left : HorzEdge.botX, right : HorzEdge.topX, dir : hxd_clipper__$Clipper_Direction.LeftToRight};
		} else {
			return { left : HorzEdge.topX, right : HorzEdge.botX, dir : hxd_clipper__$Clipper_Direction.RightToLeft};
		}
	}
	,ProcessHorizontals: function(isTopOfScanbeam) {
		var horzEdge = this.m_SortedEdges;
		while(horzEdge != null) {
			this.DeleteFromSEL(horzEdge);
			this.ProcessHorizontal(horzEdge,isTopOfScanbeam);
			horzEdge = this.m_SortedEdges;
		}
	}
	,ProcessHorizontal: function(horzEdge,isTopOfScanbeam) {
		var res = this.GetHorzDirection(horzEdge);
		var dir = res.dir;
		var horzLeft = res.left;
		var horzRight = res.right;
		var eLastHorz = horzEdge;
		var eMaxPair = null;
		while(eLastHorz.nextInLML != null && eLastHorz.nextInLML.deltaY == 0) eLastHorz = eLastHorz.nextInLML;
		if(eLastHorz.nextInLML == null) {
			eMaxPair = this.GetMaximaPair(eLastHorz);
		}
		while(true) {
			var IsLastHorz = horzEdge == eLastHorz;
			var e = dir == hxd_clipper__$Clipper_Direction.LeftToRight ? horzEdge.nextInAEL : horzEdge.prevInAEL;
			while(e != null) {
				if(e.currX == horzEdge.topX && horzEdge.nextInLML != null && e.dx < horzEdge.nextInLML.dx) {
					break;
				}
				var eNext = dir == hxd_clipper__$Clipper_Direction.LeftToRight ? e.nextInAEL : e.prevInAEL;
				if(dir == hxd_clipper__$Clipper_Direction.LeftToRight && e.currX <= horzRight || dir == hxd_clipper__$Clipper_Direction.RightToLeft && e.currX >= horzLeft) {
					if(e == eMaxPair && IsLastHorz) {
						if(horzEdge.outIdx >= 0) {
							var op1 = this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
							var eNextHorz = this.m_SortedEdges;
							while(eNextHorz != null) {
								if(eNextHorz.outIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.botX,horzEdge.topX,eNextHorz.botX,eNextHorz.topX)) {
									var op2 = this.AddOutPt(eNextHorz,new h2d_col_IPoint(eNextHorz.botX,eNextHorz.botY));
									this.AddJoin(op2,op1,new h2d_col_IPoint(eNextHorz.topX,eNextHorz.topY));
								}
								eNextHorz = eNextHorz.nextInSEL;
							}
							this.AddGhostJoin(op1,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
							this.AddLocalMaxPoly(horzEdge,eMaxPair,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
						}
						this.DeleteFromAEL(horzEdge);
						this.DeleteFromAEL(eMaxPair);
						return;
					} else if(dir == hxd_clipper__$Clipper_Direction.LeftToRight) {
						var Pt = new h2d_col_IPoint(e.currX,horzEdge.currY);
						this.IntersectEdges(horzEdge,e,Pt);
					} else {
						var Pt1 = new h2d_col_IPoint(e.currX,horzEdge.currY);
						this.IntersectEdges(e,horzEdge,Pt1);
					}
					this.SwapPositionsInAEL(horzEdge,e);
				} else if(dir == hxd_clipper__$Clipper_Direction.LeftToRight && e.currX >= horzRight || dir == hxd_clipper__$Clipper_Direction.RightToLeft && e.currX <= horzLeft) {
					break;
				}
				e = eNext;
			}
			if(horzEdge.nextInLML != null && horzEdge.nextInLML.deltaY == 0) {
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
				if(horzEdge.outIdx >= 0) {
					this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
				}
				var out = this.GetHorzDirection(horzEdge);
				dir = out.dir;
				horzLeft = out.left;
				horzRight = out.right;
			} else {
				break;
			}
		}
		if(horzEdge.nextInLML != null) {
			if(horzEdge.outIdx >= 0) {
				var op1 = this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
				if(isTopOfScanbeam) {
					this.AddGhostJoin(op1,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
				}
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
				if(horzEdge.windDelta == 0) {
					return;
				}
				var ePrev = horzEdge.prevInAEL;
				var eNext = horzEdge.nextInAEL;
				if(ePrev != null && ePrev.currX == horzEdge.botX && ePrev.currY == horzEdge.botY && ePrev.windDelta != 0 && (ePrev.outIdx >= 0 && ePrev.currY > ePrev.topY && horzEdge.deltaY * ePrev.deltaX == horzEdge.deltaX * ePrev.deltaY)) {
					var op2 = this.AddOutPt(ePrev,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
					this.AddJoin(op1,op2,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
				} else if(eNext != null && eNext.currX == horzEdge.botX && eNext.currY == horzEdge.botY && eNext.windDelta != 0 && eNext.outIdx >= 0 && eNext.currY > eNext.topY && horzEdge.deltaY * eNext.deltaX == horzEdge.deltaX * eNext.deltaY) {
					var op2 = this.AddOutPt(eNext,new h2d_col_IPoint(horzEdge.botX,horzEdge.botY));
					this.AddJoin(op1,op2,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
				}
			} else {
				horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
			}
		} else {
			if(horzEdge.outIdx >= 0) {
				this.AddOutPt(horzEdge,new h2d_col_IPoint(horzEdge.topX,horzEdge.topY));
			}
			this.DeleteFromAEL(horzEdge);
		}
	}
	,GetNextInAEL: function(e,dir) {
		if(dir == hxd_clipper__$Clipper_Direction.LeftToRight) {
			return e.nextInAEL;
		} else {
			return e.prevInAEL;
		}
	}
	,IsMinima: function(e) {
		if(e != null && e.prev.nextInLML != e) {
			return e.next.nextInLML != e;
		} else {
			return false;
		}
	}
	,IsMaxima: function(e,y) {
		if(e != null && e.topY == y) {
			return e.nextInLML == null;
		} else {
			return false;
		}
	}
	,IsIntermediate: function(e,y) {
		if(e.topY == y) {
			return e.nextInLML != null;
		} else {
			return false;
		}
	}
	,GetMaximaPair: function(e) {
		var result = null;
		if(e.next.topX == e.topX && e.next.topY == e.topY && e.next.nextInLML == null) {
			result = e.next;
		} else if(e.prev.topX == e.topX && e.prev.topY == e.topY && e.prev.nextInLML == null) {
			result = e.prev;
		}
		if(result != null && (result.outIdx == -2 || result.nextInAEL == result.prevInAEL && result.deltaY != 0)) {
			return null;
		}
		return result;
	}
	,ProcessIntersections: function(topY) {
		if(this.m_ActiveEdges == null) {
			return true;
		}
		this.BuildIntersectList(topY);
		if(this.m_IntersectList.length == 0) {
			return true;
		}
		if(this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) {
			this.ProcessIntersectList();
		} else {
			return false;
		}
		this.m_SortedEdges = null;
		return true;
	}
	,BuildIntersectList: function(topY) {
		if(this.m_ActiveEdges == null) {
			return;
		}
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while(e != null) {
			e.prevInSEL = e.prevInAEL;
			e.nextInSEL = e.nextInAEL;
			var tmp;
			if(topY == e.topY) {
				tmp = e.topX;
			} else {
				var value = e.dx * (topY - e.botY);
				tmp = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			e.currX = tmp;
			e = e.nextInAEL;
		}
		var isModified = true;
		while(isModified && this.m_SortedEdges != null) {
			isModified = false;
			e = this.m_SortedEdges;
			while(e.nextInSEL != null) {
				var eNext = e.nextInSEL;
				var pt;
				if(e.currX > eNext.currX) {
					var ipx;
					var ipy;
					var b1;
					var b2;
					if(e.dx == eNext.dx) {
						ipy = e.currY;
						if(ipy == e.topY) {
							ipx = e.topX;
						} else {
							var value = e.dx * (ipy - e.botY);
							ipx = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
						}
						pt = new h2d_col_IPoint(ipx,ipy);
					} else {
						if(e.deltaX == 0) {
							ipx = e.botX;
							if(eNext.deltaY == 0) {
								ipy = eNext.botY;
							} else {
								b2 = eNext.botY - eNext.botX / eNext.dx;
								var value1 = ipx / eNext.dx + b2;
								ipy = value1 < 0 ? value1 - 0.5 | 0 : value1 + 0.5 | 0;
							}
						} else if(eNext.deltaX == 0) {
							ipx = eNext.botX;
							if(e.deltaY == 0) {
								ipy = e.botY;
							} else {
								b1 = e.botY - e.botX / e.dx;
								var value2 = ipx / e.dx + b1;
								ipy = value2 < 0 ? value2 - 0.5 | 0 : value2 + 0.5 | 0;
							}
						} else {
							b1 = e.botX - e.botY * e.dx;
							b2 = eNext.botX - eNext.botY * eNext.dx;
							var q = (b2 - b1) / (e.dx - eNext.dx);
							ipy = q < 0 ? q - 0.5 | 0 : q + 0.5 | 0;
							var f = e.dx;
							var f1 = eNext.dx;
							if((f < 0 ? -f : f) < (f1 < 0 ? -f1 : f1)) {
								var value3 = e.dx * q + b1;
								ipx = value3 < 0 ? value3 - 0.5 | 0 : value3 + 0.5 | 0;
							} else {
								var value4 = eNext.dx * q + b2;
								ipx = value4 < 0 ? value4 - 0.5 | 0 : value4 + 0.5 | 0;
							}
						}
						if(ipy < e.topY || ipy < eNext.topY) {
							if(e.topY > eNext.topY) {
								ipy = e.topY;
							} else {
								ipy = eNext.topY;
							}
							var f2 = e.dx;
							var f3 = eNext.dx;
							if((f2 < 0 ? -f2 : f2) < (f3 < 0 ? -f3 : f3)) {
								if(ipy == e.topY) {
									ipx = e.topX;
								} else {
									var value5 = e.dx * (ipy - e.botY);
									ipx = e.botX + (value5 < 0 ? value5 - 0.5 | 0 : value5 + 0.5 | 0);
								}
							} else if(ipy == eNext.topY) {
								ipx = eNext.topX;
							} else {
								var value6 = eNext.dx * (ipy - eNext.botY);
								ipx = eNext.botX + (value6 < 0 ? value6 - 0.5 | 0 : value6 + 0.5 | 0);
							}
						}
						if(ipy > e.currY) {
							ipy = e.currY;
							var f4 = e.dx;
							var f5 = eNext.dx;
							if((f4 < 0 ? -f4 : f4) > (f5 < 0 ? -f5 : f5)) {
								if(ipy == eNext.topY) {
									ipx = eNext.topX;
								} else {
									var value7 = eNext.dx * (ipy - eNext.botY);
									ipx = eNext.botX + (value7 < 0 ? value7 - 0.5 | 0 : value7 + 0.5 | 0);
								}
							} else if(ipy == e.topY) {
								ipx = e.topX;
							} else {
								var value8 = e.dx * (ipy - e.botY);
								ipx = e.botX + (value8 < 0 ? value8 - 0.5 | 0 : value8 + 0.5 | 0);
							}
						}
						pt = new h2d_col_IPoint(ipx,ipy);
					}
					var newNode = new hxd_clipper__$Clipper_IntersectNode();
					newNode.edge1 = e;
					newNode.edge2 = eNext;
					newNode.pt = pt;
					this.m_IntersectList.push(newNode);
					this.SwapPositionsInSEL(e,eNext);
					isModified = true;
				} else {
					e = eNext;
				}
			}
			if(e.prevInSEL != null) {
				e.prevInSEL.nextInSEL = null;
			} else {
				break;
			}
		}
		this.m_SortedEdges = null;
	}
	,EdgesAdjacent: function(inode) {
		if(inode.edge1.nextInSEL != inode.edge2) {
			return inode.edge1.prevInSEL == inode.edge2;
		} else {
			return true;
		}
	}
	,IntersectNodeSort: function(node1,node2) {
		return node2.pt.y - node1.pt.y | 0;
	}
	,FixupIntersectionOrder: function() {
		this.m_IntersectList.sort(hxd_clipper_Clipper.compareY);
		var e = this.m_ActiveEdges;
		this.m_SortedEdges = e;
		while(e != null) {
			e.prevInSEL = e.prevInAEL;
			e.nextInSEL = e.nextInAEL;
			e = e.nextInAEL;
		}
		var cnt = this.m_IntersectList.length;
		var _g = 0;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			var inode = this.m_IntersectList[i];
			if(!(inode.edge1.nextInSEL == inode.edge2 || inode.edge1.prevInSEL == inode.edge2)) {
				var j = i + 1;
				while(true) {
					var tmp;
					if(j < cnt) {
						var inode1 = this.m_IntersectList[j];
						tmp = !(inode1.edge1.nextInSEL == inode1.edge2 || inode1.edge1.prevInSEL == inode1.edge2);
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					++j;
				}
				if(j == cnt) {
					return false;
				}
				var tmp1 = this.m_IntersectList[i];
				this.m_IntersectList[i] = this.m_IntersectList[j];
				this.m_IntersectList[j] = tmp1;
			}
			this.SwapPositionsInSEL(this.m_IntersectList[i].edge1,this.m_IntersectList[i].edge2);
		}
		return true;
	}
	,ProcessIntersectList: function() {
		var _g = 0;
		var _g1 = this.m_IntersectList.length;
		while(_g < _g1) {
			var i = _g++;
			var iNode = this.m_IntersectList[i];
			this.IntersectEdges(iNode.edge1,iNode.edge2,iNode.pt);
			this.SwapPositionsInAEL(iNode.edge1,iNode.edge2);
		}
		this.m_IntersectList = [];
	}
	,Round: function(value) {
		if(value < 0) {
			return value - 0.5 | 0;
		} else {
			return value + 0.5 | 0;
		}
	}
	,TopX: function(edge,currentY) {
		if(currentY == edge.topY) {
			return edge.topX;
		}
		var value = edge.dx * (currentY - edge.botY);
		return edge.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
	}
	,IntersectPoint: function(edge1,edge2) {
		var ipx;
		var ipy;
		var b1;
		var b2;
		if(edge1.dx == edge2.dx) {
			ipy = edge1.currY;
			if(ipy == edge1.topY) {
				ipx = edge1.topX;
			} else {
				var value = edge1.dx * (ipy - edge1.botY);
				ipx = edge1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
			return new h2d_col_IPoint(ipx,ipy);
		}
		if(edge1.deltaX == 0) {
			ipx = edge1.botX;
			if(edge2.deltaY == 0) {
				ipy = edge2.botY;
			} else {
				b2 = edge2.botY - edge2.botX / edge2.dx;
				var value = ipx / edge2.dx + b2;
				ipy = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			}
		} else if(edge2.deltaX == 0) {
			ipx = edge2.botX;
			if(edge1.deltaY == 0) {
				ipy = edge1.botY;
			} else {
				b1 = edge1.botY - edge1.botX / edge1.dx;
				var value = ipx / edge1.dx + b1;
				ipy = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			}
		} else {
			b1 = edge1.botX - edge1.botY * edge1.dx;
			b2 = edge2.botX - edge2.botY * edge2.dx;
			var q = (b2 - b1) / (edge1.dx - edge2.dx);
			ipy = q < 0 ? q - 0.5 | 0 : q + 0.5 | 0;
			var f = edge1.dx;
			var f1 = edge2.dx;
			if((f < 0 ? -f : f) < (f1 < 0 ? -f1 : f1)) {
				var value = edge1.dx * q + b1;
				ipx = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			} else {
				var value = edge2.dx * q + b2;
				ipx = value < 0 ? value - 0.5 | 0 : value + 0.5 | 0;
			}
		}
		if(ipy < edge1.topY || ipy < edge2.topY) {
			if(edge1.topY > edge2.topY) {
				ipy = edge1.topY;
			} else {
				ipy = edge2.topY;
			}
			var f = edge1.dx;
			var f1 = edge2.dx;
			if((f < 0 ? -f : f) < (f1 < 0 ? -f1 : f1)) {
				if(ipy == edge1.topY) {
					ipx = edge1.topX;
				} else {
					var value = edge1.dx * (ipy - edge1.botY);
					ipx = edge1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
			} else if(ipy == edge2.topY) {
				ipx = edge2.topX;
			} else {
				var value = edge2.dx * (ipy - edge2.botY);
				ipx = edge2.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
		}
		if(ipy > edge1.currY) {
			ipy = edge1.currY;
			var f = edge1.dx;
			var f1 = edge2.dx;
			if((f < 0 ? -f : f) > (f1 < 0 ? -f1 : f1)) {
				if(ipy == edge2.topY) {
					ipx = edge2.topX;
				} else {
					var value = edge2.dx * (ipy - edge2.botY);
					ipx = edge2.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
				}
			} else if(ipy == edge1.topY) {
				ipx = edge1.topX;
			} else {
				var value = edge1.dx * (ipy - edge1.botY);
				ipx = edge1.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
			}
		}
		return new h2d_col_IPoint(ipx,ipy);
	}
	,ProcessEdgesAtTopOfScanbeam: function(topY) {
		var e = this.m_ActiveEdges;
		while(e != null) {
			var IsMaximaEdge = e != null && e.topY == topY && e.nextInLML == null;
			if(IsMaximaEdge) {
				var eMaxPair = this.GetMaximaPair(e);
				IsMaximaEdge = eMaxPair == null || eMaxPair.deltaY != 0;
			}
			if(IsMaximaEdge) {
				var ePrev = e.prevInAEL;
				this.DoMaxima(e);
				if(ePrev == null) {
					e = this.m_ActiveEdges;
				} else {
					e = ePrev.nextInAEL;
				}
			} else {
				if(e.topY == topY && e.nextInLML != null && e.nextInLML.deltaY == 0) {
					e = this.UpdateEdgeIntoAEL(e);
					if(e.outIdx >= 0) {
						this.AddOutPt(e,new h2d_col_IPoint(e.botX,e.botY));
					}
					this.AddEdgeToSEL(e);
				} else {
					var tmp;
					if(topY == e.topY) {
						tmp = e.topX;
					} else {
						var value = e.dx * (topY - e.botY);
						tmp = e.botX + (value < 0 ? value - 0.5 | 0 : value + 0.5 | 0);
					}
					e.currX = tmp;
					e.currY = topY;
				}
				if(this.strictlySimple) {
					var ePrev1 = e.prevInAEL;
					if(e.outIdx >= 0 && e.windDelta != 0 && ePrev1 != null && ePrev1.outIdx >= 0 && ePrev1.currX == e.currX && ePrev1.windDelta != 0) {
						var ip = new h2d_col_IPoint(e.currX,e.currY);
						var op = this.AddOutPt(ePrev1,ip);
						var op2 = this.AddOutPt(e,ip);
						this.AddJoin(op,op2,ip);
					}
				}
				e = e.nextInAEL;
			}
		}
		this.ProcessHorizontals(true);
		e = this.m_ActiveEdges;
		while(e != null) {
			if(e.topY == topY && e.nextInLML != null) {
				var op = null;
				if(e.outIdx >= 0) {
					op = this.AddOutPt(e,new h2d_col_IPoint(e.topX,e.topY));
				}
				e = this.UpdateEdgeIntoAEL(e);
				var ePrev = e.prevInAEL;
				var eNext = e.nextInAEL;
				if(ePrev != null && ePrev.currX == e.botX && ePrev.currY == e.botY && op != null && ePrev.outIdx >= 0 && ePrev.currY > ePrev.topY && e.deltaY * ePrev.deltaX == e.deltaX * ePrev.deltaY && e.windDelta != 0 && ePrev.windDelta != 0) {
					var op2 = this.AddOutPt(ePrev,new h2d_col_IPoint(e.botX,e.botY));
					this.AddJoin(op,op2,new h2d_col_IPoint(e.topX,e.topY));
				} else if(eNext != null && eNext.currX == e.botX && eNext.currY == e.botY && op != null && eNext.outIdx >= 0 && eNext.currY > eNext.topY && e.deltaY * eNext.deltaX == e.deltaX * eNext.deltaY && e.windDelta != 0 && eNext.windDelta != 0) {
					var op21 = this.AddOutPt(eNext,new h2d_col_IPoint(e.botX,e.botY));
					this.AddJoin(op,op21,new h2d_col_IPoint(e.topX,e.topY));
				}
			}
			e = e.nextInAEL;
		}
	}
	,DoMaxima: function(e) {
		var eMaxPair = this.GetMaximaPair(e);
		if(eMaxPair == null) {
			if(e.outIdx >= 0) {
				this.AddOutPt(e,new h2d_col_IPoint(e.topX,e.topY));
			}
			this.DeleteFromAEL(e);
			return;
		}
		var eNext = e.nextInAEL;
		while(eNext != null && eNext != eMaxPair) {
			this.IntersectEdges(e,eNext,new h2d_col_IPoint(e.topX,e.topY));
			this.SwapPositionsInAEL(e,eNext);
			eNext = e.nextInAEL;
		}
		if(e.outIdx == -1 && eMaxPair.outIdx == -1) {
			this.DeleteFromAEL(e);
			this.DeleteFromAEL(eMaxPair);
		} else if(e.outIdx >= 0 && eMaxPair.outIdx >= 0) {
			if(e.outIdx >= 0) {
				this.AddLocalMaxPoly(e,eMaxPair,new h2d_col_IPoint(e.topX,e.topY));
			}
			this.DeleteFromAEL(e);
			this.DeleteFromAEL(eMaxPair);
		} else {
			throw haxe_Exception.thrown("DoMaxima error");
		}
	}
	,reversePolygons: function(polys) {
		var _g_i = 0;
		var _g_a = polys;
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			h2d_col_IPolygon.reverse(p);
		}
	}
	,PointCount: function(pts) {
		if(pts == null) {
			return 0;
		}
		var result = 0;
		var p = pts;
		do {
			++result;
			p = p.next;
		} while(p != pts);
		return result;
	}
	,BuildResult: function() {
		var solution = [];
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts == null) {
				continue;
			}
			if(this.resultKind == hxd_clipper_ResultKind.NoHoles && outRec.isHole) {
				continue;
			}
			if(this.resultKind == hxd_clipper_ResultKind.HolesOnly && !outRec.isHole) {
				continue;
			}
			var p = outRec.pts.prev;
			var cnt = this.PointCount(p);
			if(cnt < 2) {
				continue;
			}
			var points = null;
			var pg = points == null ? [] : points;
			var _g2 = 0;
			var _g3 = cnt;
			while(_g2 < _g3) {
				var j = _g2++;
				pg.push(p.pt);
				p = p.prev;
			}
			solution.push(pg);
		}
		return solution;
	}
	,BuildResult2: function(polytree) {
		polytree.clear();
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			var cnt = this.PointCount(outRec.pts);
			if(cnt < 3) {
				continue;
			}
			this.FixHoleLinkage(outRec);
			var pn = new hxd_clipper__$Clipper_PolyNode();
			polytree.allPolys.push(pn);
			outRec.polyNode = pn;
			var op = outRec.pts.prev;
			var _g2 = 0;
			var _g3 = cnt;
			while(_g2 < _g3) {
				var j = _g2++;
				pn.polygon.push(op.pt);
				op = op.prev;
			}
		}
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.polyNode == null) {
				continue;
			} else if(outRec.firstLeft != null && outRec.firstLeft.polyNode != null) {
				outRec.firstLeft.polyNode.addChild(outRec.polyNode);
			} else {
				polytree.addChild(outRec.polyNode);
			}
		}
	}
	,FixupOutPolygon: function(outRec) {
		var lastOK = null;
		outRec.bottomPt = null;
		var pp = outRec.pts;
		while(true) {
			if(pp.prev == pp || pp.prev == pp.next) {
				outRec.pts = null;
				return;
			}
			var tmp;
			var tmp1;
			var pt1 = pp.pt;
			var pt2 = pp.next.pt;
			if(!(pt1.x == pt2.x && pt1.y == pt2.y)) {
				var pt11 = pp.pt;
				var pt21 = pp.prev.pt;
				tmp1 = pt11.x == pt21.x && pt11.y == pt21.y;
			} else {
				tmp1 = true;
			}
			if(!tmp1) {
				var pt12 = pp.prev.pt;
				var pt22 = pp.pt;
				var pt3 = pp.next.pt;
				tmp = (pt12.y - pt22.y) * (pt22.x - pt3.x) - (pt12.x - pt22.x) * (pt22.y - pt3.y) == 0 && (!this.preserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.prev.pt,pp.pt,pp.next.pt));
			} else {
				tmp = true;
			}
			if(tmp) {
				lastOK = null;
				var tmp2 = pp;
				pp.prev.next = pp.next;
				pp.next.prev = pp.prev;
				pp = pp.prev;
				tmp2 = null;
			} else if(pp == lastOK) {
				break;
			} else {
				if(lastOK == null) {
					lastOK = pp;
				}
				pp = pp.next;
			}
		}
		outRec.pts = pp;
	}
	,DupOutPt: function(outPt,InsertAfter) {
		var result = new hxd_clipper__$Clipper_OutPt();
		result.pt = outPt.pt;
		result.idx = outPt.idx;
		if(InsertAfter) {
			result.next = outPt.next;
			result.prev = outPt;
			outPt.next.prev = result;
			outPt.next = result;
		} else {
			result.prev = outPt.prev;
			result.next = outPt;
			outPt.prev.next = result;
			outPt.prev = result;
		}
		return result;
	}
	,GetOverlap: function(a1,a2,b1,b2) {
		var Left;
		var Right;
		if(a1 < a2) {
			if(b1 < b2) {
				Left = a1 < b1 ? b1 : a1;
				Right = a2 > b2 ? b2 : a2;
			} else {
				Left = a1 < b2 ? b2 : a1;
				Right = a2 > b1 ? b1 : a2;
			}
		} else if(b1 < b2) {
			Left = a2 < b1 ? b1 : a2;
			Right = a1 > b2 ? b2 : a1;
		} else {
			Left = a2 < b2 ? b2 : a2;
			Right = a1 > b1 ? b1 : a1;
		}
		return { left : Left, right : Right, done : Left < Right};
	}
	,JoinHorz: function(op1,op1b,op2,op2b,pt,DiscardLeft) {
		var Dir1 = op1.pt.x > op1b.pt.x ? hxd_clipper__$Clipper_Direction.RightToLeft : hxd_clipper__$Clipper_Direction.LeftToRight;
		var Dir2 = op2.pt.x > op2b.pt.x ? hxd_clipper__$Clipper_Direction.RightToLeft : hxd_clipper__$Clipper_Direction.LeftToRight;
		if(Dir1 == Dir2) {
			return false;
		}
		if(Dir1 == hxd_clipper__$Clipper_Direction.LeftToRight) {
			while(op1.next.pt.x <= pt.x && op1.next.pt.x >= op1.pt.x && op1.next.pt.y == pt.y) op1 = op1.next;
			if(DiscardLeft && op1.pt.x != pt.x) {
				op1 = op1.next;
			}
			op1b = this.DupOutPt(op1,!DiscardLeft);
			if(op1b.pt != pt) {
				op1 = op1b;
				op1.pt = pt;
				op1b = this.DupOutPt(op1,!DiscardLeft);
			}
		} else {
			while(op1.next.pt.x >= pt.x && op1.next.pt.x <= op1.pt.x && op1.next.pt.y == pt.y) op1 = op1.next;
			if(!DiscardLeft && op1.pt.x != pt.x) {
				op1 = op1.next;
			}
			op1b = this.DupOutPt(op1,DiscardLeft);
			if(op1b.pt != pt) {
				op1 = op1b;
				op1.pt = pt;
				op1b = this.DupOutPt(op1,DiscardLeft);
			}
		}
		if(Dir2 == hxd_clipper__$Clipper_Direction.LeftToRight) {
			while(op2.next.pt.x <= pt.x && op2.next.pt.x >= op2.pt.x && op2.next.pt.y == pt.y) op2 = op2.next;
			if(DiscardLeft && op2.pt.x != pt.x) {
				op2 = op2.next;
			}
			op2b = this.DupOutPt(op2,!DiscardLeft);
			if(op2b.pt != pt) {
				op2 = op2b;
				op2.pt = pt;
				op2b = this.DupOutPt(op2,!DiscardLeft);
			}
		} else {
			while(op2.next.pt.x >= pt.x && op2.next.pt.x <= op2.pt.x && op2.next.pt.y == pt.y) op2 = op2.next;
			if(!DiscardLeft && op2.pt.x != pt.x) {
				op2 = op2.next;
			}
			op2b = this.DupOutPt(op2,DiscardLeft);
			if(op2b.pt != pt) {
				op2 = op2b;
				op2.pt = pt;
				op2b = this.DupOutPt(op2,DiscardLeft);
			}
		}
		if(Dir1 == hxd_clipper__$Clipper_Direction.LeftToRight == DiscardLeft) {
			op1.prev = op2;
			op2.next = op1;
			op1b.next = op2b;
			op2b.prev = op1b;
		} else {
			op1.next = op2;
			op2.prev = op1;
			op1b.prev = op2b;
			op2b.next = op1b;
		}
		return true;
	}
	,JoinPoints: function(j,outRec1,outRec2) {
		var op1 = j.outPt1;
		var op1b;
		var op2 = j.outPt2;
		var op2b;
		var isHorizontal = j.outPt1.pt.y == j.offPt.y;
		var tmp;
		var tmp1;
		if(isHorizontal) {
			var pt1 = j.offPt;
			var pt2 = j.outPt1.pt;
			tmp1 = pt1.x == pt2.x && pt1.y == pt2.y;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			var pt1 = j.offPt;
			var pt2 = j.outPt2.pt;
			tmp = pt1.x == pt2.x && pt1.y == pt2.y;
		} else {
			tmp = false;
		}
		if(tmp) {
			if(outRec1 != outRec2) {
				return false;
			}
			op1b = j.outPt1.next;
			while(true) {
				var tmp;
				if(op1b != op1) {
					var pt1 = op1b.pt;
					var pt2 = j.offPt;
					tmp = pt1.x == pt2.x && pt1.y == pt2.y;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				op1b = op1b.next;
			}
			var reverse1 = op1b.pt.y > j.offPt.y;
			op2b = j.outPt2.next;
			while(true) {
				var tmp;
				if(op2b != op2) {
					var pt1 = op2b.pt;
					var pt2 = j.offPt;
					tmp = pt1.x == pt2.x && pt1.y == pt2.y;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				op2b = op2b.next;
			}
			var reverse2 = op2b.pt.y > j.offPt.y;
			if(reverse1 == reverse2) {
				return false;
			}
			if(reverse1) {
				op1b = this.DupOutPt(op1,false);
				op2b = this.DupOutPt(op2,true);
				op1.prev = op2;
				op2.next = op1;
				op1b.next = op2b;
				op2b.prev = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			} else {
				op1b = this.DupOutPt(op1,true);
				op2b = this.DupOutPt(op2,false);
				op1.next = op2;
				op2.prev = op1;
				op1b.prev = op2b;
				op2b.next = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			}
		} else if(isHorizontal) {
			op1b = op1;
			while(op1.prev.pt.y == op1.pt.y && op1.prev != op1b && op1.prev != op2) op1 = op1.prev;
			while(op1b.next.pt.y == op1b.pt.y && op1b.next != op1 && op1b.next != op2) op1b = op1b.next;
			if(op1b.next == op1 || op1b.next == op2) {
				return false;
			}
			op2b = op2;
			while(op2.prev.pt.y == op2.pt.y && op2.prev != op2b && op2.prev != op1b) op2 = op2.prev;
			while(op2b.next.pt.y == op2b.pt.y && op2b.next != op2 && op2b.next != op1) op2b = op2b.next;
			if(op2b.next == op2 || op2b.next == op1) {
				return false;
			}
			var out = this.GetOverlap(op1.pt.x,op1b.pt.x,op2.pt.x,op2b.pt.x);
			if(!out.done) {
				return false;
			}
			var Left = out.left;
			var Right = out.right;
			var Pt;
			var DiscardLeftSide;
			if(op1.pt.x >= Left && op1.pt.x <= Right) {
				Pt = op1.pt;
				DiscardLeftSide = op1.pt.x > op1b.pt.x;
			} else if(op2.pt.x >= Left && op2.pt.x <= Right) {
				Pt = op2.pt;
				DiscardLeftSide = op2.pt.x > op2b.pt.x;
			} else if(op1b.pt.x >= Left && op1b.pt.x <= Right) {
				Pt = op1b.pt;
				DiscardLeftSide = op1b.pt.x > op1.pt.x;
			} else {
				Pt = op2b.pt;
				DiscardLeftSide = op2b.pt.x > op2.pt.x;
			}
			j.outPt1 = op1;
			j.outPt2 = op2;
			return this.JoinHorz(op1,op1b,op2,op2b,Pt,DiscardLeftSide);
		} else {
			op1b = op1.next;
			while(true) {
				var pt1 = op1b.pt;
				var pt2 = op1.pt;
				if(!(pt1.x == pt2.x && pt1.y == pt2.y && op1b != op1)) {
					break;
				}
				op1b = op1b.next;
			}
			var Reverse1;
			if(op1b.pt.y <= op1.pt.y) {
				var pt1 = op1.pt;
				var pt2 = op1b.pt;
				var pt3 = j.offPt;
				Reverse1 = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
			} else {
				Reverse1 = true;
			}
			if(Reverse1) {
				op1b = op1.prev;
				while(true) {
					var pt1 = op1b.pt;
					var pt2 = op1.pt;
					if(!(pt1.x == pt2.x && pt1.y == pt2.y && op1b != op1)) {
						break;
					}
					op1b = op1b.prev;
				}
				var tmp;
				if(op1b.pt.y <= op1.pt.y) {
					var pt1 = op1.pt;
					var pt2 = op1b.pt;
					var pt3 = j.offPt;
					tmp = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
				} else {
					tmp = true;
				}
				if(tmp) {
					return false;
				}
			}
			op2b = op2.next;
			while(true) {
				var pt1 = op2b.pt;
				var pt2 = op2.pt;
				if(!(pt1.x == pt2.x && pt1.y == pt2.y && op2b != op2)) {
					break;
				}
				op2b = op2b.next;
			}
			var Reverse2;
			if(op2b.pt.y <= op2.pt.y) {
				var pt1 = op2.pt;
				var pt2 = op2b.pt;
				var pt3 = j.offPt;
				Reverse2 = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
			} else {
				Reverse2 = true;
			}
			if(Reverse2) {
				op2b = op2.prev;
				while(true) {
					var pt1 = op2b.pt;
					var pt2 = op2.pt;
					if(!(pt1.x == pt2.x && pt1.y == pt2.y && op2b != op2)) {
						break;
					}
					op2b = op2b.prev;
				}
				var tmp;
				if(op2b.pt.y <= op2.pt.y) {
					var pt1 = op2.pt;
					var pt2 = op2b.pt;
					var pt3 = j.offPt;
					tmp = (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) != 0;
				} else {
					tmp = true;
				}
				if(tmp) {
					return false;
				}
			}
			if(op1b == op1 || op2b == op2 || op1b == op2b || outRec1 == outRec2 && Reverse1 == Reverse2) {
				return false;
			}
			if(Reverse1) {
				op1b = this.DupOutPt(op1,false);
				op2b = this.DupOutPt(op2,true);
				op1.prev = op2;
				op2.next = op1;
				op1b.next = op2b;
				op2b.prev = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			} else {
				op1b = this.DupOutPt(op1,true);
				op2b = this.DupOutPt(op2,false);
				op1.next = op2;
				op2.prev = op1;
				op1b.prev = op2b;
				op2b.next = op1b;
				j.outPt1 = op1;
				j.outPt2 = op1b;
				return true;
			}
		}
	}
	,PointInPolygon: function(pt,pol) {
		var result = 0;
		var cnt = pol.length;
		if(cnt < 3) {
			return 0;
		}
		var ip = pol[0];
		var _g = 1;
		var _g1 = cnt + 1;
		while(_g < _g1) {
			var i = _g++;
			var ipNext = i == cnt ? pol[0] : pol[i];
			if(ipNext.y == pt.y) {
				if(ipNext.x == pt.x || ip.y == pt.y && ipNext.x > pt.x == ip.x < pt.x) {
					return -1;
				}
			}
			if(ip.y < pt.y != ipNext.y < pt.y) {
				if(ip.x >= pt.x) {
					if(ipNext.x > pt.x) {
						result = 1 - result;
					} else {
						var d = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);
						if(d == 0) {
							return -1;
						} else if(d > 0 == ipNext.y > ip.y) {
							result = 1 - result;
						}
					}
				} else if(ipNext.x > pt.x) {
					var d1 = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);
					if(d1 == 0) {
						return -1;
					} else if(d1 > 0 == ipNext.y > ip.y) {
						result = 1 - result;
					}
				}
			}
			ip = ipNext;
		}
		return result;
	}
	,PointInPolygon2: function(pt,op) {
		var result = 0;
		var startOp = op;
		var ptx = pt.x;
		var pty = pt.y;
		var poly0x = op.pt.x;
		var poly0y = op.pt.y;
		do {
			op = op.next;
			var poly1x = op.pt.x;
			var poly1y = op.pt.y;
			if(poly1y == pty) {
				if(poly1x == ptx || poly0y == pty && poly1x > ptx == poly0x < ptx) {
					return -1;
				}
			}
			if(poly0y < pty != poly1y < pty) {
				if(poly0x >= ptx) {
					if(poly1x > ptx) {
						result = 1 - result;
					} else {
						var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
						if(d == 0) {
							return -1;
						}
						if(d > 0 == poly1y > poly0y) {
							result = 1 - result;
						}
					}
				} else if(poly1x > ptx) {
					var d1 = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
					if(d1 == 0) {
						return -1;
					}
					if(d1 > 0 == poly1y > poly0y) {
						result = 1 - result;
					}
				}
			}
			poly0x = poly1x;
			poly0y = poly1y;
		} while(startOp != op);
		return result;
	}
	,Poly2ContainsPoly1: function(outPt1,outPt2) {
		var op = outPt1;
		do {
			var res = this.PointInPolygon2(op.pt,outPt2);
			if(res >= 0) {
				return res > 0;
			}
			op = op.next;
		} while(op != outPt1);
		return true;
	}
	,FixupFirstLefts1: function(OldOutRec,NewOutRec) {
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.pts == null || outRec.firstLeft == null) {
				continue;
			}
			var firstLeft = this.ParseFirstLeft(outRec.firstLeft);
			if(firstLeft == OldOutRec) {
				if(this.Poly2ContainsPoly1(outRec.pts,NewOutRec.pts)) {
					outRec.firstLeft = NewOutRec;
				}
			}
		}
	}
	,FixupFirstLefts2: function(OldOutRec,NewOutRec) {
		var _g = 0;
		var _g1 = this.m_PolyOuts;
		while(_g < _g1.length) {
			var outRec = _g1[_g];
			++_g;
			if(outRec.firstLeft == OldOutRec) {
				outRec.firstLeft = NewOutRec;
			}
		}
	}
	,ParseFirstLeft: function(FirstLeft) {
		while(FirstLeft != null && FirstLeft.pts == null) FirstLeft = FirstLeft.firstLeft;
		return FirstLeft;
	}
	,JoinCommonEdges: function() {
		var _g = 0;
		var _g1 = this.m_Joins.length;
		while(_g < _g1) {
			var i = _g++;
			var join = this.m_Joins[i];
			var outRec1 = this.GetOutRec(join.outPt1.idx);
			var outRec2 = this.GetOutRec(join.outPt2.idx);
			if(outRec1.pts == null || outRec2.pts == null) {
				continue;
			}
			var holeStateRec;
			if(outRec1 == outRec2) {
				holeStateRec = outRec1;
			} else if(this.Param1RightOfParam2(outRec1,outRec2)) {
				holeStateRec = outRec2;
			} else if(this.Param1RightOfParam2(outRec2,outRec1)) {
				holeStateRec = outRec1;
			} else {
				holeStateRec = this.GetLowermostRec(outRec1,outRec2);
			}
			if(!this.JoinPoints(join,outRec1,outRec2)) {
				continue;
			}
			if(outRec1 == outRec2) {
				outRec1.pts = join.outPt1;
				outRec1.bottomPt = null;
				outRec2 = this.CreateOutRec();
				outRec2.pts = join.outPt2;
				this.UpdateOutPtIdxs(outRec2);
				if(this.m_UsingPolyTree) {
					var _g2 = 0;
					var _g3 = this.m_PolyOuts.length - 1;
					while(_g2 < _g3) {
						var j = _g2++;
						var oRec = this.m_PolyOuts[j];
						if(oRec.pts == null || this.ParseFirstLeft(oRec.firstLeft) != outRec1 || oRec.isHole == outRec1.isHole) {
							continue;
						}
						if(this.Poly2ContainsPoly1(oRec.pts,join.outPt2)) {
							oRec.firstLeft = outRec2;
						}
					}
				}
				if(this.Poly2ContainsPoly1(outRec2.pts,outRec1.pts)) {
					outRec2.isHole = !outRec1.isHole;
					outRec2.firstLeft = outRec1;
					if(this.m_UsingPolyTree) {
						this.FixupFirstLefts2(outRec2,outRec1);
					}
					var b = this.reverseSolution;
					if((outRec2.isHole ? !b : b) == this.Area(outRec2) > 0) {
						this.ReversePolyPtLinks(outRec2.pts);
					}
				} else if(this.Poly2ContainsPoly1(outRec1.pts,outRec2.pts)) {
					outRec2.isHole = outRec1.isHole;
					outRec1.isHole = !outRec2.isHole;
					outRec2.firstLeft = outRec1.firstLeft;
					outRec1.firstLeft = outRec2;
					if(this.m_UsingPolyTree) {
						this.FixupFirstLefts2(outRec1,outRec2);
					}
					var b1 = this.reverseSolution;
					if((outRec1.isHole ? !b1 : b1) == this.Area(outRec1) > 0) {
						this.ReversePolyPtLinks(outRec1.pts);
					}
				} else {
					outRec2.isHole = outRec1.isHole;
					outRec2.firstLeft = outRec1.firstLeft;
					if(this.m_UsingPolyTree) {
						this.FixupFirstLefts1(outRec1,outRec2);
					}
				}
			} else {
				outRec2.pts = null;
				outRec2.bottomPt = null;
				outRec2.idx = outRec1.idx;
				outRec1.isHole = holeStateRec.isHole;
				if(holeStateRec == outRec2) {
					outRec1.firstLeft = outRec2.firstLeft;
				}
				outRec2.firstLeft = outRec1;
				if(this.m_UsingPolyTree) {
					this.FixupFirstLefts2(outRec2,outRec1);
				}
			}
		}
	}
	,UpdateOutPtIdxs: function(outrec) {
		var op = outrec.pts;
		do {
			op.idx = outrec.idx;
			op = op.prev;
		} while(op != outrec.pts);
	}
	,DoSimplePolygons: function() {
		var i = 0;
		while(i < this.m_PolyOuts.length) {
			var outrec = this.m_PolyOuts[i++];
			var op = outrec.pts;
			if(op == null) {
				continue;
			}
			do {
				var op2 = op.next;
				while(op2 != outrec.pts) {
					var pt1 = op.pt;
					var pt2 = op2.pt;
					if(pt1.x == pt2.x && pt1.y == pt2.y && op2.next != op && op2.prev != op) {
						var op3 = op.prev;
						var op4 = op2.prev;
						op.prev = op4;
						op4.next = op;
						op2.prev = op3;
						op3.next = op2;
						outrec.pts = op;
						var outrec2 = this.CreateOutRec();
						outrec2.pts = op2;
						this.UpdateOutPtIdxs(outrec2);
						if(this.Poly2ContainsPoly1(outrec2.pts,outrec.pts)) {
							outrec2.isHole = !outrec.isHole;
							outrec2.firstLeft = outrec;
						} else if(this.Poly2ContainsPoly1(outrec.pts,outrec2.pts)) {
							outrec2.isHole = outrec.isHole;
							outrec.isHole = !outrec2.isHole;
							outrec2.firstLeft = outrec.firstLeft;
							outrec.firstLeft = outrec2;
						} else {
							outrec2.isHole = outrec.isHole;
							outrec2.firstLeft = outrec.firstLeft;
						}
						op2 = op;
					}
					op2 = op2.next;
				}
				op = op.next;
			} while(op != outrec.pts);
		}
	}
	,Area: function(outRec) {
		var op = outRec.pts;
		if(op == null) {
			return 0.;
		}
		var a = 0;
		do {
			a += (op.pt.x + op.prev.pt.x) * (op.prev.pt.y - op.pt.y);
			op = op.next;
		} while(op != outRec.pts);
		return a / 2;
	}
	,DistanceFromLineSqrd: function(pt,ln1,ln2) {
		var A = ln1.y - ln2.y;
		var B = ln2.x - ln1.x;
		var C = A * ln1.x + B * ln1.y;
		C = A * pt.x + B * pt.y - C;
		return C * C / (A * A + B * B);
	}
	,SlopesNearCollinear: function(pt1,pt2,pt3,distSqrd) {
		var f = pt1.x - pt2.x;
		var f1 = pt1.y - pt2.y;
		if((f < 0 ? -f : f) > (f1 < 0 ? -f1 : f1)) {
			if(pt1.x > pt2.x == pt1.x < pt3.x) {
				return this.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd;
			} else if(pt2.x > pt1.x == pt2.x < pt3.x) {
				return this.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd;
			} else {
				return this.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd;
			}
		} else if(pt1.y > pt2.y == pt1.y < pt3.y) {
			return this.DistanceFromLineSqrd(pt1,pt2,pt3) < distSqrd;
		} else if(pt2.y > pt1.y == pt2.y < pt3.y) {
			return this.DistanceFromLineSqrd(pt2,pt1,pt3) < distSqrd;
		} else {
			return this.DistanceFromLineSqrd(pt3,pt1,pt2) < distSqrd;
		}
	}
	,PointsAreClose: function(pt1,pt2,distSqrd) {
		var dx = pt1.x - pt2.x;
		var dy = pt1.y - pt2.y;
		return dx * dx + dy * dy <= distSqrd;
	}
	,ExcludeOp: function(op) {
		var result = op.prev;
		result.next = op.next;
		op.next.prev = result;
		result.idx = 0;
		return result;
	}
	,CleanPolygon: function(path,distance) {
		if(distance == null) {
			distance = 1.415;
		}
		var cnt = path.length;
		if(cnt == 0) {
			var points = null;
			return points == null ? [] : points;
		}
		var outPts = [];
		var _g = 0;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			outPts[i] = new hxd_clipper__$Clipper_OutPt();
			outPts[i].pt = path[i];
			outPts[i].next = outPts[(i + 1) % cnt];
			outPts[i].next.prev = outPts[i];
			outPts[i].idx = 0;
		}
		var distSqrd = distance * distance;
		var op = outPts[0];
		while(op.idx == 0 && op.next != op.prev) if(this.PointsAreClose(op.pt,op.prev.pt,distSqrd)) {
			op = this.ExcludeOp(op);
			--cnt;
		} else if(this.PointsAreClose(op.prev.pt,op.next.pt,distSqrd)) {
			this.ExcludeOp(op.next);
			op = this.ExcludeOp(op);
			cnt -= 2;
		} else if(this.SlopesNearCollinear(op.prev.pt,op.pt,op.next.pt,distSqrd)) {
			op = this.ExcludeOp(op);
			--cnt;
		} else {
			op.idx = 1;
			op = op.next;
		}
		if(cnt < 3) {
			cnt = 0;
		}
		var points = null;
		var result = points == null ? [] : points;
		var _g = 0;
		var _g1 = cnt;
		while(_g < _g1) {
			var i = _g++;
			result.push(op.pt);
			op = op.next;
		}
		outPts = null;
		return result;
	}
	,CleanPolygons: function(polys,distance) {
		if(distance == null) {
			distance = 1.415;
		}
		var polygons = null;
		var result = polygons == null ? [] : polygons;
		var _g = 0;
		var _g1 = polys.length;
		while(_g < _g1) {
			var i = _g++;
			result.push(this.CleanPolygon(polys[i],distance));
		}
		return result;
	}
	,Minkowski: function(pattern,path,IsSum) {
		var polyCnt = pattern.length;
		var pathCnt = path.length;
		var polygons = null;
		var result = polygons == null ? [] : polygons;
		var _g = 0;
		var _g1 = pathCnt;
		while(_g < _g1) {
			var i = _g++;
			var points = null;
			var p = points == null ? [] : points;
			var _g_i = 0;
			var _g_a = pattern;
			var _g_l = _g_a.length;
			while(_g_i < _g_l) {
				var ip = _g_a[_g_i++];
				if(IsSum) {
					p.push(new h2d_col_IPoint(path[i].x + ip.x,path[i].y + ip.y));
				} else {
					p.push(new h2d_col_IPoint(path[i].x - ip.x,path[i].y - ip.y));
				}
			}
			result.push(p);
		}
		var polygons = null;
		var quads = polygons == null ? [] : polygons;
		var _g = 0;
		var _g1 = pathCnt;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = polyCnt;
			while(_g2 < _g3) {
				var j = _g2++;
				var points = null;
				var quad = points == null ? [] : points;
				quad.push(result[i % pathCnt][j % polyCnt]);
				quad.push(result[(i + 1) % pathCnt][j % polyCnt]);
				quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);
				quad.push(result[i % pathCnt][(j + 1) % polyCnt]);
				if(!(hxd_clipper_Clipper.polArea(quad) >= 0)) {
					h2d_col_IPolygon.reverse(quad);
				}
				quads.push(quad);
			}
		}
		return quads;
	}
	,MinkowskiSum: function(pattern,pol,kind) {
		var paths = this.Minkowski(pattern,pol,true);
		var c = new hxd_clipper_Clipper();
		c.resultKind = kind == null ? hxd_clipper_ResultKind.All : kind;
		c.addPolygons(paths,hxd_clipper_PolyType.Subject);
		return c.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.NonZero);
	}
	,TranslatePath: function(path,delta) {
		var points = null;
		var outPath = points == null ? [] : points;
		var _g = 0;
		var _g1 = path.length;
		while(_g < _g1) {
			var i = _g++;
			outPath.push(new h2d_col_IPoint(path[i].x + delta.x,path[i].y + delta.y));
		}
		return outPath;
	}
	,PolyTreeToPaths: function(polytree) {
		var polygons = null;
		var result = polygons == null ? [] : polygons;
		this.AddPolyNodeToPaths(polytree,hxd_clipper_NodeType.Any,result);
		return result;
	}
	,AddPolyNodeToPaths: function(polynode,nt,paths) {
		var match = true;
		if(nt._hx_index == 1) {
			return;
		}
		if(polynode.polygon.length > 0 && match) {
			paths.push(polynode.polygon);
		}
		var _g = 0;
		var _g1 = polynode.childs;
		while(_g < _g1.length) {
			var pn = _g1[_g];
			++_g;
			this.AddPolyNodeToPaths(pn,nt,paths);
		}
	}
	,__class__: hxd_clipper_Clipper
});
var hxd_clipper_ClipperOffset = function(miterLimit,arcTolerance) {
	if(arcTolerance == null) {
		arcTolerance = 0.25;
	}
	if(miterLimit == null) {
		miterLimit = 2.0;
	}
	this.two_pi = 6.28318530717958623;
	this.def_arc_tolerance = 0.25;
	this.MiterLimit = miterLimit;
	this.ArcTolerance = arcTolerance;
	this.m_lowest = new h2d_col_IPoint(-1,0);
	this.m_normals = [];
	this.m_polyNodes = new hxd_clipper__$Clipper_PolyNode();
	this.resultKind = hxd_clipper_ResultKind.All;
};
$hxClasses["hxd.clipper.ClipperOffset"] = hxd_clipper_ClipperOffset;
hxd_clipper_ClipperOffset.__name__ = "hxd.clipper.ClipperOffset";
hxd_clipper_ClipperOffset.prototype = {
	clear: function() {
		this.m_polyNodes = new hxd_clipper__$Clipper_PolyNode();
		this.m_lowest = new h2d_col_IPoint(-1,0);
	}
	,addPolygon: function(pol,joinType,endType) {
		var highI = pol.length - 1;
		if(highI < 0) {
			return;
		}
		var newNode = new hxd_clipper__$Clipper_PolyNode();
		newNode.jointype = joinType;
		newNode.endtype = endType;
		if(endType == hxd_clipper_EndType.ClosedLine || endType == hxd_clipper_EndType.ClosedPol) {
			while(highI > 0 && pol[0] == pol[highI]) --highI;
		}
		newNode.polygon.push(pol[0]);
		var j = 0;
		var k = 0;
		var _g = 1;
		var _g1 = highI + 1;
		while(_g < _g1) {
			var i = _g++;
			if(newNode.polygon[j] != pol[i]) {
				++j;
				newNode.polygon.push(pol[i]);
				if(pol[i].y > newNode.polygon[k].y || pol[i].y == newNode.polygon[k].y && pol[i].x < newNode.polygon[k].x) {
					k = j;
				}
			}
		}
		if(endType == hxd_clipper_EndType.ClosedPol && j < 2) {
			return;
		}
		this.m_polyNodes.addChild(newNode);
		if(endType != hxd_clipper_EndType.ClosedPol) {
			return;
		}
		if(this.m_lowest.x < 0) {
			this.m_lowest = new h2d_col_IPoint(this.m_polyNodes.childs.length - 1,k);
		} else {
			var ip = this.m_polyNodes.childs[this.m_lowest.x].polygon[this.m_lowest.y];
			if(newNode.polygon[k].y > ip.y || newNode.polygon[k].y == ip.y && newNode.polygon[k].x < ip.x) {
				this.m_lowest = new h2d_col_IPoint(this.m_polyNodes.childs.length - 1,k);
			}
		}
	}
	,addPolygons: function(pols,joinType,endType) {
		var _g_i = 0;
		var _g_a = pols;
		var _g_l = _g_a.length;
		while(_g_i < _g_l) {
			var p = _g_a[_g_i++];
			this.addPolygon(p,joinType,endType);
		}
	}
	,fixOrientations: function() {
		if(this.m_lowest.x >= 0 && !(hxd_clipper_Clipper.polArea(this.m_polyNodes.childs[this.m_lowest.x].polygon) >= 0)) {
			var _g = 0;
			var _g1 = this.m_polyNodes.childs;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				if(node.endtype == hxd_clipper_EndType.ClosedPol || node.endtype == hxd_clipper_EndType.ClosedLine && hxd_clipper_Clipper.polArea(node.polygon) >= 0) {
					h2d_col_IPolygon.reverse(node.polygon);
				}
			}
		} else {
			var _g = 0;
			var _g1 = this.m_polyNodes.childs;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				if(node.endtype == hxd_clipper_EndType.ClosedLine && !(hxd_clipper_Clipper.polArea(node.polygon) >= 0)) {
					h2d_col_IPolygon.reverse(node.polygon);
				}
			}
		}
	}
	,getUnitNormal: function(pt1,pt2) {
		var dx = pt2.x - pt1.x;
		var dy = pt2.y - pt1.y;
		if(dx == 0 && dy == 0) {
			return new h2d_col_PointImpl(0.,0.);
		}
		var dz = 0.;
		if(dz == null) {
			dz = 0.;
		}
		var f = 1 / Math.sqrt(dx * dx + dy * dy + dz * dz);
		dx *= f;
		var x = dy *= f;
		var y = -dx;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		return new h2d_col_PointImpl(x,y);
	}
	,doOffset: function(delta) {
		var polygons = null;
		this.m_destPolys = polygons == null ? [] : polygons;
		this.m_delta = delta;
		if(delta > -1e-20 && delta < 1E-20) {
			var _g = 0;
			var _g1 = this.m_polyNodes.childs;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				if(node.endtype == hxd_clipper_EndType.ClosedPol) {
					this.m_destPolys.push(node.polygon);
				}
			}
			return;
		}
		if(this.MiterLimit > 2) {
			this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
		} else {
			this.m_miterLim = 0.5;
		}
		var y;
		if(this.ArcTolerance <= 0.0) {
			y = this.def_arc_tolerance;
		} else if(this.ArcTolerance > (delta < 0 ? -delta : delta) * this.def_arc_tolerance) {
			y = (delta < 0 ? -delta : delta) * this.def_arc_tolerance;
		} else {
			y = this.ArcTolerance;
		}
		var steps = 3.14159265358979323 / Math.acos(1 - y / (delta < 0 ? -delta : delta)) | 0;
		this.m_sin = Math.sin(this.two_pi / steps);
		this.m_cos = Math.cos(this.two_pi / steps);
		this.m_StepsPerRad = steps / this.two_pi;
		if(delta < 0.) {
			this.m_sin = -this.m_sin;
		}
		var _g = 0;
		var _g1 = this.m_polyNodes.childs;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			this.m_srcPoly = node.polygon;
			var len = this.m_srcPoly.length;
			if(len == 0 || delta <= 0 && (len < 3 || node.endtype != hxd_clipper_EndType.ClosedPol)) {
				continue;
			}
			var points = null;
			this.m_destPoly = points == null ? [] : points;
			if(len == 1) {
				if(node.jointype == hxd_clipper_JoinType.Round) {
					var X = 1.;
					var Y = 0.;
					var _g2 = 1;
					var _g3 = steps + 1;
					while(_g2 < _g3) {
						var j = _g2++;
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X * delta),Math.round(this.m_srcPoly[0].y + Y * delta)));
						var X2 = X;
						X = X * this.m_cos - this.m_sin * Y;
						Y = X2 * this.m_sin + Y * this.m_cos;
					}
				} else {
					var X1 = -1.;
					var Y1 = -1.;
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X1 * delta),Math.round(this.m_srcPoly[0].y + Y1 * delta)));
					if(X1 < 0) {
						X1 = 1;
					} else if(Y1 < 0) {
						Y1 = 1;
					} else {
						X1 = -1;
					}
				}
				this.m_destPolys.push(this.m_destPoly);
				continue;
			}
			this.m_normals = [];
			var _g4 = 0;
			var _g5 = len - 1;
			while(_g4 < _g5) {
				var j1 = _g4++;
				this.m_normals.push(this.getUnitNormal(this.m_srcPoly[j1],this.m_srcPoly[j1 + 1]));
			}
			if(node.endtype == hxd_clipper_EndType.ClosedLine || node.endtype == hxd_clipper_EndType.ClosedPol) {
				this.m_normals.push(this.getUnitNormal(this.m_srcPoly[len - 1],this.m_srcPoly[0]));
			} else {
				this.m_normals.push(this.m_normals[len - 2]);
			}
			if(node.endtype == hxd_clipper_EndType.ClosedPol) {
				var k = len - 1;
				var _g6 = 0;
				var _g7 = len;
				while(_g6 < _g7) {
					var j2 = _g6++;
					k = this.offsetPoint(j2,k,node.jointype);
				}
				this.m_destPolys.push(this.m_destPoly);
			} else if(node.endtype == hxd_clipper_EndType.ClosedLine) {
				var k1 = len - 1;
				var _g8 = 0;
				var _g9 = len;
				while(_g8 < _g9) {
					var j3 = _g8++;
					k1 = this.offsetPoint(j3,k1,node.jointype);
				}
				this.m_destPolys.push(this.m_destPoly);
				var points1 = null;
				this.m_destPoly = points1 == null ? [] : points1;
				var n = this.m_normals[len - 1];
				var j4 = len - 1;
				while(j4 > 0) {
					var x = -this.m_normals[j4 - 1].x;
					var y = -this.m_normals[j4 - 1].y;
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					this.m_normals[j4] = new h2d_col_PointImpl(x,y);
					--j4;
				}
				var x1 = -n.x;
				var y1 = -n.y;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				this.m_normals[0] = new h2d_col_PointImpl(x1,y1);
				k1 = 0;
				var j5 = len - 1;
				while(j5 > 0) {
					k1 = this.offsetPoint(j5,k1,node.jointype);
					--j5;
				}
				this.m_destPolys.push(this.m_destPoly);
			} else {
				var k2 = 0;
				var _g10 = 1;
				var _g11 = len - 1;
				while(_g10 < _g11) {
					var j6 = _g10++;
					k2 = this.offsetPoint(j6,k2,node.jointype);
				}
				var pt1;
				if(node.endtype == hxd_clipper_EndType.OpenButt) {
					var j7 = len - 1;
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j7].x + this.m_normals[j7].x * delta),Math.round(this.m_srcPoly[j7].y + this.m_normals[j7].y * delta));
					this.m_destPoly.push(pt1);
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j7].x - this.m_normals[j7].x * delta),Math.round(this.m_srcPoly[j7].y - this.m_normals[j7].y * delta));
					this.m_destPoly.push(pt1);
				} else {
					var j8 = len - 1;
					k2 = len - 2;
					this.m_sinA = 0;
					var x2 = -this.m_normals[j8].x;
					var y2 = -this.m_normals[j8].y;
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					this.m_normals[j8] = new h2d_col_PointImpl(x2,y2);
					if(node.endtype == hxd_clipper_EndType.OpenSquare) {
						var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k2].x * this.m_normals[j8].x + this.m_normals[k2].y * this.m_normals[j8].y) * 0.25);
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + this.m_delta * (this.m_normals[k2].x - this.m_normals[k2].y * dx)),Math.round(this.m_srcPoly[j8].y + this.m_delta * (this.m_normals[k2].y + this.m_normals[k2].x * dx))));
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + this.m_delta * (this.m_normals[j8].x + this.m_normals[j8].y * dx)),Math.round(this.m_srcPoly[j8].y + this.m_delta * (this.m_normals[j8].y - this.m_normals[j8].x * dx))));
					} else {
						var a = Math.atan2(this.m_sinA,this.m_normals[k2].x * this.m_normals[j8].x + this.m_normals[k2].y * this.m_normals[j8].y);
						var a1 = Math.round(this.m_StepsPerRad * (a < 0 ? -a : a));
						var steps1 = a1 < 1 ? 1 : a1;
						var X3 = this.m_normals[k2].x;
						var Y2 = this.m_normals[k2].y;
						var X21;
						var _g12 = 0;
						var _g13 = steps1;
						while(_g12 < _g13) {
							var i = _g12++;
							this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + X3 * this.m_delta),Math.round(this.m_srcPoly[j8].y + Y2 * this.m_delta)));
							X21 = X3;
							X3 = X3 * this.m_cos - this.m_sin * Y2;
							Y2 = X21 * this.m_sin + Y2 * this.m_cos;
						}
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j8].x + this.m_normals[j8].x * this.m_delta),Math.round(this.m_srcPoly[j8].y + this.m_normals[j8].y * this.m_delta)));
					}
				}
				var j9 = len - 1;
				while(j9 > 0) {
					var x3 = -this.m_normals[j9 - 1].x;
					var y3 = -this.m_normals[j9 - 1].y;
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					this.m_normals[j9] = new h2d_col_PointImpl(x3,y3);
					--j9;
				}
				var x4 = -this.m_normals[1].x;
				var y4 = -this.m_normals[1].y;
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				this.m_normals[0] = new h2d_col_PointImpl(x4,y4);
				k2 = len - 1;
				var j10 = k2 - 1;
				while(j10 > 0) {
					k2 = this.offsetPoint(j10,k2,node.jointype);
					--j10;
				}
				if(node.endtype == hxd_clipper_EndType.OpenButt) {
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x - this.m_normals[0].x * delta),Math.round(this.m_srcPoly[0].y - this.m_normals[0].y * delta));
					this.m_destPoly.push(pt1);
					pt1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_normals[0].x * delta),Math.round(this.m_srcPoly[0].y + this.m_normals[0].y * delta));
					this.m_destPoly.push(pt1);
				} else {
					k2 = 1;
					this.m_sinA = 0;
					if(node.endtype == hxd_clipper_EndType.OpenSquare) {
						var dx1 = Math.tan(Math.atan2(this.m_sinA,this.m_normals[1].x * this.m_normals[0].x + this.m_normals[1].y * this.m_normals[0].y) * 0.25);
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_delta * (this.m_normals[1].x - this.m_normals[1].y * dx1)),Math.round(this.m_srcPoly[0].y + this.m_delta * (this.m_normals[1].y + this.m_normals[1].x * dx1))));
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_delta * (this.m_normals[0].x + this.m_normals[0].y * dx1)),Math.round(this.m_srcPoly[0].y + this.m_delta * (this.m_normals[0].y - this.m_normals[0].x * dx1))));
					} else {
						var a2 = Math.atan2(this.m_sinA,this.m_normals[1].x * this.m_normals[0].x + this.m_normals[1].y * this.m_normals[0].y);
						var a3 = Math.round(this.m_StepsPerRad * (a2 < 0 ? -a2 : a2));
						var steps2 = a3 < 1 ? 1 : a3;
						var X4 = this.m_normals[1].x;
						var Y3 = this.m_normals[1].y;
						var X22;
						var _g14 = 0;
						var _g15 = steps2;
						while(_g14 < _g15) {
							var i1 = _g14++;
							this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + X4 * this.m_delta),Math.round(this.m_srcPoly[0].y + Y3 * this.m_delta)));
							X22 = X4;
							X4 = X4 * this.m_cos - this.m_sin * Y3;
							Y3 = X22 * this.m_sin + Y3 * this.m_cos;
						}
						this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[0].x + this.m_normals[0].x * this.m_delta),Math.round(this.m_srcPoly[0].y + this.m_normals[0].y * this.m_delta)));
					}
				}
				this.m_destPolys.push(this.m_destPoly);
			}
		}
	}
	,execute: function(delta) {
		this.fixOrientations();
		this.doOffset(delta);
		var clpr = new hxd_clipper_Clipper();
		clpr.resultKind = this.resultKind;
		clpr.addPolygons(this.m_destPolys,hxd_clipper_PolyType.Subject);
		if(delta > 0) {
			return clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Positive);
		} else {
			var r = hxd_clipper__$Clipper_ClipperBase.getBounds(this.m_destPolys);
			var points = null;
			var outer = points == null ? [] : points;
			outer.push(new h2d_col_IPoint(r.left - 10,r.bottom + 10));
			outer.push(new h2d_col_IPoint(r.right + 10,r.bottom + 10));
			outer.push(new h2d_col_IPoint(r.right + 10,r.top - 10));
			outer.push(new h2d_col_IPoint(r.left - 10,r.top - 10));
			clpr.addPolygon(outer,hxd_clipper_PolyType.Subject);
			clpr.reverseSolution = true;
			var out = clpr.execute(hxd_clipper_ClipType.Union,hxd_clipper_PolyFillType.Negative,hxd_clipper_PolyFillType.Negative);
			if(out.length > 0) {
				out.shift();
			}
			return out;
		}
	}
	,offsetPoint: function(j,k,jointype) {
		this.m_sinA = this.m_normals[k].x * this.m_normals[j].y - this.m_normals[j].x * this.m_normals[k].y;
		var f = this.m_sinA * this.m_delta;
		if((f < 0 ? -f : f) < 1.0) {
			var cosA = this.m_normals[k].x * this.m_normals[j].x + this.m_normals[j].y * this.m_normals[k].y;
			if(cosA > 0) {
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta)));
				return k;
			}
		} else if(this.m_sinA > 1.0) {
			this.m_sinA = 1.0;
		} else if(this.m_sinA < -1.0) {
			this.m_sinA = -1.0;
		}
		if(this.m_sinA * this.m_delta < 0) {
			var p1 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta));
			var p2 = new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta));
			this.m_destPoly.push(p1);
			var dx = p1.x - p2.x;
			var dy = p1.y - p2.y;
			if(dx * dx + dy * dy > 1) {
				this.m_destPoly.push(this.m_srcPoly[j]);
				this.m_destPoly.push(p2);
			}
		} else {
			switch(jointype._hx_index) {
			case 0:
				var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) * 0.25);
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
				break;
			case 1:
				var a = Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);
				var a1 = Math.round(this.m_StepsPerRad * (a < 0 ? -a : a));
				var steps = a1 < 1 ? 1 : a1;
				var X = this.m_normals[k].x;
				var Y = this.m_normals[k].y;
				var X2;
				var _g = 0;
				var _g1 = steps;
				while(_g < _g1) {
					var i = _g++;
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + X * this.m_delta),Math.round(this.m_srcPoly[j].y + Y * this.m_delta)));
					X2 = X;
					X = X * this.m_cos - this.m_sin * Y;
					Y = X2 * this.m_sin + Y * this.m_cos;
				}
				this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta)));
				break;
			case 2:
				var r = 1 + (this.m_normals[j].x * this.m_normals[k].x + this.m_normals[j].y * this.m_normals[k].y);
				if(r >= this.m_miterLim) {
					var q = this.m_delta / r;
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q),Math.round(this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q)));
				} else {
					var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) * 0.25);
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
					this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
				}
				break;
			}
		}
		return j;
	}
	,doSquare: function(j,k) {
		var dx = Math.tan(Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) * 0.25);
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),Math.round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
	}
	,doMiter: function(j,k,r) {
		var q = this.m_delta / r;
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q),Math.round(this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q)));
	}
	,doRound: function(j,k) {
		var a = Math.atan2(this.m_sinA,this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);
		var a1 = Math.round(this.m_StepsPerRad * (a < 0 ? -a : a));
		var steps = a1 < 1 ? 1 : a1;
		var X = this.m_normals[k].x;
		var Y = this.m_normals[k].y;
		var X2;
		var _g = 0;
		var _g1 = steps;
		while(_g < _g1) {
			var i = _g++;
			this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + X * this.m_delta),Math.round(this.m_srcPoly[j].y + Y * this.m_delta)));
			X2 = X;
			X = X * this.m_cos - this.m_sin * Y;
			Y = X2 * this.m_sin + Y * this.m_cos;
		}
		this.m_destPoly.push(new h2d_col_IPoint(Math.round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),Math.round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta)));
	}
	,__class__: hxd_clipper_ClipperOffset
};
var hxd_clipper_EndType = $hxEnums["hxd.clipper.EndType"] = { __ename__:"hxd.clipper.EndType",__constructs__:null
	,ClosedPol: {_hx_name:"ClosedPol",_hx_index:0,__enum__:"hxd.clipper.EndType",toString:$estr}
	,ClosedLine: {_hx_name:"ClosedLine",_hx_index:1,__enum__:"hxd.clipper.EndType",toString:$estr}
	,OpenButt: {_hx_name:"OpenButt",_hx_index:2,__enum__:"hxd.clipper.EndType",toString:$estr}
	,OpenSquare: {_hx_name:"OpenSquare",_hx_index:3,__enum__:"hxd.clipper.EndType",toString:$estr}
	,OpenRound: {_hx_name:"OpenRound",_hx_index:4,__enum__:"hxd.clipper.EndType",toString:$estr}
};
hxd_clipper_EndType.__constructs__ = [hxd_clipper_EndType.ClosedPol,hxd_clipper_EndType.ClosedLine,hxd_clipper_EndType.OpenButt,hxd_clipper_EndType.OpenSquare,hxd_clipper_EndType.OpenRound];
hxd_clipper_EndType.__empty_constructs__ = [hxd_clipper_EndType.ClosedPol,hxd_clipper_EndType.ClosedLine,hxd_clipper_EndType.OpenButt,hxd_clipper_EndType.OpenSquare,hxd_clipper_EndType.OpenRound];
var hxd_clipper_JoinType = $hxEnums["hxd.clipper.JoinType"] = { __ename__:"hxd.clipper.JoinType",__constructs__:null
	,Square: {_hx_name:"Square",_hx_index:0,__enum__:"hxd.clipper.JoinType",toString:$estr}
	,Round: {_hx_name:"Round",_hx_index:1,__enum__:"hxd.clipper.JoinType",toString:$estr}
	,Miter: {_hx_name:"Miter",_hx_index:2,__enum__:"hxd.clipper.JoinType",toString:$estr}
};
hxd_clipper_JoinType.__constructs__ = [hxd_clipper_JoinType.Square,hxd_clipper_JoinType.Round,hxd_clipper_JoinType.Miter];
hxd_clipper_JoinType.__empty_constructs__ = [hxd_clipper_JoinType.Square,hxd_clipper_JoinType.Round,hxd_clipper_JoinType.Miter];
var hxd_clipper_PolyFillType = $hxEnums["hxd.clipper.PolyFillType"] = { __ename__:"hxd.clipper.PolyFillType",__constructs__:null
	,EvenOdd: {_hx_name:"EvenOdd",_hx_index:0,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
	,NonZero: {_hx_name:"NonZero",_hx_index:1,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
	,Positive: {_hx_name:"Positive",_hx_index:2,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
	,Negative: {_hx_name:"Negative",_hx_index:3,__enum__:"hxd.clipper.PolyFillType",toString:$estr}
};
hxd_clipper_PolyFillType.__constructs__ = [hxd_clipper_PolyFillType.EvenOdd,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Negative];
hxd_clipper_PolyFillType.__empty_constructs__ = [hxd_clipper_PolyFillType.EvenOdd,hxd_clipper_PolyFillType.NonZero,hxd_clipper_PolyFillType.Positive,hxd_clipper_PolyFillType.Negative];
var hxd_clipper_PolyType = $hxEnums["hxd.clipper.PolyType"] = { __ename__:"hxd.clipper.PolyType",__constructs__:null
	,Subject: {_hx_name:"Subject",_hx_index:0,__enum__:"hxd.clipper.PolyType",toString:$estr}
	,Clip: {_hx_name:"Clip",_hx_index:1,__enum__:"hxd.clipper.PolyType",toString:$estr}
};
hxd_clipper_PolyType.__constructs__ = [hxd_clipper_PolyType.Subject,hxd_clipper_PolyType.Clip];
hxd_clipper_PolyType.__empty_constructs__ = [hxd_clipper_PolyType.Subject,hxd_clipper_PolyType.Clip];
var hxd_clipper_Rect = function(l,t,r,b) {
	if(b == null) {
		b = 0;
	}
	if(r == null) {
		r = 0;
	}
	if(t == null) {
		t = 0;
	}
	if(l == null) {
		l = 0;
	}
	this.left = l;
	this.top = t;
	this.right = r;
	this.bottom = b;
};
$hxClasses["hxd.clipper.Rect"] = hxd_clipper_Rect;
hxd_clipper_Rect.__name__ = "hxd.clipper.Rect";
hxd_clipper_Rect.prototype = {
	__class__: hxd_clipper_Rect
};
var hxd_earcut_EarNode = function() {
};
$hxClasses["hxd.earcut.EarNode"] = hxd_earcut_EarNode;
hxd_earcut_EarNode.__name__ = "hxd.earcut.EarNode";
hxd_earcut_EarNode.prototype = {
	__class__: hxd_earcut_EarNode
};
var hxd_earcut_Earcut = function() {
};
$hxClasses["hxd.earcut.Earcut"] = hxd_earcut_Earcut;
hxd_earcut_Earcut.__name__ = "hxd.earcut.Earcut";
hxd_earcut_Earcut.prototype = {
	triangulate_anon_y_Float_x_Float: function(points,holes) {
		var hasHoles = holes != null && holes.length > 0;
		var outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		var root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	,triangulate_h2d_GPoint: function(points,holes) {
		var hasHoles = holes != null && holes.length > 0;
		var outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		var root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	,eliminateHoles_triangulate_T: function(points,holes,root) {
		var queue = [];
		var _g = 0;
		var _g1 = holes.length;
		while(_g < _g1) {
			var i = _g++;
			var s = holes[i];
			var e = i == holes.length - 1 ? points.length : holes[i + 1];
			var node = this.setLinkedList_eliminateHoles_T(points,s,e,false);
			if(node == node.next) {
				node.steiner = true;
			}
			queue.push(this.getLeftmost(node));
		}
		queue.sort($bind(this,this.compareX));
		var _g = 0;
		while(_g < queue.length) {
			var q = queue[_g];
			++_g;
			this.eliminateHole(q,root);
			root = this.filterPoints(root,root.next);
		}
		return root;
	}
	,setLinkedList_eliminateHoles_T: function(points,start,end,clockwise) {
		var sum = 0.;
		var j = end - 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var node = n;
		var first = node;
		if(clockwise == sum > 0) {
			var _g = start;
			var _g1 = end;
			while(_g < _g1) {
				var i = _g++;
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			var i = end - 1;
			while(i >= start) {
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	,setLinkedList_triangulate_T: function(points,start,end,clockwise) {
		var sum = 0.;
		var j = end - 1;
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var node = n;
		var first = node;
		if(clockwise == sum > 0) {
			var _g = start;
			var _g1 = end;
			while(_g < _g1) {
				var i = _g++;
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			var i = end - 1;
			while(i >= start) {
				var p = points[i];
				var x = p.x;
				var y = p.y;
				var n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = x;
				n.y = y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	,triangulateNode: function(root,useZOrder) {
		this.triangles = [];
		root = this.filterPoints(root);
		if(useZOrder && root != null) {
			var maxX = root.x;
			this.minX = maxX;
			var maxY = root.y;
			this.minY = maxY;
			var p = root.next;
			while(p != root) {
				var x = p.x;
				var y = p.y;
				if(x < this.minX) {
					this.minX = x;
				}
				if(y < this.minY) {
					this.minY = y;
				}
				if(x > maxX) {
					maxX = x;
				}
				if(y > maxY) {
					maxY = y;
				}
				p = p.next;
			}
			var a = maxX - this.minX;
			var b = maxY - this.minY;
			this.size = a < b ? b : a;
			this.hasSize = true;
		} else {
			this.hasSize = false;
		}
		this.earcutLinked(root);
		var result = this.triangles;
		this.triangles = null;
		var n = this.allocated;
		if(this.cache != null) {
			while(n != this.cache) n = n.allocNext;
			n = n.allocNext;
		}
		while(n != null) {
			n.next = this.cache;
			this.cache = n;
			n = n.allocNext;
		}
		return result;
	}
	,eliminateHole: function(hole,root) {
		root = this.findHoleBridge(hole,root);
		if(root != null) {
			var b = this.splitPolygon(root,hole);
			this.filterPoints(b,b.next);
		}
	}
	,findHoleBridge: function(hole,root) {
		var p = root;
		var hx = hole.x;
		var hy = hole.y;
		var qx = -Infinity;
		var m = null;
		do {
			if(hy <= p.y && hy >= p.next.y) {
				var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
				if(x <= hx && x > qx) {
					qx = x;
					m = p.x < p.next.x ? p : p.next;
				}
			}
			p = p.next;
		} while(p != root);
		if(m == null) {
			return null;
		}
		var stop = m;
		var tanMin = Infinity;
		var tan;
		p = m.next;
		while(p != stop) {
			var tmp;
			if(hx >= p.x && p.x >= m.x) {
				var ax = hy < m.y ? hx : qx;
				var bx = m.x;
				var by = m.y;
				var cx = hy < m.y ? qx : hx;
				var px = p.x;
				var py = p.y;
				tmp = (cx - px) * (hy - py) - (ax - px) * (hy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (hy - py) >= 0 && (bx - px) * (hy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				var f = hy - p.y;
				tan = (f < 0 ? -f : f) / (hx - p.x);
				var tmp1;
				if(tan < tanMin || tan == tanMin && p.x > m.x) {
					var p1 = p.prev;
					var r = p.next;
					if((p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) < 0) {
						var r1 = p.next;
						if((hole.y - p.y) * (r1.x - hole.x) - (hole.x - p.x) * (r1.y - hole.y) >= 0) {
							var q = p.prev;
							tmp1 = (q.y - p.y) * (hole.x - q.x) - (q.x - p.x) * (hole.y - q.y) >= 0;
						} else {
							tmp1 = false;
						}
					} else {
						var r2 = p.prev;
						if(!((hole.y - p.y) * (r2.x - hole.x) - (hole.x - p.x) * (r2.y - hole.y) < 0)) {
							var q1 = p.next;
							tmp1 = (q1.y - p.y) * (hole.x - q1.x) - (q1.x - p.x) * (hole.y - q1.y) < 0;
						} else {
							tmp1 = true;
						}
					}
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					m = p;
					tanMin = tan;
				}
			}
			p = p.next;
		}
		return m;
	}
	,getLeftmost: function(node) {
		var p = node;
		var leftmost = node;
		do {
			if(p.x < leftmost.x) {
				leftmost = p;
			}
			p = p.next;
		} while(p != node);
		return leftmost;
	}
	,compareX: function(a,b) {
		if(a.x - b.x > 0) {
			return 1;
		} else {
			return -1;
		}
	}
	,equals: function(p1,p2) {
		if(p1.x == p2.x) {
			return p1.y == p2.y;
		} else {
			return false;
		}
	}
	,area: function(p,q,r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	,intersects: function(p1,q1,p2,q2) {
		if((q1.y - p1.y) * (p2.x - q1.x) - (q1.x - p1.x) * (p2.y - q1.y) > 0 != (q1.y - p1.y) * (q2.x - q1.x) - (q1.x - p1.x) * (q2.y - q1.y) > 0) {
			return (q2.y - p2.y) * (p1.x - q2.x) - (q2.x - p2.x) * (p1.y - q2.y) > 0 != (q2.y - p2.y) * (q1.x - q2.x) - (q2.x - p2.x) * (q1.y - q2.y) > 0;
		} else {
			return false;
		}
	}
	,locallyInside: function(a,b) {
		var p = a.prev;
		var r = a.next;
		if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
			var r = a.next;
			if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
				var q = a.prev;
				return (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
			} else {
				return false;
			}
		} else {
			var r = a.prev;
			if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
				var q = a.next;
				return (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
			} else {
				return true;
			}
		}
	}
	,filterPoints: function(start,end) {
		if(start == null) {
			return start;
		}
		if(end == null) {
			end = start;
		}
		var p = start;
		var again;
		do {
			again = false;
			var tmp;
			if(!p.steiner) {
				var p2 = p.next;
				if(!(p.x == p2.x && p.y == p2.y)) {
					var p1 = p.prev;
					var r = p.next;
					tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) == 0;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				end = p.prev;
				p = end;
				if(p == p.next) {
					return null;
				}
				again = true;
			} else {
				p = p.next;
			}
		} while(again || p != end);
		return end;
	}
	,removeNode: function(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if(p.prevZ != null) {
			p.prevZ.nextZ = p.nextZ;
		}
		if(p.nextZ != null) {
			p.nextZ.prevZ = p.prevZ;
		}
	}
	,allocNode: function(i,x,y,last) {
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		return n;
	}
	,earcutLinked: function(ear,pass) {
		if(pass == null) {
			pass = 0;
		}
		if(ear == null) {
			return;
		}
		if(pass == 0 && this.hasSize) {
			this.indexCurve(ear);
		}
		var stop = ear;
		var prev;
		var next;
		while(ear.prev != ear.next) {
			prev = ear.prev;
			next = ear.next;
			if(this.hasSize ? this.isEarHashed(ear) : this.isEar(ear)) {
				this.triangles.push(prev.i);
				this.triangles.push(ear.i);
				this.triangles.push(next.i);
				ear.next.prev = ear.prev;
				ear.prev.next = ear.next;
				if(ear.prevZ != null) {
					ear.prevZ.nextZ = ear.nextZ;
				}
				if(ear.nextZ != null) {
					ear.nextZ.prevZ = ear.prevZ;
				}
				ear = next.next;
				stop = next.next;
				continue;
			}
			ear = next;
			if(ear == stop) {
				switch(pass) {
				case 0:
					this.earcutLinked(this.filterPoints(ear),1);
					break;
				case 1:
					ear = this.cureLocalIntersections(ear);
					this.earcutLinked(ear,2);
					break;
				case 2:
					this.splitEarcut(ear);
					break;
				}
				break;
			}
		}
	}
	,isEar: function(ear) {
		var a = ear.prev;
		var b = ear;
		var c = ear.next;
		if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
			return false;
		}
		var p = ear.next.next;
		while(p != ear.prev) {
			var tmp;
			var ax = a.x;
			var ay = a.y;
			var bx = b.x;
			var by = b.y;
			var cx = c.x;
			var cy = c.y;
			var px = p.x;
			var py = p.y;
			if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.next;
		}
		return true;
	}
	,isEarHashed: function(ear) {
		var a = ear.prev;
		var b = ear;
		var c = ear.next;
		if((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y) >= 0) {
			return false;
		}
		var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
		var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
		var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
		var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
		var x = 32767 * (minTX - this.minX) / this.size | 0;
		var y = 32767 * (minTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		var minZ = x | y << 1;
		var x = 32767 * (maxTX - this.minX) / this.size | 0;
		var y = 32767 * (maxTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		var maxZ = x | y << 1;
		var p = ear.nextZ;
		while(p != null && p.z <= maxZ) {
			var tmp;
			var tmp1;
			if(p != ear.prev && p != ear.next) {
				var ax = a.x;
				var ay = a.y;
				var bx = b.x;
				var by = b.y;
				var cx = c.x;
				var cy = c.y;
				var px = p.x;
				var py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.nextZ;
		}
		p = ear.prevZ;
		while(p != null && p.z >= minZ) {
			var tmp;
			var tmp1;
			if(p != ear.prev && p != ear.next) {
				var ax = a.x;
				var ay = a.y;
				var bx = b.x;
				var by = b.y;
				var cx = c.x;
				var cy = c.y;
				var px = p.x;
				var py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p1 = p.prev;
				var r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.prevZ;
		}
		return true;
	}
	,cureLocalIntersections: function(start) {
		var p = start;
		do {
			var a = p.prev;
			var b = p.next.next;
			var tmp;
			var tmp1;
			var p2 = p.next;
			if((p.y - a.y) * (p2.x - p.x) - (p.x - a.x) * (p2.y - p.y) > 0 != (p.y - a.y) * (b.x - p.x) - (p.x - a.x) * (b.y - p.y) > 0 && (b.y - p2.y) * (a.x - b.x) - (b.x - p2.x) * (a.y - b.y) > 0 != (b.y - p2.y) * (p.x - b.x) - (b.x - p2.x) * (p.y - b.y) > 0) {
				var p1 = a.prev;
				var r = a.next;
				if((a.y - p1.y) * (r.x - a.x) - (a.x - p1.x) * (r.y - a.y) < 0) {
					var r1 = a.next;
					if((b.y - a.y) * (r1.x - b.x) - (b.x - a.x) * (r1.y - b.y) >= 0) {
						var q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					var r2 = a.prev;
					if(!((b.y - a.y) * (r2.x - b.x) - (b.x - a.x) * (r2.y - b.y) < 0)) {
						var q1 = a.next;
						tmp1 = (q1.y - a.y) * (b.x - q1.x) - (q1.x - a.x) * (b.y - q1.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p3 = b.prev;
				var r3 = b.next;
				if((b.y - p3.y) * (r3.x - b.x) - (b.x - p3.x) * (r3.y - b.y) < 0) {
					var r4 = b.next;
					if((a.y - b.y) * (r4.x - a.x) - (a.x - b.x) * (r4.y - a.y) >= 0) {
						var q2 = b.prev;
						tmp = (q2.y - b.y) * (a.x - q2.x) - (q2.x - b.x) * (a.y - q2.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					var r5 = b.prev;
					if(!((a.y - b.y) * (r5.x - a.x) - (a.x - b.x) * (r5.y - a.y) < 0)) {
						var q3 = b.next;
						tmp = (q3.y - b.y) * (a.x - q3.x) - (q3.x - b.x) * (a.y - q3.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				this.triangles.push(a.i);
				this.triangles.push(p.i);
				this.triangles.push(b.i);
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				var p4 = p.next;
				p4.next.prev = p4.prev;
				p4.prev.next = p4.next;
				if(p4.prevZ != null) {
					p4.prevZ.nextZ = p4.nextZ;
				}
				if(p4.nextZ != null) {
					p4.nextZ.prevZ = p4.prevZ;
				}
				start = b;
				p = start;
			}
			p = p.next;
		} while(p != start);
		return p;
	}
	,splitEarcut: function(start) {
		var a = start;
		do {
			var b = a.next.next;
			while(b != a.prev) {
				if(a.i != b.i && this.isValidDiagonal(a,b)) {
					var c = this.splitPolygon(a,b);
					a = this.filterPoints(a,a.next);
					c = this.filterPoints(c,c.next);
					this.earcutLinked(a);
					this.earcutLinked(c);
					return;
				}
				b = b.next;
			}
			a = a.next;
		} while(a != start);
	}
	,splitPolygon: function(a,b) {
		var i = a.i;
		var x = a.x;
		var y = a.y;
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var a2 = n;
		var i = b.i;
		var x = b.x;
		var y = b.y;
		var last = null;
		var n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = i;
		n.z = -1;
		n.x = x;
		n.y = y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		if(last != null) {
			last.next = n;
		}
		var b2 = n;
		var an = a.next;
		var bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	}
	,pointInTriangle: function(ax,ay,bx,by,cx,cy,px,py) {
		if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0) {
			return (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
		} else {
			return false;
		}
	}
	,isValidDiagonal: function(a,b) {
		if(!(a.x == b.x && a.y == b.y)) {
			var tmp;
			var tmp1;
			if(a.next.i != b.i && a.prev.i != b.i && !this.intersectsPolygon(a,b)) {
				var p = a.prev;
				var r = a.next;
				if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
					var r = a.next;
					if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
						var q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					var r = a.prev;
					if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
						var q = a.next;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var p = b.prev;
				var r = b.next;
				if((b.y - p.y) * (r.x - b.x) - (b.x - p.x) * (r.y - b.y) < 0) {
					var r = b.next;
					if((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) >= 0) {
						var q = b.prev;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					var r = b.prev;
					if(!((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) < 0)) {
						var q = b.next;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				return this.middleInside(a,b);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,middleInside: function(a,b) {
		var p = a;
		var inside = false;
		var px = (a.x + b.x) / 2;
		var py = (a.y + b.y) / 2;
		do {
			if(p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
				inside = !inside;
			}
			p = p.next;
		} while(p != a);
		return inside;
	}
	,intersectsPolygon: function(a,b) {
		var p = a;
		do {
			var tmp;
			if(p.i != a.i && p.next.i != a.i && p.i != b.i && p.next.i != b.i) {
				var q1 = p.next;
				tmp = (q1.y - p.y) * (a.x - q1.x) - (q1.x - p.x) * (a.y - q1.y) > 0 != (q1.y - p.y) * (b.x - q1.x) - (q1.x - p.x) * (b.y - q1.y) > 0 && (b.y - a.y) * (p.x - b.x) - (b.x - a.x) * (p.y - b.y) > 0 != (b.y - a.y) * (q1.x - b.x) - (b.x - a.x) * (q1.y - b.y) > 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return true;
			}
			p = p.next;
		} while(p != a);
		return false;
	}
	,zOrder: function(px,py) {
		var x = 32767 * (px - this.minX) / this.size | 0;
		var y = 32767 * (py - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		return x | y << 1;
	}
	,indexCurve: function(start) {
		var p = start;
		do {
			if(p.z < 0) {
				var x = 32767 * (p.x - this.minX) / this.size | 0;
				var y = 32767 * (p.y - this.minY) / this.size | 0;
				x = (x | x << 8) & 16711935;
				x = (x | x << 4) & 252645135;
				x = (x | x << 2) & 858993459;
				x = (x | x << 1) & 1431655765;
				y = (y | y << 8) & 16711935;
				y = (y | y << 4) & 252645135;
				y = (y | y << 2) & 858993459;
				y = (y | y << 1) & 1431655765;
				p.z = x | y << 1;
			}
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while(p != start);
		p.prevZ.nextZ = null;
		p.prevZ = null;
		this.sortLinked(p);
	}
	,sortLinked: function(list) {
		var p;
		var q;
		var e;
		var tail;
		var numMerges;
		var pSize;
		var qSize;
		var inSize = 1;
		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;
			while(p != null) {
				++numMerges;
				q = p;
				pSize = 0;
				var _g = 0;
				var _g1 = inSize;
				while(_g < _g1) {
					var i = _g++;
					++pSize;
					q = q.nextZ;
					if(q == null) {
						break;
					}
				}
				qSize = inSize;
				while(pSize > 0 || qSize > 0 && q != null) {
					if(pSize == 0) {
						e = q;
						q = q.nextZ;
						--qSize;
					} else if(qSize == 0 || q == null) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else if(p.z <= q.z) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else {
						e = q;
						q = q.nextZ;
						--qSize;
					}
					if(tail != null) {
						tail.nextZ = e;
					} else {
						list = e;
					}
					e.prevZ = tail;
					tail = e;
				}
				p = q;
			}
			tail.nextZ = null;
			inSize *= 2;
		} while(numMerges > 1);
		return list;
	}
	,__class__: hxd_earcut_Earcut
};
var hxd_fmt_bfnt_FontParser = function() { };
$hxClasses["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser;
hxd_fmt_bfnt_FontParser.__name__ = "hxd.fmt.bfnt.FontParser";
hxd_fmt_bfnt_FontParser.parse = function(bytes,path,resolveTile) {
	var tile = null;
	var font = new h2d_Font(null,0);
	var glyphs = font.glyphs;
	font.baseLine = 0;
	var _g = bytes.getInt32(0);
	switch(_g) {
	case 54938946:
		var bytes1 = new haxe_io_BytesInput(bytes);
		bytes1.set_position(bytes1.pos + 4);
		var pageCount = 0;
		while(bytes1.pos < bytes1.totlen) {
			var id = bytes1.readByte();
			var length = bytes1.readInt32();
			var pos = bytes1.pos;
			switch(id) {
			case 1:
				font.size = font.initSize = bytes1.readInt16();
				bytes1.set_position(bytes1.pos + 12);
				font.name = bytes1.readUntil(0);
				break;
			case 2:
				font.lineHeight = bytes1.readUInt16();
				font.baseLine = bytes1.readUInt16();
				bytes1.set_position(bytes1.pos + 4);
				pageCount = bytes1.readUInt16();
				if(pageCount != 1) {
					haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 220, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				}
				break;
			case 3:
				var name = bytes1.readUntil(0);
				try {
					font.tilePath = name;
					tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),name]));
				} catch( _g1 ) {
					haxe_Log.trace("Warning: Could not find referenced font texture at \"" + name + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
					font.tilePath = new haxe_io_Path(path).file + ".png";
					tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
				}
				break;
			case 4:
				var count = length / 20 | 0;
				while(count > 0) {
					var cid = bytes1.readInt32();
					var t = tile.sub(bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readInt16(),bytes1.readInt16());
					var fc = new h2d_FontChar(t,bytes1.readInt16());
					glyphs.h[cid] = fc;
					bytes1.set_position(bytes1.pos + 2);
					--count;
				}
				break;
			case 5:
				var count1 = length / 10 | 0;
				while(count1 > 0) {
					var first = bytes1.readInt32();
					var key = bytes1.readInt32();
					var fc1 = glyphs.h[key];
					if(fc1 != null) {
						fc1.addKerning(first,bytes1.readInt16());
					} else {
						bytes1.set_position(bytes1.pos + 2);
					}
					--count1;
				}
				break;
			}
			bytes1.set_position(pos + length);
		}
		break;
	case 1414415938:
		return new hxd_fmt_bfnt_Reader(new haxe_io_BytesInput(bytes)).read(function(tp) {
			try {
				font.tilePath = tp;
				tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tp]));
			} catch( _g ) {
				haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tp + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				font.tilePath = new haxe_io_Path(path).file + ".png";
				tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
			}
			return tile;
		});
	case 1836597052:case 1852794428:
		var xml = Xml.parse(bytes.toString());
		var x = xml.firstElement();
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		var xml = x;
		if(haxe_xml__$Access_HasNodeAccess.resolve(xml,"info")) {
			var tmp = haxe_xml__$Access_NodeAccess.resolve(xml,"info");
			font.name = haxe_xml__$Access_AttribAccess.resolve(tmp,"face");
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"info"),"size");
			font.size = font.initSize = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"common"),"lineHeight");
			font.lineHeight = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml,"common"),"base");
			font.baseLine = Std.parseInt(tmp);
			var p = haxe_xml__$Access_NodeAccess.resolve(xml,"pages").elements();
			while(p.hasNext()) {
				var p1 = p.next();
				if(haxe_xml__$Access_AttribAccess.resolve(p1,"id") == "0") {
					var tilePath = haxe_xml__$Access_AttribAccess.resolve(p1,"file");
					try {
						font.tilePath = tilePath;
						tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
					} catch( _g1 ) {
						haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						font.tilePath = new haxe_io_Path(path).file + ".png";
						tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
					}
				} else {
					haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 62, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
				}
			}
			var chars = haxe_xml__$Access_NodeAccess.resolve(xml,"chars").elements();
			var c = chars;
			while(c.hasNext()) {
				var c1 = c.next();
				var t = tile.sub(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"x")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"y")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"height")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"xoffset")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"yoffset")));
				var fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"xadvance")));
				var kerns = haxe_xml__$Access_NodeAccess.resolve(xml,"kernings").elements();
				var k = kerns;
				while(k.hasNext()) {
					var k1 = k.next();
					if(haxe_xml__$Access_AttribAccess.resolve(k1,"second") == haxe_xml__$Access_AttribAccess.resolve(c1,"id")) {
						fc.addKerning(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"first")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"amount")));
					}
				}
				var key = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"id"));
				glyphs.h[key] = fc;
			}
		} else {
			font.tilePath = new haxe_io_Path(path).file + ".png";
			tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
			font.name = haxe_xml__$Access_AttribAccess.resolve(xml,"family");
			var tmp = haxe_xml__$Access_AttribAccess.resolve(xml,"size");
			font.size = font.initSize = Std.parseInt(tmp);
			var tmp = haxe_xml__$Access_AttribAccess.resolve(xml,"height");
			font.lineHeight = Std.parseInt(tmp);
			var kernings = [];
			var c = xml.elements();
			while(c.hasNext()) {
				var c1 = c.next();
				var r = haxe_xml__$Access_AttribAccess.resolve(c1,"rect").split(" ");
				var o = haxe_xml__$Access_AttribAccess.resolve(c1,"offset").split(" ");
				var t = tile.sub(Std.parseInt(r[0]),Std.parseInt(r[1]),Std.parseInt(r[2]),Std.parseInt(r[3]),Std.parseInt(o[0]),Std.parseInt(o[1]));
				var fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")));
				var code = haxe_xml__$Access_AttribAccess.resolve(c1,"code");
				var code1 = StringTools.startsWith(code,"&#") ? Std.parseInt(HxOverrides.substr(code,2,code.length - 3)) : HxOverrides.cca(code,0);
				var k = c1.elements();
				while(k.hasNext()) {
					var k1 = k.next();
					var code2 = haxe_xml__$Access_AttribAccess.resolve(k1,"id");
					var next = StringTools.startsWith(code2,"&#") ? Std.parseInt(HxOverrides.substr(code2,2,code2.length - 3)) : HxOverrides.cca(code2,0);
					var adv = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"advance"));
					if(glyphs.h.hasOwnProperty(next)) {
						glyphs.h[next].addKerning(code1,adv);
					} else {
						kernings.push({ prev : code1, next : next, adv : adv});
					}
				}
				glyphs.h[code1] = fc;
			}
			var _g1 = 0;
			while(_g1 < kernings.length) {
				var k = kernings[_g1];
				++_g1;
				var g = glyphs.h[k.next];
				if(g == null) {
					continue;
				}
				g.addKerning(k.prev,k.adv);
			}
		}
		break;
	case 1868983913:
		var lines = bytes.toString().split("\n");
		var reg = new EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","");
		var idx;
		var pageCount = 0;
		var _g1 = 0;
		while(_g1 < lines.length) {
			var line = lines[_g1];
			++_g1;
			idx = line.indexOf(" ");
			switch(HxOverrides.substr(line,0,idx)) {
			case "char":
				var id = 0;
				var x = 0;
				var y = 0;
				var width = 0;
				var height = 0;
				var xoffset = 0;
				var yoffset = 0;
				var xadvance = 0;
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "height":
						var v = reg.matched(2);
						height = Std.parseInt(HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v);
						break;
					case "id":
						var v1 = reg.matched(2);
						id = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
						break;
					case "width":
						var v2 = reg.matched(2);
						width = Std.parseInt(HxOverrides.cca(v2,0) == 34 ? v2.substring(1,v2.length - 1) : v2);
						break;
					case "x":
						var v3 = reg.matched(2);
						x = Std.parseInt(HxOverrides.cca(v3,0) == 34 ? v3.substring(1,v3.length - 1) : v3);
						break;
					case "xadvance":
						var v4 = reg.matched(2);
						xadvance = Std.parseInt(HxOverrides.cca(v4,0) == 34 ? v4.substring(1,v4.length - 1) : v4);
						break;
					case "xoffset":
						var v5 = reg.matched(2);
						xoffset = Std.parseInt(HxOverrides.cca(v5,0) == 34 ? v5.substring(1,v5.length - 1) : v5);
						break;
					case "y":
						var v6 = reg.matched(2);
						y = Std.parseInt(HxOverrides.cca(v6,0) == 34 ? v6.substring(1,v6.length - 1) : v6);
						break;
					case "yoffset":
						var v7 = reg.matched(2);
						yoffset = Std.parseInt(HxOverrides.cca(v7,0) == 34 ? v7.substring(1,v7.length - 1) : v7);
						break;
					}
					var pos = reg.matchedPos();
					idx = pos.pos + pos.len;
				}
				var t = tile.sub(x,y,width,height,xoffset,yoffset);
				var fc = new h2d_FontChar(t,xadvance);
				glyphs.h[id] = fc;
				break;
			case "common":
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "base":
						var v8 = reg.matched(2);
						font.baseLine = Std.parseInt(HxOverrides.cca(v8,0) == 34 ? v8.substring(1,v8.length - 1) : v8);
						break;
					case "lineHeight":
						var v9 = reg.matched(2);
						font.lineHeight = Std.parseInt(HxOverrides.cca(v9,0) == 34 ? v9.substring(1,v9.length - 1) : v9);
						break;
					case "pages":
						var v10 = reg.matched(2);
						pageCount = Std.parseInt(HxOverrides.cca(v10,0) == 34 ? v10.substring(1,v10.length - 1) : v10);
						if(pageCount != 1) {
							haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 153, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						}
						break;
					}
					var pos1 = reg.matchedPos();
					idx = pos1.pos + pos1.len;
				}
				break;
			case "info":
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "face":
						var v11 = reg.matched(2);
						font.name = HxOverrides.cca(v11,0) == 34 ? v11.substring(1,v11.length - 1) : v11;
						break;
					case "size":
						var v12 = reg.matched(2);
						font.size = font.initSize = Std.parseInt(HxOverrides.cca(v12,0) == 34 ? v12.substring(1,v12.length - 1) : v12);
						break;
					}
					var pos2 = reg.matchedPos();
					idx = pos2.pos + pos2.len;
				}
				break;
			case "kerning":
				var first = 0;
				var second = 0;
				var advance = 0;
				while(idx < line.length && reg.matchSub(line,idx)) {
					switch(reg.matched(1)) {
					case "amount":
						var v13 = reg.matched(2);
						advance = Std.parseInt(HxOverrides.cca(v13,0) == 34 ? v13.substring(1,v13.length - 1) : v13);
						break;
					case "first":
						var v14 = reg.matched(2);
						first = Std.parseInt(HxOverrides.cca(v14,0) == 34 ? v14.substring(1,v14.length - 1) : v14);
						break;
					case "second":
						var v15 = reg.matched(2);
						second = Std.parseInt(HxOverrides.cca(v15,0) == 34 ? v15.substring(1,v15.length - 1) : v15);
						break;
					}
					var pos3 = reg.matchedPos();
					idx = pos3.pos + pos3.len;
				}
				var fc1 = glyphs.h[second];
				if(fc1 != null) {
					fc1.addKerning(first,advance);
				}
				break;
			case "page":
				while(idx < line.length && reg.matchSub(line,idx)) {
					if(reg.matched(1) == "file") {
						var v16 = reg.matched(2);
						var tilePath = HxOverrides.cca(v16,0) == 34 ? v16.substring(1,v16.length - 1) : v16;
						try {
							font.tilePath = tilePath;
							tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
						} catch( _g2 ) {
							haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 26, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
							font.tilePath = new haxe_io_Path(path).file + ".png";
							tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
						}
					}
					var pos4 = reg.matchedPos();
					idx = pos4.pos + pos4.len;
				}
				break;
			}
		}
		break;
	default:
		var sign = _g;
		throw haxe_Exception.thrown("Unknown font signature " + StringTools.hex(sign,8));
	}
	if(glyphs.h[32] == null) {
		var value = new h2d_FontChar(tile.sub(0,0,0,0),font.size >> 1);
		glyphs.h[32] = value;
	}
	font.tile = tile;
	if(font.baseLine == 0) {
		font.baseLine = font.calcBaseLine();
	}
	var fallback = glyphs.h[65533];
	if(fallback == null) {
		fallback = glyphs.h[9633];
	}
	if(fallback == null) {
		fallback = glyphs.h[63];
	}
	if(fallback != null) {
		font.defaultChar = fallback;
	}
	return font;
};
var hxd_fmt_bfnt_Reader = function(i) {
	this.i = i;
};
$hxClasses["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader;
hxd_fmt_bfnt_Reader.__name__ = "hxd.fmt.bfnt.Reader";
hxd_fmt_bfnt_Reader.parse = function(bytes,resolveTile) {
	return new hxd_fmt_bfnt_Reader(new haxe_io_BytesInput(bytes)).read(resolveTile);
};
hxd_fmt_bfnt_Reader.prototype = {
	read: function(resolveTile) {
		if(this.i.readString(4) != "BFNT" || this.i.readByte() != 0) {
			throw haxe_Exception.thrown("Not a BFNT file!");
		}
		var font = null;
		var _g = this.i.readByte();
		if(_g == 1) {
			font = new h2d_Font(this.i.readString(this.i.readUInt16()),this.i.readInt16());
			font.tilePath = this.i.readString(this.i.readUInt16());
			var tile = font.tile = resolveTile(font.tilePath);
			font.lineHeight = this.i.readInt16();
			font.baseLine = this.i.readInt16();
			var defaultChar = this.i.readInt32();
			var id;
			while(true) {
				id = this.i.readInt32();
				if(!(id != 0)) {
					break;
				}
				var t = tile.sub(this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readInt16(),this.i.readInt16());
				var glyph = new h2d_FontChar(t,this.i.readInt16());
				font.glyphs.h[id] = glyph;
				if(id == defaultChar) {
					font.defaultChar = glyph;
				}
				var prevChar;
				while(true) {
					prevChar = this.i.readInt32();
					if(!(prevChar != 0)) {
						break;
					}
					glyph.addKerning(prevChar,this.i.readInt16());
				}
			}
		} else {
			var ver = _g;
			throw haxe_Exception.thrown("Unknown BFNT version: " + ver);
		}
		return font;
	}
	,__class__: hxd_fmt_bfnt_Reader
};
var hxd_fmt_hdr_Reader = function() { };
$hxClasses["hxd.fmt.hdr.Reader"] = hxd_fmt_hdr_Reader;
hxd_fmt_hdr_Reader.__name__ = "hxd.fmt.hdr.Reader";
hxd_fmt_hdr_Reader.decode = function(bytes,sRGB) {
	var f = new haxe_io_BytesInput(bytes);
	var width = 0;
	var height = 0;
	var keys_h = Object.create(null);
	while(true) {
		var line = f.readLine();
		if(line == "") {
			break;
		}
		if(HxOverrides.cca(line,0) == 35) {
			continue;
		}
		var nameValue = line.split("=");
		if(nameValue.length > 1) {
			keys_h[nameValue.shift()] = nameValue.join("=");
		}
	}
	var parts = f.readLine().split(" ");
	height = Std.parseInt(parts[1]);
	width = Std.parseInt(parts[3]);
	var gamma = keys_h["GAMMA"] == "1";
	var data = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 * 4));
	var exposure = 1.0;
	var exp = keys_h["EXPOSURE"];
	if(exp != null) {
		var exp1 = parseFloat(exp);
		if(exp1 < 1e-12 || exp1 < 1e12) {
			exposure = exp1;
		}
	}
	var gammaCorrect = sRGB ? 1 : 0.45454545454545453;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var e = _g1++;
		_g.push(Math.pow(e,gammaCorrect));
	}
	var gammaVals = _g;
	var _g = [];
	var _g1 = 0;
	while(_g1 < 256) {
		var e = _g1++;
		_g.push(Math.pow(Math.pow(2,e - 128) / (256 * exposure),gammaCorrect));
	}
	var exps = _g;
	var _g = keys_h["FORMAT"];
	if(_g == null) {
		var fmt = _g;
		throw haxe_Exception.thrown("Unsupported HDR format " + fmt);
	} else if(_g == "32-bit_rle_rgbe") {
		var dataPos = f.pos;
		var scanLen = width * 4;
		var scanLine = new haxe_io_Bytes(new ArrayBuffer(scanLen));
		var widthBE = width >> 8 | (width & 255) << 8;
		var _g1 = 0;
		var _g2 = height;
		while(_g1 < _g2) {
			var y = _g1++;
			var h = bytes.getInt32(dataPos);
			if((h & 65535) != 514 || h >>> 16 != widthBE) {
				scanLine.blit(0,bytes,dataPos,width * 4);
				dataPos += width * 4;
			} else {
				dataPos += 4;
				var p = 0;
				var end = width * 4;
				while(p < end) {
					var len = bytes.b[dataPos++];
					if(len > 128) {
						len -= 128;
						scanLine.fill(p,len,bytes.b[dataPos++]);
					} else {
						scanLine.blit(p,bytes,dataPos,len);
						dataPos += len;
					}
					p += len;
				}
			}
			var pos = y * width * 16;
			var _g3 = 0;
			var _g4 = width;
			while(_g3 < _g4) {
				var x = _g3++;
				var e = exps[scanLine.b[x + width * 3]];
				data.setFloat(pos,gammaVals[scanLine.b[x]] * e);
				pos += 4;
				data.setFloat(pos,gammaVals[scanLine.b[x + width]] * e);
				pos += 4;
				data.setFloat(pos,gammaVals[scanLine.b[x + (width << 1)]] * e);
				pos += 4;
				data.setFloat(pos,1.0);
				pos += 4;
			}
		}
	} else {
		var fmt = _g;
		throw haxe_Exception.thrown("Unsupported HDR format " + fmt);
	}
	return { width : width, height : height, bytes : data, gamma : gamma};
};
var hxd_fmt_hmd_Property = $hxEnums["hxd.fmt.hmd.Property"] = { __ename__:"hxd.fmt.hmd.Property",__constructs__:null
	,CameraFOVY: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxd.fmt.hmd.Property",toString:$estr}; },$_._hx_name="CameraFOVY",$_.__params__ = ["v"],$_)
	,Unused_HasMaterialFlags: {_hx_name:"Unused_HasMaterialFlags",_hx_index:1,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
	,HasExtraTextures: {_hx_name:"HasExtraTextures",_hx_index:2,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
	,FourBonesByVertex: {_hx_name:"FourBonesByVertex",_hx_index:3,__enum__:"hxd.fmt.hmd.Property",toString:$estr}
};
hxd_fmt_hmd_Property.__constructs__ = [hxd_fmt_hmd_Property.CameraFOVY,hxd_fmt_hmd_Property.Unused_HasMaterialFlags,hxd_fmt_hmd_Property.HasExtraTextures,hxd_fmt_hmd_Property.FourBonesByVertex];
hxd_fmt_hmd_Property.__empty_constructs__ = [hxd_fmt_hmd_Property.Unused_HasMaterialFlags,hxd_fmt_hmd_Property.HasExtraTextures,hxd_fmt_hmd_Property.FourBonesByVertex];
var hxd_fmt_hmd_Position = function() {
};
$hxClasses["hxd.fmt.hmd.Position"] = hxd_fmt_hmd_Position;
hxd_fmt_hmd_Position.__name__ = "hxd.fmt.hmd.Position";
hxd_fmt_hmd_Position.prototype = {
	loadQuaternion: function(q) {
		q.x = this.qx;
		q.y = this.qy;
		q.z = this.qz;
		q.w = this.get_qw();
	}
	,get_qw: function() {
		var qw = 1 - (this.qx * this.qx + this.qy * this.qy + this.qz * this.qz);
		if(qw < 0) {
			return -Math.sqrt(-qw);
		} else {
			return Math.sqrt(qw);
		}
	}
	,toMatrix: function(postScale) {
		if(postScale == null) {
			postScale = false;
		}
		var m = new h3d_MatrixImpl();
		var q = hxd_fmt_hmd_Position.QTMP;
		q.x = this.qx;
		q.y = this.qy;
		q.z = this.qz;
		q.w = this.get_qw();
		q.toMatrix(m);
		if(postScale) {
			m.translate(this.x,this.y,this.z);
			m.scale(this.sx,this.sy,this.sz);
		} else {
			m._11 *= this.sx;
			m._12 *= this.sx;
			m._13 *= this.sx;
			m._21 *= this.sy;
			m._22 *= this.sy;
			m._23 *= this.sy;
			m._31 *= this.sz;
			m._32 *= this.sz;
			m._33 *= this.sz;
			m.translate(this.x,this.y,this.z);
		}
		return m;
	}
	,__class__: hxd_fmt_hmd_Position
};
var hxd_fmt_hmd_Geometry = function() {
};
$hxClasses["hxd.fmt.hmd.Geometry"] = hxd_fmt_hmd_Geometry;
hxd_fmt_hmd_Geometry.__name__ = "hxd.fmt.hmd.Geometry";
hxd_fmt_hmd_Geometry.prototype = {
	get_indexCount: function() {
		var k = 0;
		var _g = 0;
		var _g1 = this.indexCounts;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			k += i;
		}
		return k;
	}
	,__class__: hxd_fmt_hmd_Geometry
};
var hxd_fmt_hmd_Material = function() {
};
$hxClasses["hxd.fmt.hmd.Material"] = hxd_fmt_hmd_Material;
hxd_fmt_hmd_Material.__name__ = "hxd.fmt.hmd.Material";
hxd_fmt_hmd_Material.prototype = {
	__class__: hxd_fmt_hmd_Material
};
var hxd_fmt_hmd_SkinJoint = function() {
};
$hxClasses["hxd.fmt.hmd.SkinJoint"] = hxd_fmt_hmd_SkinJoint;
hxd_fmt_hmd_SkinJoint.__name__ = "hxd.fmt.hmd.SkinJoint";
hxd_fmt_hmd_SkinJoint.prototype = {
	__class__: hxd_fmt_hmd_SkinJoint
};
var hxd_fmt_hmd_SkinSplit = function() {
};
$hxClasses["hxd.fmt.hmd.SkinSplit"] = hxd_fmt_hmd_SkinSplit;
hxd_fmt_hmd_SkinSplit.__name__ = "hxd.fmt.hmd.SkinSplit";
hxd_fmt_hmd_SkinSplit.prototype = {
	__class__: hxd_fmt_hmd_SkinSplit
};
var hxd_fmt_hmd_Skin = function() {
};
$hxClasses["hxd.fmt.hmd.Skin"] = hxd_fmt_hmd_Skin;
hxd_fmt_hmd_Skin.__name__ = "hxd.fmt.hmd.Skin";
hxd_fmt_hmd_Skin.prototype = {
	__class__: hxd_fmt_hmd_Skin
};
var hxd_fmt_hmd_Model = function() {
};
$hxClasses["hxd.fmt.hmd.Model"] = hxd_fmt_hmd_Model;
hxd_fmt_hmd_Model.__name__ = "hxd.fmt.hmd.Model";
hxd_fmt_hmd_Model.prototype = {
	__class__: hxd_fmt_hmd_Model
};
var hxd_fmt_hmd_AnimationFlag = $hxEnums["hxd.fmt.hmd.AnimationFlag"] = { __ename__:"hxd.fmt.hmd.AnimationFlag",__constructs__:null
	,HasPosition: {_hx_name:"HasPosition",_hx_index:0,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasRotation: {_hx_name:"HasRotation",_hx_index:1,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasScale: {_hx_name:"HasScale",_hx_index:2,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasUV: {_hx_name:"HasUV",_hx_index:3,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasAlpha: {_hx_name:"HasAlpha",_hx_index:4,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,SingleFrame: {_hx_name:"SingleFrame",_hx_index:5,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,HasProps: {_hx_name:"HasProps",_hx_index:6,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
	,Reserved: {_hx_name:"Reserved",_hx_index:7,__enum__:"hxd.fmt.hmd.AnimationFlag",toString:$estr}
};
hxd_fmt_hmd_AnimationFlag.__constructs__ = [hxd_fmt_hmd_AnimationFlag.HasPosition,hxd_fmt_hmd_AnimationFlag.HasRotation,hxd_fmt_hmd_AnimationFlag.HasScale,hxd_fmt_hmd_AnimationFlag.HasUV,hxd_fmt_hmd_AnimationFlag.HasAlpha,hxd_fmt_hmd_AnimationFlag.SingleFrame,hxd_fmt_hmd_AnimationFlag.HasProps,hxd_fmt_hmd_AnimationFlag.Reserved];
hxd_fmt_hmd_AnimationFlag.__empty_constructs__ = [hxd_fmt_hmd_AnimationFlag.HasPosition,hxd_fmt_hmd_AnimationFlag.HasRotation,hxd_fmt_hmd_AnimationFlag.HasScale,hxd_fmt_hmd_AnimationFlag.HasUV,hxd_fmt_hmd_AnimationFlag.HasAlpha,hxd_fmt_hmd_AnimationFlag.SingleFrame,hxd_fmt_hmd_AnimationFlag.HasProps,hxd_fmt_hmd_AnimationFlag.Reserved];
var hxd_fmt_hmd_AnimationObject = function() {
};
$hxClasses["hxd.fmt.hmd.AnimationObject"] = hxd_fmt_hmd_AnimationObject;
hxd_fmt_hmd_AnimationObject.__name__ = "hxd.fmt.hmd.AnimationObject";
hxd_fmt_hmd_AnimationObject.prototype = {
	getStride: function() {
		var stride = 0;
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasPosition._hx_index) != 0) {
			stride += 3;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasRotation._hx_index) != 0) {
			stride += 3;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasScale._hx_index) != 0) {
			stride += 3;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasUV._hx_index) != 0) {
			stride += 2;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasAlpha._hx_index) != 0) {
			++stride;
		}
		if((this.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
			stride += this.props.length;
		}
		return stride;
	}
	,__class__: hxd_fmt_hmd_AnimationObject
};
var hxd_fmt_hmd_AnimationEvent = function() {
};
$hxClasses["hxd.fmt.hmd.AnimationEvent"] = hxd_fmt_hmd_AnimationEvent;
hxd_fmt_hmd_AnimationEvent.__name__ = "hxd.fmt.hmd.AnimationEvent";
hxd_fmt_hmd_AnimationEvent.prototype = {
	__class__: hxd_fmt_hmd_AnimationEvent
};
var hxd_fmt_hmd_Animation = function() {
};
$hxClasses["hxd.fmt.hmd.Animation"] = hxd_fmt_hmd_Animation;
hxd_fmt_hmd_Animation.__name__ = "hxd.fmt.hmd.Animation";
hxd_fmt_hmd_Animation.prototype = {
	__class__: hxd_fmt_hmd_Animation
};
var hxd_fmt_hmd_Data = function() {
};
$hxClasses["hxd.fmt.hmd.Data"] = hxd_fmt_hmd_Data;
hxd_fmt_hmd_Data.__name__ = "hxd.fmt.hmd.Data";
hxd_fmt_hmd_Data.prototype = {
	__class__: hxd_fmt_hmd_Data
};
var hxd_fmt_hmd__$Library_FormatMap = function(size,offset,def,prec) {
	this.size = size;
	this.offset = offset;
	this.precision = prec;
	this.def = def;
};
$hxClasses["hxd.fmt.hmd._Library.FormatMap"] = hxd_fmt_hmd__$Library_FormatMap;
hxd_fmt_hmd__$Library_FormatMap.__name__ = "hxd.fmt.hmd._Library.FormatMap";
hxd_fmt_hmd__$Library_FormatMap.prototype = {
	__class__: hxd_fmt_hmd__$Library_FormatMap
};
var hxd_fmt_hmd_GeometryBuffer = function() {
};
$hxClasses["hxd.fmt.hmd.GeometryBuffer"] = hxd_fmt_hmd_GeometryBuffer;
hxd_fmt_hmd_GeometryBuffer.__name__ = "hxd.fmt.hmd.GeometryBuffer";
hxd_fmt_hmd_GeometryBuffer.prototype = {
	__class__: hxd_fmt_hmd_GeometryBuffer
};
var hxd_fmt_hmd_Library = function(res,header) {
	this.resource = res;
	this.header = header;
	this.cachedPrimitives = [];
	this.cachedAnimations = new haxe_ds_StringMap();
	this.cachedSkin = new haxe_ds_StringMap();
};
$hxClasses["hxd.fmt.hmd.Library"] = hxd_fmt_hmd_Library;
hxd_fmt_hmd_Library.__name__ = "hxd.fmt.hmd.Library";
hxd_fmt_hmd_Library.prototype = {
	getData: function() {
		var entry = this.resource.entry;
		var b = new haxe_io_Bytes(new ArrayBuffer(entry.get_size() - this.header.dataPosition));
		entry.readFull(b,this.header.dataPosition,b.length);
		return b;
	}
	,getDefaultFormat: function(stride) {
		var format = [new hxd_BufferInput("position",3)];
		var defs = [null];
		if(stride > 3) {
			format.push(new hxd_BufferInput("normal",3));
			defs.push(null);
		}
		if(stride > 6) {
			format.push(new hxd_BufferInput("uv",2));
			defs.push(null);
		}
		if(stride > 8) {
			format.push(new hxd_BufferInput("color",3));
			var x = 1;
			var y = 1;
			var z = 1;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			defs.push(new h3d_VectorImpl(x,y,z));
		}
		if(stride > 11) {
			throw haxe_Exception.thrown("Unsupported stride");
		}
		return { format : hxd_BufferFormat.make(format), defs : defs};
	}
	,load: function(format,defaults,modelIndex) {
		if(modelIndex == null) {
			modelIndex = -1;
		}
		var x = 0.;
		var y = 0.;
		var z = 0.;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var vtmp_x = x;
		var vtmp_y = y;
		var vtmp_z = z;
		var models = modelIndex < 0 ? this.header.models : [this.header.models[modelIndex]];
		var outVertex = hxd__$FloatBuffer_Float32Expand._new(0);
		var outIndex = new Array(0);
		var stride = format.stride;
		var mid = -1;
		var _g = 0;
		while(_g < models.length) {
			var m = models[_g];
			++_g;
			var geom = this.header.geometries[m.geometry];
			if(geom == null) {
				continue;
			}
			var _g1 = 0;
			var _g2 = m.materials;
			while(_g1 < _g2.length) {
				var mat = _g2[_g1];
				++_g1;
				if(mid < 0) {
					mid = mat;
				}
				if(mid != mat) {
					throw haxe_Exception.thrown("Models have several materials");
				}
			}
			var pos = m.position.toMatrix();
			var data = this.getBuffers(geom,format,defaults);
			var start = outVertex.pos / stride | 0;
			var _g3 = 0;
			var _g4 = data.vertexes.length / stride | 0;
			while(_g3 < _g4) {
				var i = _g3++;
				var p = i * stride;
				vtmp_x = data.vertexes[p++];
				vtmp_y = data.vertexes[p++];
				vtmp_z = data.vertexes[p++];
				var px = vtmp_x * pos._11 + vtmp_y * pos._21 + vtmp_z * pos._31 + pos._41;
				var py = vtmp_x * pos._12 + vtmp_y * pos._22 + vtmp_z * pos._32 + pos._42;
				var pz = vtmp_x * pos._13 + vtmp_y * pos._23 + vtmp_z * pos._33 + pos._43;
				vtmp_x = px;
				vtmp_y = py;
				vtmp_z = pz;
				if(outVertex.pos == outVertex.array.length) {
					var newSize = outVertex.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					var newArray = new Float32Array(newSize);
					newArray.set(outVertex.array);
					outVertex.array = newArray;
				}
				outVertex.array[outVertex.pos++] = vtmp_x;
				if(outVertex.pos == outVertex.array.length) {
					var newSize1 = outVertex.array.length << 1;
					if(newSize1 < 128) {
						newSize1 = 128;
					}
					var newArray1 = new Float32Array(newSize1);
					newArray1.set(outVertex.array);
					outVertex.array = newArray1;
				}
				outVertex.array[outVertex.pos++] = vtmp_y;
				if(outVertex.pos == outVertex.array.length) {
					var newSize2 = outVertex.array.length << 1;
					if(newSize2 < 128) {
						newSize2 = 128;
					}
					var newArray2 = new Float32Array(newSize2);
					newArray2.set(outVertex.array);
					outVertex.array = newArray2;
				}
				outVertex.array[outVertex.pos++] = vtmp_z;
				var _g5 = 0;
				var _g6 = stride - 3;
				while(_g5 < _g6) {
					var j = _g5++;
					var v = data.vertexes[p++];
					if(outVertex.pos == outVertex.array.length) {
						var newSize3 = outVertex.array.length << 1;
						if(newSize3 < 128) {
							newSize3 = 128;
						}
						var newArray3 = new Float32Array(newSize3);
						newArray3.set(outVertex.array);
						outVertex.array = newArray3;
					}
					outVertex.array[outVertex.pos++] = v;
				}
			}
			var _g7 = 0;
			var _g8 = data.indexes;
			while(_g7 < _g8.length) {
				var idx = _g8[_g7];
				++_g7;
				outIndex.push(idx + start);
			}
		}
		return { vertex : outVertex, index : outIndex};
	}
	,getBuffers: function(geom,format,defaults,material) {
		if(material == 0 && geom.indexCounts.length == 1) {
			material = null;
		}
		var maps = [];
		var index = 0;
		var stride = 0;
		var lowPrec = false;
		var _g_current = 0;
		var _g_array = format.inputs;
		while(_g_current < _g_array.length) {
			var i = _g_array[_g_current++];
			var i2 = geom.vertexFormat.getInput(i.name);
			var map;
			if(i2 == null) {
				var def = defaults == null ? null : defaults[index];
				if(def == null) {
					throw haxe_Exception.thrown("Missing required " + i.name);
				}
				map = new hxd_fmt_hmd__$Library_FormatMap(i.type & 7,0,def,0);
			} else {
				if(i2.type != i.type) {
					throw haxe_Exception.thrown("Requested " + i.name + " " + (i.type == null ? "null" : hxd_InputFormat.toString(i.type)) + " but found " + (i2.type == null ? "null" : hxd_InputFormat.toString(i2.type)));
				}
				map = new hxd_fmt_hmd__$Library_FormatMap(i.type & 7,geom.vertexFormat.calculateInputOffset(i2.name),null,i2.precision);
				if(i2.precision != 0) {
					lowPrec = true;
				}
			}
			maps.push(map);
			stride += i.type & 7;
			++index;
		}
		var geomStride = geom.vertexFormat.strideBytes;
		var vsize = geom.vertexCount * geomStride;
		var vbuf = new haxe_io_Bytes(new ArrayBuffer(vsize));
		var entry = this.resource.entry;
		entry.readFull(vbuf,this.header.dataPosition + geom.vertexPosition,vsize);
		var dataPos = this.header.dataPosition + geom.indexPosition;
		var isSmall = geom.vertexCount <= 65536;
		var imult = isSmall ? 2 : 4;
		var isize;
		if(material == null) {
			isize = geom.get_indexCount() * imult;
		} else {
			var ipos = 0;
			var _g = 0;
			var _g1 = material;
			while(_g < _g1) {
				var i = _g++;
				ipos += geom.indexCounts[i];
			}
			dataPos += ipos * imult;
			isize = geom.indexCounts[material] * imult;
		}
		var ibuf = new haxe_io_Bytes(new ArrayBuffer(isize));
		entry.readFull(ibuf,dataPos,isize);
		var buf = new hxd_fmt_hmd_GeometryBuffer();
		if(material == null) {
			buf.vertexes = new Array(stride * geom.vertexCount);
			buf.indexes = new Array(geom.get_indexCount());
			var w = 0;
			var _g = 0;
			var _g1 = geom.vertexCount;
			while(_g < _g1) {
				var vid = _g++;
				var _g2 = 0;
				while(_g2 < maps.length) {
					var m = maps[_g2];
					++_g2;
					if(m.def == null) {
						var _g3 = 0;
						var _g4 = m.size;
						while(_g3 < _g4) {
							var i = _g3++;
							var this1 = buf.vertexes;
							var index = w++;
							var val;
							if(lowPrec) {
								switch(m.precision) {
								case 0:
									val = vbuf.getFloat(vid * geomStride + (i << 2) + m.offset);
									break;
								case 1:
									val = hxd_BufferFormat.float16to32(vbuf.getUInt16(vid * geomStride + (i << 1) + m.offset));
									break;
								case 2:
									val = (vbuf.b[vid * geomStride + i + m.offset] & 255) / 255;
									break;
								case 3:
									val = hxd_BufferFormat.floatS8to32(vbuf.b[vid * geomStride + i + m.offset]);
									break;
								}
							} else {
								val = vbuf.getFloat(vid * geomStride + (i << 2) + m.offset);
							}
							this1[index] = val;
						}
					} else {
						switch(m.size) {
						case 1:
							buf.vertexes[w++] = m.def.x;
							break;
						case 2:
							buf.vertexes[w++] = m.def.x;
							buf.vertexes[w++] = m.def.y;
							break;
						case 3:
							buf.vertexes[w++] = m.def.x;
							buf.vertexes[w++] = m.def.y;
							buf.vertexes[w++] = m.def.z;
							break;
						default:
							buf.vertexes[w++] = m.def.x;
							buf.vertexes[w++] = m.def.y;
							buf.vertexes[w++] = m.def.z;
							buf.vertexes[w++] = m.def.w;
						}
					}
				}
			}
			if(isSmall) {
				var r = 0;
				var _g = 0;
				var _g1 = buf.indexes.length;
				while(_g < _g1) {
					var i = _g++;
					buf.indexes[i] = ibuf.b[r++] | ibuf.b[r++] << 8;
				}
			} else {
				var _g = 0;
				var _g1 = buf.indexes.length;
				while(_g < _g1) {
					var i = _g++;
					buf.indexes[i] = ibuf.getInt32(i << 2);
				}
			}
		} else {
			var icount = geom.indexCounts[material];
			var vmap = new Array(geom.vertexCount);
			var vertexes = hxd__$FloatBuffer_Float32Expand._new(0);
			buf.indexes = new Array(icount);
			var r = 0;
			var vcount = 0;
			var _g = 0;
			var _g1 = buf.indexes.length;
			while(_g < _g1) {
				var i = _g++;
				var vid = isSmall ? ibuf.b[r++] | ibuf.b[r++] << 8 : ibuf.getInt32(i << 2);
				var rid = vmap[vid];
				if(rid == 0) {
					++vcount;
					rid = vcount;
					vmap[vid] = rid;
					var _g2 = 0;
					while(_g2 < maps.length) {
						var m = maps[_g2];
						++_g2;
						if(m.def == null) {
							var _g3 = 0;
							var _g4 = m.size;
							while(_g3 < _g4) {
								var i1 = _g3++;
								var v;
								if(lowPrec) {
									switch(m.precision) {
									case 0:
										v = vbuf.getFloat(vid * geomStride + (i1 << 2) + m.offset);
										break;
									case 1:
										v = hxd_BufferFormat.float16to32(vbuf.getUInt16(vid * geomStride + (i1 << 1) + m.offset));
										break;
									case 2:
										v = (vbuf.b[vid * geomStride + i1 + m.offset] & 255) / 255;
										break;
									case 3:
										v = hxd_BufferFormat.floatS8to32(vbuf.b[vid * geomStride + i1 + m.offset]);
										break;
									}
								} else {
									v = vbuf.getFloat(vid * geomStride + (i1 << 2) + m.offset);
								}
								if(vertexes.pos == vertexes.array.length) {
									var newSize = vertexes.array.length << 1;
									if(newSize < 128) {
										newSize = 128;
									}
									var newArray = new Float32Array(newSize);
									newArray.set(vertexes.array);
									vertexes.array = newArray;
								}
								vertexes.array[vertexes.pos++] = v;
							}
						} else {
							switch(m.size) {
							case 1:
								var v1 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize1 = vertexes.array.length << 1;
									if(newSize1 < 128) {
										newSize1 = 128;
									}
									var newArray1 = new Float32Array(newSize1);
									newArray1.set(vertexes.array);
									vertexes.array = newArray1;
								}
								vertexes.array[vertexes.pos++] = v1;
								break;
							case 2:
								var v2 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize2 = vertexes.array.length << 1;
									if(newSize2 < 128) {
										newSize2 = 128;
									}
									var newArray2 = new Float32Array(newSize2);
									newArray2.set(vertexes.array);
									vertexes.array = newArray2;
								}
								vertexes.array[vertexes.pos++] = v2;
								var v3 = m.def.y;
								if(vertexes.pos == vertexes.array.length) {
									var newSize3 = vertexes.array.length << 1;
									if(newSize3 < 128) {
										newSize3 = 128;
									}
									var newArray3 = new Float32Array(newSize3);
									newArray3.set(vertexes.array);
									vertexes.array = newArray3;
								}
								vertexes.array[vertexes.pos++] = v3;
								break;
							case 3:
								var v4 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize4 = vertexes.array.length << 1;
									if(newSize4 < 128) {
										newSize4 = 128;
									}
									var newArray4 = new Float32Array(newSize4);
									newArray4.set(vertexes.array);
									vertexes.array = newArray4;
								}
								vertexes.array[vertexes.pos++] = v4;
								var v5 = m.def.y;
								if(vertexes.pos == vertexes.array.length) {
									var newSize5 = vertexes.array.length << 1;
									if(newSize5 < 128) {
										newSize5 = 128;
									}
									var newArray5 = new Float32Array(newSize5);
									newArray5.set(vertexes.array);
									vertexes.array = newArray5;
								}
								vertexes.array[vertexes.pos++] = v5;
								var v6 = m.def.z;
								if(vertexes.pos == vertexes.array.length) {
									var newSize6 = vertexes.array.length << 1;
									if(newSize6 < 128) {
										newSize6 = 128;
									}
									var newArray6 = new Float32Array(newSize6);
									newArray6.set(vertexes.array);
									vertexes.array = newArray6;
								}
								vertexes.array[vertexes.pos++] = v6;
								break;
							default:
								var v7 = m.def.x;
								if(vertexes.pos == vertexes.array.length) {
									var newSize7 = vertexes.array.length << 1;
									if(newSize7 < 128) {
										newSize7 = 128;
									}
									var newArray7 = new Float32Array(newSize7);
									newArray7.set(vertexes.array);
									vertexes.array = newArray7;
								}
								vertexes.array[vertexes.pos++] = v7;
								var v8 = m.def.y;
								if(vertexes.pos == vertexes.array.length) {
									var newSize8 = vertexes.array.length << 1;
									if(newSize8 < 128) {
										newSize8 = 128;
									}
									var newArray8 = new Float32Array(newSize8);
									newArray8.set(vertexes.array);
									vertexes.array = newArray8;
								}
								vertexes.array[vertexes.pos++] = v8;
								var v9 = m.def.z;
								if(vertexes.pos == vertexes.array.length) {
									var newSize9 = vertexes.array.length << 1;
									if(newSize9 < 128) {
										newSize9 = 128;
									}
									var newArray9 = new Float32Array(newSize9);
									newArray9.set(vertexes.array);
									vertexes.array = newArray9;
								}
								vertexes.array[vertexes.pos++] = v9;
								var v10 = m.def.w;
								if(vertexes.pos == vertexes.array.length) {
									var newSize10 = vertexes.array.length << 1;
									if(newSize10 < 128) {
										newSize10 = 128;
									}
									var newArray10 = new Float32Array(newSize10);
									newArray10.set(vertexes.array);
									vertexes.array = newArray10;
								}
								vertexes.array[vertexes.pos++] = v10;
							}
						}
					}
				}
				buf.indexes[i] = rid - 1;
			}
			var this1 = vertexes;
			var _g = [];
			var _g1 = 0;
			var _g2 = this1.pos;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this1.array[i]);
			}
			buf.vertexes = _g;
		}
		return buf;
	}
	,makePrimitive: function(id) {
		var p = this.cachedPrimitives[id];
		if(p != null) {
			return p;
		}
		p = new h3d_prim_HMDModel(this.header.geometries[id],this.header.dataPosition,this);
		p.incref();
		this.cachedPrimitives[id] = p;
		return p;
	}
	,dispose: function() {
		var _g = 0;
		var _g1 = this.cachedPrimitives;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p != null) {
				p.decref();
			}
		}
		this.cachedPrimitives = [];
	}
	,makeMaterial: function(model,mid,loadTexture) {
		var m = this.header.materials[mid];
		var mat = h3d_mat_MaterialSetup.current.createMaterial();
		mat.name = m.name;
		mat.model = this.resource;
		mat.set_blendMode(m.blendMode);
		var props = h3d_mat_MaterialSetup.current.loadMaterialProps(mat);
		if(props == null) {
			props = mat.getDefaultModelProps();
		}
		if(m.diffuseTexture != null) {
			mat.set_texture(loadTexture(m.diffuseTexture));
			if(mat.get_texture() == null) {
				mat.set_texture(h3d_mat_Texture.fromColor(16711935));
			}
		}
		if(m.specularTexture != null) {
			mat.set_specularTexture(loadTexture(m.specularTexture));
		}
		if(m.normalMap != null) {
			mat.set_normalMap(loadTexture(m.normalMap));
		}
		mat.set_props(props);
		return mat;
	}
	,makeSkin: function(skin,geom) {
		var s = this.cachedSkin.h[skin.name];
		if(s != null) {
			return s;
		}
		s = new h3d_anim_Skin(skin.name,0,geom.props != null && geom.props.indexOf(hxd_fmt_hmd_Property.FourBonesByVertex) >= 0 ? 4 : 3);
		s.namedJoints = new haxe_ds_StringMap();
		s.allJoints = [];
		s.boundJoints = [];
		s.rootJoints = [];
		var _g = 0;
		var _g1 = skin.joints;
		while(_g < _g1.length) {
			var joint = _g1[_g];
			++_g;
			var j = new h3d_anim_Joint();
			j.name = joint.name;
			j.index = s.allJoints.length;
			j.defMat = joint.position.toMatrix();
			if(joint.bind >= 0) {
				j.bindIndex = joint.bind;
				j.transPos = joint.transpos.toMatrix(true);
				s.boundJoints[j.bindIndex] = j;
			}
			if(joint.parent >= 0) {
				var p = s.allJoints[joint.parent];
				p.subs.push(j);
				j.parent = p;
			} else {
				s.rootJoints.push(j);
			}
			s.allJoints.push(j);
			s.namedJoints.h[j.name] = j;
		}
		if(skin.split != null) {
			s.splitJoints = [];
			var _g = 0;
			var _g1 = skin.split;
			while(_g < _g1.length) {
				var ss = _g1[_g];
				++_g;
				var s1 = s.splitJoints;
				var ss1 = ss.materialIndex;
				var _g2 = [];
				var _g3 = 0;
				var _g4 = ss.joints;
				while(_g3 < _g4.length) {
					var j = _g4[_g3];
					++_g3;
					_g2.push(s.allJoints[j]);
				}
				s1.push({ material : ss1, joints : _g2});
			}
		}
		this.cachedSkin.h[skin.name] = s;
		return s;
	}
	,getModelProperty: function(objName,p,def) {
		var _g = 0;
		var _g1 = this.header.models;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			if(m.name == objName) {
				if(m.props != null) {
					var _g2 = 0;
					var _g3 = m.props;
					while(_g2 < _g3.length) {
						var pr = _g3[_g2];
						++_g2;
						if(pr._hx_index == p._hx_index) {
							return Type.enumParameters(pr)[0];
						}
					}
				}
				return def;
			}
		}
		if(def == null) {
			throw haxe_Exception.thrown("Model " + objName + " not found");
		}
		return def;
	}
	,makeObject: function(loadTexture) {
		if(loadTexture == null) {
			loadTexture = function(_) {
				return h3d_mat_Texture.fromColor(16711935);
			};
		}
		if(this.header.models.length == 0) {
			throw haxe_Exception.thrown("This file does not contain any model");
		}
		var objs = [];
		var _g = 0;
		var _g1 = this.header.models;
		while(_g < _g1.length) {
			var m = _g1[_g];
			++_g;
			var obj;
			if(m.geometry < 0) {
				obj = new h3d_scene_Object();
			} else {
				var prim = this.makePrimitive(m.geometry);
				if(m.skin != null) {
					var skinData = this.makeSkin(m.skin,this.header.geometries[m.geometry]);
					skinData.primitive = prim;
					var _g2 = [];
					var _g3 = 0;
					var _g4 = m.materials;
					while(_g3 < _g4.length) {
						var mat = _g4[_g3];
						++_g3;
						_g2.push(this.makeMaterial(m,mat,loadTexture));
					}
					obj = new h3d_scene_Skin(skinData,_g2);
				} else if(m.materials.length == 1) {
					obj = new h3d_scene_Mesh(prim,this.makeMaterial(m,m.materials[0],loadTexture));
				} else {
					var _g5 = [];
					var _g6 = 0;
					var _g7 = m.materials;
					while(_g6 < _g7.length) {
						var mat1 = _g7[_g6];
						++_g6;
						_g5.push(this.makeMaterial(m,mat1,loadTexture));
					}
					obj = new h3d_scene_MultiMaterial(prim,_g5);
				}
			}
			obj.name = m.name;
			var v = m.position.toMatrix();
			obj.defaultTransform = v;
			var f = 1;
			var b = true;
			if(b) {
				obj.flags |= f;
			} else {
				obj.flags &= ~f;
			}
			objs.push(obj);
			var p = objs[m.parent];
			if(p != null) {
				p.addChild(obj);
			}
		}
		var o = objs[0];
		if(o != null) {
			var f = 256;
			o.flags |= f;
		}
		return o;
	}
	,loadAnimation: function(name) {
		var a = this.cachedAnimations.h[name == null ? "" : name];
		if(a != null) {
			return a;
		}
		var a = null;
		if(name == null) {
			if(this.header.animations.length == 0) {
				return null;
			}
			a = this.header.animations[0];
		} else {
			var _g = 0;
			var _g1 = this.header.animations;
			while(_g < _g1.length) {
				var a2 = _g1[_g];
				++_g;
				if(a2.name == name) {
					a = a2;
					break;
				}
			}
			if(a == null) {
				throw haxe_Exception.thrown("Animation " + name + " not found !");
			}
		}
		var l = this.header.version <= 2 ? this.makeLinearAnimation(a) : this.makeAnimation(a);
		l.speed = a.speed;
		l.loop = a.loop;
		if(a.events != null) {
			l.setEvents(a.events);
		}
		l.resourcePath = this.resource.entry.get_path();
		this.cachedAnimations.h[a.name] = l;
		if(name == null) {
			this.cachedAnimations.h[""] = l;
		}
		return l;
	}
	,makeAnimation: function(a) {
		var b = new h3d_anim_BufferAnimation(a.name,a.frames,a.sampling);
		var stride = 0;
		var singleFrames = [];
		var otherFrames = [];
		var _g = 0;
		var _g1 = a.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var c = b.addObject(o.name,0);
			var sm = 1;
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.SingleFrame._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.SingleFrame._hx_index;
				singleFrames.push(c);
				sm = 0;
			} else {
				otherFrames.push(c);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasPosition._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Position._hx_index;
				stride += 3 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasRotation._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Rotation._hx_index;
				stride += 3 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasScale._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Scale._hx_index;
				stride += 3 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasUV._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.UV._hx_index;
				stride += 2 * sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasAlpha._hx_index) != 0) {
				c.layout |= 1 << h3d_anim_DataLayout.Alpha._hx_index;
				stride += sm;
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
				var _g2 = 0;
				var _g3 = o.props.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var c1 = c;
					if(i > 0) {
						c1 = b.addObject(o.name,0);
						if(sm == 0) {
							singleFrames.push(c1);
						} else {
							otherFrames.push(c1);
						}
					}
					c1.layout |= 1 << h3d_anim_DataLayout.Property._hx_index;
					c1.propName = o.props[i];
					stride += sm;
				}
			}
		}
		var pos = 0;
		var _g = 0;
		while(_g < singleFrames.length) {
			var b1 = singleFrames[_g];
			++_g;
			b1.dataOffset = pos;
			pos += b1.getStride();
		}
		var singleStride = pos;
		var _g = 0;
		while(_g < otherFrames.length) {
			var b1 = otherFrames[_g];
			++_g;
			b1.dataOffset = pos;
			pos += b1.getStride();
		}
		var entry = this.resource.entry;
		var count = stride * a.frames + singleStride;
		var data = new haxe_io_Bytes(new ArrayBuffer(count * 4));
		entry.readFull(data,this.header.dataPosition + a.dataPosition,data.length);
		b.setData(new Float32Array(data.b.buffer),stride);
		return b;
	}
	,makeLinearAnimation: function(a) {
		var l = new h3d_anim_LinearAnimation(a.name,a.frames,a.sampling);
		var entry = this.resource.entry;
		var dataPos = this.header.dataPosition + a.dataPosition;
		var _g = 0;
		var _g1 = a.objects;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			var pos = (o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasPosition._hx_index) != 0;
			var rot = (o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasRotation._hx_index) != 0;
			var scale = (o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasScale._hx_index) != 0;
			if(pos || rot || scale) {
				var frameCount = a.frames;
				if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.SingleFrame._hx_index) != 0) {
					frameCount = 1;
				}
				var fl = new Array(frameCount);
				var size = ((pos ? 3 : 0) + (rot ? 3 : 0) + (scale ? 3 : 0)) * 4 * frameCount;
				var data = entry.fetchBytes(dataPos,size);
				dataPos += size;
				var p = 0;
				var _g2 = 0;
				var _g3 = frameCount;
				while(_g2 < _g3) {
					var i = _g2++;
					var f = new h3d_anim_LinearFrame();
					if(pos) {
						f.tx = data.getFloat(p);
						p += 4;
						f.ty = data.getFloat(p);
						p += 4;
						f.tz = data.getFloat(p);
						p += 4;
					} else {
						f.tx = 0;
						f.ty = 0;
						f.tz = 0;
					}
					if(rot) {
						f.qx = data.getFloat(p);
						p += 4;
						f.qy = data.getFloat(p);
						p += 4;
						f.qz = data.getFloat(p);
						p += 4;
						var qw = 1 - (f.qx * f.qx + f.qy * f.qy + f.qz * f.qz);
						f.qw = qw < 0 ? -Math.sqrt(-qw) : Math.sqrt(qw);
					} else {
						f.qx = 0;
						f.qy = 0;
						f.qz = 0;
						f.qw = 1;
					}
					if(scale) {
						f.sx = data.getFloat(p);
						p += 4;
						f.sy = data.getFloat(p);
						p += 4;
						f.sz = data.getFloat(p);
						p += 4;
					} else {
						f.sx = 1;
						f.sy = 1;
						f.sz = 1;
					}
					fl[i] = f;
				}
				l.addCurve(o.name,fl,true,rot,scale);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasUV._hx_index) != 0) {
				var fl1 = new Array(a.frames * 2);
				var size1 = 8 * a.frames;
				var data1 = entry.fetchBytes(dataPos,size1);
				dataPos += size1;
				var _g4 = 0;
				var _g5 = fl1.length;
				while(_g4 < _g5) {
					var i1 = _g4++;
					fl1[i1] = data1.getFloat(i1 * 4);
				}
				l.addUVCurve(o.name,fl1);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasAlpha._hx_index) != 0) {
				var fl2 = new Array(a.frames);
				var size2 = 4 * a.frames;
				var data2 = entry.fetchBytes(dataPos,size2);
				dataPos += size2;
				var _g6 = 0;
				var _g7 = fl2.length;
				while(_g6 < _g7) {
					var i2 = _g6++;
					fl2[i2] = data2.getFloat(i2 * 4);
				}
				l.addAlphaCurve(o.name,fl2);
			}
			if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
				var _g8 = 0;
				var _g9 = o.props;
				while(_g8 < _g9.length) {
					var p1 = _g9[_g8];
					++_g8;
					var fl3 = new Array(a.frames);
					var size3 = 4 * a.frames;
					var data3 = entry.fetchBytes(dataPos,size3);
					dataPos += size3;
					var _g10 = 0;
					var _g11 = fl3.length;
					while(_g10 < _g11) {
						var i3 = _g10++;
						fl3[i3] = data3.getFloat(i3 * 4);
					}
					l.addPropCurve(o.name,p1,fl3);
				}
			}
		}
		return l;
	}
	,loadSkin: function(geom,skin,optimize) {
		if(optimize == null) {
			optimize = true;
		}
		if(skin.vertexWeights != null) {
			return;
		}
		var bonesPerVertex = skin.bonesPerVertex;
		if(!(bonesPerVertex == 3 || bonesPerVertex == 4)) {
			throw haxe_Exception.thrown("assert");
		}
		var use4Bones = bonesPerVertex == 4;
		skin.vertexCount = geom.vertexCount;
		var format = hxd_BufferFormat.make([new hxd_BufferInput("position",3),new hxd_BufferInput("weights",3),new hxd_BufferInput("indexes",9)]);
		var data = this.getBuffers(geom,format);
		var formatStride = format.stride;
		skin.vertexWeights = new Array(skin.vertexCount * bonesPerVertex);
		skin.vertexJoints = new Array(skin.vertexCount * bonesPerVertex);
		var _g = 0;
		var _g1 = skin.boundJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			j.offsets = new h3d_col_Bounds();
		}
		var vbuf = data.vertexes;
		var idx = 0;
		var bounds_xMin = 1e20;
		var bounds_xMax = -1e20;
		var bounds_yMin = 1e20;
		var bounds_yMax = -1e20;
		var bounds_zMin = 1e20;
		var bounds_zMax = -1e20;
		var out = NaN;
		var ranges;
		if(skin.splitJoints == null) {
			var jointsByBind = [];
			var _g = 0;
			var _g1 = skin.boundJoints;
			while(_g < _g1.length) {
				var j = _g1[_g];
				++_g;
				jointsByBind[j.bindIndex] = j;
			}
			ranges = [{ index : 0, pos : 0, count : data.indexes.length, joints : jointsByBind}];
		} else {
			var idx = 0;
			var triPos = [];
			var pos = 0;
			var _g = 0;
			var _g1 = geom.indexCounts;
			while(_g < _g1.length) {
				var n = _g1[_g];
				++_g;
				triPos.push(pos);
				pos += n;
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = skin.splitJoints;
			while(_g1 < _g2.length) {
				var j = _g2[_g1];
				++_g1;
				_g.push({ index : idx, pos : triPos[idx], count : geom.indexCounts[idx++], joints : j.joints});
			}
			ranges = _g;
		}
		var _g = 0;
		while(_g < ranges.length) {
			var r = ranges[_g];
			++_g;
			var _g1 = r.pos;
			var _g2 = r.pos + r.count;
			while(_g1 < _g2) {
				var idx = _g1++;
				var vidx = data.indexes[idx];
				var p = vidx * formatStride;
				var x = vbuf[p];
				if(x != x) {
					continue;
				}
				vbuf[p++] = out;
				var y = vbuf[p++];
				var z = vbuf[p++];
				var w1 = vbuf[p++];
				var w2 = vbuf[p++];
				var w3 = vbuf[p++];
				var w4 = 0.0;
				var vout = vidx * bonesPerVertex;
				skin.vertexWeights[vout] = w1;
				skin.vertexWeights[vout + 1] = w2;
				skin.vertexWeights[vout + 2] = w3;
				if(use4Bones) {
					w4 = 1.0 - w1 - w2 - w3;
					skin.vertexWeights[vout + 3] = w4;
				}
				var w = (w1 == 0 ? 1 : 0) | (w2 == 0 ? 2 : 0) | (w3 == 0 ? 4 : 0) | (w4 == 0 ? 8 : 0);
				var idx1 = haxe_io_FPHelper.floatToI32(vbuf[p++]);
				if(x < bounds_xMin) {
					bounds_xMin = x;
				}
				if(x > bounds_xMax) {
					bounds_xMax = x;
				}
				if(y < bounds_yMin) {
					bounds_yMin = y;
				}
				if(y > bounds_yMax) {
					bounds_yMax = y;
				}
				if(z < bounds_zMin) {
					bounds_zMin = z;
				}
				if(z > bounds_zMax) {
					bounds_zMax = z;
				}
				var _g3 = 0;
				var _g4 = bonesPerVertex;
				while(_g3 < _g4) {
					var i = _g3++;
					if((w & 1 << i) != 0) {
						skin.vertexJoints[vout++] = -1;
						continue;
					}
					var idx2 = idx1 >> (i << 3) & 255;
					var j = r.joints[idx2];
					var _this = j.offsets;
					if(x < _this.xMin) {
						_this.xMin = x;
					}
					if(x > _this.xMax) {
						_this.xMax = x;
					}
					if(y < _this.yMin) {
						_this.yMin = y;
					}
					if(y > _this.yMax) {
						_this.yMax = y;
					}
					if(z < _this.zMin) {
						_this.zMin = z;
					}
					if(z > _this.zMax) {
						_this.zMax = z;
					}
					skin.vertexJoints[vout++] = j.bindIndex;
				}
			}
		}
		if(optimize) {
			var idx = skin.allJoints.length - 1;
			var optOut = 0;
			var refVolume = (bounds_xMax - bounds_xMin) * (bounds_yMax - bounds_yMin) * (bounds_zMax - bounds_zMin);
			while(idx >= 0) {
				var j = skin.allJoints[idx--];
				if(j.offsets == null || j.parent == null || j.parent.offsets == null) {
					continue;
				}
				var poff = j.parent.offsets;
				var _this = j.offsets;
				var dx = _this.xMax - _this.xMin;
				var dy = _this.yMax - _this.yMin;
				var dz = _this.zMax - _this.zMin;
				var x = (_this.xMin + _this.xMax) * 0.5;
				var y = (_this.yMin + _this.yMax) * 0.5;
				var z = (_this.zMin + _this.zMax) * 0.5;
				var r = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5;
				if(r == null) {
					r = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				var sx = x;
				var sy = y;
				var sz = z;
				var sr = r;
				if(sr == null) {
					sr = 0.;
				}
				if(sz == null) {
					sz = 0.;
				}
				if(sy == null) {
					sy = 0.;
				}
				if(sx == null) {
					sx = 0.;
				}
				var sp_x = sx;
				var sp_y = sy;
				var sp_z = sz;
				var sp_r = sr;
				if(poff.xMin <= sp_x - sp_r && poff.yMin <= sp_y - sp_r && poff.zMin <= sp_z - sp_r && poff.xMax >= sp_x + sp_r && poff.yMax >= sp_y + sp_r && poff.zMax >= sp_z + sp_r) {
					j.offsets = null;
					++optOut;
					continue;
				}
				var b = new h3d_col_Bounds();
				b.xMin = poff.xMin;
				b.xMax = poff.xMax;
				b.yMin = poff.yMin;
				b.yMax = poff.yMax;
				b.zMin = poff.zMin;
				b.zMax = poff.zMax;
				var pext = b;
				var x1 = sp_x;
				var y1 = sp_y;
				var z1 = sp_z;
				var r1 = sp_r;
				if(x1 - r1 < pext.xMin) {
					pext.xMin = x1 - r1;
				}
				if(x1 + r1 > pext.xMax) {
					pext.xMax = x1 + r1;
				}
				if(y1 - r1 < pext.yMin) {
					pext.yMin = y1 - r1;
				}
				if(y1 + r1 > pext.yMax) {
					pext.yMax = y1 + r1;
				}
				if(z1 - r1 < pext.zMin) {
					pext.zMin = z1 - r1;
				}
				if(z1 + r1 > pext.zMax) {
					pext.zMax = z1 + r1;
				}
				var ratio = Math.sqrt(refVolume * 1.5 / ((pext.xMax - pext.xMin) * (pext.yMax - pext.yMin) * (pext.zMax - pext.zMin)));
				var k = (pext.xMax - pext.xMin) * (pext.yMax - pext.yMin) * (pext.zMax - pext.zMin) / ((poff.xMax - poff.xMin) * (poff.yMax - poff.yMin) * (poff.zMax - poff.zMin));
				if(k < ratio) {
					j.parent.offsets = pext;
					j.offsets = null;
					++optOut;
					continue;
				}
			}
		}
		var _g = 0;
		var _g1 = skin.allJoints;
		while(_g < _g1.length) {
			var j = _g1[_g];
			++_g;
			if(j.offsets == null) {
				j.offsetRay = -1;
				continue;
			}
			var b = j.offsets;
			var pt1;
			var pt2;
			var x = (b.xMin + b.xMax) * 0.5;
			var y = (b.yMin + b.yMax) * 0.5;
			var z = (b.zMin + b.zMax) * 0.5;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			var x1 = x;
			var y1 = y;
			var z1 = z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			var off_x = x1;
			var off_y = y1;
			var off_z = z1;
			var r;
			if(b.xMax - b.xMin > b.yMax - b.yMin && b.xMax - b.xMin > b.zMax - b.zMin) {
				var a = b.yMax - b.yMin;
				var b1 = b.zMax - b.zMin;
				r = (a < b1 ? b1 : a) * 0.5;
				var x2 = b.xMin + r;
				var y2 = off_y;
				var z2 = off_z;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				pt1 = new h3d_VectorImpl(x2,y2,z2);
				var x3 = b.xMax - r;
				var y3 = off_y;
				var z3 = off_z;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				pt2 = new h3d_VectorImpl(x3,y3,z3);
			} else if(b.yMax - b.yMin > b.zMax - b.zMin) {
				var a1 = b.xMax - b.xMin;
				var b2 = b.zMax - b.zMin;
				r = (a1 < b2 ? b2 : a1) * 0.5;
				var x4 = off_x;
				var y4 = b.yMin + r;
				var z4 = off_z;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				pt1 = new h3d_VectorImpl(x4,y4,z4);
				var x5 = off_x;
				var y5 = b.yMax - r;
				var z5 = off_z;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				pt2 = new h3d_VectorImpl(x5,y5,z5);
			} else {
				var a2 = b.xMax - b.xMin;
				var b3 = b.yMax - b.yMin;
				r = (a2 < b3 ? b3 : a2) * 0.5;
				var x6 = off_x;
				var y6 = off_y;
				var z6 = b.zMin + r;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				pt1 = new h3d_VectorImpl(x6,y6,z6);
				var x7 = off_x;
				var y7 = off_y;
				var z7 = b.zMax - r;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				pt2 = new h3d_VectorImpl(x7,y7,z7);
			}
			b.xMin = pt1.x;
			b.yMin = pt1.y;
			b.zMin = pt1.z;
			b.xMax = pt2.x;
			b.yMax = pt2.y;
			b.zMax = pt2.z;
			j.offsetRay = r;
		}
	}
	,__class__: hxd_fmt_hmd_Library
};
var hxd_fmt_hmd_Reader = function(i) {
	this.i = i;
};
$hxClasses["hxd.fmt.hmd.Reader"] = hxd_fmt_hmd_Reader;
hxd_fmt_hmd_Reader.__name__ = "hxd.fmt.hmd.Reader";
hxd_fmt_hmd_Reader.prototype = {
	readProperty: function() {
		var _g = this.i.readByte();
		switch(_g) {
		case 0:
			return hxd_fmt_hmd_Property.CameraFOVY(this.i.readFloat());
		case 1:
			throw haxe_Exception.thrown("Obsolete HasMaterialFlags");
		case 2:
			return hxd_fmt_hmd_Property.HasExtraTextures;
		case 3:
			return hxd_fmt_hmd_Property.FourBonesByVertex;
		default:
			var unk = _g;
			throw haxe_Exception.thrown("Unknown property #" + unk);
		}
	}
	,readProps: function() {
		if(this.version == 1) {
			return null;
		}
		var n = this.i.readByte();
		if(n == 0) {
			return null;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = n;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(this.readProperty());
		}
		return _g;
	}
	,readName: function() {
		var b = this.i.readByte();
		if(b == 255) {
			return null;
		}
		return this.i.readString(b);
	}
	,readCachedName: function() {
		var name = this.readName();
		if(name == null) {
			return null;
		}
		if(hxd_fmt_hmd_Reader.HMD_STRINGS == null) {
			hxd_fmt_hmd_Reader.HMD_STRINGS = new haxe_ds_StringMap();
		}
		var n = hxd_fmt_hmd_Reader.HMD_STRINGS.h[name];
		if(n != null) {
			return n;
		}
		hxd_fmt_hmd_Reader.HMD_STRINGS.h[name] = name;
		return name;
	}
	,readPosition: function(hasScale) {
		if(hasScale == null) {
			hasScale = true;
		}
		var p = new hxd_fmt_hmd_Position();
		p.x = this.i.readFloat();
		p.y = this.i.readFloat();
		p.z = this.i.readFloat();
		p.qx = this.i.readFloat();
		p.qy = this.i.readFloat();
		p.qz = this.i.readFloat();
		if(hasScale) {
			p.sx = this.i.readFloat();
			p.sy = this.i.readFloat();
			p.sz = this.i.readFloat();
		} else {
			p.sx = 1;
			p.sy = 1;
			p.sz = 1;
		}
		return p;
	}
	,readBounds: function() {
		var b = new h3d_col_Bounds();
		b.xMin = this.i.readFloat();
		b.yMin = this.i.readFloat();
		b.zMin = this.i.readFloat();
		b.xMax = this.i.readFloat();
		b.yMax = this.i.readFloat();
		b.zMax = this.i.readFloat();
		return b;
	}
	,readSkin: function() {
		var name = this.readCachedName();
		if(name == null) {
			return null;
		}
		var s = new hxd_fmt_hmd_Skin();
		s.props = this.readProps();
		s.name = name;
		s.joints = [];
		var _g = 0;
		var _g1 = this.i.readUInt16();
		while(_g < _g1) {
			var k = _g++;
			var j = new hxd_fmt_hmd_SkinJoint();
			j.props = this.readProps();
			j.name = this.readCachedName();
			var pid = this.i.readUInt16();
			var hasScale = (pid & 32768) != 0;
			if(hasScale) {
				pid &= 32767;
			}
			j.parent = pid - 1;
			j.position = this.readPosition(hasScale);
			j.bind = this.i.readUInt16() - 1;
			if(j.bind >= 0) {
				j.transpos = this.readPosition(hasScale);
			}
			s.joints.push(j);
		}
		var count = this.i.readByte();
		if(count > 0) {
			s.split = [];
			var _g = 0;
			var _g1 = count;
			while(_g < _g1) {
				var k = _g++;
				var ss = new hxd_fmt_hmd_SkinSplit();
				ss.materialIndex = this.i.readByte();
				var _g2 = [];
				var _g3 = 0;
				var _g4 = this.i.readByte();
				while(_g3 < _g4) {
					var k1 = _g3++;
					_g2.push(this.i.readUInt16());
				}
				ss.joints = _g2;
				s.split.push(ss);
			}
		}
		return s;
	}
	,readHeader: function(fast) {
		if(fast == null) {
			fast = false;
		}
		var d = new hxd_fmt_hmd_Data();
		var h = this.i.readString(3);
		if(h != "HMD") {
			if(HxOverrides.cca(h,0) == 59) {
				throw haxe_Exception.thrown("FBX was not converted to HMD");
			}
			throw haxe_Exception.thrown("Invalid HMD header " + encodeURIComponent(h));
		}
		this.version = this.i.readByte();
		if(this.version > 3) {
			throw haxe_Exception.thrown("Can't read HMD v" + this.version);
		}
		d.version = this.version;
		d.geometries = [];
		d.dataPosition = this.i.readInt32();
		if(fast) {
			this.i = new haxe_io_BytesInput(this.i.read(d.dataPosition - 12));
		}
		d.props = this.readProps();
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var g = new hxd_fmt_hmd_Geometry();
			g.props = this.readProps();
			g.vertexCount = this.i.readInt32();
			var stride = this.i.readByte();
			var _g2 = [];
			var _g3 = 0;
			var _g4 = this.i.readByte();
			while(_g3 < _g4) {
				var k1 = _g3++;
				var name = this.readCachedName();
				var type = this.i.readByte();
				_g2.push(new hxd_BufferInput(name,type & 15,type >> 4));
			}
			g.vertexFormat = hxd_BufferFormat.make(_g2);
			if(stride != g.vertexFormat.stride) {
				throw haxe_Exception.thrown("assert");
			}
			g.vertexPosition = this.i.readInt32();
			var subCount = this.i.readByte();
			if(subCount == 255) {
				subCount = this.i.readInt32();
			}
			var _g5 = [];
			var _g6 = 0;
			var _g7 = subCount;
			while(_g6 < _g7) {
				var k2 = _g6++;
				_g5.push(this.i.readInt32());
			}
			g.indexCounts = _g5;
			g.indexPosition = this.i.readInt32();
			g.bounds = this.readBounds();
			d.geometries.push(g);
		}
		d.materials = [];
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var m = new hxd_fmt_hmd_Material();
			m.props = this.readProps();
			m.name = this.readName();
			m.diffuseTexture = this.readName();
			m.blendMode = hxd_fmt_hmd_Reader.BLEND[this.i.readByte()];
			this.i.readByte();
			this.i.readFloat();
			if(m.props != null && m.props.indexOf(hxd_fmt_hmd_Property.HasExtraTextures) >= 0) {
				m.specularTexture = this.readName();
				m.normalMap = this.readName();
			}
			d.materials.push(m);
		}
		d.models = [];
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var m = new hxd_fmt_hmd_Model();
			m.props = this.readProps();
			m.name = this.readCachedName();
			m.parent = this.i.readInt32() - 1;
			m.follow = this.readCachedName();
			m.position = this.readPosition();
			m.geometry = this.i.readInt32() - 1;
			d.models.push(m);
			if(m.geometry < 0) {
				continue;
			}
			m.materials = [];
			var matCount = this.i.readByte();
			if(matCount == 255) {
				matCount = this.i.readInt32();
			}
			var _g2 = 0;
			var _g3 = matCount;
			while(_g2 < _g3) {
				var k1 = _g2++;
				m.materials.push(this.i.readInt32());
			}
			m.skin = this.readSkin();
		}
		d.animations = [];
		var _g = 0;
		var _g1 = this.i.readInt32();
		while(_g < _g1) {
			var k = _g++;
			var a = new hxd_fmt_hmd_Animation();
			a.props = this.readProps();
			a.name = this.readName();
			a.frames = this.i.readInt32();
			a.sampling = this.i.readFloat();
			a.speed = this.i.readFloat();
			var flags = this.i.readByte();
			a.loop = (flags & 1) != 0;
			a.dataPosition = this.i.readInt32();
			a.objects = [];
			var _g2 = 0;
			var _g3 = this.i.readInt32();
			while(_g2 < _g3) {
				var k1 = _g2++;
				var o = new hxd_fmt_hmd_AnimationObject();
				o.name = this.readCachedName();
				var i = this.i.readByte();
				if(i == null) {
					i = 0;
				}
				o.flags = i;
				a.objects.push(o);
				if((o.flags & 1 << hxd_fmt_hmd_AnimationFlag.HasProps._hx_index) != 0) {
					var _g4 = [];
					var _g5 = 0;
					var _g6 = this.i.readByte();
					while(_g5 < _g6) {
						var i1 = _g5++;
						_g4.push(this.readName());
					}
					o.props = _g4;
				}
			}
			if((flags & 2) != 0) {
				a.events = [];
				var _g7 = 0;
				var _g8 = this.i.readInt32();
				while(_g7 < _g8) {
					var k2 = _g7++;
					var e = new hxd_fmt_hmd_AnimationEvent();
					e.frame = this.i.readInt32();
					e.data = this.readCachedName();
					a.events.push(e);
				}
			}
			d.animations.push(a);
		}
		return d;
	}
	,read: function() {
		var h = this.readHeader();
		h.data = this.i.read(this.i.readInt32());
		return h;
	}
	,__class__: hxd_fmt_hmd_Reader
};
var hxd_fs_FileEntry = function() { };
$hxClasses["hxd.fs.FileEntry"] = hxd_fs_FileEntry;
hxd_fs_FileEntry.__name__ = "hxd.fs.FileEntry";
hxd_fs_FileEntry.prototype = {
	getBytes: function() {
		return null;
	}
	,readBytes: function(out,outPos,pos,len) {
		throw haxe_Exception.thrown("readBytes() not implemented");
	}
	,fetchBytes: function(pos,len) {
		var bytes = hxd_fs_FileEntry.TMP_BYTES;
		if(bytes == null || bytes.length < len) {
			var allocSize = len + 65535 & -65536;
			bytes = new haxe_io_Bytes(new ArrayBuffer(allocSize));
			hxd_fs_FileEntry.TMP_BYTES = bytes;
		}
		this.readFull(bytes,pos,len);
		return bytes;
	}
	,readFull: function(bytes,pos,len) {
		if(this.readBytes(bytes,0,pos,len) < len) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	,getSign: function() {
		var bytes = this.fetchBytes(0,4);
		return bytes.b[0] | bytes.b[1] << 8 | bytes.b[2] << 16 | bytes.b[3] << 24;
	}
	,getText: function() {
		return this.getBytes().toString();
	}
	,open: function() {
		return new hxd_fs_FileInput(this);
	}
	,load: function(onReady) {
		if(!this.get_isAvailable()) {
			throw haxe_Exception.thrown("load() not implemented");
		} else if(onReady != null) {
			onReady();
		}
	}
	,loadBitmap: function(onLoaded) {
		throw haxe_Exception.thrown("loadBitmap() not implemented");
	}
	,watch: function(onChanged) {
	}
	,exists: function(name) {
		return false;
	}
	,get: function(name) {
		return null;
	}
	,iterator: function() {
		return null;
	}
	,get_isAvailable: function() {
		return true;
	}
	,get_isDirectory: function() {
		return false;
	}
	,get_size: function() {
		return 0;
	}
	,get_path: function() {
		throw haxe_Exception.thrown("path() not implemented");
	}
	,get_directory: function() {
		var idx = this.get_path().lastIndexOf("/");
		if(idx < 0) {
			return "";
		}
		return HxOverrides.substr(this.get_path(),0,idx);
	}
	,get_extension: function() {
		var idx = this.name.lastIndexOf(".");
		if(idx < 0) {
			return "";
		}
		return HxOverrides.substr(this.name,idx + 1,null).toLowerCase();
	}
	,__class__: hxd_fs_FileEntry
};
var hxd_fs_BytesFileEntry = function(path,bytes) {
	this.fullPath = path;
	this.name = path.split("/").pop();
	this.bytes = bytes;
};
$hxClasses["hxd.fs.BytesFileEntry"] = hxd_fs_BytesFileEntry;
hxd_fs_BytesFileEntry.__name__ = "hxd.fs.BytesFileEntry";
hxd_fs_BytesFileEntry.__super__ = hxd_fs_FileEntry;
hxd_fs_BytesFileEntry.prototype = $extend(hxd_fs_FileEntry.prototype,{
	get_path: function() {
		return this.fullPath;
	}
	,getBytes: function() {
		return this.bytes;
	}
	,readBytes: function(out,outPos,pos,len) {
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	,load: function(onReady) {
		haxe_Timer.delay(onReady,1);
	}
	,loadBitmap: function(onLoaded) {
		var mime;
		switch(haxe_io_Path.extension(this.fullPath).toLowerCase()) {
		case "gif":
			mime = "image/gif";
			break;
		case "jpeg":case "jpg":
			mime = "image/jpeg";
			break;
		case "png":
			mime = "image/png";
			break;
		default:
			throw haxe_Exception.thrown("Cannot determine image encoding, try adding an extension to the resource path");
		}
		var img = new Image();
		img.onload = function() {
			onLoaded(img);
		};
		var tmp = haxe_crypto_Base64.encode(this.bytes);
		img.src = "data:" + mime + ";base64," + tmp;
	}
	,exists: function(name) {
		return false;
	}
	,get: function(name) {
		return null;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry([]);
	}
	,get_size: function() {
		return this.bytes.length;
	}
	,__class__: hxd_fs_BytesFileEntry
});
var hxd_fs_FileSystem = function() { };
$hxClasses["hxd.fs.FileSystem"] = hxd_fs_FileSystem;
hxd_fs_FileSystem.__name__ = "hxd.fs.FileSystem";
hxd_fs_FileSystem.__isInterface__ = true;
hxd_fs_FileSystem.prototype = {
	__class__: hxd_fs_FileSystem
};
var hxd_fs_BytesFileSystem = function() {
};
$hxClasses["hxd.fs.BytesFileSystem"] = hxd_fs_BytesFileSystem;
hxd_fs_BytesFileSystem.__name__ = "hxd.fs.BytesFileSystem";
hxd_fs_BytesFileSystem.__interfaces__ = [hxd_fs_FileSystem];
hxd_fs_BytesFileSystem.prototype = {
	getRoot: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getBytes: function(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,exists: function(path) {
		return this.getBytes(path) != null;
	}
	,get: function(path) {
		var bytes = this.getBytes(path);
		if(bytes == null) {
			throw haxe_Exception.thrown("Resource not found '" + path + "'");
		}
		return new hxd_fs_BytesFileEntry(path,bytes);
	}
	,dispose: function() {
	}
	,dir: function(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,__class__: hxd_fs_BytesFileSystem
};
var hxd_fs__$EmbedFileSystem_EmbedEntry = function(fs,name,relPath,data) {
	this.fs = fs;
	this.name = name;
	this.relPath = relPath;
	this.data = data;
};
$hxClasses["hxd.fs._EmbedFileSystem.EmbedEntry"] = hxd_fs__$EmbedFileSystem_EmbedEntry;
hxd_fs__$EmbedFileSystem_EmbedEntry.__name__ = "hxd.fs._EmbedFileSystem.EmbedEntry";
hxd_fs__$EmbedFileSystem_EmbedEntry.__super__ = hxd_fs_FileEntry;
hxd_fs__$EmbedFileSystem_EmbedEntry.prototype = $extend(hxd_fs_FileEntry.prototype,{
	init: function() {
		if(this.bytes == null) {
			this.bytes = haxe_Resource.getBytes(this.data);
			if(this.bytes == null) {
				throw haxe_Exception.thrown("Missing resource " + this.data);
			}
		}
	}
	,getBytes: function() {
		if(this.bytes == null) {
			this.init();
		}
		return this.bytes;
	}
	,readBytes: function(out,outPos,pos,len) {
		if(this.bytes == null) {
			this.init();
		}
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	,load: function(onReady) {
		if(onReady != null) {
			haxe_Timer.delay(onReady,1);
		}
	}
	,loadBitmap: function(onLoaded) {
		var rawData = null;
		var _g = 0;
		var _g1 = haxe_Resource.content;
		while(_g < _g1.length) {
			var res = _g1[_g];
			++_g;
			if(res.name == this.data) {
				rawData = res.data;
				break;
			}
		}
		if(rawData == null) {
			throw haxe_Exception.thrown("Missing resource " + this.data);
		}
		var image = new Image();
		image.onload = function(_) {
			onLoaded(image);
		};
		var extra = "";
		var bytes = rawData.length * 6 >> 3;
		var _g = 0;
		var _g1 = (3 - bytes * 4 % 3) % 3;
		while(_g < _g1) {
			var i = _g++;
			extra += "=";
		}
		var tmp = "data:image/" + this.get_extension() + ";base64," + rawData;
		image.src = tmp + extra;
	}
	,get_isDirectory: function() {
		return this.fs.isDirectory(this.relPath);
	}
	,get_path: function() {
		if(this.relPath == ".") {
			return "<root>";
		} else {
			return this.relPath;
		}
	}
	,exists: function(name) {
		return this.fs.exists(this.relPath == "." ? name : this.relPath + "/" + name);
	}
	,get: function(name) {
		return this.fs.get(this.relPath == "." ? name : this.relPath + "/" + name);
	}
	,get_size: function() {
		this.init();
		return this.bytes.length;
	}
	,iterator: function() {
		return new hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry(this.fs.subFiles(this.relPath));
	}
	,__class__: hxd_fs__$EmbedFileSystem_EmbedEntry
});
var hxd_fs_EmbedFileSystem = function(root) {
	this.root = root;
};
$hxClasses["hxd.fs.EmbedFileSystem"] = hxd_fs_EmbedFileSystem;
hxd_fs_EmbedFileSystem.__name__ = "hxd.fs.EmbedFileSystem";
hxd_fs_EmbedFileSystem.__interfaces__ = [hxd_fs_FileSystem];
hxd_fs_EmbedFileSystem.resolve = function(path) {
	return "R_" + path.replace(hxd_fs_EmbedFileSystem.invalidChars.r,"_");
};
hxd_fs_EmbedFileSystem.prototype = {
	getRoot: function() {
		return new hxd_fs__$EmbedFileSystem_EmbedEntry(this,"root",".",null);
	}
	,splitPath: function(path) {
		if(path == ".") {
			return [];
		} else {
			return path.split("/");
		}
	}
	,subFiles: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
		}
		if(r == null) {
			throw haxe_Exception.thrown(path + " is not a directory");
		}
		var fields = Reflect.fields(r);
		fields.sort(Reflect.compare);
		var _g = [];
		var _g1 = 0;
		while(_g1 < fields.length) {
			var name = fields[_g1];
			++_g1;
			_g.push(this.get(path == "." ? name : path + "/" + name));
		}
		return _g;
	}
	,isDirectory: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
		}
		if(r != null) {
			return r != true;
		} else {
			return false;
		}
	}
	,exists: function(path) {
		var r = this.root;
		var _g = 0;
		var _g1 = this.splitPath(path);
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r = Reflect.field(r,p);
			if(r == null) {
				return false;
			}
		}
		return true;
	}
	,get: function(path) {
		if(!this.exists(path)) {
			throw haxe_Exception.thrown(new hxd_fs_NotFound(path));
		}
		var id = hxd_fs_EmbedFileSystem.resolve(path);
		return new hxd_fs__$EmbedFileSystem_EmbedEntry(this,path.split("/").pop(),path,id);
	}
	,dispose: function() {
	}
	,dir: function(path) {
		return this.subFiles(path);
	}
	,__class__: hxd_fs_EmbedFileSystem
};
var hxd_fs_FileInput = function(entry) {
	this.nextReadPos = 0;
	this.cacheLen = 0;
	this.cachePos = 0;
	this.entry = entry;
};
$hxClasses["hxd.fs.FileInput"] = hxd_fs_FileInput;
hxd_fs_FileInput.__name__ = "hxd.fs.FileInput";
hxd_fs_FileInput.__super__ = haxe_io_Input;
hxd_fs_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	fetch: function(dataSize) {
		if(dataSize == null) {
			dataSize = 256;
		}
		var prev = this.cache;
		if(this.cache == null || this.cache.length < dataSize) {
			this.cache = hxd_fs_FileInput.PREFETCH_CACHE;
			if(this.cache != null && this.cache.length >= dataSize) {
				hxd_fs_FileInput.PREFETCH_CACHE = null;
			} else {
				this.cache = new haxe_io_Bytes(new ArrayBuffer(dataSize));
			}
		}
		var startPos = 0;
		if(this.cacheLen > 0) {
			startPos = this.cacheLen;
			dataSize -= this.cacheLen;
			this.cache.blit(0,prev,this.cachePos,this.cacheLen);
		}
		var read = this.entry.readBytes(this.cache,startPos,this.nextReadPos,dataSize);
		this.cachePos = 0;
		this.cacheLen = startPos + read;
		this.nextReadPos += read;
		if(this.cacheLen == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	,skip: function(nbytes) {
		if(this.cacheLen > 0) {
			var a = this.cacheLen;
			var k = a > nbytes ? nbytes : a;
			this.cachePos += k;
			this.cacheLen -= k;
			nbytes -= k;
		}
		this.nextReadPos += nbytes;
	}
	,readByte: function() {
		if(this.cacheLen == 0) {
			this.fetch();
		}
		var b = this.cache.b[this.cachePos++];
		this.cacheLen--;
		return b;
	}
	,readBytes: function(b,pos,len) {
		var tot = 0;
		if(len < 256 && this.cacheLen < len) {
			this.fetch();
		}
		if(this.cacheLen > 0) {
			var b1 = this.cacheLen;
			var k = len > b1 ? b1 : len;
			b.blit(pos,this.cache,this.cachePos,k);
			this.cachePos += k;
			this.cacheLen -= k;
			len -= k;
			if(len == 0) {
				return k;
			}
			pos += k;
			tot += k;
		}
		if(len > 0) {
			var k = this.entry.readBytes(b,pos,this.nextReadPos,len);
			this.nextReadPos += k;
			tot += k;
		}
		return tot;
	}
	,close: function() {
		if(this.cache != null && (hxd_fs_FileInput.PREFETCH_CACHE == null || hxd_fs_FileInput.PREFETCH_CACHE.length < this.cache.length)) {
			hxd_fs_FileInput.PREFETCH_CACHE = this.cache;
		}
		this.cache = null;
		this.cacheLen = 0;
	}
	,__class__: hxd_fs_FileInput
});
var hxd_fs_LoadedBitmap = {};
hxd_fs_LoadedBitmap._new = function(data) {
	return data;
};
hxd_fs_LoadedBitmap.toBitmap = function(this1) {
	var bmp = new hxd_BitmapData(this1.width,this1.height);
	bmp.ctx.drawImage(this1,0,0);
	return bmp;
};
hxd_fs_LoadedBitmap.toNative = function(this1) {
	return this1;
};
var hxd_fs_NotFound = function(path) {
	this.path = path;
};
$hxClasses["hxd.fs.NotFound"] = hxd_fs_NotFound;
hxd_fs_NotFound.__name__ = "hxd.fs.NotFound";
hxd_fs_NotFound.prototype = {
	toString: function() {
		return "Resource file not found '" + this.path + "'";
	}
	,__class__: hxd_fs_NotFound
};
var hxd_impl_BufferFlags = {};
hxd_impl_BufferFlags.toInt = function(this1) {
	return this1;
};
var hxd_impl_Allocator = function() {
};
$hxClasses["hxd.impl.Allocator"] = hxd_impl_Allocator;
hxd_impl_Allocator.__name__ = "hxd.impl.Allocator";
hxd_impl_Allocator.set = function(a) {
	hxd_impl_Allocator.inst = a;
};
hxd_impl_Allocator.get = function() {
	if(hxd_impl_Allocator.inst == null) {
		hxd_impl_Allocator.inst = new hxd_impl_Allocator();
	}
	return hxd_impl_Allocator.inst;
};
hxd_impl_Allocator.prototype = {
	allocBuffer: function(vertices,format,flags) {
		if(flags == null) {
			flags = 0;
		}
		var tmp;
		switch(flags) {
		case 0:
			tmp = [h3d_BufferFlag.Dynamic];
			break;
		case 1:
			tmp = null;
			break;
		case 2:
			tmp = [h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.Dynamic];
			break;
		}
		return new h3d_Buffer(vertices,format,tmp);
	}
	,ofFloats: function(v,format,flags) {
		if(flags == null) {
			flags = 0;
		}
		var nvert = v.pos / format.stride | 0;
		return this.ofSubFloats(v,nvert,format,flags);
	}
	,ofSubFloats: function(v,vertices,format,flags) {
		if(flags == null) {
			flags = 0;
		}
		var b = this.allocBuffer(vertices,format,flags);
		b.uploadFloats(v,0,vertices);
		return b;
	}
	,disposeBuffer: function(b) {
		b.dispose();
	}
	,allocIndexBuffer: function(count) {
		return h3d_Indexes._new(count);
	}
	,ofIndexes: function(ib,length) {
		if(length == null) {
			length = -1;
		}
		if(length < 0 && ib != null) {
			length = ib.length;
		}
		var idx = this.allocIndexBuffer(length);
		h3d_Indexes.uploadIndexes(idx,ib,0,length);
		return idx;
	}
	,disposeIndexBuffer: function(i) {
		i.dispose();
	}
	,onContextLost: function() {
	}
	,allocFloats: function(count) {
		var length = count;
		if(length == null) {
			length = 0;
		}
		return hxd__$FloatBuffer_Float32Expand._new(length);
	}
	,disposeFloats: function(f) {
	}
	,allocIndexes: function(count) {
		var length = count;
		if(length == null) {
			length = 0;
		}
		return new Array(length);
	}
	,disposeIndexes: function(i) {
	}
	,__class__: hxd_impl_Allocator
};
var hxd_impl_ArrayIterator = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator"] = hxd_impl_ArrayIterator;
hxd_impl_ArrayIterator.__name__ = "hxd.impl.ArrayIterator";
hxd_impl_ArrayIterator.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator
};
var hxd_impl_ArrayIterator_$h2d_$Object = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_Object"] = hxd_impl_ArrayIterator_$h2d_$Object;
hxd_impl_ArrayIterator_$h2d_$Object.__name__ = "hxd.impl.ArrayIterator_h2d_Object";
hxd_impl_ArrayIterator_$h2d_$Object.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$Object
};
var hxd_impl_ArrayIterator_$h2d_$col_$IPoint = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_IPoint"] = hxd_impl_ArrayIterator_$h2d_$col_$IPoint;
hxd_impl_ArrayIterator_$h2d_$col_$IPoint.__name__ = "hxd.impl.ArrayIterator_h2d_col_IPoint";
hxd_impl_ArrayIterator_$h2d_$col_$IPoint.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$IPoint
};
var hxd_impl_ArrayIterator_$h2d_$col_$IPolygon = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_IPolygon"] = hxd_impl_ArrayIterator_$h2d_$col_$IPolygon;
hxd_impl_ArrayIterator_$h2d_$col_$IPolygon.__name__ = "hxd.impl.ArrayIterator_h2d_col_IPolygon";
hxd_impl_ArrayIterator_$h2d_$col_$IPolygon.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$IPolygon
};
var hxd_impl_ArrayIterator_$h2d_$col_$Point = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_Point"] = hxd_impl_ArrayIterator_$h2d_$col_$Point;
hxd_impl_ArrayIterator_$h2d_$col_$Point.__name__ = "hxd.impl.ArrayIterator_h2d_col_Point";
hxd_impl_ArrayIterator_$h2d_$col_$Point.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$Point
};
var hxd_impl_ArrayIterator_$h2d_$col_$Polygon = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_Polygon"] = hxd_impl_ArrayIterator_$h2d_$col_$Polygon;
hxd_impl_ArrayIterator_$h2d_$col_$Polygon.__name__ = "hxd.impl.ArrayIterator_h2d_col_Polygon";
hxd_impl_ArrayIterator_$h2d_$col_$Polygon.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$Polygon
};
var hxd_impl_ArrayIterator_$h2d_$col_$Segment = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h2d_col_Segment"] = hxd_impl_ArrayIterator_$h2d_$col_$Segment;
hxd_impl_ArrayIterator_$h2d_$col_$Segment.__name__ = "hxd.impl.ArrayIterator_h2d_col_Segment";
hxd_impl_ArrayIterator_$h2d_$col_$Segment.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h2d_$col_$Segment
};
var hxd_impl_ArrayIterator_$h3d_$scene_$Object = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_h3d_scene_Object"] = hxd_impl_ArrayIterator_$h3d_$scene_$Object;
hxd_impl_ArrayIterator_$h3d_$scene_$Object.__name__ = "hxd.impl.ArrayIterator_h3d_scene_Object";
hxd_impl_ArrayIterator_$h3d_$scene_$Object.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$h3d_$scene_$Object
};
var hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_fs_FileEntry"] = hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry;
hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry.__name__ = "hxd.impl.ArrayIterator_hxd_fs_FileEntry";
hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry
};
var hxd_impl_ArrayIterator_$hxd_$res_$Any = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_res_Any"] = hxd_impl_ArrayIterator_$hxd_$res_$Any;
hxd_impl_ArrayIterator_$hxd_$res_$Any.__name__ = "hxd.impl.ArrayIterator_hxd_res_Any";
hxd_impl_ArrayIterator_$hxd_$res_$Any.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$res_$Any
};
var hxd_impl_ArrayIterator_$hxd_$snd_$Channel = function(a) {
	this.i = 0;
	this.a = a;
	this.l = this.a.length;
};
$hxClasses["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_$hxd_$snd_$Channel;
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.__name__ = "hxd.impl.ArrayIterator_hxd_snd_Channel";
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.prototype = {
	hasNext: function() {
		return this.i < this.l;
	}
	,next: function() {
		return this.a[this.i++];
	}
	,__class__: hxd_impl_ArrayIterator_$hxd_$snd_$Channel
};
var hxd_impl_AsyncLoader = function() { };
$hxClasses["hxd.impl.AsyncLoader"] = hxd_impl_AsyncLoader;
hxd_impl_AsyncLoader.__name__ = "hxd.impl.AsyncLoader";
hxd_impl_AsyncLoader.__isInterface__ = true;
hxd_impl_AsyncLoader.prototype = {
	__class__: hxd_impl_AsyncLoader
};
var hxd_impl_BitSet = {};
hxd_impl_BitSet._new = function(count) {
	return new haxe_io_Bytes(new ArrayBuffer(count + 7 >> 3));
};
hxd_impl_BitSet.get = function(this1,index) {
	return (this1.b[index >> 3] & 1 << (index & 7)) != 0;
};
hxd_impl_BitSet.set = function(this1,index) {
	var p = index >> 3;
	this1.b[p] |= 1 << (index & 7);
};
hxd_impl_BitSet.unset = function(this1,index) {
	var p = index >> 3;
	this1.b[p] &= ~(1 << (index & 7));
};
hxd_impl_BitSet.toggle = function(this1,index,b) {
	var p = index >> 3;
	var v = this1.b[p];
	var mask = 1 << (index & 7);
	this1.b[p] = b ? v | mask : v & ~mask;
};
hxd_impl_BitSet.clear = function(this1,b) {
	if(b == null) {
		b = false;
	}
	this1.fill(0,this1.length,b ? 255 : 0);
};
var hxd_impl_MouseMode = $hxEnums["hxd.impl.MouseMode"] = { __ename__:"hxd.impl.MouseMode",__constructs__:null
	,Absolute: {_hx_name:"Absolute",_hx_index:0,__enum__:"hxd.impl.MouseMode",toString:$estr}
	,Relative: ($_=function(callback,restorePos) { return {_hx_index:1,callback:callback,restorePos:restorePos,__enum__:"hxd.impl.MouseMode",toString:$estr}; },$_._hx_name="Relative",$_.__params__ = ["callback","restorePos"],$_)
	,AbsoluteUnbound: ($_=function(restorePos) { return {_hx_index:2,restorePos:restorePos,__enum__:"hxd.impl.MouseMode",toString:$estr}; },$_._hx_name="AbsoluteUnbound",$_.__params__ = ["restorePos"],$_)
};
hxd_impl_MouseMode.__constructs__ = [hxd_impl_MouseMode.Absolute,hxd_impl_MouseMode.Relative,hxd_impl_MouseMode.AbsoluteUnbound];
hxd_impl_MouseMode.__empty_constructs__ = [hxd_impl_MouseMode.Absolute];
var hxd_impl_UncheckedBytes = {};
hxd_impl_UncheckedBytes._new = function(v) {
	return v;
};
hxd_impl_UncheckedBytes.get = function(this1,i) {
	return this1[i];
};
hxd_impl_UncheckedBytes.set = function(this1,i,v) {
	this1[i] = v;
	return v;
};
hxd_impl_UncheckedBytes.fromBytes = function(b) {
	return b.b;
};
var hxd_poly2tri_Edge = function(p1,p2) {
	if(p1 == null || p2 == null) {
		throw haxe_Exception.thrown("Edge::new p1 or p2 is null");
	}
	var swap = false;
	if(p1.y > p2.y) {
		swap = true;
	} else if(p1.y == p2.y) {
		if(p1.x == p2.x) {
			throw haxe_Exception.thrown("Edge::repeat points " + Std.string(p1));
		}
		swap = p1.x > p2.x;
	}
	if(swap) {
		this.q = p1;
		this.p = p2;
	} else {
		this.p = p1;
		this.q = p2;
	}
	this.q.get_edge_list().push(this);
};
$hxClasses["hxd.poly2tri.Edge"] = hxd_poly2tri_Edge;
hxd_poly2tri_Edge.__name__ = "hxd.poly2tri.Edge";
hxd_poly2tri_Edge.prototype = {
	toString: function() {
		return "Edge(" + Std.string(this.p) + ", " + Std.string(this.q) + ")";
	}
	,__class__: hxd_poly2tri_Edge
};
var hxd_poly2tri_Point = function(x,y) {
	this.x = x;
	this.y = y;
	this.id = hxd_poly2tri_Point.C_ID;
	hxd_poly2tri_Point.C_ID++;
};
$hxClasses["hxd.poly2tri.Point"] = hxd_poly2tri_Point;
hxd_poly2tri_Point.__name__ = "hxd.poly2tri.Point";
hxd_poly2tri_Point.sortPoints = function(points) {
	points.sort(hxd_poly2tri_Point.cmpPoints);
};
hxd_poly2tri_Point.cmpPoints = function(l,r) {
	var ret = l.y - r.y;
	if(ret == 0) {
		ret = l.x - r.x;
	}
	if(ret < 0) {
		return -1;
	}
	if(ret > 0) {
		return 1;
	}
	return 0;
};
hxd_poly2tri_Point.prototype = {
	get_edge_list: function() {
		if(this.edge_list == null) {
			this.edge_list = [];
		}
		return this.edge_list;
	}
	,equals: function(that) {
		if(this.x == that.x) {
			return this.y == that.y;
		} else {
			return false;
		}
	}
	,toString: function() {
		return "Point(" + this.x + ", " + this.y + ")";
	}
	,__class__: hxd_poly2tri_Point
};
var hxd_res__$Any_SingleFileSystem = function(path,bytes) {
	hxd_fs_BytesFileSystem.call(this);
	this.path = path;
	this.bytes = bytes;
};
$hxClasses["hxd.res._Any.SingleFileSystem"] = hxd_res__$Any_SingleFileSystem;
hxd_res__$Any_SingleFileSystem.__name__ = "hxd.res._Any.SingleFileSystem";
hxd_res__$Any_SingleFileSystem.__super__ = hxd_fs_BytesFileSystem;
hxd_res__$Any_SingleFileSystem.prototype = $extend(hxd_fs_BytesFileSystem.prototype,{
	getBytes: function(p) {
		if(p == this.path) {
			return this.bytes;
		} else {
			return null;
		}
	}
	,__class__: hxd_res__$Any_SingleFileSystem
});
var hxd_res_Resource = function(entry) {
	this.entry = entry;
};
$hxClasses["hxd.res.Resource"] = hxd_res_Resource;
hxd_res_Resource.__name__ = "hxd.res.Resource";
hxd_res_Resource.prototype = {
	get_name: function() {
		return this.entry.name;
	}
	,toString: function() {
		return this.entry.get_path();
	}
	,watch: function(onChanged) {
		if(hxd_res_Resource.LIVE_UPDATE) {
			this.entry.watch(onChanged);
		}
	}
	,__class__: hxd_res_Resource
};
var hxd_res_Any = function(loader,entry) {
	hxd_res_Resource.call(this,entry);
	this.loader = loader;
};
$hxClasses["hxd.res.Any"] = hxd_res_Any;
hxd_res_Any.__name__ = "hxd.res.Any";
hxd_res_Any.fromBytes = function(path,bytes) {
	var fs = new hxd_res__$Any_SingleFileSystem(path,bytes);
	return new hxd_res_Loader(fs).load(path);
};
hxd_res_Any.__super__ = hxd_res_Resource;
hxd_res_Any.prototype = $extend(hxd_res_Resource.prototype,{
	toModel: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Model);
	}
	,toTexture: function() {
		return this.toImage().toTexture();
	}
	,toTile: function() {
		return this.toImage().toTile();
	}
	,toText: function() {
		return this.entry.getText();
	}
	,toImage: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Image);
	}
	,toSound: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Sound);
	}
	,toPrefab: function() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Resource);
	}
	,to: function(c) {
		return this.loader.loadCache(this.entry.get_path(),c);
	}
	,iterator: function() {
		var _g = [];
		var _g1 = this.entry.iterator();
		while(_g1.i < _g1.l) {
			var f = _g1.a[_g1.i++];
			_g.push(new hxd_res_Any(this.loader,f));
		}
		return new hxd_impl_ArrayIterator_$hxd_$res_$Any(_g);
	}
	,__class__: hxd_res_Any
});
var hxd_res_BitmapFont = function(entry) {
	hxd_res_Resource.call(this,entry);
	this.loader = hxd_res_Loader.currentInstance;
};
$hxClasses["hxd.res.BitmapFont"] = hxd_res_BitmapFont;
hxd_res_BitmapFont.__name__ = "hxd.res.BitmapFont";
hxd_res_BitmapFont.__super__ = hxd_res_Resource;
hxd_res_BitmapFont.prototype = $extend(hxd_res_Resource.prototype,{
	toFont: function() {
		if(this.font == null) {
			this.font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveTile));
		}
		return this.font;
	}
	,toSdfFont: function(size,channel,alphaCutoff,smoothing) {
		if(smoothing == null) {
			smoothing = -1;
		}
		if(alphaCutoff == null) {
			alphaCutoff = 0.5;
		}
		if(channel == null) {
			channel = 0;
		}
		if(this.sdfFonts == null) {
			this.sdfFonts = [];
		}
		if(size == null) {
			size = this.toFont().size;
		}
		var _g = 0;
		var _g1 = this.sdfFonts;
		while(_g < _g1.length) {
			var font = _g1[_g];
			++_g;
			var _g2 = font.type;
			if(_g2._hx_index == 1) {
				var fchannel = _g2.channel;
				var falphaCutoff = _g2.alphaCutoff;
				var fsmoothing = _g2.smoothing;
				if(font.size == size && fchannel == channel && falphaCutoff == alphaCutoff && fsmoothing == smoothing) {
					return font;
				}
			}
		}
		var font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveSdfTile));
		font.type = h2d_FontType.SignedDistanceField(channel,alphaCutoff,smoothing);
		font.resizeTo(size);
		this.sdfFonts.push(font);
		return font;
	}
	,resolveSdfTile: function(path) {
		var tex = this.loader.load(path).toTexture();
		tex.set_filter(h3d_mat_Filter.Linear);
		return h2d_Tile.fromTexture(tex);
	}
	,resolveTile: function(path) {
		return this.loader.load(path).toTile();
	}
	,__class__: hxd_res_BitmapFont
});
var hxd_res_DefaultFont = function() { };
$hxClasses["hxd.res.DefaultFont"] = hxd_res_DefaultFont;
hxd_res_DefaultFont.__name__ = "hxd.res.DefaultFont";
hxd_res_DefaultFont.get = function() {
	var engine = h3d_Engine.CURRENT;
	var fnt = engine.resCache.h[hxd_res_DefaultFont.__id__];
	if(fnt == null) {
		var BYTES = hxd_res_Any.fromBytes("hxd/res/defaultFont.png",haxe_Unserializer.run("s3176:iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAACPBJREFUeJztnelypDoMRp2p%:6v3PNjhrlCLX1aLIPBPlWppI03bCG0QOfn8:m0zbr8KupnS9FDqRKAzUOhAvBRfqO:tfrSZ86H:ET79o6Rhc%JzzNSD7Xn:XyEH9RPtP4X:6GDDj6ttR:Hb62d9pmX8b487StA4:DFlup5z5MSWS%tL:f6eG4BXDppGQdtApJEtPm0zkf427Oo1fAxtfO2hDIruGXCLgnAD:jNyzSsKxa18yBphyqQ1jqwBN1zHmgcU3V3jHui9xaArkS0%XzTohOX%jvGauzvjMrlUJXuqSeV07G0ekgTovWS1t61vr0CQAez7nkj7uFIELJqmdN7RWvzil7hnnXV5qLOzSMAmlcQub9ZRuEsaNoq0w5RZbN0rye1ASzplWyAiGEXQVK3kZOdRcgy9:FLoRogI02WNc7rRQw3jzsZAfWB7skR44%3jdo6Wv2qfr4rFuUCZlftrT1jjpezSih4b75ClQDMvrizz%82uA1wMCqsKvUv3YO045rxma2vjY3mpPUvuV1WKDzbLtqfNu9:AjA6tl69QM3Zn1Wfl1M8G:CUW4s6b%sWIEXWtM:omNeXrnaDRm:OyIsE1UOfQ1gCwMOLdFCqWnj8Grl5nsjVakRjHMj1DgnEcQvw%OV0AE0wGisfqTKrbBYrZ4BiB:T4ldE8dPsMxU2oEWgZZtoAyMCq2GxtLlWCFbEB%PGIYWv1kxECq0%TbDKITjpirVr9SW2zC:skqqKdUp%QwwbILKwlgZk2mkBlmUVgPPOI3IbL0GwASY2PiMdbPrfVF6:vVctIq5SoVqNdxtrvWXt1:EguYHVL:ZV4Q8F781%KVwD25r8UagTyYE4TjkllmfrU4udtI%XZdrRcm5c1T%3cPXjq9RqEYTewIrau1a%ODVSBomgeL4cLudedG%H2pah4KBQx8gSnWMC:8AvDKwS0fXU5n59Uf7gAXA1dfG1TtM1Bm2ZtKi%PCGaVlpXKrf67ngeI%uFXoW1WdvNH0ztuV3vNBvAOrC30wR0LG7kX0:p3MjoCqPYfiQNI3BK%BEhq31vfYtS5UkN5lCD%NGWMSBxAWyyeyKkAJYc2Z6JrfqpvGYF0IzxqNWoDoPrSeNJ8POMgtJg76rtSEyDNErGzUF5F3ZOq9wI2D%VtbuBsaFfkNGwBGMtUmy3BjUAtxs3x3LOk8mi7zWB6Xw7leCNlb%LRXkrk%wEOpESIlezxlvM%uSWuzQXNx1Ofjqd5Aah:qW5PGDfbjpZzRCGlbwZ5T0TqMHMVoLgCP56Nj0fqo7mhLOeMGoDPx4wE0sW64mRmXLSDaCZvxPjSeNnAGKx:hxcw8%a3Zkc7tTqjyWgbs:4d3w8wW:7AC42l3zF:dH9H9SGedwO9rmEEz4nMpCXuznFoSS5tf9x9e24ByFjqodKAQio6EjfP9C8duzLHoZ0r8oD%LzRyAZY1XN2umux8n0L3OkeygcdnDzMYTSvQvc47G7g4q3xL2EqE8jhbAN6H9YDJ6TaxBeCduJNy3AjkrghySay8QXOU84lZSQ8plj:ioYuIG%axvLUrcoRxHHGHXelgKzkTWSxtLK:7whM8UaGLzs3qJ7P5IxNI0axh%hbAgxhWMGJ01M%KVKIASXQcipVR7MEz524XboQNoKVwPZPNhkpRjD5yRdM53B0c0qKDvE4X9PVw78JYWPc7usEo9cm1TAa0%R:hh44n1UXz1sjaB0dbJATdGoB:R1Dv:c4DGktSez33TNqW96MZtVo:R53sPLQxvGseCWu7y2d7Kji70MgQRUIwM5nNb%1bc8HyK%MAHiMtq2q5ypaOS39rdTz9jMaac4kg87eDpSsp4%bx:iS3UZLOqMQPM44Y3jGuSoCVabERyaCsj:90qs7TG1soWePZbICViWharvnSgrfTwYsz0gjckvUApHcDOdwa9waDvIGjCFZ:2vwzfVeGj7W%qs4ns0ettbMASJvG:WfJ%JAGHOVvI6GSxtMEUfNENK%FH%NtNaz1qzif7B79mcC2AdbG8zVxyNqMtrGkTQqZWmHUqvJjDJg%BZ9Rf552I8qtY%a:jUMnEG3j9V1RvWgUryfqFyXql1etX2aP:vGER8JWCCLdxhME4OlMbWTdLQCRhA%qX1WegVrZEbtjCjQjsDnKM200Y8nLjDaAx%WdVgg8:zfQY%1620Q8grcxpRDcfQvwMN2ivYm7s4GSRkGZLuRvV5T3AP1tAe08q8qtY38KJo4Ejgglbxh3awCJQyL35l:AjAKwN:5CKozAqpRm7zibBBUCMDJFi:p5GlMKcJUbGAm4aIkdlPCpttK9xz1RxMhzAdVCkDmnE5H:GURPXLta7ypHcz248%GLWR6Q%cL7ZdHRVOddWHPt1VRWX6O1mERXuNt6HmBmooGXnlB178MX3vIr5nhCejkUbf7VhgyalyWwngcjqsorxxg5xy%oDeDZ:Du0Qub%2aP6M%XVfSFK90D6ihjranoC2pUgUVVe0VdUw2bmeEKyASx1OwvWfQ7dPqi1XlFe1Vd0nbu1C:%HEeEObuSH:LyRKzSW6QZKvjDXDNKxqvIsR19a:624vKKvW9Zy5nTw5swQO2zGbODmDNdmpWwBmJ%hNo7n7WAJ5L703FN4DD:Sr3RcK6uar0XVnHvHUbHeDqadawaLFA3jbTwW6tH2aC%5oqgfLXYRGcOab5SKOVvz8sY75AneZATyQd:qyt1ByFjkGoCrR6u8gXLtc2tn:51qD22s7Pwi5Z5jEryNtS6jy6U5qfS8HZwFTWp0ogWdj3Wu0nmPWJ8K3HO62gvoul:dhKbBPPWmp:fdwBXwXNGa8TY92ruBzVG%GpoqnUXtp9CeCdza4JvZLhDqyqb3hT8RRDtH5VmyavKKREn0XCW1f3WiDKWmpTpf7GTQc:F6OpCdC3guJdp5C8CzkTY9JAg8Ekh:bxaAPxVMf28WgP7XMMrWAovwhO8I2gxkC8DibAFYnC0Ai6OFgjeL4Pmm0M2L0dzAzSJY2cDNy:E8ELJ5MdsLWJwtAIuzBWBxtgAszhaAxdkCsDi:AYnqZwd25SoPAAAAAElFTkSuQmCC"));
		var DESC = hxd_res_Any.fromBytes("hxd/res/defaultFont.fnt",haxe_Unserializer.run("s14030:PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPEZvbnQgc2l6ZT0iMTIiIGZhbWlseT0iUGl4ZWwgT3BlcmF0b3IiIGhlaWdodD0iMTYiIHN0eWxlPSJSZWd1bGFyIj4KIDxDaGFyIHdpZHRoPSI0IiBvZmZzZXQ9IjAgMTMiIHJlY3Q9IjEgMTIgMCAwIiBjb2RlPSIgIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjIgMyAxIDkiIGNvZGU9IiEiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNCAzIDMgMyIgY29kZT0iJnF1b3Q7Ii8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjggMyA2IDkiIGNvZGU9IiMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMiIgcmVjdD0iMTUgMSA1IDEzIiBjb2RlPSIkIi8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjIxIDMgNyA5IiBjb2RlPSIlIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjI5IDMgNSA5IiBjb2RlPSImYW1wOyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSA0IiByZWN0PSIzNSAzIDEgMyIgY29kZT0iJyIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSIzNyAzIDMgOSIgY29kZT0iKCIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSI0MSAzIDMgOSIgY29kZT0iKSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI0NSAzIDUgNSIgY29kZT0iKiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI1MSA1IDUgNSIgY29kZT0iKyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxMiIgcmVjdD0iNTcgMTEgMiAzIiBjb2RlPSIsIi8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDgiIHJlY3Q9IjYwIDcgNCAxIiBjb2RlPSItIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDEyIiByZWN0PSI2NSAxMSAxIDEiIGNvZGU9Ii4iLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjcgMyAzIDkiIGNvZGU9Ii8iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzEgMyA1IDkiIGNvZGU9IjAiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzcgMyAzIDkiIGNvZGU9IjEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMyA1IDkiIGNvZGU9IjIiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODcgMyA1IDkiIGNvZGU9IjMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTMgMyA1IDkiIGNvZGU9IjQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTkgMyA1IDkiIGNvZGU9IjUiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA1IDMgNSA5IiBjb2RlPSI2Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjExMSAzIDUgOSIgY29kZT0iNyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMTcgMyA1IDkiIGNvZGU9IjgiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSAxNSA1IDkiIGNvZGU9IjkiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNiIgcmVjdD0iNyAxNyAxIDciIGNvZGU9IjoiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNiIgcmVjdD0iOSAxNyAyIDkiIGNvZGU9IjsiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNiIgcmVjdD0iMTIgMTcgMyA1IiBjb2RlPSImbHQ7Ii8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDciIHJlY3Q9IjE2IDE4IDQgMyIgY29kZT0iPSIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA2IiByZWN0PSIyMSAxNyAzIDUiIGNvZGU9Ij4iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjUgMTUgNSA5IiBjb2RlPSI:Ii8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjMxIDE1IDcgOSIgY29kZT0iQCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzOSAxNSA1IDkiIGNvZGU9IkEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNDUgMTUgNSA5IiBjb2RlPSJCIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjUxIDE1IDUgOSIgY29kZT0iQyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI1NyAxNSA1IDkiIGNvZGU9IkQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjMgMTUgNSA5IiBjb2RlPSJFIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjY5IDE1IDUgOSIgY29kZT0iRiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI3NSAxNSA1IDkiIGNvZGU9IkciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMTUgNSA5IiBjb2RlPSJIIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9Ijg3IDE1IDEgOSIgY29kZT0iSSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI4OSAxNSA1IDkiIGNvZGU9IkoiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTUgMTUgNSA5IiBjb2RlPSJLIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEwMSAxNSA1IDkiIGNvZGU9IkwiLz4KIDxDaGFyIHdpZHRoPSI5IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA3IDE1IDcgOSIgY29kZT0iTSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMTUgMTUgNSA5IiBjb2RlPSJOIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEyMSAxNSA1IDkiIGNvZGU9Ik8iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSAyNyA1IDkiIGNvZGU9IlAiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNyAyNyA1IDkiIGNvZGU9IlEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTMgMjcgNSA5IiBjb2RlPSJSIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjE5IDI3IDUgOSIgY29kZT0iUyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNSAyNyA1IDkiIGNvZGU9IlQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMzEgMjcgNSA5IiBjb2RlPSJVIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjM3IDI3IDUgOSIgY29kZT0iViIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA0IiByZWN0PSI0MyAyNyA3IDkiIGNvZGU9IlciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNTEgMjcgNSA5IiBjb2RlPSJYIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjU3IDI3IDUgOSIgY29kZT0iWSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI2MyAyNyA1IDkiIGNvZGU9IloiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjkgMjcgMyA5IiBjb2RlPSJbIi8%CiA8Q2hhciB3aWR0aD0iNSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjczIDI3IDMgOSIgY29kZT0iXCIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSI3NyAyNyAzIDkiIGNvZGU9Il0iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMjcgNSAzIiBjb2RlPSJeIi8%CiA8Q2hhciB3aWR0aD0iNSIgb2Zmc2V0PSIwIDE0IiByZWN0PSI4NyAzNyA1IDEiIGNvZGU9Il8iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNCIgcmVjdD0iOTMgMjcgMiAyIiBjb2RlPSJgIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9Ijk2IDI5IDUgNyIgY29kZT0iYSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMDIgMjcgNSA5IiBjb2RlPSJiIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjEwOCAyOSA1IDciIGNvZGU9ImMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTE0IDI3IDUgOSIgY29kZT0iZCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMjAgMjkgNSA3IiBjb2RlPSJlIi8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEgMzkgNSA5IiBjb2RlPSJmIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjcgNDEgNSA5IiBjb2RlPSJnIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEzIDM5IDUgOSIgY29kZT0iaCIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSA0IiByZWN0PSIxOSAzOSAxIDkiIGNvZGU9ImkiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjEgMzkgNSAxMSIgY29kZT0iaiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNyAzOSA1IDkiIGNvZGU9ImsiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iMzMgMzkgMSA5IiBjb2RlPSJsIi8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjM1IDQxIDcgNyIgY29kZT0ibSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI0MyA0MSA1IDciIGNvZGU9Im4iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNDkgNDEgNSA3IiBjb2RlPSJvIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjU1IDQxIDUgOSIgY29kZT0icCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI2MSA0MSA1IDkiIGNvZGU9InEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNjcgNDEgNSA3IiBjb2RlPSJyIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjczIDQxIDUgNyIgY29kZT0icyIvPgogPENoYXIgd2lkdGg9IjYiIG9mZnNldD0iMSA1IiByZWN0PSI3OSA0MCA1IDgiIGNvZGU9InQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iODUgNDEgNSA3IiBjb2RlPSJ1Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjkxIDQxIDUgNyIgY29kZT0idiIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA2IiByZWN0PSI5NyA0MSA3IDciIGNvZGU9InciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iMTA1IDQxIDUgNyIgY29kZT0ieCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMTEgNDEgNSA5IiBjb2RlPSJ5Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjExNyA0MSA1IDciIGNvZGU9InoiLz4KIDxDaGFyIHdpZHRoPSI2IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSA1NCA0IDkiIGNvZGU9InsiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iNiA1NCAxIDkiIGNvZGU9InwiLz4KIDxDaGFyIHdpZHRoPSI2IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOCA1NCA0IDkiIGNvZGU9In0iLz4KIDxDaGFyIHdpZHRoPSI4IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTMgNTQgNiAyIiBjb2RlPSJ%Ii8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjIwIDU2IDEgOSIgY29kZT0iwqEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjIgNTQgNSAxMSIgY29kZT0iwqIiLz4KIDxDaGFyIHdpZHRoPSI4IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjggNTQgNiA5IiBjb2RlPSLCoyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzNSA1NCA1IDkiIGNvZGU9IsKlIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjQxIDU0IDEgOSIgY29kZT0iwqYiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNDMgNTQgMyAxIiBjb2RlPSLCqCIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA0IiByZWN0PSI0NyA1NCA3IDkiIGNvZGU9IsKpIi8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjU1IDU2IDYgNSIgY29kZT0iwqsiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgOCIgcmVjdD0iNjIgNTggNSAzIiBjb2RlPSLCrCIvPgogPENoYXIgd2lkdGg9IjYiIG9mZnNldD0iMSA0IiByZWN0PSI2OCA1NCA0IDQiIGNvZGU9IsKwIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjczIDU2IDUgNyIgY29kZT0iwrEiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzkgNTQgMiAyIiBjb2RlPSLCtCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI4MiA1NiA1IDkiIGNvZGU9IsK1Ii8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDQiIHJlY3Q9Ijg4IDU0IDcgOSIgY29kZT0iwrYiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgOCIgcmVjdD0iOTYgNTggMSAxIiBjb2RlPSLCtyIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMCAxMyIgcmVjdD0iOTggNjMgMyAyIiBjb2RlPSLCuCIvPgogPENoYXIgd2lkdGg9IjgiIG9mZnNldD0iMSA2IiByZWN0PSIxMDIgNTYgNiA1IiBjb2RlPSLCuyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMDkgNTYgNSA5IiBjb2RlPSLCvyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSIxMTUgNTEgNSAxMiIgY29kZT0iw4AiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iMTIxIDUxIDUgMTIiIGNvZGU9IsOBIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjEgNjcgNSAxMiIgY29kZT0iw4IiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iNyA2NyA2IDEyIiBjb2RlPSLDgyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAyIiByZWN0PSIxNCA2OCA1IDExIiBjb2RlPSLDhCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAwIiByZWN0PSIyMCA2NiA1IDEzIiBjb2RlPSLDhSIvPgogPENoYXIgd2lkdGg9IjExIiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjYgNzAgOSA5IiBjb2RlPSLDhiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzNiA3MCA1IDExIiBjb2RlPSLDhyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI0MiA2NyA1IDEyIiBjb2RlPSLDiCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI0OCA2NyA1IDEyIiBjb2RlPSLDiSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI1NCA2NyA1IDEyIiBjb2RlPSLDiiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAyIiByZWN0PSI2MCA2OCA1IDExIiBjb2RlPSLDiyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxIiByZWN0PSI2NiA2NyAyIDEyIiBjb2RlPSLDjCIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSAxIiByZWN0PSI2OSA2NyAyIDEyIiBjb2RlPSLDjSIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxIiByZWN0PSI3MiA2NyAzIDEyIiBjb2RlPSLDjiIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAyIiByZWN0PSI3NiA2OCAzIDExIiBjb2RlPSLDjyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMCA0IiByZWN0PSI4MCA3MCA2IDkiIGNvZGU9IsOQIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9Ijg3IDY3IDYgMTIiIGNvZGU9IsORIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9Ijk0IDY3IDUgMTIiIGNvZGU9IsOSIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjEwMCA2NyA1IDEyIiBjb2RlPSLDkyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSIxMDYgNjcgNSAxMiIgY29kZT0iw5QiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iMTEyIDY3IDYgMTIiIGNvZGU9IsOVIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9IjExOSA2OCA1IDExIiBjb2RlPSLDliIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxIDg3IDUgNSIgY29kZT0iw5ciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjAgNCIgcmVjdD0iNyA4NSA3IDkiIGNvZGU9IsOYIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjE1IDgyIDUgMTIiIGNvZGU9IsOZIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjIxIDgyIDUgMTIiIGNvZGU9IsOaIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjI3IDgyIDUgMTIiIGNvZGU9IsObIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9IjMzIDgzIDUgMTEiIGNvZGU9IsOcIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjM5IDgyIDUgMTIiIGNvZGU9IsOdIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjQ1IDg1IDUgOSIgY29kZT0iw54iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNTEgODUgNSA5IiBjb2RlPSLDnyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI1NyA4NCA1IDEwIiBjb2RlPSLDoCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI2MyA4NCA1IDEwIiBjb2RlPSLDoSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI2OSA4NCA1IDEwIiBjb2RlPSLDoiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI3NSA4NCA2IDEwIiBjb2RlPSLDoyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI4MiA4NSA1IDkiIGNvZGU9IsOkIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9Ijg4IDgzIDUgMTEiIGNvZGU9IsOlIi8%CiA8Q2hhciB3aWR0aD0iMTEiIG9mZnNldD0iMSA2IiByZWN0PSI5NCA4NyA5IDciIGNvZGU9IsOmIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjEwNCA4NyA1IDkiIGNvZGU9IsOnIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjExMCA4NCA1IDEwIiBjb2RlPSLDqCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSIxMTYgODQgNSAxMCIgY29kZT0iw6kiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iMSA5NyA1IDEwIiBjb2RlPSLDqiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI3IDk4IDUgOSIgY29kZT0iw6siLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgMyIgcmVjdD0iMTMgOTcgMiAxMCIgY29kZT0iw6wiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgMyIgcmVjdD0iMTYgOTcgMiAxMCIgY29kZT0iw60iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgMyIgcmVjdD0iMTkgOTcgMyAxMCIgY29kZT0iw64iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNCIgcmVjdD0iMjMgOTggMyA5IiBjb2RlPSLDryIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNyA5OCA2IDkiIGNvZGU9IsOwIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjM0IDk3IDYgMTAiIGNvZGU9IsOxIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjQxIDk3IDUgMTAiIGNvZGU9IsOyIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjQ3IDk3IDUgMTAiIGNvZGU9IsOzIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjUzIDk3IDUgMTAiIGNvZGU9IsO0Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjU5IDk3IDYgMTAiIGNvZGU9IsO1Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjY2IDk4IDUgOSIgY29kZT0iw7YiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNzIgMTAwIDUgNSIgY29kZT0iw7ciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjAgNiIgcmVjdD0iNzggMTAwIDcgNyIgY29kZT0iw7giLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iODYgOTcgNSAxMCIgY29kZT0iw7kiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iOTIgOTcgNSAxMCIgY29kZT0iw7oiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iOTggOTcgNSAxMCIgY29kZT0iw7siLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA0IDk4IDUgOSIgY29kZT0iw7wiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iMTEwIDk3IDUgMTIiIGNvZGU9IsO9Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjExNiA5OCA1IDExIiBjb2RlPSLDviIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxIDExMCA1IDExIiBjb2RlPSLDvyIvPgo8L0ZvbnQ%Cg"));
		var bmp = new hxd_res_BitmapFont(DESC.entry);
		bmp.loader = BYTES.loader;
		fnt = bmp.toFont();
		engine.resCache.set(hxd_res_DefaultFont,fnt);
	}
	return fnt;
};
var hxd_res_Font = function(entry) {
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Font"] = hxd_res_Font;
hxd_res_Font.__name__ = "hxd.res.Font";
hxd_res_Font.__super__ = hxd_res_Resource;
hxd_res_Font.prototype = $extend(hxd_res_Resource.prototype,{
	build: function(size,options) {
		var _this_r = new RegExp("[^A-Za-z0-9_]","g".split("u").join(""));
		var name = "R_" + this.entry.get_path().replace(_this_r,"_");
		return hxd_res_FontBuilder.getFont(name,size,options);
	}
	,__class__: hxd_res_Font
});
var hxd_res_FontBuilder = function(name,size,opt) {
	this.font = new h2d_Font(name,size);
	this.options = opt == null ? { } : opt;
	if(this.options.antiAliasing == null) {
		this.options.antiAliasing = true;
	}
	if(this.options.chars == null) {
		this.options.chars = hxd_Charset.DEFAULT_CHARS;
	}
};
$hxClasses["hxd.res.FontBuilder"] = hxd_res_FontBuilder;
hxd_res_FontBuilder.__name__ = "hxd.res.FontBuilder";
hxd_res_FontBuilder.getFont = function(name,size,options) {
	var key = name + "#" + size;
	var f = hxd_res_FontBuilder.FONTS.h[key];
	if(f != null && f.tile.innerTex != null) {
		return f;
	}
	f = new hxd_res_FontBuilder(name,size,options).build();
	hxd_res_FontBuilder.FONTS.h[key] = f;
	return f;
};
hxd_res_FontBuilder.dispose = function() {
	var h = hxd_res_FontBuilder.FONTS.h;
	var f_h = h;
	var f_keys = Object.keys(h);
	var f_length = f_keys.length;
	var f_current = 0;
	while(f_current < f_length) {
		var f = f_h[f_keys[f_current++]];
		f.dispose();
	}
	hxd_res_FontBuilder.FONTS = new haxe_ds_StringMap();
};
hxd_res_FontBuilder.prototype = {
	build: function() {
		var bmp = window.document.createElement("canvas");
		var ctx = bmp.getContext("2d",null);
		ctx.font = "" + this.font.size + "px " + this.font.name;
		ctx.textAlign = "left";
		ctx.textBaseline = "bottom";
		this.font.lineHeight = 0;
		var surf = 0;
		var sizes = [];
		var h = this.getFontHeight(this.font,"MgO0pj");
		var xMarg = 10;
		var _g = 0;
		var _g1 = this.options.chars.length;
		while(_g < _g1) {
			var i = _g++;
			var textChar = this.options.chars.charAt(i);
			var w = Math.ceil(ctx.measureText(textChar).width) + 1;
			if(w == 1) {
				continue;
			}
			surf += (w + 1 + xMarg) * (h + 1);
			if(h > this.font.lineHeight) {
				this.font.lineHeight = h;
			}
			sizes[i] = { w : w, h : h};
		}
		var side = Math.ceil(Math.sqrt(surf));
		var width = 1;
		while(side > width) width <<= 1;
		var height = width;
		while(width * height >> 1 > surf) height >>= 1;
		if(this.innerTex != null) {
			width = this.innerTex.width;
			height = this.innerTex.height;
		}
		var all;
		var done;
		while(true) {
			done = true;
			bmp.width = width;
			bmp.height = height;
			ctx.font = "" + this.font.size + "px " + this.font.name;
			ctx.textAlign = "left";
			ctx.textBaseline = "bottom";
			ctx.fillStyle = "red";
			this.font.glyphs = new haxe_ds_IntMap();
			all = [];
			var x = 0;
			var y = 0;
			var lineH = 0;
			var _g = 0;
			var _g1 = this.options.chars.length;
			while(_g < _g1) {
				var i = _g++;
				var size = sizes[i];
				if(size == null) {
					continue;
				}
				var w = size.w + xMarg;
				var h = size.h;
				if(h > lineH) {
					lineH = h;
				}
				if(x + w > width || i == 0) {
					x = 0;
					y += lineH + 1;
				}
				if(y + h > height) {
					done = false;
					height <<= 1;
					break;
				}
				ctx.fillStyle = "black";
				ctx.globalAlpha = 0.0;
				ctx.fillRect(x,y,w,h);
				ctx.globalAlpha = 1.0;
				ctx.fillStyle = "white";
				ctx.fillText(this.options.chars.charAt(i),x,y);
				var t = new h2d_Tile(this.innerTex,x,y - h,w - 1,h - 1);
				all.push(t);
				var this1 = this.font.glyphs;
				var key = HxOverrides.cca(this.options.chars,i);
				var value = new h2d_FontChar(t,w - (1 + xMarg));
				this1.h[key] = value;
				x += w + 1;
			}
			if(done) {
				break;
			}
		}
		var rbmp = hxd_BitmapData.fromNative(ctx);
		if(this.innerTex == null) {
			this.innerTex = h3d_mat_Texture.fromBitmap(rbmp);
			this.font.tile = h2d_Tile.fromTexture(this.innerTex);
			var _g = 0;
			while(_g < all.length) {
				var t = all[_g];
				++_g;
				t.setTexture(this.innerTex);
			}
			this.innerTex.realloc = $bind(this,this.build);
		} else {
			this.innerTex.uploadBitmap(rbmp);
		}
		return this.font;
	}
	,getFontHeight: function(font,chars) {
		var body = window.document.body;
		var dummy = window.document.createElement("div");
		var dummyText = window.document.createTextNode(chars);
		dummy.appendChild(dummyText);
		dummy.style.fontSize = font.size + "px";
		dummy.style.fontFamily = font.name;
		body.appendChild(dummy);
		var result = dummy.offsetHeight;
		body.removeChild(dummy);
		return result;
	}
	,__class__: hxd_res_FontBuilder
};
var hxd_res_ImageFormat = {};
hxd_res_ImageFormat.get_useLoadBitmap = function(this1) {
	return this1 == 0;
};
hxd_res_ImageFormat.toInt = function(this1) {
	return this1;
};
hxd_res_ImageFormat.getName = function(this1) {
	switch(this1) {
	case 0:
		return "JPG";
	case 1:
		return "PNG";
	case 2:
		return "GIF";
	case 3:
		return "TGA";
	case 4:
		return "DDS";
	case 5:
		return "RAW";
	case 6:
		return "HDR";
	}
};
var hxd_res_ImageInfoFlag = $hxEnums["hxd.res.ImageInfoFlag"] = { __ename__:"hxd.res.ImageInfoFlag",__constructs__:null
	,IsCube: {_hx_name:"IsCube",_hx_index:0,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
	,Dxt10Header: {_hx_name:"Dxt10Header",_hx_index:1,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
};
hxd_res_ImageInfoFlag.__constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
hxd_res_ImageInfoFlag.__empty_constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
var hxd_res_ImageInfo = function() {
	this.layerCount = 1;
	this.mipOffset = 0;
	this.mipLevels = 1;
	this.height = 0;
	this.width = 0;
	this.flags = 0;
};
$hxClasses["hxd.res.ImageInfo"] = hxd_res_ImageInfo;
hxd_res_ImageInfo.__name__ = "hxd.res.ImageInfo";
hxd_res_ImageInfo.prototype = {
	__class__: hxd_res_ImageInfo
};
var hxd_res_Image = function(entry) {
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Image"] = hxd_res_Image;
hxd_res_Image.__name__ = "hxd.res.Image";
hxd_res_Image.customCheckInfo = function(i) {
};
hxd_res_Image.setupTextureFlags = function(tex) {
};
hxd_res_Image.__super__ = hxd_res_Resource;
hxd_res_Image.prototype = $extend(hxd_res_Resource.prototype,{
	getFormat: function() {
		return this.getInfo().dataFormat;
	}
	,getPixelFormat: function() {
		return this.getInfo().pixelFormat;
	}
	,getSize: function() {
		return this.getInfo();
	}
	,getInfo: function() {
		if(this.inf != null) {
			return this.inf;
		}
		this.inf = new hxd_res_ImageInfo();
		var f = this.entry.open();
		f.fetch(256);
		var head;
		try {
			head = f.readUInt16();
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				head = 0;
			} else {
				throw _g;
			}
		}
		switch(head) {
		case 16163:
			this.inf.dataFormat = 6;
			while(f.readLine() != "") {
			}
			var parts = f.readLine().split(" ");
			this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
			this.inf.height = Std.parseInt(parts[1]);
			this.inf.width = Std.parseInt(parts[3]);
			break;
		case 17476:
			this.inf.dataFormat = 4;
			f.skip(10);
			this.inf.height = f.readInt32();
			this.inf.width = f.readInt32();
			f.skip(8);
			this.inf.mipLevels = f.readInt32();
			f.skip(48);
			var caps = f.readInt32();
			var fourCC = f.readInt32();
			var bpp = f.readInt32();
			var rMask = f.readInt32();
			var gMask = f.readInt32();
			var bMask = f.readInt32();
			var aMask = f.readInt32();
			var caps2 = f.readInt32();
			var cubes = f.readInt32();
			if((cubes & 65024) == 65024) {
				this.inf.flags |= 1 << hxd_res_ImageInfoFlag.IsCube._hx_index;
			}
			switch(fourCC & 16777215) {
			case 0:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					switch(bpp) {
					case 16:
						if(rMask == 65535) {
							if(gMask == 0) {
								if(bMask == 0) {
									if(aMask == 0) {
										this.inf.pixelFormat = hxd_PixelFormat.R16U;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
						} else {
							throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
						}
						break;
					case 32:
						switch(rMask) {
						case 255:
							if(gMask == 65280) {
								if(bMask == 16711680) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.RGBA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						case 65535:
							if(gMask == -65536) {
								if(bMask == 0) {
									if(aMask == 0) {
										this.inf.pixelFormat = hxd_PixelFormat.RG16U;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						case 16711680:
							if(gMask == 65280) {
								if(bMask == 255) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.BGRA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						default:
							throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
						}
						break;
					default:
						throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
					}
				}
				break;
			case 36:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA16U;
				}
				break;
			case 111:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R16F;
				}
				break;
			case 112:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG16F;
				}
				break;
			case 113:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA16F;
				}
				break;
			case 114:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R32F;
				}
				break;
			case 115:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG32F;
				}
				break;
			case 116:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
				}
				break;
			case 4805697:
				var v = (fourCC >>> 24) - 48;
				var tmp;
				switch(v) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(4);
					break;
				case 2:
					tmp = hxd_PixelFormat.S3TC(5);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			case 5527620:
				var dxt = (fourCC >>> 24) - 48;
				var tmp;
				switch(dxt) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(1);
					break;
				case 2:case 3:
					tmp = hxd_PixelFormat.S3TC(2);
					break;
				case 4:case 5:
					tmp = hxd_PixelFormat.S3TC(3);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			default:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					var dxgi = f.readInt32();
					var tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					var imgType = f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				}
			}
			if(this.inf.pixelFormat == null) {
				var fid = String.fromCodePoint((fourCC & 255)) + String.fromCodePoint((fourCC >> 8 & 255)) + String.fromCodePoint((fourCC >> 16 & 255)) + String.fromCodePoint((fourCC >>> 24));
				if((fourCC & 255) == fourCC) {
					fid = "" + fourCC;
				}
				throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported 4CC " + fid);
			}
			break;
		case 18759:
			this.inf.dataFormat = 2;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.readInt32();
			this.inf.width = f.readUInt16();
			this.inf.height = f.readUInt16();
			break;
		case 20617:
			this.inf.dataFormat = 1;
			f.set_bigEndian(true);
			f.skip(6);
			while(true) {
				var dataLen = f.readInt32();
				if(f.readInt32() == 1229472850) {
					this.inf.width = f.readInt32();
					this.inf.height = f.readInt32();
					var colbits = f.readByte();
					var colType = f.readByte();
					var tmp;
					switch(colbits) {
					case 8:
						tmp = hxd_PixelFormat.BGRA;
						break;
					case 16:
						switch(colType) {
						case 0:
							tmp = hxd_PixelFormat.R16U;
							break;
						case 2:
							tmp = hxd_PixelFormat.RGBA16U;
							break;
						case 4:
							tmp = hxd_PixelFormat.RG16U;
							break;
						case 6:
							tmp = hxd_PixelFormat.RGBA16U;
							break;
						default:
							throw haxe_Exception.thrown("Unsupported png format " + colbits + "/" + colType + "(" + this.entry.get_path() + ")");
						}
						break;
					default:
						throw haxe_Exception.thrown("Unsupported png format " + colbits + "/" + colType + "(" + this.entry.get_path() + ")");
					}
					this.inf.pixelFormat = tmp;
					break;
				}
				f.skip(dataLen + 4);
			}
			break;
		case 55551:
			this.inf.dataFormat = 0;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.set_bigEndian(true);
			_hx_loop3: while(true) switch(f.readUInt16()) {
			case 65472:case 65473:case 65474:
				var len = f.readUInt16();
				var prec = f.readByte();
				this.inf.height = f.readUInt16();
				this.inf.width = f.readUInt16();
				break _hx_loop3;
			default:
				f.skip(f.readUInt16() - 2);
			}
			break;
		default:
			if(this.entry.get_extension() == "tga") {
				this.inf.dataFormat = 3;
				this.inf.pixelFormat = hxd_PixelFormat.ARGB;
				f.skip(10);
				this.inf.width = f.readUInt16();
				this.inf.height = f.readUInt16();
			} else if(this.entry.get_extension() == "raw") {
				this.inf.dataFormat = 5;
				this.inf.pixelFormat = hxd_PixelFormat.R32F;
				var size = Math.sqrt(this.entry.get_size() >> 2) | 0;
				if(this.entry.get_size() != size * size * 4) {
					var size2 = Math.sqrt(this.entry.get_size() >> 1) | 0;
					if(this.entry.get_size() == size2 * size2 * 2) {
						this.inf.pixelFormat = hxd_PixelFormat.R16F;
						size = size2;
					} else {
						throw haxe_Exception.thrown("RAW format does not match 32 bit per components on " + size + "x" + size);
					}
				}
				this.inf.width = this.inf.height = size;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + this.entry.get_path());
			}
		}
		f.close();
		if(this.inf.pixelFormat == null) {
			throw haxe_Exception.thrown("Unsupported internal format (" + this.entry.get_path() + ")");
		}
		if(hxd_res_Image.MIPMAP_MAX_SIZE != 0 && this.inf.mipLevels > 1) {
			while(((this.inf.width | this.inf.height) & 7) == 0 && this.inf.width >> 1 >= hxd_res_Image.MIPMAP_MAX_SIZE && this.inf.height >> 1 >= hxd_res_Image.MIPMAP_MAX_SIZE) {
				this.inf.width >>= 1;
				this.inf.height >>= 1;
				this.inf.mipLevels--;
				this.inf.mipOffset++;
			}
		}
		hxd_res_Image.customCheckInfo(this);
		return this.inf;
	}
	,getPixels: function(fmt,index) {
		var pixels;
		if(index == null) {
			index = 0;
		}
		switch(this.getInfo().dataFormat) {
		case 0:
			var bytes = this.entry.getBytes();
			if(this.inf.pixelFormat != hxd_PixelFormat.BGRA) {
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			var p;
			try {
				p = hxd_res_NanoJpeg.decode(bytes);
			} catch( _g ) {
				var e = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Failed to decode JPG " + this.entry.get_path() + " (" + Std.string(e) + ")");
			}
			pixels = new hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA);
			break;
		case 1:
			var bytes = this.entry.getBytes();
			var png = new format_png_Reader(new haxe_io_BytesInput(bytes));
			png.checkCRC = false;
			pixels = hxd_Pixels.alloc(this.inf.width,this.inf.height,this.inf.pixelFormat);
			var pdata = png.read();
			switch(this.inf.pixelFormat._hx_index) {
			case 1:
				format_png_Tools.extract32(pdata,pixels.bytes,false);
				break;
			case 18:case 19:case 20:case 21:
				var pixels1 = pixels.bytes;
				var tmp;
				if(this.inf.pixelFormat == hxd_PixelFormat.RGBA16U) {
					var _g = format_png_Tools.getHeader(pdata).color;
					tmp = _g._hx_index == 1 && _g.alpha == false;
				} else {
					tmp = false;
				}
				format_png_Tools.extract(pdata,pixels1,tmp);
				break;
			default:
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			break;
		case 2:
			var bytes = this.entry.getBytes();
			var gif = new format_gif_Reader(new haxe_io_BytesInput(bytes)).read();
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullRGBA(gif,0),hxd_PixelFormat.RGBA);
			} else {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA);
			}
			break;
		case 3:
			var bytes = this.entry.getBytes();
			var r = new format_tga_Reader(new haxe_io_BytesInput(bytes)).read();
			if(r.header.imageType != format_tga_ImageType.UncompressedTrueColor || r.header.bitsPerPixel != 32) {
				throw haxe_Exception.thrown("Not supported TGA " + Std.string(r.header.imageType) + "/" + r.header.bitsPerPixel);
			}
			var w = r.header.width;
			var h = r.header.height;
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.RGBA);
				var bytes = pixels.bytes;
				var _g = 0;
				var _g1 = w * h;
				while(_g < _g1) {
					var i = _g++;
					var c = r.imageData[i];
					c = c >>> 24 | c << 8;
					bytes.setInt32(i << 2,c);
				}
			} else {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB);
				var access = hxd_PixelsARGB.fromPixels(pixels);
				var p = 0;
				var _g = 0;
				var _g1 = h;
				while(_g < _g1) {
					var y = _g++;
					var _g2 = 0;
					var _g3 = w;
					while(_g2 < _g3) {
						var x = _g2++;
						var c = r.imageData[p++];
						access.bytes.setInt32((x + y * access.width << 2) + access.offset,c >>> 24 | c >> 8 & 65280 | c << 8 & 16711680 | c << 24);
					}
				}
			}
			switch(r.header.imageOrigin._hx_index) {
			case 0:
				pixels.flipY();
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("Not supported " + Std.string(r.header.imageOrigin));
			}
			break;
		case 4:
			var pos = 128;
			var mipLevel = 0;
			if((this.inf.flags & 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index) != 0) {
				pos += 20;
			}
			index += this.inf.mipOffset;
			if(index > 0) {
				var totLevels = this.inf.mipLevels + this.inf.mipOffset;
				var bpp = hxd_Pixels.calcStride(1,this.inf.pixelFormat);
				var layer = index / totLevels | 0;
				mipLevel = index % totLevels;
				var totSize = 0;
				var _g = 0;
				var _g1 = totLevels;
				while(_g < _g1) {
					var i = _g++;
					var w = this.inf.width << this.inf.mipOffset >> i;
					var h = this.inf.height << this.inf.mipOffset >> i;
					if(w == 0) {
						w = 1;
					}
					if(h == 0) {
						h = 1;
					}
					var size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
					totSize += size;
					if(i < mipLevel) {
						pos += size;
					} else if(layer == 0) {
						break;
					}
				}
				pos += totSize * layer;
			}
			var bytes;
			var w = this.inf.width >> mipLevel - this.inf.mipOffset;
			var h = this.inf.height >> mipLevel - this.inf.mipOffset;
			if(w == 0) {
				w = 1;
			}
			if(h == 0) {
				h = 1;
			}
			if(this.inf.mipLevels + this.inf.mipOffset == 1 && (this.inf.flags & 1 << hxd_res_ImageInfoFlag.IsCube._hx_index) == 0) {
				bytes = this.entry.getBytes();
			} else {
				var size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
				bytes = new haxe_io_Bytes(new ArrayBuffer(size));
				this.entry.readFull(bytes,pos,size);
				pos = 0;
			}
			pixels = new hxd_Pixels(w,h,bytes,this.inf.pixelFormat,pos);
			break;
		case 5:
			var bytes = this.entry.getBytes();
			pixels = new hxd_Pixels(this.inf.width,this.inf.height,bytes,this.inf.pixelFormat);
			break;
		case 6:
			var data = hxd_fmt_hdr_Reader.decode(this.entry.getBytes(),false);
			pixels = new hxd_Pixels(data.width,data.height,data.bytes,this.inf.pixelFormat);
			break;
		}
		if(fmt != null) {
			pixels.convert(fmt);
		}
		return pixels;
	}
	,toBitmap: function() {
		this.getInfo();
		var bmp = new hxd_BitmapData(this.inf.width,this.inf.height);
		var pixels = this.getPixels();
		bmp.setPixels(pixels);
		pixels.dispose();
		return bmp;
	}
	,watchCallb: function() {
		var w = this.inf.width;
		var h = this.inf.height;
		this.inf = null;
		var s = this.getInfo();
		if(w != s.width || h != s.height) {
			this.tex.resize(s.width,s.height);
		}
		this.tex.realloc = null;
		this.loadTexture();
	}
	,asyncLoad: function(data) {
		var tmp;
		if(this.tex != null) {
			var _this = this.tex;
			tmp = _this.isDepth() ? _this.t == null : _this.t == null && _this.realloc == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			return;
		}
		this.tex.dispose();
		this.tex.flags &= -1 - (1 << h3d_mat_TextureFlags.Loading._hx_index);
		this.tex.format = this.inf.pixelFormat;
		this.tex.width = this.inf.width;
		this.tex.height = this.inf.height;
		this.loadTexture(data);
	}
	,loadTexture: function(asyncData) {
		var _gthis = this;
		if(this.getInfo().dataFormat == 0) {
			this.tex.flags |= 1 << h3d_mat_TextureFlags.Loading._hx_index;
			this.entry.loadBitmap(function(bmp) {
				var bmp1 = hxd_fs_LoadedBitmap.toBitmap(bmp);
				_gthis.tex.alloc();
				_gthis.tex.uploadBitmap(bmp1);
				bmp1.ctx = null;
				bmp1.pixel = null;
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				_gthis.tex.flags &= -1 - (1 << h3d_mat_TextureFlags.Loading._hx_index);
				if(_gthis.tex.waitLoads != null) {
					var arr = _gthis.tex.waitLoads;
					_gthis.tex.waitLoads = null;
					var _g = 0;
					while(_g < arr.length) {
						var f = arr[_g];
						++_g;
						f();
					}
				}
				if(hxd_res_Image.ENABLE_AUTO_WATCH) {
					_gthis.watch($bind(_gthis,_gthis.watchCallb));
				}
			});
			return;
		}
		var load = function() {
			if((_gthis.enableAsyncLoading || (_gthis.tex.flags & 1 << h3d_mat_TextureFlags.AsyncLoading._hx_index) != 0) && asyncData == null && hxd_res_Image.ASYNC_LOADER.isSupported(_gthis)) {
				_gthis.tex.dispose();
				_gthis.tex.format = hxd_PixelFormat.RGBA;
				_gthis.tex.width = 1;
				_gthis.tex.height = 1;
				_gthis.tex.customMipLevels = 1;
				_gthis.tex.flags |= 1 << h3d_mat_TextureFlags.Loading._hx_index;
				_gthis.tex.alloc();
				_gthis.tex.uploadPixels(hxd_res_Image.BLACK_1x1);
				_gthis.tex.width = _gthis.inf.width;
				_gthis.tex.height = _gthis.inf.height;
				hxd_res_Image.ASYNC_LOADER.load(_gthis);
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				return;
			}
			var t0 = HxOverrides.now() / 1000;
			_gthis.tex.customMipLevels = _gthis.inf.mipLevels;
			_gthis.tex.alloc();
			if(_gthis.inf.dataFormat == 4) {
				var pos = 128;
				if((_gthis.inf.flags & 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index) != 0) {
					pos += 20;
				}
				var _g = 0;
				var _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					var layer = _g++;
					var _g2 = 0;
					var _g3 = _gthis.inf.mipOffset;
					while(_g2 < _g3) {
						var mip = _g2++;
						var w = _gthis.inf.width << _gthis.inf.mipOffset >> mip;
						var h = _gthis.inf.height << _gthis.inf.mipOffset >> mip;
						var size = hxd_Pixels.calcDataSize(w,h,_gthis.inf.pixelFormat);
						pos += size;
					}
					var _g4 = 0;
					var _g5 = _gthis.inf.mipLevels;
					while(_g4 < _g5) {
						var mip1 = _g4++;
						var w1 = _gthis.inf.width >> mip1;
						var h1 = _gthis.inf.height >> mip1;
						if(w1 == 0) {
							w1 = 1;
						}
						if(h1 == 0) {
							h1 = 1;
						}
						var size1 = hxd_Pixels.calcDataSize(w1,h1,_gthis.inf.pixelFormat);
						var bytes = asyncData == null ? _gthis.entry.fetchBytes(pos,size1) : asyncData;
						_gthis.tex.uploadPixels(new hxd_Pixels(w1,h1,bytes,_gthis.inf.pixelFormat,asyncData == null ? 0 : pos),mip1,layer);
						pos += size1;
					}
				}
			} else {
				var _g = 0;
				var _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					var layer = _g++;
					var _g2 = 0;
					var _g3 = _gthis.inf.mipLevels;
					while(_g2 < _g3) {
						var mip = _g2++;
						var pixels = _gthis.getPixels(_gthis.tex.format,layer * _gthis.inf.mipLevels + mip);
						_gthis.tex.uploadPixels(pixels,mip,layer);
						pixels.dispose();
					}
				}
			}
			if(hxd_res_Image.LOG_TEXTURE_LOAD && asyncData == null) {
				var time = (HxOverrides.now() / 1000 - t0) * 1000.0;
				var _g = _gthis.inf.pixelFormat;
				var fmtStr;
				if(_g._hx_index == 22) {
					var _g1 = _g.v;
					fmtStr = true;
				} else {
					fmtStr = false;
				}
				var fmtStr1 = fmtStr ? "DXT" : hxd_res_ImageFormat.getName(_gthis.inf.dataFormat);
				haxe_Log.trace(fmtStr1 + " " + (time | 0) + "." + (time * 10 | 0) % 10 + "ms " + _gthis.inf.width + "x" + _gthis.inf.height + " " + _gthis.entry.get_path(),{ fileName : "hxd/res/Image.hx", lineNumber : 597, className : "hxd.res.Image", methodName : "loadTexture"});
			}
			_gthis.tex.realloc = function() {
				_gthis.loadTexture();
			};
			if(hxd_res_Image.ENABLE_AUTO_WATCH) {
				_gthis.watch($bind(_gthis,_gthis.watchCallb));
			}
		};
		if(this.entry.get_isAvailable()) {
			load();
		} else {
			this.entry.load(load);
		}
	}
	,toTexture: function() {
		var _gthis = this;
		if(this.tex != null) {
			return this.tex;
		}
		this.getInfo();
		var flags = [h3d_mat_TextureFlags.NoAlloc];
		var fmt = this.inf.pixelFormat;
		if(fmt == hxd_PixelFormat.BGRA || fmt == hxd_PixelFormat.ARGB || fmt == hxd_PixelFormat.RGBA) {
			fmt = h3d_mat_Texture.nativeFormat;
		}
		if((this.inf.flags & 1 << hxd_res_ImageInfoFlag.IsCube._hx_index) != 0) {
			flags.push(h3d_mat_TextureFlags.Cube);
		}
		if(this.inf.mipLevels > 1) {
			flags.push(h3d_mat_TextureFlags.MipMapped);
			flags.push(h3d_mat_TextureFlags.ManualMipMapGen);
		}
		if(this.inf.layerCount > 1) {
			this.tex = new h3d_mat_TextureArray(this.inf.width,this.inf.height,this.inf.layerCount,flags,fmt);
		} else {
			this.tex = new h3d_mat_Texture(this.inf.width,this.inf.height,flags,fmt);
		}
		if(hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear) {
			this.tex.set_filter(hxd_res_Image.DEFAULT_FILTER);
		}
		this.tex.setName(this.entry.get_path());
		hxd_res_Image.setupTextureFlags(this.tex);
		if((this.tex.flags & 1 << h3d_mat_TextureFlags.IsArray._hx_index) != 0 || (this.tex.flags & 1 << h3d_mat_TextureFlags.LazyLoading._hx_index) == 0) {
			this.loadTexture();
		} else {
			this.tex.realloc = function() {
				_gthis.loadTexture();
			};
		}
		return this.tex;
	}
	,toTile: function() {
		this.getInfo();
		return h2d_Tile.fromTexture(this.toTexture()).sub(0,0,this.inf.width,this.inf.height);
	}
	,__class__: hxd_res_Image
});
var hxd_res_Loader = function(fs) {
	this.fs = fs;
	this.cache = new haxe_ds_StringMap();
};
$hxClasses["hxd.res.Loader"] = hxd_res_Loader;
hxd_res_Loader.__name__ = "hxd.res.Loader";
hxd_res_Loader.prototype = {
	cleanCache: function() {
		this.cache = new haxe_ds_StringMap();
	}
	,dir: function(path) {
		var r = [];
		var entries = this.fs.dir(path);
		var _g = 0;
		while(_g < entries.length) {
			var e = entries[_g];
			++_g;
			r.push(new hxd_res_Any(this,e));
		}
		return r;
	}
	,exists: function(path) {
		return this.fs.exists(path);
	}
	,load: function(path) {
		return new hxd_res_Any(this,this.fs.get(path));
	}
	,loadCache: function(path,c) {
		var res = this.cache.h[path];
		if(res == null) {
			var entry = this.fs.get(path);
			var old = hxd_res_Loader.currentInstance;
			hxd_res_Loader.currentInstance = this;
			res = Type.createInstance(c,[entry]);
			hxd_res_Loader.currentInstance = old;
			this.cache.h[path] = res;
		} else if((js_Boot.__downcastCheck(res,c) ? res : null) == null) {
			throw haxe_Exception.thrown(path + " has been reintrepreted from " + Std.string(js_Boot.getClass(res)) + " to " + Std.string(c));
		}
		return res;
	}
	,dispose: function() {
		this.cleanCache();
		this.fs.dispose();
	}
	,__class__: hxd_res_Loader
};
var hxd_res_Model = function(entry) {
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Model"] = hxd_res_Model;
hxd_res_Model.__name__ = "hxd.res.Model";
hxd_res_Model.__super__ = hxd_res_Resource;
hxd_res_Model.prototype = $extend(hxd_res_Resource.prototype,{
	toHmd: function() {
		var fs = this.entry.open();
		var hmd = new hxd_fmt_hmd_Reader(fs).readHeader();
		fs.close();
		return new hxd_fmt_hmd_Library(this,hmd);
	}
	,__class__: hxd_res_Model
});
var hxd_res_Filter = $hxEnums["hxd.res.Filter"] = { __ename__:"hxd.res.Filter",__constructs__:null
	,Fast: {_hx_name:"Fast",_hx_index:0,__enum__:"hxd.res.Filter",toString:$estr}
	,Chromatic: {_hx_name:"Chromatic",_hx_index:1,__enum__:"hxd.res.Filter",toString:$estr}
};
hxd_res_Filter.__constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
hxd_res_Filter.__empty_constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
var hxd_res__$NanoJpeg_FastBytes = {};
hxd_res__$NanoJpeg_FastBytes._new = function(b) {
	return b;
};
hxd_res__$NanoJpeg_FastBytes.get = function(this1,i) {
	return this1.b[i];
};
hxd_res__$NanoJpeg_FastBytes.set = function(this1,i,v) {
	this1.b[i] = v;
};
var hxd_res__$NanoJpeg_Component = function() {
};
$hxClasses["hxd.res._NanoJpeg.Component"] = hxd_res__$NanoJpeg_Component;
hxd_res__$NanoJpeg_Component.__name__ = "hxd.res._NanoJpeg.Component";
hxd_res__$NanoJpeg_Component.prototype = {
	__class__: hxd_res__$NanoJpeg_Component
};
var hxd_res_NanoJpeg = function() {
	this.comps = [new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component()].slice(0);
	this.qtab = [new Array(64),new Array(64),new Array(64),new Array(64)].slice(0);
	this.counts = new Array(16);
	this.block = new Array(64);
	this.njZZ = [0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63].slice(0);
	this.vlctab = [null,null,null,null,null,null,null,null].slice(0);
};
$hxClasses["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg;
hxd_res_NanoJpeg.__name__ = "hxd.res.NanoJpeg";
hxd_res_NanoJpeg.CF = function(x) {
	var x1 = x + 64 >> 7;
	if(x1 < 0) {
		return 0;
	} else if(x1 > 255) {
		return 255;
	} else {
		return x1;
	}
};
hxd_res_NanoJpeg.njClip = function(x) {
	if(x < 0) {
		return 0;
	} else if(x > 255) {
		return 255;
	} else {
		return x;
	}
};
hxd_res_NanoJpeg.decode = function(bytes,filter,position,size) {
	if(size == null) {
		size = -1;
	}
	if(position == null) {
		position = 0;
	}
	if(hxd_res_NanoJpeg.inst == null) {
		hxd_res_NanoJpeg.inst = new hxd_res_NanoJpeg();
	}
	hxd_res_NanoJpeg.inst.njInit(bytes,position,size,filter);
	return hxd_res_NanoJpeg.inst.njDecode();
};
hxd_res_NanoJpeg.prototype = {
	alloc: function(nbytes) {
		return new haxe_io_Bytes(new ArrayBuffer(nbytes));
	}
	,free: function(bytes) {
	}
	,njInit: function(bytes,pos,size,filter) {
		this.bytes = bytes;
		this.pos = pos;
		this.filter = filter == null ? hxd_res_Filter.Chromatic : filter;
		if(size < 0) {
			size = bytes.length - pos;
		}
		if(this.vlctab[0] == null) {
			this.vlctab[0] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[1] == null) {
			this.vlctab[1] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[2] == null) {
			this.vlctab[2] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[3] == null) {
			this.vlctab[3] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		this.size = size;
		this.qtused = 0;
		this.qtavail = 0;
		this.rstinterval = 0;
		this.length = 0;
		this.buf = 0;
		this.bufbits = 0;
		this.progressive = false;
		this.comps[0].dcpred = 0;
		this.comps[1].dcpred = 0;
		this.comps[2].dcpred = 0;
	}
	,cleanup: function() {
		this.bytes = null;
		var _g = 0;
		var _g1 = this.comps;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.pixels != null) {
				c.pixels = null;
			}
		}
		if(this.vlctab[0] != null) {
			this.vlctab[0] = null;
		}
		if(this.vlctab[1] != null) {
			this.vlctab[1] = null;
		}
		if(this.vlctab[2] != null) {
			this.vlctab[2] = null;
		}
		if(this.vlctab[3] != null) {
			this.vlctab[3] = null;
		}
		if(this.vlctab[4] != null) {
			this.vlctab[4] = null;
		}
		if(this.vlctab[5] != null) {
			this.vlctab[5] = null;
		}
		if(this.vlctab[6] != null) {
			this.vlctab[6] = null;
		}
		if(this.vlctab[7] != null) {
			this.vlctab[7] = null;
		}
	}
	,njSkip: function(count) {
		this.pos += count;
		this.size -= count;
		this.length -= count;
	}
	,syntax: function(flag) {
	}
	,get: function(p) {
		return this.bytes.b[this.pos + p];
	}
	,njDecode16: function(p) {
		return this.bytes.b[this.pos + p] << 8 | this.bytes.b[this.pos + (p + 1)];
	}
	,njByteAlign: function() {
		this.bufbits &= 248;
	}
	,njShowBits: function(bits) {
		if(bits == 0) {
			return 0;
		}
		while(this.bufbits < bits) {
			if(this.size <= 0) {
				this.buf = this.buf << 8 | 255;
				this.bufbits += 8;
				continue;
			}
			var newbyte = this.bytes.b[this.pos];
			this.pos++;
			this.size--;
			this.bufbits += 8;
			this.buf = this.buf << 8 | newbyte;
			if(newbyte == 255) {
				var marker = this.bytes.b[this.pos];
				this.pos++;
				this.size--;
				switch(marker) {
				case 217:
					this.size = 0;
					break;
				case 0:case 255:
					break;
				default:
					this.buf = this.buf << 8 | marker;
					this.bufbits += 8;
				}
			}
		}
		return this.buf >> this.bufbits - bits & (1 << bits) - 1;
	}
	,njSkipBits: function(bits) {
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
	}
	,njGetBits: function(bits) {
		var r = this.njShowBits(bits);
		this.bufbits -= bits;
		return r;
	}
	,njDecodeLength: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
	}
	,njSkipMarker: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
	}
	,njDecodeSOF: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.bytes.b[this.pos] != 8) {
			this.notSupported();
		}
		this.height = this.bytes.b[this.pos + 1] << 8 | this.bytes.b[this.pos + 2];
		this.width = this.bytes.b[this.pos + 3] << 8 | this.bytes.b[this.pos + 4];
		this.ncomp = this.bytes.b[this.pos + 5];
		this.pos += 6;
		this.size -= 6;
		this.length -= 6;
		switch(this.ncomp) {
		case 1:case 3:
			break;
		default:
			this.notSupported();
		}
		var ssxmax = 0;
		var ssymax = 0;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.cid = this.bytes.b[this.pos];
			c.ssx = this.bytes.b[this.pos + 1] >> 4;
			if((c.ssx & c.ssx - 1) != 0) {
				this.notSupported();
			}
			c.ssy = this.bytes.b[this.pos + 1] & 15;
			if((c.ssy & c.ssy - 1) != 0) {
				this.notSupported();
			}
			c.qtsel = this.bytes.b[this.pos + 2];
			this.pos += 3;
			this.size -= 3;
			this.length -= 3;
			this.qtused |= 1 << c.qtsel;
			if(c.ssx > ssxmax) {
				ssxmax = c.ssx;
			}
			if(c.ssy > ssymax) {
				ssymax = c.ssy;
			}
		}
		if(this.ncomp == 1) {
			var c = this.comps[0];
			ssymax = 1;
			ssxmax = ssymax;
			c.ssx = c.ssy = ssxmax;
		}
		this.mbsizex = ssxmax << 3;
		this.mbsizey = ssymax << 3;
		this.mbwidth = (this.width + this.mbsizex - 1) / this.mbsizex | 0;
		this.mbheight = (this.height + this.mbsizey - 1) / this.mbsizey | 0;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.width = (this.width * c.ssx + ssxmax - 1) / ssxmax | 0;
			c.stride = c.width + 7 & 2147483640;
			c.height = (this.height * c.ssy + ssymax - 1) / ssymax | 0;
			c.stride = this.mbwidth * this.mbsizex * c.ssx / ssxmax | 0;
			if(c.width < 3 && c.ssx != ssxmax || c.height < 3 && c.ssy != ssymax) {
				this.notSupported();
			}
			c.pixels = new haxe_io_Bytes(new ArrayBuffer(c.stride * (this.mbheight * this.mbsizey * c.ssy / ssymax | 0)));
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
	}
	,njDecodeDQT: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		while(this.length >= 65) {
			var i = this.bytes.b[this.pos];
			this.qtavail |= 1 << i;
			var t = this.qtab[i];
			var _g = 0;
			while(_g < 64) {
				var k = _g++;
				t[k] = this.bytes.b[this.pos + (k + 1)];
			}
			this.pos += 65;
			this.size -= 65;
			this.length -= 65;
		}
	}
	,njDecodeDHT: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		while(this.length >= 17) {
			var i = this.bytes.b[this.pos];
			i = i >> 4 & 1 | (i & 3) << 1;
			this.counts[0] = this.bytes.b[this.pos + 1];
			this.counts[1] = this.bytes.b[this.pos + 2];
			this.counts[2] = this.bytes.b[this.pos + 3];
			this.counts[3] = this.bytes.b[this.pos + 4];
			this.counts[4] = this.bytes.b[this.pos + 5];
			this.counts[5] = this.bytes.b[this.pos + 6];
			this.counts[6] = this.bytes.b[this.pos + 7];
			this.counts[7] = this.bytes.b[this.pos + 8];
			this.counts[8] = this.bytes.b[this.pos + 9];
			this.counts[9] = this.bytes.b[this.pos + 10];
			this.counts[10] = this.bytes.b[this.pos + 11];
			this.counts[11] = this.bytes.b[this.pos + 12];
			this.counts[12] = this.bytes.b[this.pos + 13];
			this.counts[13] = this.bytes.b[this.pos + 14];
			this.counts[14] = this.bytes.b[this.pos + 15];
			this.counts[15] = this.bytes.b[this.pos + 16];
			this.pos += 17;
			this.size -= 17;
			this.length -= 17;
			var vlc = this.vlctab[i];
			var vpos = 0;
			var remain = 65536;
			var spread = 65536;
			var _g = 1;
			while(_g < 17) {
				var codelen = _g++;
				spread >>= 1;
				var currcnt = this.counts[codelen - 1];
				if(currcnt == 0) {
					continue;
				}
				remain -= currcnt << 16 - codelen;
				var _g1 = 0;
				var _g2 = currcnt;
				while(_g1 < _g2) {
					var i1 = _g1++;
					var code = this.bytes.b[this.pos + i1];
					var _g3 = 0;
					var _g4 = spread;
					while(_g3 < _g4) {
						var j = _g3++;
						vlc.b[vpos++] = codelen;
						vlc.b[vpos++] = code;
					}
				}
				this.pos += currcnt;
				this.size -= currcnt;
				this.length -= currcnt;
			}
			while(remain-- != 0) {
				vlc.b[vpos] = 0;
				vpos += 2;
			}
		}
	}
	,njDecodeDRI: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		this.rstinterval = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
	}
	,njGetVLC: function(vlc) {
		var value = this.njShowBits(16);
		var bits = vlc.b[value << 1];
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
		value = vlc.b[value << 1 | 1];
		this.vlcCode = value;
		bits = value & 15;
		if(bits == 0) {
			return 0;
		}
		var r = this.njShowBits(bits);
		this.bufbits -= bits;
		value = r;
		if(value < 1 << bits - 1) {
			value += (-1 << bits) + 1;
		}
		return value;
	}
	,njRowIDCT: function(bp) {
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
			return;
		}
		var x0 = (this.block[bp] << 11) + 128;
		var x8 = 565 * (x4 + x5);
		x4 = x8 + 2276 * x4;
		x5 = x8 - 3406 * x5;
		x8 = 2408 * (x6 + x7);
		x6 = x8 - 799 * x6;
		x7 = x8 - 4017 * x7;
		x8 = x0 + x1;
		x0 -= x1;
		x1 = 1108 * (x3 + x2);
		x2 = x1 - 3784 * x2;
		x3 = x1 + 1568 * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = 181 * (x4 + x5) + 128 >> 8;
		x4 = 181 * (x4 - x5) + 128 >> 8;
		this.block[bp] = x7 + x1 >> 8;
		this.block[bp + 1] = x3 + x2 >> 8;
		this.block[bp + 2] = x0 + x4 >> 8;
		this.block[bp + 3] = x8 + x6 >> 8;
		this.block[bp + 4] = x8 - x6 >> 8;
		this.block[bp + 5] = x0 - x4 >> 8;
		this.block[bp + 6] = x3 - x2 >> 8;
		this.block[bp + 7] = x7 - x1 >> 8;
	}
	,njColIDCT: function(bp,out,po,stride) {
		var x1 = this.block[bp + 32] << 8;
		var x2 = this.block[bp + 48];
		var x3 = this.block[bp + 16];
		var x4 = this.block[bp + 8];
		var x5 = this.block[bp + 56];
		var x6 = this.block[bp + 40];
		var x7 = this.block[bp + 24];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[bp] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			out.b[po] = x1;
			po += stride;
			return;
		}
		var x0 = (this.block[bp] << 8) + 8192;
		var x8 = 565 * (x4 + x5) + 4;
		x4 = x8 + 2276 * x4 >> 3;
		x5 = x8 - 3406 * x5 >> 3;
		x8 = 2408 * (x6 + x7) + 4;
		x6 = x8 - 799 * x6 >> 3;
		x7 = x8 - 4017 * x7 >> 3;
		x8 = x0 + x1;
		x0 -= x1;
		x1 = 1108 * (x3 + x2) + 4;
		x2 = x1 - 3784 * x2 >> 3;
		x3 = x1 + 1568 * x3 >> 3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = 181 * (x4 + x5) + 128 >> 8;
		x4 = 181 * (x4 - x5) + 128 >> 8;
		var x = (x7 + x1 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x3 + x2 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x0 + x4 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x8 + x6 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x8 - x6 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x0 - x4 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x3 - x2 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
		po += stride;
		var x = (x7 - x1 >> 14) + 128;
		out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
	}
	,njDecodeBlock: function(c,po) {
		var out = c.pixels;
		var value;
		var coef = 0;
		var _g = 0;
		while(_g < 64) {
			var i = _g++;
			this.block[i] = 0;
		}
		var c1 = c;
		var c2 = c1.dcpred;
		var vlc = this.vlctab[c.dctabsel];
		var value1 = this.njShowBits(16);
		var bits = vlc.b[value1 << 1];
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
		value1 = vlc.b[value1 << 1 | 1];
		this.vlcCode = value1;
		bits = value1 & 15;
		var tmp;
		if(bits == 0) {
			tmp = 0;
		} else {
			var r = this.njShowBits(bits);
			this.bufbits -= bits;
			value1 = r;
			if(value1 < 1 << bits - 1) {
				value1 += (-1 << bits) + 1;
			}
			tmp = value1;
		}
		c1.dcpred = c2 + tmp;
		var qt = this.qtab[c.qtsel];
		var at = this.vlctab[c.actabsel];
		this.block[0] = c.dcpred * qt[0];
		do {
			var value1 = this.njShowBits(16);
			var bits = at.b[value1 << 1];
			if(this.bufbits < bits) {
				this.njShowBits(bits);
			}
			this.bufbits -= bits;
			value1 = at.b[value1 << 1 | 1];
			this.vlcCode = value1;
			bits = value1 & 15;
			if(bits == 0) {
				value = 0;
			} else {
				var r = this.njShowBits(bits);
				this.bufbits -= bits;
				value1 = r;
				if(value1 < 1 << bits - 1) {
					value1 += (-1 << bits) + 1;
				}
				value = value1;
			}
			if(this.vlcCode == 0) {
				break;
			}
			coef += (this.vlcCode >> 4) + 1;
			this.block[this.njZZ[coef]] = value * qt[coef];
		} while(coef < 63);
		var bp = 0;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 8;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 16;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 24;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 32;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 40;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 48;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var bp = 56;
		var x0;
		var x8;
		var x1 = this.block[bp + 4] << 11;
		var x2 = this.block[bp + 6];
		var x3 = this.block[bp + 2];
		var x4 = this.block[bp + 1];
		var x5 = this.block[bp + 7];
		var x6 = this.block[bp + 5];
		var x7 = this.block[bp + 3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var val = this.block[bp + 7] = this.block[bp] << 3;
			var val1 = this.block[bp + 6] = val;
			var val = this.block[bp + 5] = val1;
			var val1 = this.block[bp + 4] = val;
			var val = this.block[bp + 3] = val1;
			var val1 = this.block[bp + 2] = val;
			var val = this.block[bp + 1] = val1;
			this.block[bp] = val;
		} else {
			x0 = (this.block[bp] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[bp] = x7 + x1 >> 8;
			this.block[bp + 1] = x3 + x2 >> 8;
			this.block[bp + 2] = x0 + x4 >> 8;
			this.block[bp + 3] = x8 + x6 >> 8;
			this.block[bp + 4] = x8 - x6 >> 8;
			this.block[bp + 5] = x0 - x4 >> 8;
			this.block[bp + 6] = x3 - x2 >> 8;
			this.block[bp + 7] = x7 - x1 >> 8;
		}
		var po1 = po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[32] << 8;
		var x2 = this.block[48];
		var x3 = this.block[16];
		var x4 = this.block[8];
		var x5 = this.block[56];
		var x6 = this.block[40];
		var x7 = this.block[24];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[0] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[0] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 1 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[33] << 8;
		var x2 = this.block[49];
		var x3 = this.block[17];
		var x4 = this.block[9];
		var x5 = this.block[57];
		var x6 = this.block[41];
		var x7 = this.block[25];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[1] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[1] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 2 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[34] << 8;
		var x2 = this.block[50];
		var x3 = this.block[18];
		var x4 = this.block[10];
		var x5 = this.block[58];
		var x6 = this.block[42];
		var x7 = this.block[26];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[2] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[2] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 3 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[35] << 8;
		var x2 = this.block[51];
		var x3 = this.block[19];
		var x4 = this.block[11];
		var x5 = this.block[59];
		var x6 = this.block[43];
		var x7 = this.block[27];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[3] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[3] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 4 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[36] << 8;
		var x2 = this.block[52];
		var x3 = this.block[20];
		var x4 = this.block[12];
		var x5 = this.block[60];
		var x6 = this.block[44];
		var x7 = this.block[28];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[4] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[4] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 5 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[37] << 8;
		var x2 = this.block[53];
		var x3 = this.block[21];
		var x4 = this.block[13];
		var x5 = this.block[61];
		var x6 = this.block[45];
		var x7 = this.block[29];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[5] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[5] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 6 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[38] << 8;
		var x2 = this.block[54];
		var x3 = this.block[22];
		var x4 = this.block[14];
		var x5 = this.block[62];
		var x6 = this.block[46];
		var x7 = this.block[30];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[6] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[6] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
		var po1 = 7 + po;
		var stride = c.stride;
		var x0;
		var x8;
		var x1 = this.block[39] << 8;
		var x2 = this.block[55];
		var x3 = this.block[23];
		var x4 = this.block[15];
		var x5 = this.block[63];
		var x6 = this.block[47];
		var x7 = this.block[31];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			var x = (this.block[7] + 32 >> 6) + 128;
			x1 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
			out.b[po1] = x1;
			po1 += stride;
		} else {
			x0 = (this.block[7] << 8) + 8192;
			x8 = 565 * (x4 + x5) + 4;
			x4 = x8 + 2276 * x4 >> 3;
			x5 = x8 - 3406 * x5 >> 3;
			x8 = 2408 * (x6 + x7) + 4;
			x6 = x8 - 799 * x6 >> 3;
			x7 = x8 - 4017 * x7 >> 3;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2) + 4;
			x2 = x1 - 3784 * x2 >> 3;
			x3 = x1 + 1568 * x3 >> 3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			var x = (x7 + x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 + x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 + x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 + x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x8 - x6 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x0 - x4 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x3 - x2 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 += stride;
			var x = (x7 - x1 >> 14) + 128;
			out.b[po1] = x < 0 ? 0 : x > 255 ? 255 : x;
		}
	}
	,notSupported: function() {
		throw haxe_Exception.thrown("This JPG file is not supported");
	}
	,njDecodeScan: function() {
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.bytes.b[this.pos] != this.ncomp) {
			this.notSupported();
		}
		this.pos += 1;
		this.size -= 1;
		this.length -= 1;
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			c.dctabsel = this.bytes.b[this.pos + 1] >> 4 << 1;
			c.actabsel = (this.bytes.b[this.pos + 1] & 3) << 1 | 1;
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
		}
		var start = this.bytes.b[this.pos];
		var count = this.bytes.b[this.pos + 1];
		var other = this.bytes.b[this.pos + 2];
		if(!this.progressive && start != 0 || count != 63 - start || other != 0) {
			this.notSupported();
		}
		var count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		var mbx = 0;
		var mby = 0;
		var rstcount = this.rstinterval;
		var nextrst = 0;
		while(true) {
			var _g = 0;
			var _g1 = this.ncomp;
			while(_g < _g1) {
				var i = _g++;
				var c = this.comps[i];
				var _g2 = 0;
				var _g3 = c.ssy;
				while(_g2 < _g3) {
					var sby = _g2++;
					var _g4 = 0;
					var _g5 = c.ssx;
					while(_g4 < _g5) {
						var sbx = _g4++;
						this.njDecodeBlock(c,(mby * c.ssy + sby) * c.stride + mbx * c.ssx + sbx << 3);
					}
				}
			}
			if(++mbx >= this.mbwidth) {
				mbx = 0;
				if(++mby >= this.mbheight) {
					break;
				}
			}
			if(this.rstinterval != 0 && --rstcount == 0) {
				this.bufbits &= 248;
				var r = this.njShowBits(16);
				this.bufbits -= 16;
				var i1 = r;
				nextrst = nextrst + 1 & 7;
				rstcount = this.rstinterval;
				this.comps[0].dcpred = 0;
				this.comps[1].dcpred = 0;
				this.comps[2].dcpred = 0;
			}
		}
	}
	,njUpsampleH: function(c) {
		var xmax = c.width - 3;
		var cout = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		var lout = cout;
		var lin = c.pixels;
		var pi = 0;
		var po = 0;
		var _g = 0;
		var _g1 = c.height;
		while(_g < _g1) {
			var y = _g++;
			var x = 139 * lin.b[pi] + -11 * lin.b[pi + 1] + 64 >> 7;
			lout.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
			var x1 = 104 * lin.b[pi] + 27 * lin.b[pi + 1] + -3 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 1] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			var x2 = 28 * lin.b[pi] + 109 * lin.b[pi + 1] + -9 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 2] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			var _g2 = 0;
			var _g3 = xmax;
			while(_g2 < _g3) {
				var x3 = _g2++;
				var x4 = -9 * lin.b[pi + x3] + 111 * lin.b[pi + x3 + 1] + 29 * lin.b[pi + x3 + 2] + -3 * lin.b[pi + x3 + 3] + 64 >> 7;
				lout.b[po + (x3 << 1) + 3] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
				var x5 = -3 * lin.b[pi + x3] + 29 * lin.b[pi + x3 + 1] + 111 * lin.b[pi + x3 + 2] + -9 * lin.b[pi + x3 + 3] + 64 >> 7;
				lout.b[po + (x3 << 1) + 4] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			}
			pi += c.stride;
			po += c.width << 1;
			var x6 = 28 * lin.b[pi - 1] + 109 * lin.b[pi - 2] + -9 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 3] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			var x7 = 104 * lin.b[pi - 1] + 27 * lin.b[pi - 2] + -3 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 2] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
			var x8 = 139 * lin.b[pi - 1] + -11 * lin.b[pi - 2] + 64 >> 7;
			lout.b[po - 1] = x8 < 0 ? 0 : x8 > 255 ? 255 : x8;
		}
		c.width <<= 1;
		c.stride = c.width;
		c.pixels = cout;
	}
	,njUpsampleV: function(c) {
		var w = c.width;
		var s1 = c.stride;
		var s2 = s1 + s1;
		var out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		var pi = 0;
		var po = 0;
		var cout = out;
		var cin = c.pixels;
		var _g = 0;
		var _g1 = w;
		while(_g < _g1) {
			var x = _g++;
			po = x;
			pi = po;
			var x1 = 139 * cin.b[pi] + -11 * cin.b[pi + s1] + 64 >> 7;
			cout.b[po] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po += w;
			var x2 = 104 * cin.b[pi] + 27 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po += w;
			var x3 = 28 * cin.b[pi] + 109 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po += w;
			pi += s1;
			var _g2 = 0;
			var _g3 = c.height - 2;
			while(_g2 < _g3) {
				var y = _g2++;
				var x4 = -9 * cin.b[pi - s1] + 111 * cin.b[pi] + 29 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
				po += w;
				var x5 = -3 * cin.b[pi - s1] + 29 * cin.b[pi] + 111 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
				po += w;
				pi += s1;
			}
			pi += s1;
			var x6 = 28 * cin.b[pi] + 109 * cin.b[pi - s1] + -9 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po += w;
			var x7 = 104 * cin.b[pi] + 27 * cin.b[pi - s1] + -3 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
			po += w;
			var x8 = 139 * cin.b[pi] + -11 * cin.b[pi - s1] + 64 >> 7;
			cout.b[po] = x8 < 0 ? 0 : x8 > 255 ? 255 : x8;
		}
		c.height <<= 1;
		c.stride = c.width;
		c.pixels = out;
	}
	,njUpsample: function(c) {
		var xshift = 0;
		var yshift = 0;
		while(c.width < this.width) {
			c.width <<= 1;
			++xshift;
		}
		while(c.height < this.height) {
			c.height <<= 1;
			++yshift;
		}
		var out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height));
		var lin = c.pixels;
		var pout = 0;
		var lout = out;
		var _g = 0;
		var _g1 = c.height;
		while(_g < _g1) {
			var y = _g++;
			var pin = (y >> yshift) * c.stride;
			var _g2 = 0;
			var _g3 = c.width;
			while(_g2 < _g3) {
				var x = _g2++;
				lout.b[pout++] = lin.b[(x >> xshift) + pin];
			}
		}
		c.stride = c.width;
		c.pixels = out;
	}
	,njConvert: function() {
		var _g = 0;
		var _g1 = this.ncomp;
		while(_g < _g1) {
			var i = _g++;
			var c = this.comps[i];
			switch(this.filter._hx_index) {
			case 0:
				if(c.width < this.width || c.height < this.height) {
					this.njUpsample(c);
				}
				break;
			case 1:
				while(c.width < this.width || c.height < this.height) {
					if(c.width < this.width) {
						this.njUpsampleH(c);
					}
					if(c.height < this.height) {
						this.njUpsampleV(c);
					}
				}
				break;
			}
			if(c.width < this.width || c.height < this.height) {
				throw haxe_Exception.thrown("assert");
			}
		}
		var pixels = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
		if(this.ncomp == 3) {
			var py = this.comps[0].pixels;
			var pcb = this.comps[1].pixels;
			var pcr = this.comps[2].pixels;
			var pix = pixels;
			var k1 = 0;
			var k2 = 0;
			var k3 = 0;
			var out = 0;
			var _g = 0;
			var _g1 = this.height;
			while(_g < _g1) {
				var yy = _g++;
				var _g2 = 0;
				var _g3 = this.width;
				while(_g2 < _g3) {
					var x = _g2++;
					var y = py.b[k1++] << 8;
					var cb = pcb.b[k2++] - 128;
					var cr = pcr.b[k3++] - 128;
					var x1 = y + 359 * cr + 128 >> 8;
					var r = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
					var x2 = y - 88 * cb - 183 * cr + 128 >> 8;
					var g = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
					var x3 = y + 454 * cb + 128 >> 8;
					var b = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
					pix.b[out++] = b;
					pix.b[out++] = g;
					pix.b[out++] = r;
					pix.b[out++] = 255;
				}
				k1 += this.comps[0].stride - this.width;
				k2 += this.comps[1].stride - this.width;
				k3 += this.comps[2].stride - this.width;
			}
		} else {
			throw haxe_Exception.thrown("TODO");
		}
		return pixels;
	}
	,njDecode: function() {
		if(this.size < 2 || this.bytes.b[this.pos] != 255 || this.bytes.b[this.pos + 1] != 216) {
			throw haxe_Exception.thrown("This file is not a JPEG");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		_hx_loop1: while(true) {
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
			switch(this.bytes.b[this.pos + (-1)]) {
			case 192:
				this.njDecodeSOF();
				break;
			case 194:
				this.progressive = true;
				if(this.progressive) {
					throw haxe_Exception.thrown("Unsupported progressive JPG");
				}
				if(this.vlctab[4] == null) {
					this.vlctab[4] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[5] == null) {
					this.vlctab[5] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[6] == null) {
					this.vlctab[6] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[7] == null) {
					this.vlctab[7] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				this.njDecodeSOF();
				break;
			case 195:
				throw haxe_Exception.thrown("Unsupported lossless JPG");
			case 196:
				this.njDecodeDHT();
				break;
			case 218:
				this.njDecodeScan();
				break _hx_loop1;
			case 219:
				this.njDecodeDQT();
				break;
			case 221:
				this.njDecodeDRI();
				break;
			case 254:
				this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
				this.pos += 2;
				this.size -= 2;
				this.length -= 2;
				var count = this.length;
				this.pos += count;
				this.size -= count;
				this.length -= count;
				break;
			default:
				switch(this.bytes.b[this.pos + (-1)] & 240) {
				case 192:
					throw haxe_Exception.thrown("Unsupported jpeg type " + (this.bytes.b[this.pos + (-1)] & 15));
				case 224:
					this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
					this.pos += 2;
					this.size -= 2;
					this.length -= 2;
					var count1 = this.length;
					this.pos += count1;
					this.size -= count1;
					this.length -= count1;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported jpeg tag 0x" + StringTools.hex(this.bytes.b[this.pos + (-1)],2));
				}
			}
		}
		var pixels = this.njConvert();
		this.cleanup();
		return { pixels : pixels, width : this.width, height : this.height};
	}
	,__class__: hxd_res_NanoJpeg
};
var hxd_res_SoundFormat = $hxEnums["hxd.res.SoundFormat"] = { __ename__:"hxd.res.SoundFormat",__constructs__:null
	,Wav: {_hx_name:"Wav",_hx_index:0,__enum__:"hxd.res.SoundFormat",toString:$estr}
	,Mp3: {_hx_name:"Mp3",_hx_index:1,__enum__:"hxd.res.SoundFormat",toString:$estr}
	,OggVorbis: {_hx_name:"OggVorbis",_hx_index:2,__enum__:"hxd.res.SoundFormat",toString:$estr}
};
hxd_res_SoundFormat.__constructs__ = [hxd_res_SoundFormat.Wav,hxd_res_SoundFormat.Mp3,hxd_res_SoundFormat.OggVorbis];
hxd_res_SoundFormat.__empty_constructs__ = [hxd_res_SoundFormat.Wav,hxd_res_SoundFormat.Mp3,hxd_res_SoundFormat.OggVorbis];
var hxd_res_Sound = function(entry) {
	this.lastPlay = 0.;
	hxd_res_Resource.call(this,entry);
};
$hxClasses["hxd.res.Sound"] = hxd_res_Sound;
hxd_res_Sound.__name__ = "hxd.res.Sound";
hxd_res_Sound.supportedFormat = function(fmt) {
	switch(fmt._hx_index) {
	case 0:case 1:
		return true;
	case 2:
		return false;
	}
};
hxd_res_Sound.startWorker = function() {
	return false;
};
hxd_res_Sound.__super__ = hxd_res_Resource;
hxd_res_Sound.prototype = $extend(hxd_res_Resource.prototype,{
	getData: function() {
		if(this.data != null) {
			return this.data;
		}
		var bytes = this.entry.getBytes();
		switch(bytes.b[0]) {
		case 73:case 255:
			this.data = new hxd_snd_Mp3Data(bytes);
			break;
		case 79:
			throw haxe_Exception.thrown("OGG format requires -lib stb_ogg_sound (for " + this.entry.get_path() + ")");
		case 82:
			this.data = new hxd_snd_WavData(bytes);
			break;
		default:
		}
		if(this.data == null) {
			throw haxe_Exception.thrown("Unsupported sound format " + this.entry.get_path());
		}
		if(hxd_res_Sound.ENABLE_AUTO_WATCH) {
			this.watch($bind(this,this.watchCallb));
		}
		return this.data;
	}
	,dispose: function() {
		this.stop();
		this.data = null;
	}
	,stop: function() {
		if(this.channel != null) {
			this.channel.stop();
			this.channel = null;
		}
	}
	,play: function(loop,volume,channelGroup,soundGroup) {
		if(volume == null) {
			volume = 1.;
		}
		if(loop == null) {
			loop = false;
		}
		this.lastPlay = HxOverrides.now() / 1000;
		this.channel = hxd_snd_Manager.get().play(this,channelGroup,soundGroup);
		this.channel.loop = loop;
		this.channel.set_volume(volume);
		return this.channel;
	}
	,watchCallb: function() {
		var old = this.data;
		this.data = null;
		var data = this.getData();
		if(old != null) {
			if(old.channels != data.channels || old.samples != data.samples || old.sampleFormat != data.sampleFormat || old.samplingRate != data.samplingRate) {
				var manager = hxd_snd_Manager.get();
				var ch = manager.getAll(this);
				while(ch.hasNext()) {
					var ch1 = ch.next();
					ch1.duration = data.get_duration();
					ch1.set_position(ch1.position);
				}
			}
		}
	}
	,__class__: hxd_res_Sound
});
var hxd_snd_ChannelBase = function() {
	this.volume = 1.;
	this.bindedEffects = [];
	this.effects = [];
	this.mute = false;
	this.priority = 0.;
};
$hxClasses["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase;
hxd_snd_ChannelBase.__name__ = "hxd.snd.ChannelBase";
hxd_snd_ChannelBase.prototype = {
	getEffect: function(etype) {
		if(this.effects == null) {
			return null;
		}
		var _g = 0;
		var _g1 = this.effects;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			var e1 = js_Boot.__downcastCheck(e,etype) ? e : null;
			if(e1 != null) {
				return e1;
			}
		}
		return null;
	}
	,set_volume: function(v) {
		this.currentFade = null;
		return this.volume = v;
	}
	,fadeTo: function(volume,time,onEnd) {
		if(time == null) {
			time = 1.;
		}
		this.currentFade = { start : HxOverrides.now() / 1000, duration : time, startVolume : this.volume, targetVolume : volume, onEnd : onEnd};
	}
	,updateCurrentVolume: function(now) {
		if(this.currentFade != null) {
			var f = this.currentFade;
			var dt = now - f.start;
			if(dt >= f.duration) {
				this.set_volume(f.targetVolume);
				if(f.onEnd != null) {
					f.onEnd();
				}
			} else {
				this.set_volume(f.startVolume + dt / f.duration * (f.targetVolume - f.startVolume));
				this.currentFade = f;
			}
		}
		this.currentVolume = this.volume;
	}
	,addEffect: function(e) {
		if(e == null) {
			throw haxe_Exception.thrown("Can't add null effect");
		}
		if(this.effects.indexOf(e) >= 0) {
			throw haxe_Exception.thrown("effect already added on this channel");
		}
		this.effects.push(e);
		return e;
	}
	,removeEffect: function(e) {
		HxOverrides.remove(this.effects,e);
	}
	,__class__: hxd_snd_ChannelBase
};
var hxd_snd_Channel = function() {
	this.queue = [];
	this.positionChanged = false;
	this.isLoading = false;
	this.isVirtual = false;
	this.lastStamp = 0.0;
	this.audibleVolume = 1.0;
	this.allowVirtual = true;
	this.loop = false;
	this.pause = false;
	this.position = 0.0;
	hxd_snd_ChannelBase.call(this);
	this.id = hxd_snd_Channel.ID++;
};
$hxClasses["hxd.snd.Channel"] = hxd_snd_Channel;
hxd_snd_Channel.__name__ = "hxd.snd.Channel";
hxd_snd_Channel.__super__ = hxd_snd_ChannelBase;
hxd_snd_Channel.prototype = $extend(hxd_snd_ChannelBase.prototype,{
	onEnd: function() {
	}
	,set_position: function(v) {
		this.lastStamp = HxOverrides.now() / 1000;
		this.positionChanged = true;
		if(v > this.duration) {
			v = this.duration;
		} else if(v < 0) {
			v = 0;
		}
		return this.position = v;
	}
	,set_pause: function(v) {
		if(!v) {
			this.lastStamp = HxOverrides.now() / 1000;
		}
		return this.pause = v;
	}
	,updateCurrentVolume: function(now) {
		if(this.pause && this.currentFade != null) {
			var f = this.currentFade;
			this.currentFade = null;
			this.updateCurrentVolume(now);
			this.currentFade = f;
		}
		hxd_snd_ChannelBase.prototype.updateCurrentVolume.call(this,now);
		this.channelGroup.updateCurrentVolume(now);
		this.currentVolume *= this.channelGroup.currentVolume * this.soundGroup.volume;
		if(this.manager != null) {
			var _g = 0;
			var _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
			var _g = 0;
			var _g1 = this.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
		}
	}
	,calcAudibleVolume: function(now) {
		this.updateCurrentVolume(now);
		this.audibleVolume = this.currentVolume;
		if(this.manager != null) {
			var _g = 0;
			var _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
			var _g = 0;
			var _g1 = this.effects;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
		}
	}
	,queueSound: function(sound) {
		this.queue.push(sound);
	}
	,stop: function() {
		if(this.manager != null) {
			this.manager.releaseChannel(this);
		}
	}
	,isReleased: function() {
		return this.manager == null;
	}
	,__class__: hxd_snd_Channel
});
var hxd_snd_ChannelGroup = function(name) {
	hxd_snd_ChannelBase.call(this);
	this.name = name;
};
$hxClasses["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup;
hxd_snd_ChannelGroup.__name__ = "hxd.snd.ChannelGroup";
hxd_snd_ChannelGroup.__super__ = hxd_snd_ChannelBase;
hxd_snd_ChannelGroup.prototype = $extend(hxd_snd_ChannelBase.prototype,{
	__class__: hxd_snd_ChannelGroup
});
var hxd_snd_SampleFormat = $hxEnums["hxd.snd.SampleFormat"] = { __ename__:"hxd.snd.SampleFormat",__constructs__:null
	,UI8: {_hx_name:"UI8",_hx_index:0,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,I16: {_hx_name:"I16",_hx_index:1,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,F32: {_hx_name:"F32",_hx_index:2,__enum__:"hxd.snd.SampleFormat",toString:$estr}
};
hxd_snd_SampleFormat.__constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
hxd_snd_SampleFormat.__empty_constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
var hxd_snd_Data = function() { };
$hxClasses["hxd.snd.Data"] = hxd_snd_Data;
hxd_snd_Data.__name__ = "hxd.snd.Data";
hxd_snd_Data.formatBytes = function(format) {
	switch(format._hx_index) {
	case 0:
		return 1;
	case 1:
		return 2;
	case 2:
		return 4;
	}
};
hxd_snd_Data.prototype = {
	isLoading: function() {
		return false;
	}
	,decode: function(out,outPos,sampleStart,sampleCount) {
		var bpp = this.getBytesPerSample();
		if(sampleStart < 0 || sampleCount < 0 || outPos < 0 || outPos + sampleCount * bpp > out.length) {
			var s = "sampleStart = " + sampleStart;
			s += " sampleCount = " + sampleCount;
			s += " outPos = " + outPos;
			s += " bpp = " + bpp;
			s += " out.length = " + out.length;
			throw haxe_Exception.thrown(s);
		}
		if(sampleStart + sampleCount >= this.samples) {
			var count = 0;
			if(sampleStart < this.samples) {
				count = this.samples - sampleStart;
				this.decodeBuffer(out,outPos,sampleStart,count);
			}
			out.fill(outPos + count * bpp,(sampleCount - count) * bpp,0);
			return;
		}
		this.decodeBuffer(out,outPos,sampleStart,sampleCount);
	}
	,resample: function(rate,format,channels) {
		if(this.sampleFormat == format && this.samplingRate == rate && this.channels == channels) {
			return this;
		}
		var newSamples = Math.ceil(this.samples * (rate / this.samplingRate));
		var bpp = this.getBytesPerSample();
		var data = new haxe_io_Bytes(new ArrayBuffer(bpp * this.samples));
		this.decodeBuffer(data,0,0,this.samples);
		var out = channels * newSamples;
		var out1;
		switch(format._hx_index) {
		case 0:
			out1 = 1;
			break;
		case 1:
			out1 = 2;
			break;
		case 2:
			out1 = 4;
			break;
		}
		var out2 = new haxe_io_Bytes(new ArrayBuffer(out * out1));
		this.resampleBuffer(out2,0,data,0,rate,format,channels,this.samples);
		var data = new hxd_snd_WavData(null);
		data.channels = channels;
		data.samples = newSamples;
		data.sampleFormat = format;
		data.samplingRate = rate;
		data.rawData = out2;
		return data;
	}
	,resampleBuffer: function(out,outPos,input,inPos,rate,format,channels,samples) {
		var bpp = this.getBytesPerSample();
		var newSamples = Math.ceil(samples * (rate / this.samplingRate));
		var resample = samples != newSamples;
		if(!resample && this.sampleFormat == hxd_snd_SampleFormat.I16 && format == hxd_snd_SampleFormat.I16 && channels == 1 && this.channels == 2) {
			var r = inPos;
			var w = outPos;
			var _g = 0;
			var _g1 = samples;
			while(_g < _g1) {
				var i = _g++;
				var sl = input.getUInt16(r);
				r += 2;
				var sr = input.getUInt16(r);
				r += 2;
				var s;
				if((sl ^ sr) >= 32768) {
					if((sl & 32768) != 0) {
						sl |= -65536;
					}
					if((sr & 32768) != 0) {
						sr |= -65536;
					}
					s = sl + sr >> 1 & 65535;
				} else {
					s = sl + sr >> 1;
				}
				out.setUInt16(w,s);
				w += 2;
			}
			return;
		}
		var srcChannels = this.channels;
		var commonChannels = channels < srcChannels ? channels : srcChannels;
		var extraChannels = channels - commonChannels;
		var sval = 0.;
		var ival = 0;
		var _g = 0;
		var _g1 = newSamples;
		while(_g < _g1) {
			var i = _g++;
			var targetSample = i / (newSamples - 1) * (samples - 1);
			var isample = targetSample | 0;
			var offset = targetSample - isample;
			var srcPos = inPos + isample * bpp;
			if(isample == samples - 1) {
				resample = false;
			}
			var _g2 = 0;
			var _g3 = commonChannels;
			while(_g2 < _g3) {
				var k = _g2++;
				var sval1;
				var sval2 = 0.;
				switch(this.sampleFormat._hx_index) {
				case 0:
					sval1 = input.b[srcPos] / 255;
					if(resample) {
						sval2 = input.b[srcPos + bpp] / 255;
					}
					++srcPos;
					break;
				case 1:
					var v = input.getUInt16(srcPos);
					sval1 = ((v & 32768) == 0 ? v : v | -65536) / 32768;
					if(resample) {
						var v1 = input.getUInt16(srcPos + bpp);
						sval2 = ((v1 & 32768) == 0 ? v1 : v1 | -65536) / 32768;
					}
					srcPos += 2;
					break;
				case 2:
					sval1 = input.getFloat(srcPos);
					if(resample) {
						sval2 = input.getFloat(srcPos + bpp);
					}
					srcPos += 4;
					break;
				}
				sval = resample ? sval1 + offset * (sval2 - sval1) : sval1;
				switch(format._hx_index) {
				case 0:
					ival = (sval + 1) * 128 | 0;
					if(ival > 255) {
						ival = 255;
					}
					out.b[outPos++] = ival;
					break;
				case 1:
					ival = sval * 32768 | 0;
					if(ival > 32767) {
						ival = 32767;
					}
					ival &= 65535;
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
			var _g4 = 0;
			var _g5 = extraChannels;
			while(_g4 < _g5) {
				var i1 = _g4++;
				switch(format._hx_index) {
				case 0:
					out.b[outPos++] = ival;
					break;
				case 1:
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,getBytesPerSample: function() {
		var tmp;
		switch(this.sampleFormat._hx_index) {
		case 0:
			tmp = 1;
			break;
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 4;
			break;
		}
		return this.channels * tmp;
	}
	,load: function(onEnd) {
		onEnd();
	}
	,get_duration: function() {
		return this.samples / this.samplingRate;
	}
	,__class__: hxd_snd_Data
};
var hxd_snd_EffectDriver = function() {
};
$hxClasses["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver;
hxd_snd_EffectDriver.__name__ = "hxd.snd.EffectDriver";
hxd_snd_EffectDriver.prototype = {
	acquire: function() {
	}
	,release: function() {
	}
	,update: function(e) {
	}
	,bind: function(e,source) {
	}
	,apply: function(e,source) {
	}
	,unbind: function(e,source) {
	}
	,__class__: hxd_snd_EffectDriver
};
var hxd_snd_DriverFeature = $hxEnums["hxd.snd.DriverFeature"] = { __ename__:"hxd.snd.DriverFeature",__constructs__:null
	,MasterVolume: {_hx_name:"MasterVolume",_hx_index:0,__enum__:"hxd.snd.DriverFeature",toString:$estr}
};
hxd_snd_DriverFeature.__constructs__ = [hxd_snd_DriverFeature.MasterVolume];
hxd_snd_DriverFeature.__empty_constructs__ = [hxd_snd_DriverFeature.MasterVolume];
var hxd_snd_Driver = function() { };
$hxClasses["hxd.snd.Driver"] = hxd_snd_Driver;
hxd_snd_Driver.__name__ = "hxd.snd.Driver";
hxd_snd_Driver.__isInterface__ = true;
hxd_snd_Driver.prototype = {
	__class__: hxd_snd_Driver
};
var hxd_snd_Effect = function(type) {
	this.refs = 0;
	this.priority = 0;
	this.retainTime = 0.0;
	this.lastStamp = 0.0;
	var managerDriver = hxd_snd_Manager.get().driver;
	if(managerDriver != null) {
		this.driver = managerDriver.getEffectDriver(type);
	}
};
$hxClasses["hxd.snd.Effect"] = hxd_snd_Effect;
hxd_snd_Effect.__name__ = "hxd.snd.Effect";
hxd_snd_Effect.prototype = {
	applyAudibleVolumeModifier: function(v) {
		return v;
	}
	,getVolumeModifier: function() {
		return 1;
	}
	,__class__: hxd_snd_Effect
};
var hxd_snd_Listener = function() {
	this.position = new h3d_VectorImpl(0.,0.,0.);
	this.velocity = new h3d_VectorImpl(0.,0.,0.);
	var x = 1;
	var y = 0;
	var z = 0;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.direction = new h3d_VectorImpl(x,y,z);
	var x = 0;
	var y = 0;
	var z = 1;
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	this.up = new h3d_VectorImpl(x,y,z);
};
$hxClasses["hxd.snd.Listener"] = hxd_snd_Listener;
hxd_snd_Listener.__name__ = "hxd.snd.Listener";
hxd_snd_Listener.prototype = {
	syncCamera: function(cam) {
		var _this = this.position;
		var v = cam.pos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		var _this = this.direction;
		var x = cam.target.x - cam.pos.x;
		var y = cam.target.y - cam.pos.y;
		var z = cam.target.z - cam.pos.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		var _this = this.direction;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		var _this = this.up;
		var v = cam.up;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
	}
	,__class__: hxd_snd_Listener
};
var hxd_snd_Source = function(driver) {
	this.start = 0;
	this.playing = false;
	this.volume = -1.0;
	this.id = hxd_snd_Source.ID++;
	this.handle = driver.createSource();
	this.buffers = [];
};
$hxClasses["hxd.snd.Source"] = hxd_snd_Source;
hxd_snd_Source.__name__ = "hxd.snd.Source";
hxd_snd_Source.prototype = {
	dispose: function() {
		hxd_snd_Manager.get().driver.destroySource(this.handle);
	}
	,__class__: hxd_snd_Source
};
var hxd_snd_Buffer = function(driver) {
	this.end = 0;
	this.handle = driver.createBuffer();
	this.refs = 0;
	this.lastStop = HxOverrides.now() / 1000;
};
$hxClasses["hxd.snd.Buffer"] = hxd_snd_Buffer;
hxd_snd_Buffer.__name__ = "hxd.snd.Buffer";
hxd_snd_Buffer.prototype = {
	dispose: function() {
		hxd_snd_Manager.get().driver.destroyBuffer(this.handle);
	}
	,__class__: hxd_snd_Buffer
};
var hxd_snd_Manager = function() {
	this.suspended = false;
	this.timeOffset = 0.;
	try {
		this.driver = new hxd_snd_webaudio_Driver();
	} catch( _g ) {
		if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
			this.driver = null;
		} else {
			throw _g;
		}
	}
	this.masterVolume = 1.0;
	this.hasMasterVolume = this.driver == null ? true : this.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume);
	this.masterSoundGroup = new hxd_snd_SoundGroup("master");
	this.masterChannelGroup = new hxd_snd_ChannelGroup("master");
	this.listener = new hxd_snd_Listener();
	this.soundBufferMap = new haxe_ds_StringMap();
	this.soundBufferKeys = [];
	this.freeStreamBuffers = [];
	this.effectGC = [];
	this.soundBufferCount = 0;
	if(this.driver != null) {
		this.sources = [];
		var _g = 0;
		var _g1 = hxd_snd_Manager.MAX_SOURCES;
		while(_g < _g1) {
			var i = _g++;
			this.sources.push(new hxd_snd_Source(this.driver));
		}
	}
	this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(24));
	this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2));
};
$hxClasses["hxd.snd.Manager"] = hxd_snd_Manager;
hxd_snd_Manager.__name__ = "hxd.snd.Manager";
hxd_snd_Manager.get = function() {
	if(hxd_snd_Manager.instance == null) {
		hxd_snd_Manager.instance = new hxd_snd_Manager();
		hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(($_=hxd_snd_Manager.instance,$bind($_,$_.update)));
		hxd_snd_Manager.instance.updateEvent.isBlocking = false;
	}
	return hxd_snd_Manager.instance;
};
hxd_snd_Manager.regEffect = function(list,e) {
	var l = list;
	while(l != null) {
		if(l == e) {
			return list;
		}
		l = l.next;
	}
	e.next = list;
	return e;
};
hxd_snd_Manager.prototype = {
	getTmpBytes: function(size) {
		if(this.cachedBytes.length < size) {
			this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.cachedBytes;
	}
	,getResampleBytes: function(size) {
		if(this.resampleBytes.length < size) {
			this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.resampleBytes;
	}
	,stopAll: function() {
		while(this.channels != null) this.channels.stop();
	}
	,stopAllNotLooping: function() {
		var c = this.channels;
		while(c != null) {
			var n = c.next;
			if(!c.loop) {
				c.stop();
			}
			c = n;
		}
	}
	,stopByName: function(name) {
		var c = this.channels;
		while(c != null) {
			var n = c.next;
			if(c.soundGroup != null && c.soundGroup.name == name) {
				c.stop();
			}
			c = n;
		}
	}
	,getAll: function(sound) {
		var ch = this.channels;
		var result = [];
		while(ch != null) {
			if(ch.sound == sound) {
				result.push(ch);
			}
			ch = ch.next;
		}
		return new hxd_impl_ArrayIterator_$hxd_$snd_$Channel(result);
	}
	,cleanCache: function() {
		var i = 0;
		while(i < this.soundBufferKeys.length) {
			var k = this.soundBufferKeys[i];
			var b = this.soundBufferMap.h[k];
			++i;
			if(b.refs > 0) {
				continue;
			}
			var _this = this.soundBufferMap;
			if(Object.prototype.hasOwnProperty.call(_this.h,k)) {
				delete(_this.h[k]);
			}
			HxOverrides.remove(this.soundBufferKeys,k);
			--i;
			b.dispose();
			--this.soundBufferCount;
		}
	}
	,dispose: function() {
		this.stopAll();
		if(this.driver != null) {
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s = _g1[_g];
				++_g;
				s.dispose();
			}
			var h = this.soundBufferMap.h;
			var b_h = h;
			var b_keys = Object.keys(h);
			var b_length = b_keys.length;
			var b_current = 0;
			while(b_current < b_length) {
				var b = b_h[b_keys[b_current++]];
				b.dispose();
			}
			var _g = 0;
			var _g1 = this.freeStreamBuffers;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				b.dispose();
			}
			var _g = 0;
			var _g1 = this.effectGC;
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				e.driver.release();
			}
			this.driver.dispose();
		}
		this.sources = null;
		this.soundBufferMap = null;
		this.soundBufferKeys = null;
		this.freeStreamBuffers = null;
		this.effectGC = null;
		this.updateEvent.stop();
		hxd_snd_Manager.instance = null;
	}
	,play: function(sound,channelGroup,soundGroup) {
		if(soundGroup == null) {
			soundGroup = this.masterSoundGroup;
		}
		if(channelGroup == null) {
			channelGroup = this.masterChannelGroup;
		}
		var sdat = sound.getData();
		if(sdat.samples == 0) {
			throw haxe_Exception.thrown(Std.string(sound) + " has no samples");
		}
		var c = new hxd_snd_Channel();
		c.sound = sound;
		c.duration = sdat.get_duration();
		c.manager = this;
		c.soundGroup = soundGroup;
		c.channelGroup = channelGroup;
		c.next = this.channels;
		c.isLoading = sdat.isLoading();
		c.isVirtual = this.driver == null;
		c.lastStamp = HxOverrides.now() / 1000;
		this.channels = c;
		return c;
	}
	,updateVirtualChannels: function(now) {
		var c = this.channels;
		while(c != null) {
			if(c.pause || !c.isVirtual || c.isLoading) {
				c = c.next;
				continue;
			}
			var a = now - c.lastStamp;
			c.set_position(c.position + (a < 0.0 ? 0.0 : a));
			c.lastStamp = now;
			var next = c.next;
			while(c.position >= c.duration) {
				c.set_position(c.position - c.duration);
				c.onEnd();
				if(next != null && next.manager == null) {
					next = null;
				}
				if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
				} else if(!c.loop) {
					this.releaseChannel(c);
					break;
				}
			}
			c = next;
		}
	}
	,update: function() {
		if(this.timeOffset != 0) {
			var c = this.channels;
			while(c != null) {
				c.lastStamp += this.timeOffset;
				if(c.currentFade != null) {
					c.currentFade.start += this.timeOffset;
				}
				c = c.next;
			}
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s = _g1[_g];
				++_g;
				var _g2 = 0;
				var _g3 = s.buffers;
				while(_g2 < _g3.length) {
					var b = _g3[_g2];
					++_g2;
					b.lastStop += this.timeOffset;
				}
			}
			this.timeOffset = 0;
		}
		this.now = HxOverrides.now() / 1000;
		if(this.driver == null) {
			this.updateVirtualChannels(this.now);
			return;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			if(c.positionChanged) {
				this.releaseSource(s);
				continue;
			}
			var lastBuffer = null;
			var count = this.driver.getProcessedBuffers(s.handle);
			var _g2 = 0;
			var _g3 = count;
			while(_g2 < _g3) {
				var i = _g2++;
				var b = this.unqueueBuffer(s);
				if(b == null) {
					continue;
				}
				lastBuffer = b;
				if(b.isEnd) {
					c.sound = b.sound;
					c.duration = b.sound.getData().get_duration();
					c.set_position(c.duration);
					c.positionChanged = false;
					c.onEnd();
					s.start = 0;
				}
			}
			if(s.buffers.length == 0) {
				if(!lastBuffer.isEnd) {
					c.set_position((lastBuffer.start + lastBuffer.samples) / lastBuffer.sampleRate);
					this.releaseSource(s);
				} else if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
					c.set_position(0);
					this.releaseSource(s);
				} else if(c.loop) {
					c.set_position(0);
					this.releaseSource(s);
				} else {
					this.releaseChannel(c);
				}
				continue;
			}
			c.sound = s.buffers[0].sound;
			c.duration = c.sound.getData().get_duration();
			var playedSamples = this.driver.getPlayedSampleCount(s.handle);
			if(playedSamples < 0) {
				playedSamples = 0;
			}
			c.set_position(s.start / this.targetRate + playedSamples / s.buffers[0].sampleRate);
			c.positionChanged = false;
			if(s.buffers.length < hxd_snd_Manager.BUFFER_QUEUE_LENGTH) {
				var b1 = s.buffers[s.buffers.length - 1];
				if(!b1.isEnd) {
					this.queueBuffer(s,b1.sound,b1.start + b1.samples);
				} else if(c.queue.length > 0) {
					var snd = c.queue[0];
					if(this.queueBuffer(s,snd,0)) {
						c.queue.shift();
					}
				} else if(c.loop) {
					this.queueBuffer(s,b1.sound,0);
				}
			}
		}
		var c = this.channels;
		while(c != null) {
			c.calcAudibleVolume(this.now);
			if(c.isLoading && !c.sound.getData().isLoading()) {
				c.isLoading = false;
			}
			c.isVirtual = this.suspended || c.pause || c.mute || c.channelGroup.mute || c.allowVirtual && c.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD || c.isLoading;
			c = c.next;
		}
		var list = this.channels;
		var cmp = $bind(this,this.sortChannel);
		var tmp;
		if(list == null) {
			tmp = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		this.channels = tmp;
		var audibleCount = 0;
		var c = this.channels;
		while(c != null && !c.isVirtual) {
			if(++audibleCount > this.sources.length) {
				c.isVirtual = true;
			} else if(c.soundGroup.maxAudible >= 0) {
				if(c.soundGroup.lastUpdate != this.now) {
					c.soundGroup.lastUpdate = this.now;
					c.soundGroup.numAudible = 0;
				}
				if(++c.soundGroup.numAudible > c.soundGroup.maxAudible) {
					c.isVirtual = true;
					--audibleCount;
				}
			}
			c = c.next;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.channel == null || !s.channel.isVirtual) {
				continue;
			}
			this.releaseSource(s);
		}
		var c = this.channels;
		while(c != null) {
			if(c.source != null || c.isVirtual) {
				c = c.next;
				continue;
			}
			var s = null;
			var _g = 0;
			var _g1 = this.sources;
			while(_g < _g1.length) {
				var s2 = _g1[_g];
				++_g;
				if(s2.channel == null) {
					s = s2;
					break;
				}
			}
			if(s == null) {
				throw haxe_Exception.thrown("could not get a source");
			}
			s.channel = c;
			c.source = s;
			this.checkTargetFormat(c.sound.getData(),c.soundGroup.mono);
			s.start = Math.floor(c.position * this.targetRate);
			if(s.start < 0) {
				s.start = 0;
			}
			this.queueBuffer(s,c.sound,s.start);
			c.positionChanged = false;
			c = c.next;
		}
		var usedEffects = null;
		var volume = this.hasMasterVolume ? 1. : this.masterVolume;
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			var v = c.currentVolume * volume;
			if(s.volume != v) {
				if(v < 0) {
					v = 0;
				}
				s.volume = v;
				this.driver.setSourceVolume(s.handle,v);
			}
			if(!s.playing) {
				this.driver.playSource(s.handle);
				s.playing = true;
			}
			var i = c.bindedEffects.length;
			while(--i >= 0) {
				var e = c.bindedEffects[i];
				if(c.effects.indexOf(e) < 0 && c.channelGroup.effects.indexOf(e) < 0) {
					this.unbindEffect(c,s,e);
				}
			}
			var _g2 = 0;
			var _g3 = c.channelGroup.effects;
			while(_g2 < _g3.length) {
				var e1 = _g3[_g2];
				++_g2;
				if(c.bindedEffects.indexOf(e1) < 0) {
					this.bindEffect(c,s,e1);
				}
			}
			var _g4 = 0;
			var _g5 = c.effects;
			while(_g4 < _g5.length) {
				var e2 = _g5[_g4];
				++_g4;
				if(c.bindedEffects.indexOf(e2) < 0) {
					this.bindEffect(c,s,e2);
				}
			}
			var _g6 = 0;
			var _g7 = c.bindedEffects;
			while(_g6 < _g7.length) {
				var e3 = _g7[_g6];
				++_g6;
				usedEffects = hxd_snd_Manager.regEffect(usedEffects,e3);
			}
		}
		var list = usedEffects;
		var cmp = $bind(this,this.sortEffect);
		if(list == null) {
			usedEffects = null;
		} else {
			var insize = 1;
			var nmerges;
			var psize = 0;
			var qsize = 0;
			var p;
			var q;
			var e;
			var tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					var _g = 0;
					var _g1 = insize;
					while(_g < _g1) {
						var i = _g++;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			usedEffects = list;
		}
		var e = usedEffects;
		while(e != null) {
			e.driver.update(e);
			e = e.next;
		}
		var _g = 0;
		var _g1 = this.sources;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var c = s.channel;
			if(c == null) {
				continue;
			}
			var _g2 = 0;
			var _g3 = c.bindedEffects;
			while(_g2 < _g3.length) {
				var e = _g3[_g2];
				++_g2;
				e.driver.apply(e,s.handle);
			}
		}
		var _g = 0;
		var _g1 = this.effectGC;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(this.now - e.lastStamp > e.retainTime) {
				e.driver.release();
				HxOverrides.remove(this.effectGC,e);
				break;
			}
		}
		this.updateVirtualChannels(this.now);
		var _this = this.listener.direction;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		var _this = this.listener.up;
		var k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-20) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		if(this.hasMasterVolume) {
			this.driver.setMasterVolume(this.masterVolume);
		}
		this.driver.setListenerParams(this.listener.position,this.listener.direction,this.listener.up,this.listener.velocity);
		this.driver.update();
		if(this.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE) {
			var now = HxOverrides.now() / 1000;
			var i = 0;
			while(i < this.soundBufferKeys.length) {
				var k = this.soundBufferKeys[i];
				var b = this.soundBufferMap.h[k];
				++i;
				if(b.refs > 0 || b.lastStop + 60.0 > now) {
					continue;
				}
				var _this = this.soundBufferMap;
				if(Object.prototype.hasOwnProperty.call(_this.h,k)) {
					delete(_this.h[k]);
				}
				HxOverrides.remove(this.soundBufferKeys,k);
				--i;
				b.dispose();
				--this.soundBufferCount;
			}
		}
	}
	,progressiveDecodeBuffer: function(s,snd,start) {
		var data = snd.getData();
		var samples = Math.ceil(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT);
		if(s.streamStart != start || s.streamSound != snd) {
			s.streamSound = snd;
			s.streamStart = start;
			s.streamPos = start;
		}
		var end = start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(s.streamPos == end) {
			return true;
		}
		var bpp = data.getBytesPerSample();
		var reqSize = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp;
		if(s.streamBuffer == null || s.streamBuffer.length < reqSize) {
			s.streamBuffer = new haxe_io_Bytes(new ArrayBuffer(reqSize));
			s.streamPos = start;
		}
		var remain = end - s.streamPos;
		if(remain > samples) {
			remain = samples;
		}
		data.decode(s.streamBuffer,(s.streamPos - start) * bpp,s.streamPos,remain);
		s.streamPos += remain;
		return s.streamPos == end;
	}
	,queueBuffer: function(s,snd,start) {
		var data = snd.getData();
		var sgroup = s.channel.soundGroup;
		var b = null;
		if(data.get_duration() <= hxd_snd_Manager.STREAM_DURATION) {
			b = this.getSoundBuffer(snd,sgroup);
			this.driver.queueBuffer(s.handle,b.handle,start,true);
		} else {
			if(s.buffers.length > 0 && hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1 && !this.progressiveDecodeBuffer(s,snd,start)) {
				return false;
			}
			b = this.getStreamBuffer(s,snd,sgroup,start);
			this.driver.queueBuffer(s.handle,b.handle,0,b.isEnd);
		}
		s.buffers.push(b);
		return true;
	}
	,unqueueBuffer: function(s) {
		var b = s.buffers.shift();
		if(b == null) {
			return null;
		}
		this.driver.unqueueBuffer(s.handle,b.handle);
		if(b.isStream) {
			this.freeStreamBuffers.unshift(b);
		} else if(--b.refs == 0) {
			b.lastStop = HxOverrides.now() / 1000;
		}
		return b;
	}
	,bindEffect: function(c,s,e) {
		if(e.refs == 0 && !HxOverrides.remove(this.effectGC,e)) {
			e.driver.acquire();
		}
		++e.refs;
		e.driver.bind(e,s.handle);
		c.bindedEffects.push(e);
	}
	,unbindEffect: function(c,s,e) {
		e.driver.unbind(e,s.handle);
		HxOverrides.remove(c.bindedEffects,e);
		if(--e.refs == 0) {
			e.lastStamp = this.now;
			this.effectGC.push(e);
		}
	}
	,releaseSource: function(s) {
		if(s.channel != null) {
			var _g = 0;
			var _g1 = s.channel.bindedEffects.slice();
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.unbindEffect(s.channel,s,e);
			}
			s.channel.bindedEffects = [];
			s.channel.source = null;
			s.channel = null;
		}
		if(s.playing) {
			s.playing = false;
			this.driver.stopSource(s.handle);
			s.volume = -1.0;
		}
		while(s.buffers.length > 0) this.unqueueBuffer(s);
	}
	,checkTargetFormat: function(dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		this.targetRate = dat.samplingRate;
		this.targetChannels = forceMono || dat.channels == 1 ? 1 : 2;
		var tmp;
		switch(dat.sampleFormat._hx_index) {
		case 0:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 1:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		case 2:
			tmp = hxd_snd_SampleFormat.F32;
			break;
		}
		this.targetFormat = tmp;
		if(this.targetChannels == dat.channels && this.targetFormat == dat.sampleFormat) {
			return this.targetRate == dat.samplingRate;
		} else {
			return false;
		}
	}
	,getSoundBuffer: function(snd,grp) {
		var _gthis = this;
		var data = snd.getData();
		var mono = grp.mono;
		var key = snd.entry.get_path();
		if(mono && data.channels != 1) {
			key += "mono";
		}
		var b = this.soundBufferMap.h[key];
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = false;
			b.isEnd = true;
			b.sound = snd;
			data.load(function() {
				_gthis.fillSoundBuffer(b,data,mono);
			});
			this.soundBufferMap.h[key] = b;
			this.soundBufferKeys.push(key);
			++this.soundBufferCount;
		}
		++b.refs;
		return b;
	}
	,fillSoundBuffer: function(buf,dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		if(!this.checkTargetFormat(dat,forceMono)) {
			dat = dat.resample(this.targetRate,this.targetFormat,this.targetChannels);
		}
		var length = dat.samples * dat.getBytesPerSample();
		var bytes = this.getTmpBytes(length);
		dat.decode(bytes,0,0,dat.samples);
		this.driver.setBufferData(buf.handle,bytes,length,this.targetFormat,this.targetChannels,this.targetRate);
		buf.sampleRate = this.targetRate;
		buf.samples = dat.samples;
	}
	,getStreamBuffer: function(src,snd,grp,start) {
		var data = snd.getData();
		var b = this.freeStreamBuffers.shift();
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = true;
		}
		var samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(start + samples >= data.samples) {
			samples = data.samples - start;
			b.isEnd = true;
		} else {
			b.isEnd = false;
		}
		b.sound = snd;
		b.samples = samples;
		b.start = start;
		var size = samples * data.getBytesPerSample();
		var bytes;
		if(src.streamSound == snd && src.streamStart == start) {
			while(!this.progressiveDecodeBuffer(src,snd,start)) {
			}
			bytes = src.streamBuffer;
		} else {
			bytes = this.getTmpBytes(size);
			data.decode(bytes,0,start,samples);
		}
		if(!this.checkTargetFormat(data,grp.mono)) {
			var size1 = Math.ceil(samples * (this.targetRate / data.samplingRate)) * this.targetChannels;
			var size2;
			switch(this.targetFormat._hx_index) {
			case 0:
				size2 = 1;
				break;
			case 1:
				size2 = 2;
				break;
			case 2:
				size2 = 4;
				break;
			}
			size = size1 * size2;
			var resampleBytes = this.getResampleBytes(size);
			data.resampleBuffer(resampleBytes,0,bytes,0,this.targetRate,this.targetFormat,this.targetChannels,samples);
			bytes = resampleBytes;
		}
		this.driver.setBufferData(b.handle,bytes,size,this.targetFormat,this.targetChannels,this.targetRate);
		b.sampleRate = this.targetRate;
		return b;
	}
	,sortChannel: function(a,b) {
		if(a.isVirtual != b.isVirtual) {
			if(a.isVirtual) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.channelGroup.priority != b.channelGroup.priority) {
			if(a.channelGroup.priority < b.channelGroup.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.priority != b.priority) {
			if(a.priority < b.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.audibleVolume != b.audibleVolume) {
			if(a.audibleVolume < b.audibleVolume) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.id < b.id) {
			return 1;
		} else {
			return -1;
		}
	}
	,sortEffect: function(a,b) {
		return b.priority - a.priority;
	}
	,releaseChannel: function(c) {
		if(c.manager == null) {
			return;
		}
		if(this.channels == c) {
			this.channels = c.next;
		} else {
			var prev = this.channels;
			while(prev.next != c) prev = prev.next;
			prev.next = c.next;
		}
		var _g = 0;
		var _g1 = c.effects;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			c.removeEffect(e);
		}
		if(c.source != null) {
			this.releaseSource(c.source);
		}
		c.next = null;
		c.manager = null;
		c.effects = null;
		c.bindedEffects = null;
		c.currentFade = null;
		var snd = c.sound;
		if(snd != null && snd.channel == c) {
			snd.channel = null;
		}
	}
	,__class__: hxd_snd_Manager
};
var hxd_snd_Mp3Data = function(bytes) {
	var mp = new format_mp3_Reader(new haxe_io_BytesInput(bytes)).read();
	this.samples = mp.sampleCount;
	var frame = mp.frames[0].data;
	var lame = -1;
	var _g = 0;
	var _g1 = frame.length - 24;
	while(_g < _g1) {
		var i = _g++;
		if(frame.b[i] == 76 && frame.b[i + 1] == 65 && frame.b[i + 2] == 77 && frame.b[i + 3] == 69) {
			lame = i;
			break;
		}
	}
	if(lame >= 0) {
		var startEnd = frame.b[lame + 21] << 16 | frame.b[lame + 22] << 8 | frame.b[lame + 23];
		var start = startEnd >> 12;
		var end = startEnd & 4095;
		this.samples -= start + end + 1152;
	}
	var header = mp.frames[0].header;
	this.sampleFormat = hxd_snd_SampleFormat.F32;
	this.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate);
	this.channels = header.channelMode == format_mp3_ChannelMode.Mono ? 1 : 2;
	var ctx = hxd_snd_webaudio_Context.get();
	if(ctx == null) {
		return;
	}
	ctx.decodeAudioData(bytes.b.bufferValue,$bind(this,this.processBuffer));
	var decodedRate = ctx.sampleRate | 0;
	this.samples = Math.ceil(this.samples * decodedRate / this.samplingRate);
	this.samplingRate = decodedRate;
};
$hxClasses["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data;
hxd_snd_Mp3Data.__name__ = "hxd.snd.Mp3Data";
hxd_snd_Mp3Data.__super__ = hxd_snd_Data;
hxd_snd_Mp3Data.prototype = $extend(hxd_snd_Data.prototype,{
	isLoading: function() {
		return this.buffer == null;
	}
	,load: function(onEnd) {
		if(this.buffer != null) {
			onEnd();
		} else {
			this.onEnd = onEnd;
		}
	}
	,processBuffer: function(buf) {
		var left = buf.getChannelData(0);
		this.samples = buf.length;
		if(this.channels == 1) {
			this.buffer = haxe_io_Bytes.ofData(left.buffer);
			return;
		}
		var right = buf.numberOfChannels < 2 ? left : buf.getChannelData(1);
		var join = new Float32Array(left.length * 2);
		var w = 0;
		var _g = 0;
		var _g1 = buf.length;
		while(_g < _g1) {
			var i = _g++;
			join[w++] = left[i];
			join[w++] = right[i];
		}
		this.buffer = haxe_io_Bytes.ofData(join.buffer);
		if(this.onEnd != null) {
			this.onEnd();
			this.onEnd = null;
		}
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		if(this.buffer == null) {
			out.fill(outPos,sampleCount * 4 * this.channels,0);
		} else {
			out.blit(outPos,this.buffer,sampleStart * 4 * this.channels,sampleCount * 4 * this.channels);
		}
	}
	,__class__: hxd_snd_Mp3Data
});
var hxd_snd_SoundGroup = function(name) {
	this.name = name;
	this.maxAudible = -1;
	this.volume = 1;
	this.mono = false;
};
$hxClasses["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup;
hxd_snd_SoundGroup.__name__ = "hxd.snd.SoundGroup";
hxd_snd_SoundGroup.prototype = {
	__class__: hxd_snd_SoundGroup
};
var hxd_snd_WavData = function(bytes) {
	if(bytes != null) {
		this.init(new format_wav_Reader(new haxe_io_BytesInput(bytes)).read());
	}
};
$hxClasses["hxd.snd.WavData"] = hxd_snd_WavData;
hxd_snd_WavData.__name__ = "hxd.snd.WavData";
hxd_snd_WavData.__super__ = hxd_snd_Data;
hxd_snd_WavData.prototype = $extend(hxd_snd_Data.prototype,{
	init: function(d) {
		var h = d.header;
		this.samplingRate = h.samplingRate;
		this.channels = h.channels;
		var tmp;
		switch(h.bitsPerSample) {
		case 8:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 16:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported WAV " + h.bitsPerSample + " bits");
		}
		this.sampleFormat = tmp;
		this.rawData = d.data;
		this.samples = this.rawData.length / this.getBytesPerSample() | 0;
	}
	,decodeBuffer: function(out,outPos,sampleStart,sampleCount) {
		var bpp = this.getBytesPerSample();
		out.blit(outPos,this.rawData,sampleStart * bpp,sampleCount * bpp);
	}
	,__class__: hxd_snd_WavData
});
var hxd_snd_effect_LowPass = function() {
	hxd_snd_Effect.call(this,"lowpass");
	this.priority = 100;
	this.gainHF = 1.0;
};
$hxClasses["hxd.snd.effect.LowPass"] = hxd_snd_effect_LowPass;
hxd_snd_effect_LowPass.__name__ = "hxd.snd.effect.LowPass";
hxd_snd_effect_LowPass.__super__ = hxd_snd_Effect;
hxd_snd_effect_LowPass.prototype = $extend(hxd_snd_Effect.prototype,{
	__class__: hxd_snd_effect_LowPass
});
var hxd_snd_effect_Pitch = function(value) {
	if(value == null) {
		value = 1.0;
	}
	hxd_snd_Effect.call(this,"pitch");
	this.value = value;
};
$hxClasses["hxd.snd.effect.Pitch"] = hxd_snd_effect_Pitch;
hxd_snd_effect_Pitch.__name__ = "hxd.snd.effect.Pitch";
hxd_snd_effect_Pitch.__super__ = hxd_snd_Effect;
hxd_snd_effect_Pitch.prototype = $extend(hxd_snd_Effect.prototype,{
	__class__: hxd_snd_effect_Pitch
});
var hxd_snd_effect_Spatialization = function() {
	hxd_snd_Effect.call(this,"spatialization");
	this.position = new h3d_VectorImpl(0.,0.,0.);
	this.velocity = new h3d_VectorImpl(0.,0.,0.);
	this.direction = new h3d_VectorImpl(0.,0.,0.);
	this.referenceDistance = 1.0;
	this.rollOffFactor = 1.0;
};
$hxClasses["hxd.snd.effect.Spatialization"] = hxd_snd_effect_Spatialization;
hxd_snd_effect_Spatialization.__name__ = "hxd.snd.effect.Spatialization";
hxd_snd_effect_Spatialization.__super__ = hxd_snd_Effect;
hxd_snd_effect_Spatialization.prototype = $extend(hxd_snd_Effect.prototype,{
	getVolumeModifier: function() {
		if(this.fadeDistance == null) {
			return 1.;
		}
		var _this = hxd_snd_Manager.get().listener.position;
		var v = this.position;
		var dx = v.x - _this.x;
		var dy = v.y - _this.y;
		var dz = v.z - _this.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		if(this.maxDistance != null) {
			dist -= this.maxDistance;
		} else {
			dist -= this.referenceDistance;
		}
		var volume = 1 - dist / this.fadeDistance;
		if(volume > 1) {
			volume = 1;
		}
		if(volume < 0) {
			volume = 0;
		}
		return volume;
	}
	,applyAudibleVolumeModifier: function(v) {
		var _this = hxd_snd_Manager.get().listener.position;
		var v1 = this.position;
		var dx = v1.x - _this.x;
		var dy = v1.y - _this.y;
		var dz = v1.z - _this.z;
		var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		var b = this.referenceDistance;
		if(dist < b) {
			dist = b;
		}
		if(this.maxDistance != null) {
			var b = this.maxDistance;
			if(dist > b) {
				dist = b;
			}
		}
		var volume = this.referenceDistance / (this.referenceDistance + this.rollOffFactor * (dist - this.referenceDistance));
		return v * volume;
	}
	,__class__: hxd_snd_effect_Spatialization
});
var hxd_snd_webaudio_BufferHandle = function() {
};
$hxClasses["hxd.snd.webaudio.BufferHandle"] = hxd_snd_webaudio_BufferHandle;
hxd_snd_webaudio_BufferHandle.__name__ = "hxd.snd.webaudio.BufferHandle";
hxd_snd_webaudio_BufferHandle.prototype = {
	__class__: hxd_snd_webaudio_BufferHandle
};
var hxd_snd_webaudio_SourceHandle = function() {
	this.buffers = [];
	this.sampleOffset = 0;
	this.pitch = 1;
	this.firstPlay = true;
};
$hxClasses["hxd.snd.webaudio.SourceHandle"] = hxd_snd_webaudio_SourceHandle;
hxd_snd_webaudio_SourceHandle.__name__ = "hxd.snd.webaudio.SourceHandle";
hxd_snd_webaudio_SourceHandle.prototype = {
	updateDestination: function() {
		this.destination = this.gain;
		if(this.lowPass != null) {
			this.lowPass.connect(this.destination);
			this.destination = this.lowPass;
		}
		if(this.panner != null) {
			this.panner.connect(this.destination);
			this.destination = this.panner;
		}
		this.gain.connect(hxd_snd_webaudio_Context.destination);
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.node != null) {
				b.restart(this);
			}
		}
	}
	,applyPitch: function() {
		var t = 0.;
		var _g = 0;
		var _g1 = this.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			t = b.readjust(t,this);
		}
	}
	,__class__: hxd_snd_webaudio_SourceHandle
};
var hxd_snd_webaudio_BufferPlayback = function() {
};
$hxClasses["hxd.snd.webaudio.BufferPlayback"] = hxd_snd_webaudio_BufferPlayback;
hxd_snd_webaudio_BufferPlayback.__name__ = "hxd.snd.webaudio.BufferPlayback";
hxd_snd_webaudio_BufferPlayback.prototype = {
	get_currentSample: function() {
		if(this.consumed) {
			return this.buffer.samples;
		}
		if(this.node == null || !this.dirty || this.node.context.currentTime < this.lastTime) {
			return 0;
		}
		this.lastSamples += Math.floor((this.node.context.currentTime - this.lastTime) * this.buffer.inst.sampleRate * this.node.playbackRate.value);
		this.lastTime = this.node.context.currentTime;
		return this.lastSamples;
	}
	,set: function(buf,grainOffset) {
		this.buffer = buf;
		this.offset = isNaN(grainOffset) ? 0 : grainOffset;
		this.dirty = false;
		this.consumed = false;
		this.starts = 0;
		this.ends = 0;
	}
	,start: function(ctx,source,time) {
		this.dirty = true;
		this.consumed = false;
		if(this.node != null) {
			this.stop();
		}
		if(source.firstPlay && this.buffer.samples > 10) {
			source.firstPlay = false;
			var _g = [];
			var _g1 = 0;
			var _g2 = this.buffer.inst.numberOfChannels;
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(this.buffer.inst.getChannelData(i));
			}
			var channels = _g;
			var j = 0;
			var fade = 0.;
			while(j < 10) {
				var i = 0;
				while(i < channels.length) {
					channels[i][j] *= fade;
					++i;
				}
				++j;
				fade += 0.1;
				if(fade > 1) {
					fade = 1;
				}
			}
		}
		this.node = ctx.createBufferSource();
		this.node.buffer = this.buffer.inst;
		this.node.addEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.connect(source.destination);
		this.node.playbackRate.value = source.pitch;
		this.node.start(time,this.offset);
		this.lastSamples = 0;
		this.lastTime = time;
		this.starts = time;
		return this.ends = time + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	,readjust: function(time,source) {
		if(this.consumed || this.node == null) {
			return this.ends;
		}
		var ctx = source.driver.ctx;
		var shiftTime = ctx.currentTime;
		this.node.playbackRate.setValueAtTime(source.pitch,shiftTime);
		var elapsed = shiftTime - this.starts;
		if(elapsed < 0) {
			return this.start(ctx,source,time == 0 ? shiftTime : time);
		}
		this.starts = shiftTime - elapsed / source.pitch;
		return this.ends = this.starts + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	,restart: function(source) {
		if(this.consumed || this.node == null) {
			return;
		}
		var ctx = hxd_snd_webaudio_Context.get();
		if(ctx.currentTime > this.starts) {
			this.offset += (ctx.currentTime - this.starts) * source.pitch;
			this.start(ctx,source,ctx.currentTime);
		} else {
			this.start(ctx,source,this.starts);
		}
	}
	,stop: function(immediate) {
		if(immediate == null) {
			immediate = true;
		}
		if(this.node != null) {
			this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
			if(immediate) {
				this.node.disconnect();
			} else {
				this.node.stop();
			}
			this.node = null;
		}
	}
	,onBufferConsumed: function(e) {
		this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.disconnect();
		this.node = null;
		this.consumed = true;
	}
	,clear: function() {
		this.buffer = null;
		this.node = null;
	}
	,__class__: hxd_snd_webaudio_BufferPlayback
};
var hxd_snd_webaudio_Context = function() { };
$hxClasses["hxd.snd.webaudio.Context"] = hxd_snd_webaudio_Context;
hxd_snd_webaudio_Context.__name__ = "hxd.snd.webaudio.Context";
hxd_snd_webaudio_Context.get = function() {
	if(hxd_snd_webaudio_Context.ctx == null) {
		try {
			hxd_snd_webaudio_Context.ctx = new AudioContext();
		} catch( _g ) {
			try {
				hxd_snd_webaudio_Context.ctx = new window.webkitAudioContext();
			} catch( _g1 ) {
				hxd_snd_webaudio_Context.ctx = null;
			}
		}
		if(hxd_snd_webaudio_Context.ctx == null) {
			throw haxe_Exception.thrown("WebAudio API not available in this browser!");
		}
		if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
			hxd_snd_webaudio_Context.waitForPageInput();
		}
		hxd_snd_webaudio_Context.ctx.addEventListener("statechange",function(_) {
			if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
				hxd_snd_webaudio_Context.waitForPageInput();
			}
		});
		hxd_snd_webaudio_Context.bufferPool = [];
		hxd_snd_webaudio_Context.gainPool = [];
		hxd_snd_webaudio_Context.masterGain = hxd_snd_webaudio_Context.ctx.createGain();
		hxd_snd_webaudio_Context.masterGain.connect(hxd_snd_webaudio_Context.ctx.destination);
		hxd_snd_webaudio_Context.destination = hxd_snd_webaudio_Context.masterGain;
	}
	return hxd_snd_webaudio_Context.ctx;
};
hxd_snd_webaudio_Context.getGain = function() {
	if(hxd_snd_webaudio_Context.gainPool.length != 0) {
		return hxd_snd_webaudio_Context.gainPool.pop();
	} else {
		return hxd_snd_webaudio_Context.ctx.createGain();
	}
};
hxd_snd_webaudio_Context.putGain = function(gain) {
	hxd_snd_webaudio_Context.gainPool.push(gain);
	gain.gain.value = 1;
};
hxd_snd_webaudio_Context.waitForPageInput = function() {
	if(!hxd_snd_webaudio_Context.suspended) {
		window.document.addEventListener("click",hxd_snd_webaudio_Context.resumeContext);
		window.document.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.addEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
		hxd_snd_webaudio_Context.suspended = true;
	}
};
hxd_snd_webaudio_Context.resumeContext = function(_) {
	if(hxd_snd_webaudio_Context.suspended) {
		if(hxd_snd_webaudio_Context.ctx != null) {
			hxd_snd_webaudio_Context.ctx.resume();
		}
		window.document.removeEventListener("click",hxd_snd_webaudio_Context.resumeContext);
		window.document.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
		window.document.body.removeEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
		hxd_snd_webaudio_Context.suspended = false;
	}
};
hxd_snd_webaudio_Context.getBuffer = function(channels,sampleCount,rate) {
	var _g = 0;
	var _g1 = hxd_snd_webaudio_Context.bufferPool;
	while(_g < _g1.length) {
		var pool = _g1[_g];
		++_g;
		if(pool.channels == channels && pool.samples == sampleCount && pool.rate == rate) {
			if(pool.pool.length != 0) {
				return pool.pool.pop();
			} else {
				return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
			}
		}
	}
	var pool = new hxd_snd_webaudio__$Context_BufferPool(channels,sampleCount,rate);
	hxd_snd_webaudio_Context.bufferPool.push(pool);
	return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
};
hxd_snd_webaudio_Context.putBuffer = function(buf) {
	var rate = buf.sampleRate | 0;
	var _g = 0;
	var _g1 = hxd_snd_webaudio_Context.bufferPool;
	while(_g < _g1.length) {
		var pool = _g1[_g];
		++_g;
		if(pool.channels == buf.numberOfChannels && pool.samples == buf.length && pool.rate == rate) {
			pool.pool.push(buf);
			break;
		}
	}
};
var hxd_snd_webaudio__$Context_BufferPool = function(channels,samples,rate) {
	this.pool = [];
	this.channels = channels;
	this.samples = samples;
	this.rate = rate;
};
$hxClasses["hxd.snd.webaudio._Context.BufferPool"] = hxd_snd_webaudio__$Context_BufferPool;
hxd_snd_webaudio__$Context_BufferPool.__name__ = "hxd.snd.webaudio._Context.BufferPool";
hxd_snd_webaudio__$Context_BufferPool.prototype = {
	__class__: hxd_snd_webaudio__$Context_BufferPool
};
var hxd_snd_webaudio_Driver = function() {
	this.playbackPool = [];
	this.ctx = hxd_snd_webaudio_Context.get();
};
$hxClasses["hxd.snd.webaudio.Driver"] = hxd_snd_webaudio_Driver;
hxd_snd_webaudio_Driver.__name__ = "hxd.snd.webaudio.Driver";
hxd_snd_webaudio_Driver.__interfaces__ = [hxd_snd_Driver];
hxd_snd_webaudio_Driver.prototype = {
	getBuffer: function(channels,sampleCount,rate) {
		return hxd_snd_webaudio_Context.getBuffer(channels,sampleCount,rate);
	}
	,putBuffer: function(buf) {
		hxd_snd_webaudio_Context.putBuffer(buf);
	}
	,getGain: function() {
		if(hxd_snd_webaudio_Context.gainPool.length != 0) {
			return hxd_snd_webaudio_Context.gainPool.pop();
		} else {
			return hxd_snd_webaudio_Context.ctx.createGain();
		}
	}
	,putGain: function(gain) {
		hxd_snd_webaudio_Context.gainPool.push(gain);
		gain.gain.value = 1;
	}
	,hasFeature: function(d) {
		return true;
	}
	,setMasterVolume: function(value) {
		hxd_snd_webaudio_Context.masterGain.gain.value = value;
	}
	,setListenerParams: function(position,direction,up,velocity) {
		this.ctx.listener.setPosition(-position.x,position.y,position.z);
		this.ctx.listener.setOrientation(-direction.x,direction.y,direction.z,-up.x,up.y,up.z);
	}
	,createSource: function() {
		var s = new hxd_snd_webaudio_SourceHandle();
		s.driver = this;
		s.gain = hxd_snd_webaudio_Context.gainPool.length != 0 ? hxd_snd_webaudio_Context.gainPool.pop() : hxd_snd_webaudio_Context.ctx.createGain();
		s.updateDestination();
		return s;
	}
	,playSource: function(source) {
		if(!source.playing) {
			source.playing = true;
			if(source.buffers.length != 0) {
				var time = this.ctx.currentTime;
				var _g = 0;
				var _g1 = source.buffers;
				while(_g < _g1.length) {
					var b = _g1[_g];
					++_g;
					if(b.consumed) {
						continue;
					}
					time = b.start(this.ctx,source,time);
				}
			}
		}
	}
	,stopSource: function(source) {
		source.playing = false;
		source.sampleOffset = 0;
	}
	,setSourceVolume: function(source,value) {
		source.gain.gain.value = value;
	}
	,destroySource: function(source) {
		this.stopSource(source);
		source.gain.disconnect();
		source.driver = null;
		var gain = source.gain;
		hxd_snd_webaudio_Context.gainPool.push(gain);
		gain.gain.value = 1;
		source.gain = null;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.stop();
			b.clear();
			this.playbackPool.push(b);
		}
		source.buffers = [];
	}
	,createBuffer: function() {
		var b = new hxd_snd_webaudio_BufferHandle();
		b.samples = 0;
		return b;
	}
	,setBufferData: function(buffer,data,size,format,channelCount,samplingRate) {
		var sampleCount;
		switch(format._hx_index) {
		case 0:
			sampleCount = 1;
			break;
		case 1:
			sampleCount = 2;
			break;
		case 2:
			sampleCount = 4;
			break;
		}
		var sampleCount1 = size / sampleCount / channelCount | 0;
		buffer.samples = sampleCount1;
		if(sampleCount1 == 0) {
			return;
		}
		if(buffer.inst == null) {
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		} else if(buffer.inst.sampleRate != samplingRate || buffer.inst.numberOfChannels != channelCount || buffer.inst.length != sampleCount1) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		}
		switch(format._hx_index) {
		case 0:
			var ui8 = new Uint8Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = (ui8[i] - 128) / 128;
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = (ui8[r] - 128) / 128;
					right[i] = (ui8[r + 1] - 128) / 128;
					r += channelCount;
				}
			}
			break;
		case 1:
			var i16 = new Int16Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = i16[i] / 32768;
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = i16[r] / 32768;
					right[i] = i16[r + 1] / 32768;
					r += channelCount;
				}
			}
			break;
		case 2:
			var f32 = new Float32Array(data.b.bufferValue);
			if(channelCount == 1) {
				var chn = buffer.inst.getChannelData(0);
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					chn[i] = f32[i];
				}
			} else {
				var left = buffer.inst.getChannelData(0);
				var right = buffer.inst.getChannelData(1);
				var r = 0;
				var _g = 0;
				var _g1 = sampleCount1;
				while(_g < _g1) {
					var i = _g++;
					left[i] = f32[r];
					right[i] = f32[r + 1];
					r += channelCount;
				}
			}
			break;
		}
	}
	,destroyBuffer: function(buffer) {
		if(buffer.inst != null) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
		}
		buffer.inst = null;
	}
	,queueBuffer: function(source,buffer,sampleStart,endOfStream) {
		var buf = this.playbackPool.length != 0 ? this.playbackPool.pop() : new hxd_snd_webaudio_BufferPlayback();
		if(buffer.inst == null) {
			return;
		}
		buf.set(buffer,sampleStart / buffer.inst.length * buffer.inst.duration);
		buffer.isEnd = endOfStream;
		source.buffers.push(buf);
		if(source.playing) {
			if(source.buffers.length != 1) {
				var t = source.buffers[source.buffers.length - 2].ends;
				var tmp = this.ctx;
				var tmp1;
				if(isFinite(t)) {
					var b = this.ctx.currentTime;
					tmp1 = t < b ? b : t;
				} else {
					tmp1 = this.ctx.currentTime;
				}
				buf.start(tmp,source,tmp1);
			} else {
				buf.start(this.ctx,source,this.ctx.currentTime);
			}
		}
	}
	,unqueueBuffer: function(source,buffer) {
		var i = 0;
		while(i < source.buffers.length) {
			var b = source.buffers[i];
			if(b.buffer == buffer) {
				source.buffers.splice(i,1);
				b.stop(!buffer.isEnd);
				b.clear();
				this.playbackPool.push(b);
				break;
			}
		}
		if(buffer.isEnd || !source.playing) {
			source.sampleOffset = 0;
		} else {
			source.sampleOffset += buffer.samples;
		}
	}
	,getProcessedBuffers: function(source) {
		var cnt = 0;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.consumed) {
				++cnt;
			}
		}
		return cnt;
	}
	,getPlayedSampleCount: function(source) {
		var consumed = 0;
		var buf = null;
		var _g = 0;
		var _g1 = source.buffers;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			if(b.consumed) {
				consumed += b.buffer.samples;
			} else if(b.dirty) {
				buf = b;
				break;
			}
		}
		if(buf != null) {
			return source.sampleOffset + consumed + buf.get_currentSample();
		}
		return source.sampleOffset + consumed;
	}
	,update: function() {
	}
	,dispose: function() {
	}
	,getEffectDriver: function(type) {
		switch(type) {
		case "lowpass":
			return new hxd_snd_webaudio_LowPassDriver();
		case "pitch":
			return new hxd_snd_webaudio_PitchDriver();
		case "spatialization":
			return new hxd_snd_webaudio_SpatializationDriver();
		default:
			return new hxd_snd_EffectDriver();
		}
	}
	,get_masterGain: function() {
		return hxd_snd_webaudio_Context.masterGain;
	}
	,set_destination: function(node) {
		return hxd_snd_webaudio_Context.destination = node;
	}
	,get_destination: function() {
		return hxd_snd_webaudio_Context.destination;
	}
	,__class__: hxd_snd_webaudio_Driver
};
var hxd_snd_webaudio_LowPassDriver = function() {
	this.pool = [];
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.LowPassDriver"] = hxd_snd_webaudio_LowPassDriver;
hxd_snd_webaudio_LowPassDriver.__name__ = "hxd.snd.webaudio.LowPassDriver";
hxd_snd_webaudio_LowPassDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_LowPassDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	get: function(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		var node = ctx.createBiquadFilter();
		node.type = "lowpass";
		return node;
	}
	,bind: function(e,source) {
		source.lowPass = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	,apply: function(e,source) {
		var min = 40;
		var max = source.driver.ctx.sampleRate / 2;
		var octaves = Math.log(max / min) / Math.LN2;
		source.lowPass.frequency.value = max * Math.pow(2,octaves * (e.gainHF - 1));
	}
	,unbind: function(e,source) {
		this.pool.push(source.lowPass);
		source.lowPass.disconnect();
		source.lowPass = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
	,__class__: hxd_snd_webaudio_LowPassDriver
});
var hxd_snd_webaudio_PitchDriver = function() {
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.PitchDriver"] = hxd_snd_webaudio_PitchDriver;
hxd_snd_webaudio_PitchDriver.__name__ = "hxd.snd.webaudio.PitchDriver";
hxd_snd_webaudio_PitchDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_PitchDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	apply: function(e,source) {
		if(source.pitch != e.value) {
			source.pitch = e.value;
			source.applyPitch();
		}
	}
	,unbind: function(e,source) {
		source.pitch = 1;
		source.applyPitch();
	}
	,__class__: hxd_snd_webaudio_PitchDriver
});
var hxd_snd_webaudio_SpatializationDriver = function() {
	this.pool = [];
	hxd_snd_EffectDriver.call(this);
};
$hxClasses["hxd.snd.webaudio.SpatializationDriver"] = hxd_snd_webaudio_SpatializationDriver;
hxd_snd_webaudio_SpatializationDriver.__name__ = "hxd.snd.webaudio.SpatializationDriver";
hxd_snd_webaudio_SpatializationDriver.__super__ = hxd_snd_EffectDriver;
hxd_snd_webaudio_SpatializationDriver.prototype = $extend(hxd_snd_EffectDriver.prototype,{
	get: function(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		var node = ctx.createPanner();
		return node;
	}
	,bind: function(e,source) {
		source.panner = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	,apply: function(e,source) {
		source.panner.setPosition(-e.position.x,e.position.y,e.position.z);
		source.panner.setOrientation(-e.direction.x,e.direction.y,e.direction.z);
		source.panner.rolloffFactor = e.rollOffFactor;
		source.panner.refDistance = e.referenceDistance;
		var maxDist = e.maxDistance == null ? 3.40282347e38 : e.maxDistance;
		source.panner.maxDistance = maxDist;
	}
	,unbind: function(e,source) {
		this.pool.push(source.panner);
		source.panner.disconnect();
		source.panner = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
	,__class__: hxd_snd_webaudio_SpatializationDriver
});
var hxsl_BufferKind = $hxEnums["hxsl.BufferKind"] = { __ename__:"hxsl.BufferKind",__constructs__:null
	,Uniform: {_hx_name:"Uniform",_hx_index:0,__enum__:"hxsl.BufferKind",toString:$estr}
	,RW: {_hx_name:"RW",_hx_index:1,__enum__:"hxsl.BufferKind",toString:$estr}
};
hxsl_BufferKind.__constructs__ = [hxsl_BufferKind.Uniform,hxsl_BufferKind.RW];
hxsl_BufferKind.__empty_constructs__ = [hxsl_BufferKind.Uniform,hxsl_BufferKind.RW];
var hxsl_Type = $hxEnums["hxsl.Type"] = { __ename__:"hxsl.Type",__constructs__:null
	,TVoid: {_hx_name:"TVoid",_hx_index:0,__enum__:"hxsl.Type",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"hxsl.Type",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:2,__enum__:"hxsl.Type",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:3,__enum__:"hxsl.Type",toString:$estr}
	,TString: {_hx_name:"TString",_hx_index:4,__enum__:"hxsl.Type",toString:$estr}
	,TVec: ($_=function(size,t) { return {_hx_index:5,size:size,t:t,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TVec",$_.__params__ = ["size","t"],$_)
	,TMat3: {_hx_name:"TMat3",_hx_index:6,__enum__:"hxsl.Type",toString:$estr}
	,TMat4: {_hx_name:"TMat4",_hx_index:7,__enum__:"hxsl.Type",toString:$estr}
	,TMat3x4: {_hx_name:"TMat3x4",_hx_index:8,__enum__:"hxsl.Type",toString:$estr}
	,TBytes: ($_=function(size) { return {_hx_index:9,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBytes",$_.__params__ = ["size"],$_)
	,TSampler2D: {_hx_name:"TSampler2D",_hx_index:10,__enum__:"hxsl.Type",toString:$estr}
	,TSampler2DArray: {_hx_name:"TSampler2DArray",_hx_index:11,__enum__:"hxsl.Type",toString:$estr}
	,TSamplerCube: {_hx_name:"TSamplerCube",_hx_index:12,__enum__:"hxsl.Type",toString:$estr}
	,TStruct: ($_=function(vl) { return {_hx_index:13,vl:vl,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TStruct",$_.__params__ = ["vl"],$_)
	,TFun: ($_=function(variants) { return {_hx_index:14,variants:variants,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TFun",$_.__params__ = ["variants"],$_)
	,TArray: ($_=function(t,size) { return {_hx_index:15,t:t,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["t","size"],$_)
	,TBuffer: ($_=function(t,size,kind) { return {_hx_index:16,t:t,size:size,kind:kind,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBuffer",$_.__params__ = ["t","size","kind"],$_)
	,TChannel: ($_=function(size) { return {_hx_index:17,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TChannel",$_.__params__ = ["size"],$_)
	,TMat2: {_hx_name:"TMat2",_hx_index:18,__enum__:"hxsl.Type",toString:$estr}
};
hxsl_Type.__constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TVec,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TBytes,hxsl_Type.TSampler2D,hxsl_Type.TSampler2DArray,hxsl_Type.TSamplerCube,hxsl_Type.TStruct,hxsl_Type.TFun,hxsl_Type.TArray,hxsl_Type.TBuffer,hxsl_Type.TChannel,hxsl_Type.TMat2];
hxsl_Type.__empty_constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TSampler2D,hxsl_Type.TSampler2DArray,hxsl_Type.TSamplerCube,hxsl_Type.TMat2];
var hxsl_VecType = $hxEnums["hxsl.VecType"] = { __ename__:"hxsl.VecType",__constructs__:null
	,VInt: {_hx_name:"VInt",_hx_index:0,__enum__:"hxsl.VecType",toString:$estr}
	,VFloat: {_hx_name:"VFloat",_hx_index:1,__enum__:"hxsl.VecType",toString:$estr}
	,VBool: {_hx_name:"VBool",_hx_index:2,__enum__:"hxsl.VecType",toString:$estr}
};
hxsl_VecType.__constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
hxsl_VecType.__empty_constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
var hxsl_SizeDecl = $hxEnums["hxsl.SizeDecl"] = { __ename__:"hxsl.SizeDecl",__constructs__:null
	,SConst: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SConst",$_.__params__ = ["v"],$_)
	,SVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SVar",$_.__params__ = ["v"],$_)
};
hxsl_SizeDecl.__constructs__ = [hxsl_SizeDecl.SConst,hxsl_SizeDecl.SVar];
hxsl_SizeDecl.__empty_constructs__ = [];
var hxsl_Error = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
$hxClasses["hxsl.Error"] = hxsl_Error;
hxsl_Error.__name__ = "hxsl.Error";
hxsl_Error.t = function(msg,pos) {
	throw haxe_Exception.thrown(new hxsl_Error(msg,pos));
};
hxsl_Error.prototype = {
	toString: function() {
		return "Error(" + this.msg + ")@" + Std.string(this.pos);
	}
	,__class__: hxsl_Error
};
var hxsl_VarKind = $hxEnums["hxsl.VarKind"] = { __ename__:"hxsl.VarKind",__constructs__:null
	,Global: {_hx_name:"Global",_hx_index:0,__enum__:"hxsl.VarKind",toString:$estr}
	,Input: {_hx_name:"Input",_hx_index:1,__enum__:"hxsl.VarKind",toString:$estr}
	,Param: {_hx_name:"Param",_hx_index:2,__enum__:"hxsl.VarKind",toString:$estr}
	,Var: {_hx_name:"Var",_hx_index:3,__enum__:"hxsl.VarKind",toString:$estr}
	,Local: {_hx_name:"Local",_hx_index:4,__enum__:"hxsl.VarKind",toString:$estr}
	,Output: {_hx_name:"Output",_hx_index:5,__enum__:"hxsl.VarKind",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:6,__enum__:"hxsl.VarKind",toString:$estr}
};
hxsl_VarKind.__constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
hxsl_VarKind.__empty_constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
var hxsl_VarQualifier = $hxEnums["hxsl.VarQualifier"] = { __ename__:"hxsl.VarQualifier",__constructs__:null
	,Const: ($_=function(max) { return {_hx_index:0,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["max"],$_)
	,Private: {_hx_name:"Private",_hx_index:1,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Nullable: {_hx_name:"Nullable",_hx_index:2,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerObject: {_hx_name:"PerObject",_hx_index:3,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Name: ($_=function(n) { return {_hx_index:4,n:n,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Name",$_.__params__ = ["n"],$_)
	,Shared: {_hx_name:"Shared",_hx_index:5,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Precision: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Precision",$_.__params__ = ["p"],$_)
	,Range: ($_=function(min,max) { return {_hx_index:7,min:min,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Range",$_.__params__ = ["min","max"],$_)
	,Ignore: {_hx_name:"Ignore",_hx_index:8,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerInstance: ($_=function(v) { return {_hx_index:9,v:v,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="PerInstance",$_.__params__ = ["v"],$_)
	,Doc: ($_=function(s) { return {_hx_index:10,s:s,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Doc",$_.__params__ = ["s"],$_)
	,Borrow: ($_=function(source) { return {_hx_index:11,source:source,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Borrow",$_.__params__ = ["source"],$_)
	,Sampler: ($_=function(name) { return {_hx_index:12,name:name,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Sampler",$_.__params__ = ["name"],$_)
};
hxsl_VarQualifier.__constructs__ = [hxsl_VarQualifier.Const,hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Name,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Precision,hxsl_VarQualifier.Range,hxsl_VarQualifier.Ignore,hxsl_VarQualifier.PerInstance,hxsl_VarQualifier.Doc,hxsl_VarQualifier.Borrow,hxsl_VarQualifier.Sampler];
hxsl_VarQualifier.__empty_constructs__ = [hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Ignore];
var hxsl_Prec = $hxEnums["hxsl.Prec"] = { __ename__:"hxsl.Prec",__constructs__:null
	,Low: {_hx_name:"Low",_hx_index:0,__enum__:"hxsl.Prec",toString:$estr}
	,Medium: {_hx_name:"Medium",_hx_index:1,__enum__:"hxsl.Prec",toString:$estr}
	,High: {_hx_name:"High",_hx_index:2,__enum__:"hxsl.Prec",toString:$estr}
};
hxsl_Prec.__constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
hxsl_Prec.__empty_constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
var hxsl_Const = $hxEnums["hxsl.Const"] = { __ename__:"hxsl.Const",__constructs__:null
	,CNull: {_hx_name:"CNull",_hx_index:0,__enum__:"hxsl.Const",toString:$estr}
	,CBool: ($_=function(b) { return {_hx_index:1,b:b,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CBool",$_.__params__ = ["b"],$_)
	,CInt: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["v"],$_)
	,CString: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["v"],$_)
};
hxsl_Const.__constructs__ = [hxsl_Const.CNull,hxsl_Const.CBool,hxsl_Const.CInt,hxsl_Const.CFloat,hxsl_Const.CString];
hxsl_Const.__empty_constructs__ = [hxsl_Const.CNull];
var hxsl_ExprDef = $hxEnums["hxsl.ExprDef"] = { __ename__:"hxsl.ExprDef",__constructs__:null
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EConst",$_.__params__ = ["c"],$_)
	,EIdent: ($_=function(i) { return {_hx_index:1,i:i,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EIdent",$_.__params__ = ["i"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:2,e:e,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EParenthesis",$_.__params__ = ["e"],$_)
	,EField: ($_=function(e,f) { return {_hx_index:3,e:e,f:f,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EField",$_.__params__ = ["e","f"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:4,op:op,e1:e1,e2:e2,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EBinop",$_.__params__ = ["op","e1","e2"],$_)
	,EUnop: ($_=function(op,e1) { return {_hx_index:5,op:op,e1:e1,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EUnop",$_.__params__ = ["op","e1"],$_)
	,ECall: ($_=function(e,args) { return {_hx_index:6,e:e,args:args,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="ECall",$_.__params__ = ["e","args"],$_)
	,EBlock: ($_=function(el) { return {_hx_index:7,el:el,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EBlock",$_.__params__ = ["el"],$_)
	,EVars: ($_=function(v) { return {_hx_index:8,v:v,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EVars",$_.__params__ = ["v"],$_)
	,EFunction: ($_=function(f) { return {_hx_index:9,f:f,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EFunction",$_.__params__ = ["f"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:10,econd:econd,eif:eif,eelse:eelse,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,EDiscard: {_hx_name:"EDiscard",_hx_index:11,__enum__:"hxsl.ExprDef",toString:$estr}
	,EFor: ($_=function(v,loop,block) { return {_hx_index:12,v:v,loop:loop,block:block,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EFor",$_.__params__ = ["v","loop","block"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:13,e:e,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EReturn",$_.__params__ = ["e"],$_)
	,EBreak: {_hx_name:"EBreak",_hx_index:14,__enum__:"hxsl.ExprDef",toString:$estr}
	,EContinue: {_hx_name:"EContinue",_hx_index:15,__enum__:"hxsl.ExprDef",toString:$estr}
	,EArray: ($_=function(e,eindex) { return {_hx_index:16,e:e,eindex:eindex,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EArray",$_.__params__ = ["e","eindex"],$_)
	,EArrayDecl: ($_=function(el) { return {_hx_index:17,el:el,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EArrayDecl",$_.__params__ = ["el"],$_)
	,ESwitch: ($_=function(e,cases,def) { return {_hx_index:18,e:e,cases:cases,def:def,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="ESwitch",$_.__params__ = ["e","cases","def"],$_)
	,EWhile: ($_=function(cond,loop,normalWhile) { return {_hx_index:19,cond:cond,loop:loop,normalWhile:normalWhile,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EWhile",$_.__params__ = ["cond","loop","normalWhile"],$_)
	,EMeta: ($_=function(name,args,e) { return {_hx_index:20,name:name,args:args,e:e,__enum__:"hxsl.ExprDef",toString:$estr}; },$_._hx_name="EMeta",$_.__params__ = ["name","args","e"],$_)
};
hxsl_ExprDef.__constructs__ = [hxsl_ExprDef.EConst,hxsl_ExprDef.EIdent,hxsl_ExprDef.EParenthesis,hxsl_ExprDef.EField,hxsl_ExprDef.EBinop,hxsl_ExprDef.EUnop,hxsl_ExprDef.ECall,hxsl_ExprDef.EBlock,hxsl_ExprDef.EVars,hxsl_ExprDef.EFunction,hxsl_ExprDef.EIf,hxsl_ExprDef.EDiscard,hxsl_ExprDef.EFor,hxsl_ExprDef.EReturn,hxsl_ExprDef.EBreak,hxsl_ExprDef.EContinue,hxsl_ExprDef.EArray,hxsl_ExprDef.EArrayDecl,hxsl_ExprDef.ESwitch,hxsl_ExprDef.EWhile,hxsl_ExprDef.EMeta];
hxsl_ExprDef.__empty_constructs__ = [hxsl_ExprDef.EDiscard,hxsl_ExprDef.EBreak,hxsl_ExprDef.EContinue];
var hxsl_TExprDef = $hxEnums["hxsl.TExprDef"] = { __ename__:"hxsl.TExprDef",__constructs__:null
	,TConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TConst",$_.__params__ = ["c"],$_)
	,TVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVar",$_.__params__ = ["v"],$_)
	,TGlobal: ($_=function(g) { return {_hx_index:2,g:g,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TGlobal",$_.__params__ = ["g"],$_)
	,TParenthesis: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TParenthesis",$_.__params__ = ["e"],$_)
	,TBlock: ($_=function(el) { return {_hx_index:4,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBlock",$_.__params__ = ["el"],$_)
	,TBinop: ($_=function(op,e1,e2) { return {_hx_index:5,op:op,e1:e1,e2:e2,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBinop",$_.__params__ = ["op","e1","e2"],$_)
	,TUnop: ($_=function(op,e1) { return {_hx_index:6,op:op,e1:e1,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TUnop",$_.__params__ = ["op","e1"],$_)
	,TVarDecl: ($_=function(v,init) { return {_hx_index:7,v:v,init:init,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVarDecl",$_.__params__ = ["v","init"],$_)
	,TCall: ($_=function(e,args) { return {_hx_index:8,e:e,args:args,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TCall",$_.__params__ = ["e","args"],$_)
	,TSwiz: ($_=function(e,regs) { return {_hx_index:9,e:e,regs:regs,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwiz",$_.__params__ = ["e","regs"],$_)
	,TIf: ($_=function(econd,eif,eelse) { return {_hx_index:10,econd:econd,eif:eif,eelse:eelse,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,TDiscard: {_hx_name:"TDiscard",_hx_index:11,__enum__:"hxsl.TExprDef",toString:$estr}
	,TReturn: ($_=function(e) { return {_hx_index:12,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TReturn",$_.__params__ = ["e"],$_)
	,TFor: ($_=function(v,it,loop) { return {_hx_index:13,v:v,it:it,loop:loop,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TFor",$_.__params__ = ["v","it","loop"],$_)
	,TContinue: {_hx_name:"TContinue",_hx_index:14,__enum__:"hxsl.TExprDef",toString:$estr}
	,TBreak: {_hx_name:"TBreak",_hx_index:15,__enum__:"hxsl.TExprDef",toString:$estr}
	,TArray: ($_=function(e,index) { return {_hx_index:16,e:e,index:index,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["e","index"],$_)
	,TArrayDecl: ($_=function(el) { return {_hx_index:17,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArrayDecl",$_.__params__ = ["el"],$_)
	,TSwitch: ($_=function(e,cases,def) { return {_hx_index:18,e:e,cases:cases,def:def,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwitch",$_.__params__ = ["e","cases","def"],$_)
	,TWhile: ($_=function(e,loop,normalWhile) { return {_hx_index:19,e:e,loop:loop,normalWhile:normalWhile,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TWhile",$_.__params__ = ["e","loop","normalWhile"],$_)
	,TMeta: ($_=function(m,args,e) { return {_hx_index:20,m:m,args:args,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TMeta",$_.__params__ = ["m","args","e"],$_)
};
hxsl_TExprDef.__constructs__ = [hxsl_TExprDef.TConst,hxsl_TExprDef.TVar,hxsl_TExprDef.TGlobal,hxsl_TExprDef.TParenthesis,hxsl_TExprDef.TBlock,hxsl_TExprDef.TBinop,hxsl_TExprDef.TUnop,hxsl_TExprDef.TVarDecl,hxsl_TExprDef.TCall,hxsl_TExprDef.TSwiz,hxsl_TExprDef.TIf,hxsl_TExprDef.TDiscard,hxsl_TExprDef.TReturn,hxsl_TExprDef.TFor,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak,hxsl_TExprDef.TArray,hxsl_TExprDef.TArrayDecl,hxsl_TExprDef.TSwitch,hxsl_TExprDef.TWhile,hxsl_TExprDef.TMeta];
hxsl_TExprDef.__empty_constructs__ = [hxsl_TExprDef.TDiscard,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak];
var hxsl_FunctionKind = $hxEnums["hxsl.FunctionKind"] = { __ename__:"hxsl.FunctionKind",__constructs__:null
	,Vertex: {_hx_name:"Vertex",_hx_index:0,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Fragment: {_hx_name:"Fragment",_hx_index:1,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Init: {_hx_name:"Init",_hx_index:2,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Helper: {_hx_name:"Helper",_hx_index:3,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Main: {_hx_name:"Main",_hx_index:4,__enum__:"hxsl.FunctionKind",toString:$estr}
};
hxsl_FunctionKind.__constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper,hxsl_FunctionKind.Main];
hxsl_FunctionKind.__empty_constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper,hxsl_FunctionKind.Main];
var hxsl_TGlobal = $hxEnums["hxsl.TGlobal"] = { __ename__:"hxsl.TGlobal",__constructs__:null
	,Radians: {_hx_name:"Radians",_hx_index:0,__enum__:"hxsl.TGlobal",toString:$estr}
	,Degrees: {_hx_name:"Degrees",_hx_index:1,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sin: {_hx_name:"Sin",_hx_index:2,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cos: {_hx_name:"Cos",_hx_index:3,__enum__:"hxsl.TGlobal",toString:$estr}
	,Tan: {_hx_name:"Tan",_hx_index:4,__enum__:"hxsl.TGlobal",toString:$estr}
	,Asin: {_hx_name:"Asin",_hx_index:5,__enum__:"hxsl.TGlobal",toString:$estr}
	,Acos: {_hx_name:"Acos",_hx_index:6,__enum__:"hxsl.TGlobal",toString:$estr}
	,Atan: {_hx_name:"Atan",_hx_index:7,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pow: {_hx_name:"Pow",_hx_index:8,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp: {_hx_name:"Exp",_hx_index:9,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log: {_hx_name:"Log",_hx_index:10,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp2: {_hx_name:"Exp2",_hx_index:11,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log2: {_hx_name:"Log2",_hx_index:12,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sqrt: {_hx_name:"Sqrt",_hx_index:13,__enum__:"hxsl.TGlobal",toString:$estr}
	,Inversesqrt: {_hx_name:"Inversesqrt",_hx_index:14,__enum__:"hxsl.TGlobal",toString:$estr}
	,Abs: {_hx_name:"Abs",_hx_index:15,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sign: {_hx_name:"Sign",_hx_index:16,__enum__:"hxsl.TGlobal",toString:$estr}
	,Floor: {_hx_name:"Floor",_hx_index:17,__enum__:"hxsl.TGlobal",toString:$estr}
	,Ceil: {_hx_name:"Ceil",_hx_index:18,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fract: {_hx_name:"Fract",_hx_index:19,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mod: {_hx_name:"Mod",_hx_index:20,__enum__:"hxsl.TGlobal",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:21,__enum__:"hxsl.TGlobal",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:22,__enum__:"hxsl.TGlobal",toString:$estr}
	,Clamp: {_hx_name:"Clamp",_hx_index:23,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mix: {_hx_name:"Mix",_hx_index:24,__enum__:"hxsl.TGlobal",toString:$estr}
	,Step: {_hx_name:"Step",_hx_index:25,__enum__:"hxsl.TGlobal",toString:$estr}
	,Smoothstep: {_hx_name:"Smoothstep",_hx_index:26,__enum__:"hxsl.TGlobal",toString:$estr}
	,Length: {_hx_name:"Length",_hx_index:27,__enum__:"hxsl.TGlobal",toString:$estr}
	,Distance: {_hx_name:"Distance",_hx_index:28,__enum__:"hxsl.TGlobal",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:29,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cross: {_hx_name:"Cross",_hx_index:30,__enum__:"hxsl.TGlobal",toString:$estr}
	,Normalize: {_hx_name:"Normalize",_hx_index:31,__enum__:"hxsl.TGlobal",toString:$estr}
	,LReflect: {_hx_name:"LReflect",_hx_index:32,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texture: {_hx_name:"Texture",_hx_index:33,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureLod: {_hx_name:"TextureLod",_hx_index:34,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texel: {_hx_name:"Texel",_hx_index:35,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureSize: {_hx_name:"TextureSize",_hx_index:36,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToInt: {_hx_name:"ToInt",_hx_index:37,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToFloat: {_hx_name:"ToFloat",_hx_index:38,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToBool: {_hx_name:"ToBool",_hx_index:39,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec2: {_hx_name:"Vec2",_hx_index:40,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec3: {_hx_name:"Vec3",_hx_index:41,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec4: {_hx_name:"Vec4",_hx_index:42,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec2: {_hx_name:"IVec2",_hx_index:43,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec3: {_hx_name:"IVec3",_hx_index:44,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec4: {_hx_name:"IVec4",_hx_index:45,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec2: {_hx_name:"BVec2",_hx_index:46,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec3: {_hx_name:"BVec3",_hx_index:47,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec4: {_hx_name:"BVec4",_hx_index:48,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat2: {_hx_name:"Mat2",_hx_index:49,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3: {_hx_name:"Mat3",_hx_index:50,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat4: {_hx_name:"Mat4",_hx_index:51,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3x4: {_hx_name:"Mat3x4",_hx_index:52,__enum__:"hxsl.TGlobal",toString:$estr}
	,Saturate: {_hx_name:"Saturate",_hx_index:53,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pack: {_hx_name:"Pack",_hx_index:54,__enum__:"hxsl.TGlobal",toString:$estr}
	,Unpack: {_hx_name:"Unpack",_hx_index:55,__enum__:"hxsl.TGlobal",toString:$estr}
	,PackNormal: {_hx_name:"PackNormal",_hx_index:56,__enum__:"hxsl.TGlobal",toString:$estr}
	,UnpackNormal: {_hx_name:"UnpackNormal",_hx_index:57,__enum__:"hxsl.TGlobal",toString:$estr}
	,ScreenToUv: {_hx_name:"ScreenToUv",_hx_index:58,__enum__:"hxsl.TGlobal",toString:$estr}
	,UvToScreen: {_hx_name:"UvToScreen",_hx_index:59,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdx: {_hx_name:"DFdx",_hx_index:60,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdy: {_hx_name:"DFdy",_hx_index:61,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fwidth: {_hx_name:"Fwidth",_hx_index:62,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelRead: {_hx_name:"ChannelRead",_hx_index:63,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelReadLod: {_hx_name:"ChannelReadLod",_hx_index:64,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelFetch: {_hx_name:"ChannelFetch",_hx_index:65,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelTextureSize: {_hx_name:"ChannelTextureSize",_hx_index:66,__enum__:"hxsl.TGlobal",toString:$estr}
	,Trace: {_hx_name:"Trace",_hx_index:67,__enum__:"hxsl.TGlobal",toString:$estr}
	,VertexID: {_hx_name:"VertexID",_hx_index:68,__enum__:"hxsl.TGlobal",toString:$estr}
	,InstanceID: {_hx_name:"InstanceID",_hx_index:69,__enum__:"hxsl.TGlobal",toString:$estr}
	,FragCoord: {_hx_name:"FragCoord",_hx_index:70,__enum__:"hxsl.TGlobal",toString:$estr}
	,FrontFacing: {_hx_name:"FrontFacing",_hx_index:71,__enum__:"hxsl.TGlobal",toString:$estr}
	,FloatBitsToInt: {_hx_name:"FloatBitsToInt",_hx_index:72,__enum__:"hxsl.TGlobal",toString:$estr}
	,FloatBitsToUint: {_hx_name:"FloatBitsToUint",_hx_index:73,__enum__:"hxsl.TGlobal",toString:$estr}
	,IntBitsToFloat: {_hx_name:"IntBitsToFloat",_hx_index:74,__enum__:"hxsl.TGlobal",toString:$estr}
	,UintBitsToFloat: {_hx_name:"UintBitsToFloat",_hx_index:75,__enum__:"hxsl.TGlobal",toString:$estr}
	,RoundEven: {_hx_name:"RoundEven",_hx_index:76,__enum__:"hxsl.TGlobal",toString:$estr}
	,SetLayout: {_hx_name:"SetLayout",_hx_index:77,__enum__:"hxsl.TGlobal",toString:$estr}
};
hxsl_TGlobal.__constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing,hxsl_TGlobal.FloatBitsToInt,hxsl_TGlobal.FloatBitsToUint,hxsl_TGlobal.IntBitsToFloat,hxsl_TGlobal.UintBitsToFloat,hxsl_TGlobal.RoundEven,hxsl_TGlobal.SetLayout];
hxsl_TGlobal.__empty_constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing,hxsl_TGlobal.FloatBitsToInt,hxsl_TGlobal.FloatBitsToUint,hxsl_TGlobal.IntBitsToFloat,hxsl_TGlobal.UintBitsToFloat,hxsl_TGlobal.RoundEven,hxsl_TGlobal.SetLayout];
var hxsl_Component = $hxEnums["hxsl.Component"] = { __ename__:"hxsl.Component",__constructs__:null
	,X: {_hx_name:"X",_hx_index:0,__enum__:"hxsl.Component",toString:$estr}
	,Y: {_hx_name:"Y",_hx_index:1,__enum__:"hxsl.Component",toString:$estr}
	,Z: {_hx_name:"Z",_hx_index:2,__enum__:"hxsl.Component",toString:$estr}
	,W: {_hx_name:"W",_hx_index:3,__enum__:"hxsl.Component",toString:$estr}
};
hxsl_Component.__constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Component.__empty_constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
var hxsl_Tools = function() { };
$hxClasses["hxsl.Tools"] = hxsl_Tools;
hxsl_Tools.__name__ = "hxsl.Tools";
hxsl_Tools.allocVarId = function() {
	return ++hxsl_Tools.UID;
};
hxsl_Tools.getName = function(v) {
	if(v.qualifiers == null) {
		return v.name;
	}
	var _g = 0;
	var _g1 = v.qualifiers;
	while(_g < _g1.length) {
		var q = _g1[_g];
		++_g;
		if(q._hx_index == 4) {
			var n = q.n;
			return n;
		}
	}
	return v.name;
};
hxsl_Tools.getDoc = function(v) {
	if(v.qualifiers == null) {
		return null;
	}
	var _g = 0;
	var _g1 = v.qualifiers;
	while(_g < _g1.length) {
		var q = _g1[_g];
		++_g;
		if(q._hx_index == 10) {
			var s = q.s;
			return s;
		}
	}
	return null;
};
hxsl_Tools.getConstBits = function(v) {
	var _g = v.type;
	switch(_g._hx_index) {
	case 1:
		var _g1 = 0;
		var _g2 = v.qualifiers;
		while(_g1 < _g2.length) {
			var q = _g2[_g1];
			++_g1;
			if(q._hx_index == 0) {
				var n = q.max;
				if(n != null) {
					var bits = 0;
					while(n >= 1 << bits) ++bits;
					return bits;
				}
				return 8;
			}
		}
		break;
	case 2:
		return 1;
	case 17:
		var _g1 = _g.size;
		return 3 + hxsl_Tools.MAX_CHANNELS_BITS;
	default:
	}
	return 0;
};
hxsl_Tools.isConst = function(v) {
	var _g = v.type;
	var tmp;
	if(_g._hx_index == 17) {
		var _g1 = _g.size;
		tmp = true;
	} else {
		tmp = false;
	}
	if(tmp) {
		return true;
	}
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			if(q._hx_index == 0) {
				var _g2 = q.max;
				return true;
			}
		}
	}
	return false;
};
hxsl_Tools.isStruct = function(v) {
	var _g = v.type;
	if(_g._hx_index == 13) {
		var _g1 = _g.vl;
		return true;
	} else {
		return false;
	}
};
hxsl_Tools.isArray = function(v) {
	var _g = v.type;
	if(_g._hx_index == 15) {
		var _g1 = _g.t;
		var _g1 = _g.size;
		return true;
	} else {
		return false;
	}
};
hxsl_Tools.hasQualifier = function(v,q) {
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q2 = _g1[_g];
			++_g;
			if(q2 == q) {
				return true;
			}
		}
	}
	return false;
};
hxsl_Tools.hasBorrowQualifier = function(v,path) {
	if(v.qualifiers != null) {
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			if(q._hx_index == 11) {
				var s = q.source;
				return path == s;
			}
		}
	}
	return false;
};
hxsl_Tools.isSampler = function(t) {
	switch(t._hx_index) {
	case 10:case 11:case 12:
		return true;
	case 17:
		var _g = t.size;
		return true;
	default:
		return false;
	}
};
hxsl_Tools.toString = function(t) {
	switch(t._hx_index) {
	case 5:
		var size = t.size;
		var t1 = t.t;
		var prefix;
		switch(t1._hx_index) {
		case 0:
			prefix = "I";
			break;
		case 1:
			prefix = "";
			break;
		case 2:
			prefix = "B";
			break;
		}
		return prefix + "Vec" + size;
	case 9:
		var n = t.size;
		return "Bytes" + n;
	case 13:
		var vl = t.vl;
		var _g = [];
		var _g1 = 0;
		while(_g1 < vl.length) {
			var v = vl[_g1];
			++_g1;
			_g.push(v.name + " : " + hxsl_Tools.toString(v.type));
		}
		return "{" + _g.join(",") + "}";
	case 15:
		var t1 = t.t;
		var s = t.size;
		var tmp = hxsl_Tools.toString(t1) + "[";
		var tmp1;
		switch(s._hx_index) {
		case 0:
			var i = s.v;
			tmp1 = "" + i;
			break;
		case 1:
			var v = s.v;
			tmp1 = v.name;
			break;
		}
		return tmp + tmp1 + "]";
	case 16:
		var t1 = t.t;
		var s = t.size;
		var k = t.kind;
		var prefix;
		switch(k._hx_index) {
		case 0:
			prefix = "buffer";
			break;
		case 1:
			prefix = "rwbuffer";
			break;
		}
		var tmp = prefix + " " + hxsl_Tools.toString(t1) + "[";
		var tmp1;
		switch(s._hx_index) {
		case 0:
			var i = s.v;
			tmp1 = "" + i;
			break;
		case 1:
			var v = s.v;
			tmp1 = v.name;
			break;
		}
		return tmp + tmp1 + "]";
	default:
		return HxOverrides.substr($hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name,1,null);
	}
};
hxsl_Tools.toType = function(t) {
	switch(t._hx_index) {
	case 0:
		return hxsl_Type.TInt;
	case 1:
		return hxsl_Type.TFloat;
	case 2:
		return hxsl_Type.TBool;
	}
};
hxsl_Tools.hasSideEffect = function(e) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		return false;
	case 1:
		var _g1 = _g.v;
		return false;
	case 2:
		var _g1 = _g.g;
		return false;
	case 3:
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 4:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(e)) {
				return true;
			}
		}
		return false;
	case 5:
		var _g1 = _g.op;
		var _g2 = _g.e1;
		var _g3 = _g.e2;
		switch(_g1._hx_index) {
		case 4:
			return true;
		case 20:
			var _g4 = _g1.op;
			return true;
		default:
			var e1 = _g2;
			var e2 = _g3;
			if(!hxsl_Tools.hasSideEffect(e1)) {
				return hxsl_Tools.hasSideEffect(e2);
			} else {
				return true;
			}
		}
		break;
	case 6:
		var _g1 = _g.op;
		var e1 = _g.e1;
		return hxsl_Tools.hasSideEffect(e1);
	case 7:
		var _g1 = _g.v;
		var _g1 = _g.init;
		return true;
	case 8:
		var _g1 = _g.e;
		var _g2 = _g.args;
		var _g3 = _g1.e;
		var _g4 = _g1.p;
		var _g4 = _g1.t;
		if(_g3._hx_index == 2) {
			if(_g3.g._hx_index == 77) {
				return true;
			} else {
				var e = _g1;
				var pl = _g2;
				var _g3 = e.e;
				var tmp;
				if(_g3._hx_index == 2) {
					var _g4 = _g3.g;
					tmp = true;
				} else {
					tmp = false;
				}
				if(!tmp) {
					return true;
				}
				var _g3 = 0;
				while(_g3 < pl.length) {
					var p = pl[_g3];
					++_g3;
					if(hxsl_Tools.hasSideEffect(p)) {
						return true;
					}
				}
				return false;
			}
		} else {
			var e = _g1;
			var pl = _g2;
			var _g1 = e.e;
			var tmp;
			if(_g1._hx_index == 2) {
				var _g2 = _g1.g;
				tmp = true;
			} else {
				tmp = false;
			}
			if(!tmp) {
				return true;
			}
			var _g1 = 0;
			while(_g1 < pl.length) {
				var p = pl[_g1];
				++_g1;
				if(hxsl_Tools.hasSideEffect(p)) {
					return true;
				}
			}
			return false;
		}
		break;
	case 9:
		var _g1 = _g.regs;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		if(!(hxsl_Tools.hasSideEffect(econd) || hxsl_Tools.hasSideEffect(eif))) {
			if(eelse != null) {
				return hxsl_Tools.hasSideEffect(eelse);
			} else {
				return false;
			}
		} else {
			return true;
		}
		break;
	case 12:
		var _g1 = _g.e;
		return true;
	case 13:
		var _g1 = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		if(!hxsl_Tools.hasSideEffect(it)) {
			return hxsl_Tools.hasSideEffect(loop);
		} else {
			return true;
		}
		break;
	case 11:case 14:case 15:
		return true;
	case 16:
		var e = _g.e;
		var index = _g.index;
		if(!hxsl_Tools.hasSideEffect(e)) {
			return hxsl_Tools.hasSideEffect(index);
		} else {
			return true;
		}
		break;
	case 17:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			if(hxsl_Tools.hasSideEffect(e)) {
				return true;
			}
		}
		return false;
	case 18:
		var e = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = c.values;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				if(hxsl_Tools.hasSideEffect(v)) {
					return true;
				}
			}
			if(hxsl_Tools.hasSideEffect(c.expr)) {
				return true;
			}
		}
		if(!hxsl_Tools.hasSideEffect(e)) {
			if(def != null) {
				return hxsl_Tools.hasSideEffect(def);
			} else {
				return false;
			}
		} else {
			return true;
		}
		break;
	case 19:
		var _g1 = _g.normalWhile;
		var e = _g.e;
		var loop = _g.loop;
		if(!hxsl_Tools.hasSideEffect(e)) {
			return hxsl_Tools.hasSideEffect(loop);
		} else {
			return true;
		}
		break;
	case 20:
		var _g1 = _g.m;
		var _g1 = _g.args;
		var e = _g.e;
		return hxsl_Tools.hasSideEffect(e);
	}
};
hxsl_Tools.iter = function(e,f) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		break;
	case 1:
		var _g1 = _g.v;
		break;
	case 2:
		var _g1 = _g.g;
		break;
	case 3:
		var e = _g.e;
		f(e);
		break;
	case 4:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			f(e);
		}
		break;
	case 5:
		var _g1 = _g.op;
		var e1 = _g.e1;
		var e2 = _g.e2;
		f(e1);
		f(e2);
		break;
	case 6:
		var _g1 = _g.op;
		var e1 = _g.e1;
		f(e1);
		break;
	case 7:
		var _g1 = _g.v;
		var init = _g.init;
		if(init != null) {
			f(init);
		}
		break;
	case 8:
		var e = _g.e;
		var args = _g.args;
		f(e);
		var _g1 = 0;
		while(_g1 < args.length) {
			var a = args[_g1];
			++_g1;
			f(a);
		}
		break;
	case 9:
		var _g1 = _g.regs;
		var e = _g.e;
		f(e);
		break;
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		f(econd);
		f(eif);
		if(eelse != null) {
			f(eelse);
		}
		break;
	case 12:
		var e = _g.e;
		if(e != null) {
			f(e);
		}
		break;
	case 13:
		var _g1 = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		f(it);
		f(loop);
		break;
	case 11:case 14:case 15:
		break;
	case 16:
		var e = _g.e;
		var index = _g.index;
		f(e);
		f(index);
		break;
	case 17:
		var el = _g.el;
		var _g1 = 0;
		while(_g1 < el.length) {
			var e = el[_g1];
			++_g1;
			f(e);
		}
		break;
	case 18:
		var e = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		f(e);
		var _g1 = 0;
		while(_g1 < cases.length) {
			var c = cases[_g1];
			++_g1;
			var _g2 = 0;
			var _g3 = c.values;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				f(v);
			}
			f(c.expr);
		}
		if(def != null) {
			f(def);
		}
		break;
	case 19:
		var _g1 = _g.normalWhile;
		var e = _g.e;
		var loop = _g.loop;
		f(e);
		f(loop);
		break;
	case 20:
		var _g1 = _g.m;
		var _g1 = _g.args;
		var e = _g.e;
		f(e);
		break;
	}
};
hxsl_Tools.map = function(e,f) {
	var ed;
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var _g1 = _g.c;
		ed = e.e;
		break;
	case 1:
		var _g1 = _g.v;
		ed = e.e;
		break;
	case 2:
		var _g1 = _g.g;
		ed = e.e;
		break;
	case 3:
		var e1 = _g.e;
		ed = hxsl_TExprDef.TParenthesis(f(e1));
		break;
	case 4:
		var el = _g.el;
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < el.length) {
			var e1 = el[_g2];
			++_g2;
			_g1.push(f(e1));
		}
		ed = hxsl_TExprDef.TBlock(_g1);
		break;
	case 5:
		var op = _g.op;
		var e1 = _g.e1;
		var e2 = _g.e2;
		ed = hxsl_TExprDef.TBinop(op,f(e1),f(e2));
		break;
	case 6:
		var op = _g.op;
		var e1 = _g.e1;
		ed = hxsl_TExprDef.TUnop(op,f(e1));
		break;
	case 7:
		var v = _g.v;
		var init = _g.init;
		ed = hxsl_TExprDef.TVarDecl(v,init != null ? f(init) : null);
		break;
	case 8:
		var e1 = _g.e;
		var args = _g.args;
		var ed1 = f(e1);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < args.length) {
			var a = args[_g2];
			++_g2;
			_g1.push(f(a));
		}
		ed = hxsl_TExprDef.TCall(ed1,_g1);
		break;
	case 9:
		var e1 = _g.e;
		var c = _g.regs;
		ed = hxsl_TExprDef.TSwiz(f(e1),c);
		break;
	case 10:
		var econd = _g.econd;
		var eif = _g.eif;
		var eelse = _g.eelse;
		ed = hxsl_TExprDef.TIf(f(econd),f(eif),eelse != null ? f(eelse) : null);
		break;
	case 12:
		var e1 = _g.e;
		ed = hxsl_TExprDef.TReturn(e1 != null ? f(e1) : null);
		break;
	case 13:
		var v = _g.v;
		var it = _g.it;
		var loop = _g.loop;
		ed = hxsl_TExprDef.TFor(v,f(it),f(loop));
		break;
	case 11:case 14:case 15:
		ed = e.e;
		break;
	case 16:
		var e1 = _g.e;
		var index = _g.index;
		ed = hxsl_TExprDef.TArray(f(e1),f(index));
		break;
	case 17:
		var el = _g.el;
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < el.length) {
			var e1 = el[_g2];
			++_g2;
			_g1.push(f(e1));
		}
		ed = hxsl_TExprDef.TArrayDecl(_g1);
		break;
	case 18:
		var e1 = _g.e;
		var cases = _g.cases;
		var def = _g.def;
		var ed1 = f(e1);
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < cases.length) {
			var c = cases[_g2];
			++_g2;
			var _g3 = [];
			var _g4 = 0;
			var _g5 = c.values;
			while(_g4 < _g5.length) {
				var v = _g5[_g4];
				++_g4;
				_g3.push(f(v));
			}
			_g1.push({ values : _g3, expr : f(c.expr)});
		}
		ed = hxsl_TExprDef.TSwitch(ed1,_g1,def == null ? null : f(def));
		break;
	case 19:
		var e1 = _g.e;
		var loop = _g.loop;
		var normalWhile = _g.normalWhile;
		ed = hxsl_TExprDef.TWhile(f(e1),f(loop),normalWhile);
		break;
	case 20:
		var m = _g.m;
		var args = _g.args;
		var e1 = _g.e;
		ed = hxsl_TExprDef.TMeta(m,args,f(e1));
		break;
	}
	return { e : ed, t : e.t, p : e.p};
};
hxsl_Tools.size = function(t) {
	switch(t._hx_index) {
	case 0:
		return 0;
	case 1:case 3:
		return 1;
	case 5:
		var _g = t.t;
		var n = t.size;
		return n;
	case 6:
		return 9;
	case 7:
		return 16;
	case 8:
		return 12;
	case 9:
		var s = t.size;
		return s;
	case 2:case 4:case 10:case 11:case 12:
		return 0;
	case 13:
		var vl = t.vl;
		var s = 0;
		var _g = 0;
		while(_g < vl.length) {
			var v = vl[_g];
			++_g;
			s += hxsl_Tools.size(v.type);
		}
		return s;
	case 14:
		var _g = t.variants;
		return 0;
	case 15:
		var _g = t.t;
		var _g1 = t.size;
		switch(_g1._hx_index) {
		case 0:
			var v = _g1.v;
			var t1 = _g;
			return hxsl_Tools.size(t1) * v;
		case 1:
			var _g = _g1.v;
			return 0;
		}
		break;
	case 16:
		var _g = t.size;
		var _g1 = t.kind;
		if(_g._hx_index == 0) {
			var v = _g.v;
			var t1 = t.t;
			return hxsl_Tools.size(t1) * v;
		} else {
			return 0;
		}
		break;
	case 17:
		var n = t.size;
		return n;
	case 18:
		return 4;
	}
};
hxsl_Tools.evalConst = function(e) {
	var _g = e.e;
	switch(_g._hx_index) {
	case 0:
		var c = _g.c;
		switch(c._hx_index) {
		case 0:
			return null;
		case 1:
			var b = c.b;
			return b;
		case 2:
			var i = c.v;
			return i;
		case 3:
			var f = c.v;
			return f;
		case 4:
			var s = c.v;
			return s;
		}
		break;
	case 8:
		var _g1 = _g.e;
		var _g2 = _g.args;
		var _g = _g1.e;
		var _g3 = _g1.p;
		var _g3 = _g1.t;
		if(_g._hx_index == 2) {
			switch(_g.g._hx_index) {
			case 40:case 41:
				var args = _g2;
				var _g = [];
				var _g1 = 0;
				while(_g1 < args.length) {
					var a = args[_g1];
					++_g1;
					_g.push(hxsl_Tools.evalConst(a));
				}
				var vals = _g;
				if(vals.length == 1) {
					var x = vals[0];
					var y = vals[0];
					var z = vals[0];
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					return new h3d_VectorImpl(x,y,z);
				}
				var x = vals[0];
				var y = vals[1];
				var z = vals[2];
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				return new h3d_VectorImpl(x,y,z);
			case 42:
				var args = _g2;
				var _g = [];
				var _g1 = 0;
				while(_g1 < args.length) {
					var a = args[_g1];
					++_g1;
					_g.push(hxsl_Tools.evalConst(a));
				}
				var vals = _g;
				if(vals.length == 1) {
					var x = vals[0];
					var y = vals[0];
					var z = vals[0];
					var w = vals[0];
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					return new h3d_Vector4Impl(x,y,z,w);
				}
				var x = vals[0];
				var y = vals[1];
				var z = vals[2];
				var w = vals[3];
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				return new h3d_Vector4Impl(x,y,z,w);
			default:
				throw haxe_Exception.thrown("Unhandled constant init " + hxsl_Printer.toString(e));
			}
		} else {
			throw haxe_Exception.thrown("Unhandled constant init " + hxsl_Printer.toString(e));
		}
		break;
	default:
		throw haxe_Exception.thrown("Unhandled constant init " + hxsl_Printer.toString(e));
	}
};
var hxsl_Tools2 = function() { };
$hxClasses["hxsl.Tools2"] = hxsl_Tools2;
hxsl_Tools2.__name__ = "hxsl.Tools2";
hxsl_Tools2.toString = function(g) {
	var n = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
	return n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
};
var hxsl_Tools3 = function() { };
$hxClasses["hxsl.Tools3"] = hxsl_Tools3;
hxsl_Tools3.__name__ = "hxsl.Tools3";
hxsl_Tools3.toString = function(s) {
	return hxsl_Printer.shaderToString(s);
};
var hxsl_Tools4 = function() { };
$hxClasses["hxsl.Tools4"] = hxsl_Tools4;
hxsl_Tools4.__name__ = "hxsl.Tools4";
hxsl_Tools4.toString = function(e) {
	return hxsl_Printer.toString(e);
};
var hxsl_BatchShader = function() {
	this.Batch_Count__ = 0;
	hxsl_Shader.call(this);
};
$hxClasses["hxsl.BatchShader"] = hxsl_BatchShader;
hxsl_BatchShader.__name__ = "hxsl.BatchShader";
hxsl_BatchShader.__super__ = hxsl_Shader;
hxsl_BatchShader.prototype = $extend(hxsl_Shader.prototype,{
	get_Batch_HasOffset: function() {
		return this.Batch_HasOffset__;
	}
	,set_Batch_HasOffset: function(_v) {
		this.constModified = true;
		return this.Batch_HasOffset__ = _v;
	}
	,get_Batch_Count: function() {
		return this.Batch_Count__;
	}
	,set_Batch_Count: function(_v) {
		this.constModified = true;
		return this.Batch_Count__ = _v;
	}
	,get_Batch_Buffer: function() {
		return this.Batch_Buffer__;
	}
	,set_Batch_Buffer: function(_v) {
		return this.Batch_Buffer__ = _v;
	}
	,updateConstants: function(globals) {
		this.constBits = 0;
		if(this.Batch_HasOffset__) {
			this.constBits |= 1;
		}
		var v = this.Batch_Count__;
		if(v >>> 17 != 0) {
			throw haxe_Exception.thrown("Batch_Count" + " is out of range " + v + ">" + 131071);
		}
		this.constBits |= v << 1;
		this.updateConstantsFinal(globals);
	}
	,getParamValue: function(index) {
		switch(index) {
		case 0:
			return this.Batch_HasOffset__;
		case 1:
			return this.Batch_Count__;
		case 2:
			return this.Batch_Buffer__;
		default:
		}
		return null;
	}
	,getParamFloatValue: function(index) {
		return 0.;
	}
	,setParamIndexValue: function(index,val) {
		switch(index) {
		case 0:
			this.Batch_HasOffset__ = val;
			break;
		case 1:
			this.Batch_Count__ = val;
			break;
		case 2:
			this.Batch_Buffer__ = val;
			break;
		default:
		}
	}
	,setParamIndexFloatValue: function(index,val) {
	}
	,clone: function() {
		var s = Object.create(hxsl_BatchShader.prototype);
		s.shader = this.shader;
		s.Batch_HasOffset__ = this.Batch_HasOffset__;
		s.Batch_Count__ = this.Batch_Count__;
		s.Batch_Buffer__ = this.Batch_Buffer__;
		return s;
	}
	,__class__: hxsl_BatchShader
});
var hxsl_BatchInstanceParams = function(forcedPerInstance) {
	this.forcedPerInstance = forcedPerInstance;
};
$hxClasses["hxsl.BatchInstanceParams"] = hxsl_BatchInstanceParams;
hxsl_BatchInstanceParams.__name__ = "hxsl.BatchInstanceParams";
hxsl_BatchInstanceParams.prototype = {
	getSignature: function() {
		if(this.cachedSignature == null) {
			var _g = 0;
			var _g1 = this.forcedPerInstance;
			while(_g < _g1.length) {
				var fp = _g1[_g];
				++_g;
				fp.params.sort(Reflect.compare);
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = this.forcedPerInstance;
			while(_g1 < _g2.length) {
				var s = _g2[_g1];
				++_g1;
				_g.push(s.shader + "=" + s.params.join(","));
			}
			this.cachedSignature = HxOverrides.substr(haxe_crypto_Md5.encode(_g.join(";")),0,8);
		}
		return this.cachedSignature;
	}
	,__class__: hxsl_BatchInstanceParams
};
var hxsl_SearchMap = function() {
	this.minId = 0;
	this.nexts = [];
};
$hxClasses["hxsl.SearchMap"] = hxsl_SearchMap;
hxsl_SearchMap.__name__ = "hxsl.SearchMap";
hxsl_SearchMap.prototype = {
	set: function(id,s) {
		if(this.minId == 0) {
			this.minId = id;
			this.nexts = [s];
			return;
		}
		var offset = id - this.minId;
		if(offset < 0) {
			var n = [];
			var _g = 0;
			var _g1 = this.nexts.length;
			while(_g < _g1) {
				var i = _g++;
				n[i - offset] = this.nexts[i];
			}
			this.nexts = n;
			this.minId += offset;
			offset = 0;
		}
		this.nexts[offset] = s;
	}
	,get: function(id) {
		return this.nexts[id - this.minId];
	}
	,__class__: hxsl_SearchMap
};
var hxsl_Cache = function() {
	this.linkCache = new hxsl_SearchMap();
	this.linkShaders = new haxe_ds_StringMap();
	this.batchShaders = new haxe_ds_ObjectMap();
	this.batchShadersParams = new haxe_ds_StringMap();
	this.byID = new haxe_ds_StringMap();
};
$hxClasses["hxsl.Cache"] = hxsl_Cache;
hxsl_Cache.__name__ = "hxsl.Cache";
hxsl_Cache.get = function() {
	var c = hxsl_Cache.INST;
	if(c == null) {
		c = new hxsl_Cache();
		hxsl_Cache.INST = c;
	}
	return c;
};
hxsl_Cache.set = function(c) {
	hxsl_Cache.INST = c;
};
hxsl_Cache.clear = function() {
	hxsl_Cache.INST = null;
};
hxsl_Cache.prototype = {
	getLinkShader: function(vars) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < vars.length) {
			var v = vars[_g1];
			++_g1;
			_g.push(Std.string(v));
		}
		var key = _g.join(",");
		var shader = this.linkShaders.h[key];
		if(shader != null) {
			return shader;
		}
		var s = new hxsl_SharedShader("");
		var id = HxOverrides.substr(haxe_crypto_Md5.encode(key),0,8);
		s.data = { name : "shaderLinker_" + id, vars : [], funs : []};
		var pos = null;
		var outVars_h = Object.create(null);
		var outputCount = 0;
		var tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		var makeVec = function(g,size,args,makeOutExpr) {
			var out = [];
			var rem = size;
			var _g = 0;
			var _g1 = args.length;
			while(_g < _g1) {
				var i = _g++;
				var e = makeOutExpr(args[args.length - 1 - i],rem - (args.length - 1 - i));
				rem -= hxsl_Tools.size(e.t);
				out.unshift(e);
			}
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},out), t : hxsl_Type.TVec(size,hxsl_VecType.VFloat), p : pos};
		};
		var makeVar = function(name,t,parent) {
			var path = parent == null ? name : hxsl_Tools.getName(parent) + "." + name;
			var v = outVars_h[path];
			if(v != null) {
				return v;
			}
			v = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Var, parent : parent};
			if(parent == null) {
				s.data.vars.push(v);
			} else {
				var _g = parent.type;
				if(_g._hx_index == 13) {
					var vl = _g.vl;
					vl.push(v);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			}
			outVars_h[path] = v;
			return v;
		};
		var makeOutExpr = null;
		makeOutExpr = function(v,rem) {
			switch(v._hx_index) {
			case 0:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(v1)), t : hxsl_Type.TFloat, p : pos};
			case 1:
				var vname = v.v;
				var size = v.size;
				var v1 = outVars_h[vname];
				if(v1 != null) {
					return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
				}
				var path = vname.split(".");
				var parent = null;
				while(path.length > 1) parent = makeVar(path.shift(),hxsl_Type.TStruct([]),parent);
				if(size != null) {
					rem = size;
				}
				v1 = makeVar(path.shift(),rem == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(rem,hxsl_VecType.VFloat),parent);
				return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
			case 2:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v1,3)]), t : tvec4, p : pos};
			case 3:
				var v1 = v.v;
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v1,1)]), t : tvec4, p : pos};
			case 4:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec2,2,args,makeOutExpr);
			case 5:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec3,3,args,makeOutExpr);
			case 6:
				var args = v.a;
				return makeVec(hxsl_TGlobal.Vec4,4,args,makeOutExpr);
			case 7:
				var v1 = v.a;
				var comps = v.swiz;
				return { e : hxsl_TExprDef.TSwiz(makeOutExpr(v1,4),comps), t : hxsl_Type.TVec(comps.length,hxsl_VecType.VFloat), p : pos};
			}
		};
		var makeOutput = function(v) {
			outputCount += 1;
			var ov = { id : hxsl_Tools.allocVarId(), type : tvec4, name : "OUTPUT" + (outputCount - 1), kind : hxsl_VarKind.Output};
			s.data.vars.push(ov);
			return { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(ov), t : tvec4, p : pos},makeOutExpr(v,4)), t : hxsl_Type.TVoid, p : pos};
		};
		var defineFun = function(kind,vars) {
			var fv = { id : hxsl_Tools.allocVarId(), type : hxsl_Type.TFun([]), name : ("" + Std.string(kind)).toLowerCase(), kind : hxsl_VarKind.Function};
			var _g = [];
			var _g1 = 0;
			while(_g1 < vars.length) {
				var v = vars[_g1];
				++_g1;
				_g.push(makeOutput(v));
			}
			var f = { kind : kind, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(_g), p : pos, t : hxsl_Type.TVoid}};
			s.data.funs.push(f);
		};
		defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")]);
		defineFun(hxsl_FunctionKind.Fragment,vars);
		shader = Object.create(hxsl_Shader.prototype);
		shader.shader = s;
		this.linkShaders.h[key] = shader;
		shader.updateConstantsFinal(null);
		return shader;
	}
	,link: function(shaders,mode) {
		var c = this.linkCache;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			var i = s1.instance;
			var cs = c.nexts[i.id - c.minId];
			if(cs == null) {
				cs = new hxsl_SearchMap();
				c.set(i.id,cs);
			}
			c = cs;
		}
		if(c.linked == null) {
			c.linked = this.compileRuntimeShader(shaders,mode);
		}
		return c.linked;
	}
	,compileRuntimeShader: function(shaders,mode) {
		var shaderDatas = [];
		var index = 0;
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			var i = s1.instance;
			shaderDatas.push({ inst : i, p : s1.priority, index : index++});
		}
		shaderDatas.reverse();
		haxe_ds_ArraySort.sort(shaderDatas,function(s1,s2) {
			return s2.p - s1.p;
		});
		var linker = new hxsl_Linker(mode);
		var s;
		try {
			var _g = [];
			var _g1 = 0;
			while(_g1 < shaderDatas.length) {
				var s1 = shaderDatas[_g1];
				++_g1;
				_g.push(s1.inst.shader);
			}
			s = linker.link(_g);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				var _g1 = [];
				var _g2 = 0;
				while(_g2 < shaderDatas.length) {
					var s1 = shaderDatas[_g2];
					++_g2;
					_g1.push(hxsl_Printer.shaderToString(s1.inst.shader));
				}
				var shaders1 = _g1;
				e.msg += "\n\nin\n\n" + shaders1.join("\n-----\n");
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		if(mode == hxsl_LinkMode.Batch) {
			var checkRec = null;
			checkRec = function(v) {
				if(v.qualifiers != null && v.qualifiers.indexOf(hxsl_VarQualifier.PerObject) >= 0) {
					if(v.qualifiers.length == 1) {
						v.qualifiers = null;
					} else {
						v.qualifiers = v.qualifiers.slice();
						HxOverrides.remove(v.qualifiers,hxsl_VarQualifier.PerObject);
					}
					if(v.kind != hxsl_VarKind.Var) {
						v.kind = hxsl_VarKind.Local;
					}
				}
				var _g = v.type;
				if(_g._hx_index == 13) {
					var vl = _g.vl;
					var _g = 0;
					while(_g < vl.length) {
						var v = vl[_g];
						++_g;
						checkRec(v);
					}
				}
			};
			var _g = 0;
			var _g1 = s.vars;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				checkRec(v);
			}
		}
		var prev = s;
		var splitter = new hxsl_Splitter();
		var sl;
		try {
			sl = splitter.split(s);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				var e = _g1;
				e.msg += "\n\nin\n\n" + hxsl_Printer.shaderToString(s);
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		var paramVars = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = linker.allVars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			if(v.v.kind == hxsl_VarKind.Param) {
				var _g2 = v.v.type;
				if(_g2._hx_index == 13) {
					var _g3 = _g2.vl;
					continue;
				}
				var inf = shaderDatas[v.instanceIndex];
				var nv = splitter.varMap.h[v.v.__id__];
				paramVars.h[nv == null ? v.id : nv.id] = { instance : inf.index, index : inf.inst.params.h[v.merged[0].id]};
			}
		}
		var prev = sl;
		var sl1 = new hxsl_Dce().dce(sl);
		var r = this.buildRuntimeShader(sl1,paramVars);
		r.mode = mode;
		var _g = [];
		var _g_l = shaders;
		var _g_last = null;
		while(_g_l != _g_last) {
			var s = _g_l.s;
			_g_l = _g_l.next;
			var s1 = s;
			_g.push(new hxsl_ShaderInstanceDesc(s1.shader,s1.constBits));
		}
		r.spec = { instances : _g, signature : null};
		var _g = 0;
		var _g1 = shaderDatas.length;
		while(_g < _g1) {
			var i = _g++;
			var s = shaderDatas[shaderDatas.length - 1 - i];
			r.spec.instances[s.index].index = i;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = r.spec.instances;
		while(_g1 < _g2.length) {
			var i = _g2[_g1];
			++_g1;
			_g.push(i.shader.data.name + "_" + i.bits + "_" + i.index);
		}
		var signParts = _g;
		var tmp = signParts.join(":");
		r.spec.signature = haxe_crypto_Md5.encode(tmp);
		var _g = [];
		var _g1 = 0;
		var _g2 = r.getShaders();
		while(_g1 < _g2.length) {
			var s = _g2[_g1];
			++_g1;
			_g.push(hxsl_Printer.shaderToString(s.data));
		}
		r.signature = haxe_crypto_Md5.encode(_g.join(""));
		var r2 = this.byID.h[r.signature];
		if(r2 != null) {
			r.id = r2.id;
		} else {
			this.byID.h[r.signature] = r;
		}
		return r;
	}
	,buildRuntimeShader: function(shaders,paramVars) {
		var r = new hxsl_RuntimeShader();
		r.globals = new haxe_ds_IntMap();
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var kind;
			switch(s.name) {
			case "fragment":
				kind = hxsl_FunctionKind.Fragment;
				break;
			case "main":
				kind = hxsl_FunctionKind.Main;
				break;
			case "vertex":
				kind = hxsl_FunctionKind.Vertex;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			var fl = this.flattenShader(s,kind,paramVars);
			fl.kind = kind;
			switch(kind._hx_index) {
			case 0:
				r.vertex = fl;
				break;
			case 1:
				r.fragment = fl;
				break;
			case 4:
				r.vertex = fl;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.initGlobals(r,fl);
		}
		return r;
	}
	,initGlobals: function(r,s) {
		var p = s.globals;
		while(p != null) {
			r.globals.h[p.gid] = true;
			p = p.next;
		}
		var p = s.params;
		while(p != null) {
			if(p.perObjectGlobal != null) {
				r.globals.h[p.perObjectGlobal.gid] = true;
			}
			p = p.next;
		}
	}
	,getPath: function(v) {
		if(v.parent == null) {
			return v.name;
		}
		return this.getPath(v.parent) + "." + v.name;
	}
	,flattenShader: function(s,kind,params) {
		var flat = new hxsl_Flatten();
		var c = new hxsl_RuntimeShaderData();
		var data = flat.flatten(s,kind);
		var textures = [];
		c.texturesCount = 0;
		var g = flat.allocData.keys();
		while(g.hasNext()) {
			var g1 = g.next();
			var alloc = flat.allocData.h[g1.__id__];
			switch(g1.kind._hx_index) {
			case 0:
				var _g = [];
				var _g1 = 0;
				while(_g1 < alloc.length) {
					var a = alloc[_g1];
					++_g1;
					if(a.v != null) {
						_g.push(new hxsl_AllocGlobal(a.pos,this.getPath(a.v),a.v.type));
					}
				}
				var out = _g;
				var _g2 = 0;
				var _g3 = out.length - 1;
				while(_g2 < _g3) {
					var i = _g2++;
					out[i].next = out[i + 1];
				}
				var _g4 = g1.type;
				if(_g4._hx_index == 15) {
					var _g5 = _g4.t;
					var _g6 = _g4.size;
					if(_g5._hx_index == 5) {
						if(_g5.size == 4) {
							if(_g5.t._hx_index == 1) {
								if(_g6._hx_index == 0) {
									var size = _g6.v;
									c.globals = out[0];
									c.globalsSize = size;
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					} else {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 2:
				var out1 = [];
				var count = 0;
				var _g7 = 0;
				while(_g7 < alloc.length) {
					var a1 = alloc[_g7];
					++_g7;
					if(a1.v == null) {
						continue;
					}
					var p = params.h[a1.v.id];
					if(p == null) {
						var ap = new hxsl_AllocParam(a1.v.name,a1.pos,-1,-1,a1.v.type);
						ap.perObjectGlobal = new hxsl_AllocGlobal(-1,this.getPath(a1.v),a1.v.type);
						out1.push(ap);
						++count;
						continue;
					}
					var ap1 = new hxsl_AllocParam(a1.v.name,a1.pos,p.instance,p.index,a1.v.type);
					var _g8 = a1.v.type;
					if(_g8._hx_index == 15) {
						var _g9 = _g8.size;
						var t = _g8.t;
						if(hxsl_Tools.isSampler(t)) {
							ap1.pos = -a1.size;
							count += a1.size;
						} else {
							++count;
						}
					} else {
						++count;
					}
					out1.push(ap1);
				}
				var _g10 = 0;
				var _g11 = out1.length - 1;
				while(_g10 < _g11) {
					var i1 = _g10++;
					out1[i1].next = out1[i1 + 1];
				}
				var _g12 = g1.type;
				if(_g12._hx_index == 15) {
					var _g13 = _g12.t;
					var _g14 = _g12.size;
					var t1 = _g13;
					if(hxsl_Tools.isSampler(t1)) {
						textures.push({ t : t1, all : out1});
						c.texturesCount += count;
					} else {
						switch(_g13._hx_index) {
						case 5:
							if(_g13.size == 4) {
								if(_g13.t._hx_index == 1) {
									if(_g14._hx_index == 0) {
										var size1 = _g14.v;
										c.params = out1[0];
										c.paramsSize = size1;
									} else {
										throw haxe_Exception.thrown("assert");
									}
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
							break;
						case 16:
							var _g15 = _g13.t;
							var _g16 = _g13.size;
							var _g17 = _g13.kind;
							if(c.buffers == null) {
								c.buffers = out1[0];
								c.bufferCount = out1.length;
							} else {
								var p1 = c.buffers;
								while(p1.next != null) p1 = p1.next;
								p1.next = out1[0];
								c.bufferCount += out1.length;
							}
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		if(textures.length > 0) {
			textures.sort(function(t1,t2) {
				return t1.t._hx_index - t2.t._hx_index;
			});
			c.textures = textures[0].all[0];
			var _g = 1;
			var _g1 = textures.length;
			while(_g < _g1) {
				var i = _g++;
				var prevAll = textures[i - 1].all;
				var prev = prevAll[prevAll.length - 1];
				prev.next = textures[i].all[0];
			}
		}
		if(c.globals == null) {
			c.globalsSize = 0;
		}
		if(c.params == null) {
			c.paramsSize = 0;
		}
		if(c.buffers == null) {
			c.bufferCount = 0;
		}
		c.data = data;
		return c;
	}
	,makeBatchShader: function(rt,shaders,params) {
		var batchMap;
		if(params == null) {
			batchMap = this.batchShaders;
		} else {
			var this1 = this.batchShadersParams;
			var key = params.getSignature();
			batchMap = this1.h[key];
			if(batchMap == null) {
				batchMap = new haxe_ds_ObjectMap();
				var this1 = this.batchShadersParams;
				var key = params.getSignature();
				this1.h[key] = batchMap;
			}
		}
		var sh = batchMap.h[rt.__id__];
		if(sh == null) {
			sh = this.createBatchShader(rt,shaders,params);
			batchMap.set(rt,sh);
		}
		var shader = Object.create(hxsl_BatchShader.prototype);
		shader.shader = sh.shader;
		shader.params = sh.params;
		shader.paramsSize = sh.size;
		return shader;
	}
	,isPerInstance: function(v) {
		if(v.qualifiers == null) {
			return false;
		}
		var _g = 0;
		var _g1 = v.qualifiers;
		while(_g < _g1.length) {
			var q = _g1[_g];
			++_g;
			var tmp;
			switch(q._hx_index) {
			case 3:
				tmp = true;
				break;
			case 9:
				var _g2 = q.v;
				tmp = true;
				break;
			default:
				tmp = false;
			}
			if(tmp) {
				return true;
			}
		}
		return false;
	}
	,createBatchShader: function(rt,shaders,params) {
		var _gthis = this;
		var s = new hxsl_SharedShader("");
		var id = HxOverrides.substr(params == null ? rt.spec.signature : haxe_crypto_Md5.encode(rt.spec.signature + params.getSignature()),0,8);
		var declVar = function(name,t,kind) {
			return { id : hxsl_Tools.allocVarId(), type : t, name : name, kind : kind};
		};
		var instancedParams = [];
		if(params != null) {
			var forcedPerInstance = params.forcedPerInstance;
			var instanceIndex = 1;
			var forcedIndex = forcedPerInstance.length - 1;
			var s1 = shaders;
			while(s1 != null && forcedIndex >= 0) {
				if(s1.s.shader.data.name == forcedPerInstance[forcedIndex].shader) {
					instancedParams[instanceIndex] = forcedPerInstance[forcedIndex].params;
					--forcedIndex;
				}
				++instanceIndex;
				s1 = s1.next;
			}
		}
		var pos = null;
		var hasOffset = declVar("Batch_HasOffset",hxsl_Type.TBool,hxsl_VarKind.Param);
		var inputOffset = declVar("Batch_Start",hxsl_Type.TFloat,hxsl_VarKind.Input);
		hasOffset.qualifiers = [hxsl_VarQualifier.Const()];
		inputOffset.qualifiers = [hxsl_VarQualifier.PerInstance(1)];
		var vcount = declVar("Batch_Count",hxsl_Type.TInt,hxsl_VarKind.Param);
		var vbuffer = declVar("Batch_Buffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SVar(vcount),hxsl_BufferKind.Uniform),hxsl_VarKind.Param);
		var voffset = declVar("Batch_Offset",hxsl_Type.TInt,hxsl_VarKind.Local);
		var ebuffer = { e : hxsl_TExprDef.TVar(vbuffer), p : pos, t : vbuffer.type};
		var eoffset = { e : hxsl_TExprDef.TVar(voffset), p : pos, t : voffset.type};
		var tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		var countBits = 16;
		vcount.qualifiers = [hxsl_VarQualifier.Const(1 << countBits)];
		s.data = { name : "batchShader_" + id, vars : [vcount,hasOffset,vbuffer,voffset,inputOffset], funs : []};
		var getVarRec = null;
		getVarRec = function(v,name,kind) {
			if(v.kind == kind && v.name == name) {
				return v;
			}
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					var v1 = getVarRec(v,name,kind);
					if(v1 != null) {
						return v1;
					}
				}
			}
			return null;
		};
		var getVar = function(p) {
			var s = shaders;
			if(p.perObjectGlobal != null) {
				var path = p.perObjectGlobal.path.split(".");
				while(s != null) {
					var _g = 0;
					var _g1 = s.s.shader.data.vars;
					while(_g < _g1.length) {
						var v = _g1[_g];
						++_g;
						if(v.name != path[0]) {
							continue;
						}
						var v1 = getVarRec(v,p.name,hxsl_VarKind.Global);
						if(v1 != null) {
							return v1;
						}
					}
					s = s.next;
				}
			} else {
				var i = p.instance - 1;
				while(i > 0) {
					--i;
					s = s.next;
				}
				var name = p.name;
				while(true) {
					var _g = 0;
					var _g1 = s.s.shader.data.vars;
					while(_g < _g1.length) {
						var v = _g1[_g];
						++_g;
						var v1 = getVarRec(v,name,hxsl_VarKind.Param);
						if(v1 != null) {
							return v1;
						}
					}
					var cc = HxOverrides.cca(name,name.length - 1);
					if(cc >= 48 && cc <= 57) {
						name = HxOverrides.substr(name,0,-1);
					} else {
						break;
					}
				}
			}
			throw haxe_Exception.thrown("Var not found " + p.name);
		};
		var params = null;
		var used = [];
		var addParam = function(p) {
			var size;
			var _g = p.type;
			switch(_g._hx_index) {
			case 3:
				size = 1;
				break;
			case 5:
				if(_g.t._hx_index == 1) {
					var n = _g.size;
					size = n;
				} else {
					throw haxe_Exception.thrown("Unsupported batch var type " + Std.string(p.type));
				}
				break;
			case 7:
				size = 16;
				break;
			default:
				throw haxe_Exception.thrown("Unsupported batch var type " + Std.string(p.type));
			}
			var index;
			if(size >= 4) {
				index = used.length << 2;
				var _g = 0;
				var _g1 = size >> 2;
				while(_g < _g1) {
					var i = _g++;
					used.push(15);
				}
			} else if(size == 1) {
				var best = -1;
				var _g = 0;
				var _g1 = used.length;
				while(_g < _g1) {
					var i = _g++;
					if(used[i] != 15 && (best < 0 || used[best] < used[i])) {
						best = i;
					}
				}
				if(best < 0) {
					best = used.length;
					used.push(0);
				}
				index = best << 2;
				var _g = 0;
				while(_g < 4) {
					var k = _g++;
					var bit = 3 - k;
					if((used[best] & 1 << bit) == 0) {
						used[best] |= 1 << bit;
						index += bit;
						break;
					}
				}
			} else {
				var k = size == 2 ? 3 : 7;
				var best = -1;
				var _g = 0;
				var _g1 = used.length;
				while(_g < _g1) {
					var i = _g++;
					if((used[i] & k) == 0) {
						used[i] |= k;
						best = i;
						break;
					}
				}
				if(best < 0) {
					best = used.length;
					used.push(k);
				}
				index = best << 2;
			}
			var p2 = new hxsl_AllocParam(p.name,index,p.instance,p.index,p.type);
			p2.perObjectGlobal = p.perObjectGlobal;
			p2.next = params;
			params = p2;
		};
		var p = rt.vertex.params;
		while(p != null) {
			var v = getVar(p);
			var params1 = instancedParams[p.instance];
			if(params1 != null && params1.indexOf(v.name) >= 0 ? true : _gthis.isPerInstance(v)) {
				addParam(p);
			}
			p = p.next;
		}
		var p = rt.fragment.params;
		while(p != null) {
			var v = getVar(p);
			var params1 = instancedParams[p.instance];
			if(params1 != null && params1.indexOf(v.name) >= 0 ? true : _gthis.isPerInstance(v)) {
				addParam(p);
			}
			p = p.next;
		}
		var parentVars = new haxe_ds_ObjectMap();
		var swiz = [[hxsl_Component.X],[hxsl_Component.Y],[hxsl_Component.Z],[hxsl_Component.W]];
		var readOffset = function(index) {
			return { e : hxsl_TExprDef.TArray(ebuffer,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,eoffset,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos}), t : tvec4, p : pos};
		};
		var extractVar = function(v) {
			var vreal = declVar(v.name,v.type,hxsl_VarKind.Local);
			if(v.perObjectGlobal != null) {
				var path = v.perObjectGlobal.path.split(".");
				path.pop();
				var cur = vreal;
				while(path.length > 0) {
					var key = path.join(".");
					var name = path.pop();
					var vp = parentVars.h[path.__id__];
					if(vp == null) {
						vp = declVar(name,hxsl_Type.TStruct([]),hxsl_VarKind.Local);
						parentVars.set(path,vp);
					}
					var _g = vp.type;
					if(_g._hx_index == 13) {
						var vl = _g.vl;
						vl.push(cur);
					}
					cur.parent = vp;
					cur = vp;
				}
			}
			s.data.vars.push(vreal);
			var index = v.pos >> 2;
			var extract;
			var _g = v.type;
			switch(_g._hx_index) {
			case 3:
				extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(index),swiz[v.pos & 3])};
				break;
			case 5:
				var _g1 = _g.t;
				switch(_g.size) {
				case 2:
					if(_g1._hx_index == 1) {
						var swiz1;
						switch(v.pos & 3) {
						case 0:
							swiz1 = [hxsl_Component.X,hxsl_Component.Y];
							break;
						case 1:
							swiz1 = [hxsl_Component.Y,hxsl_Component.Z];
							break;
						default:
							swiz1 = [hxsl_Component.Z,hxsl_Component.W];
						}
						extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(index),swiz1)};
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				case 3:
					if(_g1._hx_index == 1) {
						extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(index),(v.pos & 3) == 0 ? [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z] : [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W])};
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				case 4:
					if(_g1._hx_index == 1) {
						extract = readOffset(index);
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 7:
				extract = { p : pos, t : v.type, e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), t : hxsl_Type.TVoid, p : pos},[readOffset(index),readOffset(index + 1),readOffset(index + 2),readOffset(index + 3)])};
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			return { p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(vreal), p : pos, t : v.type},extract), t : hxsl_Type.TVoid};
		};
		var exprs = [];
		var stride = used.length;
		var p = params;
		while(p != null) {
			exprs.push(extractVar(p));
			p = p.next;
		}
		var inits = [];
		inits.push({ p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,eoffset,{ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.InstanceID), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVoid});
		inits.push({ p : pos, e : hxsl_TExprDef.TIf({ e : hxsl_TExprDef.TVar(hasOffset), t : hxsl_Type.TBool, p : pos},{ p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd),eoffset,{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TVoid, p : pos},[{ p : pos, t : hxsl_Type.TFloat, e : hxsl_TExprDef.TVar(inputOffset)}]), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVoid},null), t : hxsl_Type.TVoid});
		inits.push({ p : pos, t : hxsl_Type.TInt, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult),eoffset,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), t : hxsl_Type.TInt, p : pos})});
		var fv = declVar("init",hxsl_Type.TFun([]),hxsl_VarKind.Function);
		var f = { kind : hxsl_FunctionKind.Init, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(inits.concat(exprs)), p : pos, t : hxsl_Type.TVoid}};
		s.data.funs.push(f);
		s.consts = new hxsl_ShaderConst(vcount,1,countBits + 1);
		s.consts.globalId = 0;
		s.consts.next = new hxsl_ShaderConst(hasOffset,0,1);
		s.consts.next.globalId = 0;
		return { shader : s, params : params, size : stride};
	}
	,__class__: hxsl_Cache
};
var hxsl_Channel = $hxEnums["hxsl.Channel"] = { __ename__:"hxsl.Channel",__constructs__:null
	,Unknown: {_hx_name:"Unknown",_hx_index:0,__enum__:"hxsl.Channel",toString:$estr}
	,R: {_hx_name:"R",_hx_index:1,__enum__:"hxsl.Channel",toString:$estr}
	,G: {_hx_name:"G",_hx_index:2,__enum__:"hxsl.Channel",toString:$estr}
	,B: {_hx_name:"B",_hx_index:3,__enum__:"hxsl.Channel",toString:$estr}
	,A: {_hx_name:"A",_hx_index:4,__enum__:"hxsl.Channel",toString:$estr}
	,PackedFloat: {_hx_name:"PackedFloat",_hx_index:5,__enum__:"hxsl.Channel",toString:$estr}
	,PackedNormal: {_hx_name:"PackedNormal",_hx_index:6,__enum__:"hxsl.Channel",toString:$estr}
};
hxsl_Channel.__constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
hxsl_Channel.__empty_constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
var hxsl_Clone = function() {
	this.varMap = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Clone"] = hxsl_Clone;
hxsl_Clone.__name__ = "hxsl.Clone";
hxsl_Clone.shaderData = function(s) {
	return new hxsl_Clone().shader(s);
};
hxsl_Clone.prototype = {
	tvar: function(v) {
		var v2 = this.varMap.h[v.id];
		if(v2 != null) {
			return v2;
		}
		v2 = { id : hxsl_Tools.allocVarId(), type : v.type, name : v.name, kind : v.kind};
		this.varMap.h[v.id] = v2;
		if(v.parent != null) {
			v2.parent = this.tvar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		v2.type = this.ttype(v.type);
		return v2;
	}
	,tfun: function(f) {
		var tmp = this.ttype(f.ret);
		var f1 = f.kind;
		var tmp1 = this.tvar(f.ref);
		var _g = [];
		var _g1 = 0;
		var _g2 = f.args;
		while(_g1 < _g2.length) {
			var a = _g2[_g1];
			++_g1;
			_g.push(this.tvar(a));
		}
		return { ret : tmp, kind : f1, ref : tmp1, args : _g, expr : this.texpr(f.expr)};
	}
	,ttype: function(t) {
		switch(t._hx_index) {
		case 13:
			var vl = t.vl;
			var _g = [];
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				_g.push(this.tvar(v));
			}
			return hxsl_Type.TStruct(_g);
		case 14:
			var vars = t.variants;
			return hxsl_Type.TFun(vars);
		case 15:
			var t1 = t.t;
			var size = t.size;
			var tmp = this.ttype(t1);
			var tmp1;
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				tmp1 = size;
				break;
			case 1:
				var v = size.v;
				tmp1 = hxsl_SizeDecl.SVar(this.tvar(v));
				break;
			}
			return hxsl_Type.TArray(tmp,tmp1);
		default:
			return t;
		}
	}
	,texpr: function(e) {
		var e2 = hxsl_Tools.map(e,$bind(this,this.texpr));
		e2.t = this.ttype(e.t);
		var _g = e2.e;
		var tmp;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			tmp = hxsl_TExprDef.TVar(this.tvar(v));
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			tmp = hxsl_TExprDef.TVarDecl(this.tvar(v),init);
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			tmp = hxsl_TExprDef.TFor(this.tvar(v),it,loop);
			break;
		default:
			tmp = e2.e;
		}
		e2.e = tmp;
		return e2;
	}
	,shader: function(s) {
		var s1 = s.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.vars;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			_g.push(this.tvar(v));
		}
		var tmp = _g;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.funs;
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			_g.push(this.tfun(f));
		}
		return { name : s1, vars : tmp, funs : _g};
	}
	,__class__: hxsl_Clone
};
var hxsl__$Dce_Exit = function() {
};
$hxClasses["hxsl._Dce.Exit"] = hxsl__$Dce_Exit;
hxsl__$Dce_Exit.__name__ = "hxsl._Dce.Exit";
hxsl__$Dce_Exit.prototype = {
	__class__: hxsl__$Dce_Exit
};
var hxsl__$Dce_VarDeps = function(v) {
	this.v = v;
	this.used = false;
	this.deps = new haxe_ds_IntMap();
};
$hxClasses["hxsl._Dce.VarDeps"] = hxsl__$Dce_VarDeps;
hxsl__$Dce_VarDeps.__name__ = "hxsl._Dce.VarDeps";
hxsl__$Dce_VarDeps.prototype = {
	__class__: hxsl__$Dce_VarDeps
};
var hxsl_Dce = function() {
};
$hxClasses["hxsl.Dce"] = hxsl_Dce;
hxsl_Dce.__name__ = "hxsl.Dce";
hxsl_Dce.prototype = {
	debug: function(msg,pos) {
	}
	,dce: function(shaders) {
		this.used = new haxe_ds_IntMap();
		this.channelVars = [];
		var inputs = [];
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.vars;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				var i = this.get(v);
				if(v.kind == hxsl_VarKind.Input) {
					inputs.push(i);
				}
				var tmp;
				if(v.kind != hxsl_VarKind.Output) {
					var _g3 = v.type;
					if(_g3._hx_index == 16) {
						var _g4 = _g3.t;
						var _g5 = _g3.size;
						tmp = _g3.kind._hx_index == 1;
					} else {
						tmp = false;
					}
				} else {
					tmp = true;
				}
				if(tmp) {
					i.keep = true;
				}
			}
		}
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				this.check(f.expr,[],[]);
			}
		}
		var outExprs = [];
		do {
			var v = this.used.iterator();
			while(v.hasNext()) {
				var v1 = v.next();
				if(v1.keep) {
					this.markRec(v1);
				}
			}
			while(inputs.length > 1 && !inputs[inputs.length - 1].used) inputs.pop();
			var _g = 0;
			while(_g < inputs.length) {
				var v2 = inputs[_g];
				++_g;
				this.markRec(v2);
			}
			outExprs = [];
			var _g1 = 0;
			while(_g1 < shaders.length) {
				var s = shaders[_g1];
				++_g1;
				var _g2 = 0;
				var _g3 = s.funs;
				while(_g2 < _g3.length) {
					var f = _g3[_g2];
					++_g2;
					outExprs.push(this.mapExpr(f.expr,false));
				}
			}
			this.markAsKeep = false;
			var _g4 = 0;
			while(_g4 < outExprs.length) {
				var e = outExprs[_g4];
				++_g4;
				this.checkBranches(e);
			}
		} while(this.markAsKeep);
		var _g = 0;
		while(_g < shaders.length) {
			var s = shaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				f.expr = outExprs.shift();
			}
		}
		var v = this.used.iterator();
		while(v.hasNext()) {
			var v1 = v.next();
			if(v1.used) {
				continue;
			}
			if(v1.v.kind == hxsl_VarKind.Input) {
				continue;
			}
			var _g = 0;
			while(_g < shaders.length) {
				var s = shaders[_g];
				++_g;
				HxOverrides.remove(s.vars,v1.v);
			}
		}
		return shaders.slice();
	}
	,get: function(v) {
		var vd = this.used.h[v.id];
		if(vd == null) {
			vd = new hxsl__$Dce_VarDeps(v);
			this.used.h[v.id] = vd;
		}
		return vd;
	}
	,markRec: function(v) {
		if(v.used) {
			return;
		}
		v.used = true;
		var d = v.deps.iterator();
		while(d.hasNext()) {
			var d1 = d.next();
			this.markRec(d1);
		}
	}
	,link: function(v,writeTo) {
		var vd = this.get(v);
		var _g = 0;
		while(_g < writeTo.length) {
			var w = writeTo[_g];
			++_g;
			if(w == null) {
				if(!vd.keep) {
					vd.keep = true;
					this.markAsKeep = true;
				}
				continue;
			}
			w.deps.h[v.id] = vd;
		}
	}
	,check: function(e,writeTo,isAffected) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			this.link(v,writeTo);
			break;
		case 4:
			var el = _g.el;
			var noWrite = [];
			var _g1 = 0;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				this.check(el[i],i < el.length - 1 ? noWrite : writeTo,isAffected);
			}
			break;
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g4 = _g2.e;
				var _g5 = _g2.p;
				var _g5 = _g2.t;
				switch(_g4._hx_index) {
				case 1:
					var v = _g4.v;
					var e1 = _g3;
					var v1 = this.get(v);
					writeTo.push(v1);
					this.check(e1,writeTo,isAffected);
					writeTo.pop();
					if(isAffected.indexOf(v1) < 0) {
						isAffected.push(v1);
					}
					break;
				case 9:
					var _g5 = _g4.e;
					var _g6 = _g4.regs;
					var _g6 = _g5.e;
					var _g7 = _g5.p;
					var _g7 = _g5.t;
					if(_g6._hx_index == 1) {
						var v = _g6.v;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v1) < 0) {
							isAffected.push(v1);
						}
					} else {
						var _g5 = this;
						var writeTo1 = writeTo;
						var isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g5.check(e,writeTo1,isAffected1);
						});
					}
					break;
				case 16:
					var _g6 = _g4.e;
					var _g7 = _g6.e;
					var _g8 = _g6.p;
					var _g8 = _g6.t;
					if(_g7._hx_index == 1) {
						var v = _g7.v;
						var i = _g4.index;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1);
						this.check(i,writeTo,isAffected);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v1) < 0) {
							isAffected.push(v1);
						}
					} else {
						var _g4 = this;
						var writeTo2 = writeTo;
						var isAffected2 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g4.check(e,writeTo2,isAffected2);
						});
					}
					break;
				default:
					var _g6 = this;
					var writeTo3 = writeTo;
					var isAffected3 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g6.check(e,writeTo3,isAffected3);
					});
				}
				break;
			case 20:
				var _g7 = _g1.op;
				var _g1 = _g2.e;
				var _g7 = _g2.p;
				var _g7 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					var e1 = _g3;
					var v1 = this.get(v);
					writeTo.push(v1);
					this.check(e1,writeTo,isAffected);
					writeTo.pop();
					if(isAffected.indexOf(v1) < 0) {
						isAffected.push(v1);
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g7 = _g1.regs;
					var _g7 = _g2.e;
					var _g8 = _g2.p;
					var _g8 = _g2.t;
					if(_g7._hx_index == 1) {
						var v = _g7.v;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v1) < 0) {
							isAffected.push(v1);
						}
					} else {
						var _g2 = this;
						var writeTo4 = writeTo;
						var isAffected4 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g2.check(e,writeTo4,isAffected4);
						});
					}
					break;
				case 16:
					var _g7 = _g1.e;
					var _g8 = _g7.e;
					var _g9 = _g7.p;
					var _g9 = _g7.t;
					if(_g8._hx_index == 1) {
						var v = _g8.v;
						var i = _g1.index;
						var e1 = _g3;
						var v1 = this.get(v);
						writeTo.push(v1);
						this.check(i,writeTo,isAffected);
						this.check(e1,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v1) < 0) {
							isAffected.push(v1);
						}
					} else {
						var _g1 = this;
						var writeTo5 = writeTo;
						var isAffected5 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g1.check(e,writeTo5,isAffected5);
						});
					}
					break;
				default:
					var _g3 = this;
					var writeTo6 = writeTo;
					var isAffected6 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g3.check(e,writeTo6,isAffected6);
					});
				}
				break;
			default:
				var _g7 = this;
				var writeTo7 = writeTo;
				var isAffected7 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g7.check(e,writeTo7,isAffected7);
				});
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			if(init != null) {
				writeTo.push(this.get(v));
				this.check(init,writeTo,isAffected);
				writeTo.pop();
			} else {
				var _g8 = this;
				var writeTo8 = writeTo;
				var isAffected8 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g8.check(e,writeTo8,isAffected8);
				});
			}
			break;
		case 8:
			var _g9 = _g.e;
			var _g10 = _g.args;
			var _g11 = _g9.e;
			var _g12 = _g9.p;
			var _g12 = _g9.t;
			if(_g11._hx_index == 2) {
				switch(_g11.g._hx_index) {
				case 63:
					if(_g10.length == 3) {
						var _g9 = _g10[0];
						var _g11 = _g10[2];
						var _g12 = _g9.e;
						var _g13 = _g9.p;
						var _g13 = _g9.t;
						if(_g12._hx_index == 1) {
							var _g9 = _g11.e;
							var _g13 = _g11.p;
							var _g13 = _g11.t;
							if(_g9._hx_index == 0) {
								var _g11 = _g9.c;
								if(_g11._hx_index == 2) {
									var cid = _g11.v;
									var uv = _g10[1];
									var c = _g12.v;
									this.check(uv,writeTo,isAffected);
									if(this.channelVars[cid] == null) {
										this.channelVars[cid] = c;
										this.link(c,writeTo);
									} else {
										this.link(this.channelVars[cid],writeTo);
									}
								} else {
									var _g9 = this;
									var writeTo9 = writeTo;
									var isAffected9 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g9.check(e,writeTo9,isAffected9);
									});
								}
							} else {
								var _g11 = this;
								var writeTo10 = writeTo;
								var isAffected10 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g11.check(e,writeTo10,isAffected10);
								});
							}
						} else {
							var _g12 = this;
							var writeTo11 = writeTo;
							var isAffected11 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g12.check(e,writeTo11,isAffected11);
							});
						}
					} else {
						var _g13 = this;
						var writeTo12 = writeTo;
						var isAffected12 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g13.check(e,writeTo12,isAffected12);
						});
					}
					break;
				case 64:
					if(_g10.length == 4) {
						var _g14 = _g10[0];
						var _g15 = _g10[3];
						var _g16 = _g14.e;
						var _g17 = _g14.p;
						var _g17 = _g14.t;
						if(_g16._hx_index == 1) {
							var _g14 = _g15.e;
							var _g17 = _g15.p;
							var _g17 = _g15.t;
							if(_g14._hx_index == 0) {
								var _g15 = _g14.c;
								if(_g15._hx_index == 2) {
									var cid = _g15.v;
									var lod = _g10[2];
									var uv = _g10[1];
									var c = _g16.v;
									this.check(uv,writeTo,isAffected);
									this.check(lod,writeTo,isAffected);
									if(this.channelVars[cid] == null) {
										this.channelVars[cid] = c;
										this.link(c,writeTo);
									} else {
										this.link(this.channelVars[cid],writeTo);
									}
								} else {
									var _g10 = this;
									var writeTo13 = writeTo;
									var isAffected13 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g10.check(e,writeTo13,isAffected13);
									});
								}
							} else {
								var _g14 = this;
								var writeTo14 = writeTo;
								var isAffected14 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g14.check(e,writeTo14,isAffected14);
								});
							}
						} else {
							var _g15 = this;
							var writeTo15 = writeTo;
							var isAffected15 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g15.check(e,writeTo15,isAffected15);
							});
						}
					} else {
						var _g16 = this;
						var writeTo16 = writeTo;
						var isAffected16 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g16.check(e,writeTo16,isAffected16);
						});
					}
					break;
				default:
					var _g17 = this;
					var writeTo17 = writeTo;
					var isAffected17 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g17.check(e,writeTo17,isAffected17);
					});
				}
			} else {
				var _g18 = this;
				var writeTo18 = writeTo;
				var isAffected18 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g18.check(e,writeTo18,isAffected18);
				});
			}
			break;
		case 10:
			var e1 = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			var affect = [];
			this.check(eif,writeTo,affect);
			if(eelse != null) {
				this.check(eelse,writeTo,affect);
			}
			var len = affect.length;
			var _g19 = 0;
			while(_g19 < writeTo.length) {
				var v = writeTo[_g19];
				++_g19;
				if(affect.indexOf(v) < 0) {
					affect.push(v);
				}
			}
			this.check(e1,affect,isAffected);
			var _g19 = 0;
			var _g20 = len;
			while(_g19 < _g20) {
				var i = _g19++;
				var v = affect[i];
				if(isAffected.indexOf(v) < 0) {
					isAffected.push(v);
				}
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var affect = [];
			this.check(loop,writeTo,affect);
			this.check(it,affect,isAffected);
			var _g = 0;
			while(_g < affect.length) {
				var v = affect[_g];
				++_g;
				if(isAffected.indexOf(v) < 0) {
					isAffected.push(v);
				}
			}
			break;
		default:
			var _g = this;
			var writeTo19 = writeTo;
			var isAffected19 = isAffected;
			hxsl_Tools.iter(e,function(e) {
				_g.check(e,writeTo19,isAffected19);
			});
		}
	}
	,checkBranches: function(e) {
		var _g = e.e;
		if(_g._hx_index == 10) {
			var _g1 = _g.eif;
			var _g1 = _g.eelse;
			var cond = _g.econd;
			var writeTo = [null];
			this.check(cond,writeTo,[]);
		}
		hxsl_Tools.iter(e,$bind(this,this.checkBranches));
	}
	,mapExpr: function(e,isVar) {
		var _gthis = this;
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var out = [];
			var count = 0;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				var isVar1 = isVar && count == el.length - 1;
				var e2 = this.mapExpr(e1,isVar1);
				if(hxsl_Tools.hasSideEffect(e2) || isVar1) {
					out.push(e2);
				}
				++count;
			}
			return { e : hxsl_TExprDef.TBlock(out), p : e.p, t : e.t};
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g3 = _g2.e;
				var _g4 = _g2.p;
				var _g4 = _g2.t;
				switch(_g3._hx_index) {
				case 1:
					var v = _g3.v;
					if(!this.get(v).used) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					var _g4 = _g3.e;
					var _g5 = _g3.regs;
					var _g5 = _g4.e;
					var _g6 = _g4.p;
					var _g6 = _g4.t;
					if(_g5._hx_index == 1) {
						var v = _g5.v;
						if(!this.get(v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 16:
					var _g4 = _g3.e;
					var _g5 = _g3.index;
					var _g3 = _g4.e;
					var _g5 = _g4.p;
					var _g5 = _g4.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(!this.get(v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			case 20:
				var _g3 = _g1.op;
				var _g1 = _g2.e;
				var _g3 = _g2.p;
				var _g3 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					if(!this.get(v).used) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g3 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(!this.get(v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 16:
					var _g2 = _g1.e;
					var _g3 = _g1.index;
					var _g1 = _g2.e;
					var _g3 = _g2.p;
					var _g3 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						if(!this.get(v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			default:
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			if(!this.get(v).used) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				switch(_g3.g._hx_index) {
				case 63:
					if(_g2.length == 3) {
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var uv = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(uv,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 64:
					if(_g2.length == 4) {
						var _g1 = _g2[0];
						var _g1 = _g2[3];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[2];
								var uv = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(uv,true),this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 65:
					switch(_g2.length) {
					case 3:
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var pos = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(pos,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 4:
						var _g1 = _g2[0];
						var _g1 = _g2[3];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[2];
								var pos = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(pos,true),this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 66:
					switch(_g2.length) {
					case 2:
						var _g1 = _g2[0];
						var _g1 = _g2[1];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p}]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 3:
						var _g1 = _g2[0];
						var _g1 = _g2[2];
						var _g3 = _g1.e;
						var _g4 = _g1.p;
						var _g4 = _g1.t;
						if(_g3._hx_index == 0) {
							var _g1 = _g3.c;
							if(_g1._hx_index == 2) {
								var cid = _g1.v;
								var lod = _g2[1];
								var c = this.channelVars[cid];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(lod,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 10:
			var e1 = _g.econd;
			var econd = _g.eif;
			var eelse = _g.eelse;
			var e2 = this.mapExpr(e1,true);
			var econd1 = this.mapExpr(econd,isVar);
			var eelse1 = eelse == null ? null : this.mapExpr(eelse,isVar);
			if(!isVar && !hxsl_Tools.hasSideEffect(econd1) && (eelse1 == null || !hxsl_Tools.hasSideEffect(eelse1))) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e2.t, p : e2.p};
			}
			return { e : hxsl_TExprDef.TIf(e2,econd1,eelse1), p : e2.p, t : e2.t};
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var it1 = this.mapExpr(it,true);
			var loop1 = this.mapExpr(loop,false);
			if(!hxsl_Tools.hasSideEffect(loop1)) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			}
			return { e : hxsl_TExprDef.TFor(v,it1,loop1), p : e.p, t : e.t};
		default:
			return hxsl_Tools.map(e,function(e) {
				return _gthis.mapExpr(e,true);
			});
		}
	}
	,__class__: hxsl_Dce
};
var hxsl_Eval = function() {
	this.varMap = new haxe_ds_ObjectMap();
	this.funMap = new haxe_ds_ObjectMap();
	this.constants = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Eval"] = hxsl_Eval;
hxsl_Eval.__name__ = "hxsl.Eval";
hxsl_Eval.prototype = {
	setConstant: function(v,c) {
		this.constants.h[v.id] = hxsl_TExprDef.TConst(c);
	}
	,mapVar: function(v) {
		var v2 = this.varMap.h[v.__id__];
		if(v2 != null) {
			if(v == v2) {
				return v2;
			} else {
				return this.mapVar(v2);
			}
		}
		if(v.parent != null) {
			this.mapVar(v.parent);
			v2 = this.varMap.h[v.__id__];
			if(v2 != null) {
				if(v == v2) {
					return v2;
				} else {
					return this.mapVar(v2);
				}
			}
		}
		var _g = v.type;
		var v21;
		if(_g._hx_index == 17) {
			var _g1 = _g.size;
			v21 = true;
		} else {
			v21 = false;
		}
		v2 = { id : v21 ? v.id : hxsl_Tools.allocVarId(), name : v.name, type : v.type, kind : v.kind};
		if(v.parent != null) {
			v2.parent = this.mapVar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		this.varMap.set(v,v2);
		this.varMap.set(v2,v2);
		var _g = v2.type;
		switch(_g._hx_index) {
		case 13:
			var vl = _g.vl;
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < vl.length) {
				var v = vl[_g2];
				++_g2;
				_g1.push(this.mapVar(v));
			}
			v2.type = hxsl_Type.TStruct(_g1);
			break;
		case 15:
			var _g1 = _g.size;
			if(_g1._hx_index == 1) {
				var vs = _g1.v;
				var t = _g.t;
				var c = this.constants.h[vs.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					} else if(c._hx_index == 0) {
						var _g1 = c.c;
						if(_g1._hx_index == 2) {
							var v = _g1.v;
							var _g1 = v2.type;
							var tmp;
							switch(_g1._hx_index) {
							case 15:
								var _g2 = _g1.t;
								var _g2 = _g1.size;
								tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v));
								break;
							case 16:
								var _g2 = _g1.t;
								var _g2 = _g1.size;
								var kind = _g1.kind;
								tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v),kind);
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							v2.type = tmp;
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					}
				} else {
					var vs2 = this.mapVar(vs);
					var _g1 = v2.type;
					var tmp;
					switch(_g1._hx_index) {
					case 15:
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2));
						break;
					case 16:
						var _g2 = _g1.t;
						var _g2 = _g1.size;
						var kind = _g1.kind;
						tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2),kind);
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
					v2.type = tmp;
				}
			}
			break;
		case 16:
			var _g1 = _g.size;
			var _g2 = _g.kind;
			if(_g1._hx_index == 1) {
				var vs = _g1.v;
				var t = _g.t;
				var c = this.constants.h[vs.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					} else if(c._hx_index == 0) {
						var _g = c.c;
						if(_g._hx_index == 2) {
							var v = _g.v;
							var _g = v2.type;
							var tmp;
							switch(_g._hx_index) {
							case 15:
								var _g1 = _g.t;
								var _g1 = _g.size;
								tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v));
								break;
							case 16:
								var _g1 = _g.t;
								var _g1 = _g.size;
								var kind = _g.kind;
								tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v),kind);
								break;
							default:
								throw haxe_Exception.thrown("assert");
							}
							v2.type = tmp;
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + vs.name,null);
					}
				} else {
					var vs2 = this.mapVar(vs);
					var _g = v2.type;
					var tmp;
					switch(_g._hx_index) {
					case 15:
						var _g1 = _g.t;
						var _g1 = _g.size;
						tmp = hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2));
						break;
					case 16:
						var _g1 = _g.t;
						var _g1 = _g.size;
						var kind = _g.kind;
						tmp = hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2),kind);
						break;
					default:
						throw haxe_Exception.thrown("assert");
					}
					v2.type = tmp;
				}
			}
			break;
		default:
		}
		return v2;
	}
	,checkSamplerRec: function(t) {
		if(hxsl_Tools.isSampler(t)) {
			return true;
		}
		switch(t._hx_index) {
		case 13:
			var vl = t.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				if(this.checkSamplerRec(v.type)) {
					return true;
				}
			}
			return false;
		case 15:
			var _g = t.size;
			var t1 = t.t;
			return this.checkSamplerRec(t1);
		case 16:
			var _g = t.t;
			var _g = t.size;
			var _g = t.kind;
			return true;
		default:
		}
		return false;
	}
	,needsInline: function(f) {
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(this.checkSamplerRec(a.type)) {
				return true;
			}
		}
		return false;
	}
	,'eval': function(s) {
		var funs = [];
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var f1 = f.kind;
			var f2 = this.mapVar(f.ref);
			var _g2 = [];
			var _g3 = 0;
			var _g4 = f.args;
			while(_g3 < _g4.length) {
				var a = _g4[_g3];
				++_g3;
				_g2.push(this.mapVar(a));
			}
			var f21 = { kind : f1, ref : f2, args : _g2, ret : f.ret, expr : f.expr};
			if(f.kind == hxsl_FunctionKind.Helper && this.inlineCalls || this.needsInline(f21)) {
				this.funMap.set(f21.ref,f);
			} else {
				funs.push(f21);
			}
		}
		var _g = 0;
		var _g1 = funs.length;
		while(_g < _g1) {
			var i = _g++;
			this.curFun = funs[i];
			this.curFun.expr = this.evalExpr(this.curFun.expr,false);
		}
		var s1 = s.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = s.vars;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			_g.push(this.mapVar(v));
		}
		return { name : s1, vars : _g, funs : funs};
	}
	,hasReturn: function(e) {
		this.markReturn = false;
		this.hasReturnLoop(e);
		return this.markReturn;
	}
	,hasReturnLoop: function(e) {
		var _g = e.e;
		if(_g._hx_index == 12) {
			var _g1 = _g.e;
			this.markReturn = true;
		} else if(!this.markReturn) {
			hxsl_Tools.iter(e,$bind(this,this.hasReturnLoop));
		}
	}
	,handleReturn: function(e,isFinal) {
		if(isFinal == null) {
			isFinal = false;
		}
		var _g = e.e;
		switch(_g._hx_index) {
		case 3:
			var v = _g.e;
			var v1 = this.handleReturn(v,isFinal);
			return { e : hxsl_TExprDef.TParenthesis(v1), t : v1.t, p : e.p};
		case 4:
			var el = _g.el;
			var i = 0;
			var last = el.length;
			var out = [];
			_hx_loop1: while(i < last) {
				var e1 = el[i++];
				if(i == last) {
					out.push(this.handleReturn(e1,isFinal));
				} else {
					var _g1 = e1.e;
					switch(_g1._hx_index) {
					case 10:
						if(_g1.eelse == null) {
							var eif = _g1.eif;
							var econd = _g1.econd;
							if(isFinal && this.hasReturn(eif)) {
								out.push(this.handleReturn({ e : hxsl_TExprDef.TIf(econd,eif,{ e : hxsl_TExprDef.TBlock(el.slice(i)), t : e1.t, p : e1.p}), t : e1.t, p : e1.p}));
								break _hx_loop1;
							} else {
								out.push(this.handleReturn(e1));
							}
						} else {
							out.push(this.handleReturn(e1));
						}
						break;
					case 12:
						var e2 = _g1.e;
						out.push(this.handleReturn(e2,isFinal));
						break _hx_loop1;
					default:
						out.push(this.handleReturn(e1));
					}
				}
			}
			var t = isFinal ? out.length == 0 ? hxsl_Type.TVoid : out[out.length - 1].t : e.t;
			return { e : hxsl_TExprDef.TBlock(out), t : t, p : e.p};
		case 10:
			var cond = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			if(eelse != null && isFinal) {
				var cond1 = this.handleReturn(cond);
				var eif1 = this.handleReturn(eif,isFinal);
				return { e : hxsl_TExprDef.TIf(cond1,eif1,this.handleReturn(eelse,isFinal)), t : eif1.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
			}
			break;
		case 12:
			var v = _g.e;
			if(!isFinal) {
				hxsl_Error.t("Cannot inline not final return",e.p);
			}
			if(v == null) {
				return { e : hxsl_TExprDef.TBlock([]), t : hxsl_Type.TVoid, p : e.p};
			}
			return this.handleReturn(v,true);
		default:
			return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
		}
	}
	,handleReturnDef: function(e) {
		return this.handleReturn(e);
	}
	,evalCall: function(g,args,oldArgs,pos) {
		switch(g._hx_index) {
		case 38:
			if(args.length == 1) {
				var _g = args[0];
				var _g1 = _g.e;
				var _g2 = _g.p;
				var _g2 = _g.t;
				if(_g1._hx_index == 0) {
					var _g = _g1.c;
					if(_g._hx_index == 2) {
						var i = _g.v;
						return hxsl_TExprDef.TConst(hxsl_Const.CFloat(i));
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
			break;
		case 63:case 64:
			var i;
			var _g = args[0].e;
			if(_g._hx_index == 0) {
				var _g1 = _g.c;
				if(_g1._hx_index == 2) {
					var i1 = _g1.v;
					i = i1;
				} else {
					hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
					throw haxe_Exception.thrown("assert");
				}
			} else {
				hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
				throw haxe_Exception.thrown("assert");
			}
			var channel = oldArgs[0];
			var _g = channel.e;
			var channel1;
			if(_g._hx_index == 1) {
				var v = _g.v;
				channel1 = hxsl_TExprDef.TVar(this.mapVar(v));
			} else {
				throw haxe_Exception.thrown("assert");
			}
			channel = { e : channel1, t : channel.t, p : channel.p};
			var count;
			var _g = channel.t;
			if(_g._hx_index == 17) {
				var i1 = _g.size;
				count = i1;
			} else {
				throw haxe_Exception.thrown("assert");
			}
			var channelMode = Type.createEnumIndex(hxsl_Channel,i & 7,null);
			var targs = [channel];
			var _g = 1;
			var _g1 = args.length;
			while(_g < _g1) {
				var i1 = _g++;
				targs.push(args[i1]);
			}
			targs.push({ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(i >> 3)), t : hxsl_Type.TInt, p : pos});
			var tget = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},targs), t : hxsl_Type.TVoid, p : pos};
			switch(channelMode._hx_index) {
			case 0:
				var zero = { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), t : hxsl_Type.TFloat, p : pos};
				if(count == 1) {
					return zero.e;
				}
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4][count - 2]), t : hxsl_Type.TVoid, p : pos},[zero]);
			case 1:case 2:case 3:case 4:
				var tmp;
				switch(count) {
				case 1:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X];
						break;
					case 2:
						tmp = [hxsl_Component.Y];
						break;
					case 3:
						tmp = [hxsl_Component.Z];
						break;
					case 4:
						tmp = [hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 2:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 3:
						tmp = [hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 3:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
				}
				return hxsl_TExprDef.TSwiz(tget,tmp);
			case 5:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), t : hxsl_Type.TVoid, p : pos},[tget]);
			case 6:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), t : hxsl_Type.TVoid, p : pos},[tget]);
			}
			break;
		case 67:
			var args1 = args;
			var _g = 0;
			while(_g < args1.length) {
				var a = args1[_g];
				++_g;
				haxe_Log.trace(hxsl_Printer.toString(a),{ fileName : a.p.file, lineNumber : 0, className : null, methodName : null});
			}
			return hxsl_TExprDef.TBlock([]);
		default:
			return null;
		}
	}
	,constantsToString: function() {
		var _g = [];
		var c = this.constants.keys();
		while(c.hasNext()) {
			var c1 = c.next();
			_g.push(c1 + " => " + hxsl_Printer.toString({ e : this.constants.h[c1], t : hxsl_Type.TVoid, p : null},true));
		}
		return _g.toString();
	}
	,ifBlock: function(e) {
		var tmp;
		if(e != null) {
			var _g = e.e;
			var tmp1;
			if(_g._hx_index == 10) {
				var _g1 = _g.econd;
				var _g1 = _g.eif;
				var _g1 = _g.eelse;
				tmp1 = true;
			} else {
				tmp1 = false;
			}
			tmp = !tmp1;
		} else {
			tmp = true;
		}
		if(tmp) {
			return e;
		}
		return { e : hxsl_TExprDef.TBlock([e]), t : e.t, p : e.p};
	}
	,evalExpr: function(e,isVal) {
		if(isVal == null) {
			isVal = true;
		}
		var _gthis = this;
		var d;
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.c;
			d = e.e;
			break;
		case 1:
			var v = _g.v;
			var c = this.constants.h[v.id];
			if(c != null) {
				d = c;
			} else {
				var v2 = this.mapVar(v);
				d = hxsl_TExprDef.TVar(v2);
			}
			break;
		case 2:
			var _g1 = _g.g;
			d = e.e;
			break;
		case 3:
			var e1 = _g.e;
			var e2 = this.evalExpr(e1,isVal);
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var _g2 = _g1.c;
				d = e2.e;
			} else {
				d = hxsl_TExprDef.TParenthesis(e2);
			}
			break;
		case 4:
			var el = _g.el;
			var out = [];
			var last = el.length - 1;
			var _g1 = 0;
			var _g2 = el.length;
			while(_g1 < _g2) {
				var i = _g1++;
				var isVal1 = isVal && i == last;
				var e1 = this.evalExpr(el[i],isVal1);
				var _g3 = e1.e;
				switch(_g3._hx_index) {
				case 0:
					var _g4 = _g3.c;
					if(isVal1) {
						out.push(e1);
					}
					break;
				case 1:
					var _g5 = _g3.v;
					if(isVal1) {
						out.push(e1);
					}
					break;
				default:
					out.push(e1);
				}
			}
			d = out.length == 1 && this.curFun.kind != hxsl_FunctionKind.Init ? out[0].e : hxsl_TExprDef.TBlock(out);
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var e11 = this.evalExpr(e1);
			var e21 = this.evalExpr(e2);
			switch(op._hx_index) {
			case 0:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a + b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a + b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 1:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a * b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a * b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 2:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a / b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a / b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 3:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a - b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a - b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 4:case 21:
				d = hxsl_TExprDef.TBinop(op,e11,e21);
				break;
			case 5:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 6:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 7:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 8:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 9:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 10:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 0:
						d = _g2._hx_index == 0 ? _g2.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(op,e11,e21);
						break;
					case 1:
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								var b = _g4.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a == b ? 0 : 1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 2:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a - b <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g4 = _g2.c;
							switch(_g4._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								var b = _g4.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 4:
						var _g1 = _g3.v;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							switch(_g3._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								var b = _g3.v;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a > b ? 1 : a == b ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 11:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a & b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 12:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a | b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 13:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a ^ b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 14:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 1) {
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							if(_g3._hx_index == 1) {
								var b = _g3.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a && b));
							} else {
								var a = _g1;
								d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
							}
						} else {
							var a = _g1;
							d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
						}
					} else if(_g2._hx_index == 0) {
						var _g1 = _g2.c;
						if(_g1._hx_index == 1) {
							var a = _g1.b;
							d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else if(_g2._hx_index == 0) {
					var _g1 = _g2.c;
					if(_g1._hx_index == 1) {
						var a = _g1.b;
						d = a == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 15:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 1) {
						var _g1 = _g3.b;
						if(_g2._hx_index == 0) {
							var _g3 = _g2.c;
							if(_g3._hx_index == 1) {
								var b = _g3.b;
								var a = _g1;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(a || b));
							} else {
								var a = _g1;
								d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
							}
						} else {
							var a = _g1;
							d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e21.e;
						}
					} else if(_g2._hx_index == 0) {
						var _g1 = _g2.c;
						if(_g1._hx_index == 1) {
							var a = _g1.b;
							d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else if(_g2._hx_index == 0) {
					var _g1 = _g2.c;
					if(_g1._hx_index == 1) {
						var a = _g1.b;
						d = a == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(a)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 16:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a << b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 17:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a >> b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 18:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					if(_g3._hx_index == 2) {
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a >>> b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
					} else {
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 19:
				var _g1 = e11.e;
				var _g2 = e21.e;
				if(_g1._hx_index == 0) {
					var _g3 = _g1.c;
					switch(_g3._hx_index) {
					case 2:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 2) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CInt(a % b | 0));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					case 3:
						if(_g2._hx_index == 0) {
							var _g1 = _g2.c;
							if(_g1._hx_index == 3) {
								var b = _g1.v;
								var a = _g3.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(a % b));
							} else {
								d = hxsl_TExprDef.TBinop(op,e11,e21);
							}
						} else {
							d = hxsl_TExprDef.TBinop(op,e11,e21);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(op,e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TBinop(op,e11,e21);
				}
				break;
			case 20:
				var _g1 = op.op;
				d = hxsl_TExprDef.TBinop(op,e11,e21);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = this.evalExpr(e1);
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var c = _g1.c;
				switch(op._hx_index) {
				case 2:
					if(c._hx_index == 1) {
						var b = c.b;
						d = hxsl_TExprDef.TConst(hxsl_Const.CBool(!b));
					} else {
						d = hxsl_TExprDef.TUnop(op,e2);
					}
					break;
				case 3:
					switch(c._hx_index) {
					case 2:
						var i = c.v;
						d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-i));
						break;
					case 3:
						var f = c.v;
						d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-f));
						break;
					default:
						d = hxsl_TExprDef.TUnop(op,e2);
					}
					break;
				default:
					d = hxsl_TExprDef.TUnop(op,e2);
				}
			} else {
				d = hxsl_TExprDef.TUnop(op,e2);
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			d = hxsl_TExprDef.TVarDecl(this.mapVar(v),init == null ? null : this.evalExpr(init));
			break;
		case 8:
			var c = _g.e;
			var eargs = _g.args;
			var c1 = this.evalExpr(c);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < eargs.length) {
				var a = eargs[_g2];
				++_g2;
				_g1.push(this.evalExpr(a));
			}
			var args = _g1;
			var _g1 = c1.e;
			switch(_g1._hx_index) {
			case 1:
				var v = _g1.v;
				if(this.funMap.h.__keys__[v.__id__] != null) {
					var f = this.funMap.h[v.__id__];
					var outExprs = [];
					var undo = [];
					var _g2 = 0;
					var _g3 = f.args.length;
					while(_g2 < _g3) {
						var i = _g2++;
						var v = [f.args[i]];
						var e1 = args[i];
						var _g4 = e1.e;
						switch(_g4._hx_index) {
						case 0:
							var _g5 = _g4.c;
							var old = [this.constants.h[v[0].id]];
							undo.push((function(old,v) {
								return function() {
									if(old[0] == null) {
										_gthis.constants.remove(v[0].id);
									} else {
										_gthis.constants.h[v[0].id] = old[0];
									}
								};
							})(old,v));
							this.constants.h[v[0].id] = e1.e;
							break;
						case 1:
							var _g6 = _g4.v;
							var _g7 = _g6.id;
							var _g8 = _g6.name;
							var _g9 = _g6.parent;
							var _g10 = _g6.qualifiers;
							var _g11 = _g6.type;
							switch(_g6.kind._hx_index) {
							case 0:case 1:case 2:
								var old1 = [this.constants.h[v[0].id]];
								undo.push((function(old,v) {
									return function() {
										if(old[0] == null) {
											_gthis.constants.remove(v[0].id);
										} else {
											_gthis.constants.h[v[0].id] = old[0];
										}
									};
								})(old1,v));
								this.constants.h[v[0].id] = e1.e;
								break;
							default:
								var old2 = [this.varMap.h[v[0].__id__]];
								if(old2[0] == null) {
									undo.push((function(v) {
										return function() {
											_gthis.varMap.remove(v[0]);
										};
									})(v));
								} else {
									this.varMap.remove(v[0]);
									undo.push((function(old,v) {
										return function() {
											_gthis.varMap.set(v[0],old[0]);
										};
									})(old2,v));
								}
								var v2 = this.mapVar(v[0]);
								outExprs.push({ e : hxsl_TExprDef.TVarDecl(v2,e1), t : hxsl_Type.TVoid, p : e1.p});
							}
							break;
						default:
							var old3 = [this.varMap.h[v[0].__id__]];
							if(old3[0] == null) {
								undo.push((function(v) {
									return function() {
										_gthis.varMap.remove(v[0]);
									};
								})(v));
							} else {
								this.varMap.remove(v[0]);
								undo.push((function(old,v) {
									return function() {
										_gthis.varMap.set(v[0],old[0]);
									};
								})(old3,v));
							}
							var v21 = this.mapVar(v[0]);
							outExprs.push({ e : hxsl_TExprDef.TVarDecl(v21,e1), t : hxsl_Type.TVoid, p : e1.p});
						}
					}
					var e1 = this.handleReturn(this.evalExpr(f.expr,false),true);
					var _g2 = 0;
					while(_g2 < undo.length) {
						var u = undo[_g2];
						++_g2;
						u();
					}
					var _g2 = e1.e;
					if(_g2._hx_index == 4) {
						var el = _g2.el;
						var _g2 = 0;
						while(_g2 < el.length) {
							var e2 = el[_g2];
							++_g2;
							outExprs.push(e2);
						}
					} else {
						outExprs.push(e1);
					}
					d = hxsl_TExprDef.TBlock(outExprs);
				} else {
					d = hxsl_TExprDef.TCall(c1,args);
				}
				break;
			case 2:
				var g = _g1.g;
				var v1 = this.evalCall(g,args,eargs,e.p);
				d = v1 != null ? v1 : hxsl_TExprDef.TCall(c1,args);
				break;
			default:
				d = hxsl_Error.t("Cannot eval non-static call expresssion '" + new hxsl_Printer().exprString(c1) + "'",c1.p);
			}
			break;
		case 9:
			var e1 = _g.e;
			var r = _g.regs;
			d = hxsl_TExprDef.TSwiz(this.evalExpr(e1),r.slice());
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			var econd1 = this.evalExpr(econd);
			var _g1 = econd1.e;
			if(_g1._hx_index == 0) {
				var _g2 = _g1.c;
				if(_g2._hx_index == 1) {
					var b = _g2.b;
					d = b ? this.evalExpr(eif,isVal).e : eelse == null ? hxsl_TExprDef.TConst(hxsl_Const.CNull) : this.evalExpr(eelse,isVal).e;
				} else if(isVal && eelse != null && this.eliminateConditionals) {
					d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(eelse,true),this.evalExpr(eif,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd1.p},[econd1]), t : hxsl_Type.TFloat, p : e.p}]);
				} else {
					eif = this.evalExpr(eif,isVal);
					if(eelse != null) {
						eelse = this.evalExpr(eelse,isVal);
						var _g1 = eelse.e;
						if(_g1._hx_index == 0 && _g1.c._hx_index == 0) {
							eelse = null;
						}
					}
					eif = this.ifBlock(eif);
					eelse = this.ifBlock(eelse);
					d = hxsl_TExprDef.TIf(econd1,eif,eelse);
				}
			} else if(isVal && eelse != null && this.eliminateConditionals) {
				d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(eelse,true),this.evalExpr(eif,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd1.p},[econd1]), t : hxsl_Type.TFloat, p : e.p}]);
			} else {
				eif = this.evalExpr(eif,isVal);
				if(eelse != null) {
					eelse = this.evalExpr(eelse,isVal);
					var _g1 = eelse.e;
					if(_g1._hx_index == 0 && _g1.c._hx_index == 0) {
						eelse = null;
					}
				}
				eif = this.ifBlock(eif);
				eelse = this.ifBlock(eelse);
				d = hxsl_TExprDef.TIf(econd1,eif,eelse);
			}
			break;
		case 11:
			d = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			var e1 = _g.e;
			d = hxsl_TExprDef.TReturn(e1 == null ? null : this.evalExpr(e1));
			break;
		case 13:
			var v1 = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var v2 = this.mapVar(v1);
			var it1 = this.evalExpr(it);
			var e1;
			var _g1 = it1.e;
			if(_g1._hx_index == 5) {
				var _g2 = _g1.e1;
				var _g3 = _g1.e2;
				if(_g1.op._hx_index == 21) {
					var _g1 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g1._hx_index == 0) {
						var _g2 = _g1.c;
						if(_g2._hx_index == 2) {
							var _g1 = _g3.e;
							var _g4 = _g3.p;
							var _g4 = _g3.t;
							if(_g1._hx_index == 0) {
								var _g3 = _g1.c;
								if(_g3._hx_index == 2) {
									var len = _g3.v;
									var start = _g2.v;
									if(this.unrollLoops) {
										var out = [];
										var _g1 = start;
										var _g2 = len;
										while(_g1 < _g2) {
											var i = _g1++;
											this.constants.h[v1.id] = hxsl_TExprDef.TConst(hxsl_Const.CInt(i));
											out.push(this.evalExpr(loop,false));
										}
										this.constants.remove(v1.id);
										e1 = hxsl_TExprDef.TBlock(out);
									} else {
										e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
									}
								} else {
									e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
								}
							} else {
								e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
							}
						} else {
							e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
						}
					} else {
						e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
					}
				} else {
					e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
				}
			} else {
				e1 = hxsl_TExprDef.TFor(v2,it1,this.ifBlock(this.evalExpr(loop,false)));
			}
			this.varMap.remove(v1);
			d = e1;
			break;
		case 14:
			d = hxsl_TExprDef.TContinue;
			break;
		case 15:
			d = hxsl_TExprDef.TBreak;
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.index;
			var e11 = this.evalExpr(e1);
			var e21 = this.evalExpr(e2);
			var _g1 = e11.e;
			var _g2 = e21.e;
			if(_g1._hx_index == 17) {
				if(_g2._hx_index == 0) {
					var _g3 = _g2.c;
					if(_g3._hx_index == 2) {
						var i = _g3.v;
						var el = _g1.el;
						d = i >= 0 && i < el.length ? el[i].e : hxsl_TExprDef.TArray(e11,e21);
					} else {
						d = hxsl_TExprDef.TArray(e11,e21);
					}
				} else {
					d = hxsl_TExprDef.TArray(e11,e21);
				}
			} else {
				d = hxsl_TExprDef.TArray(e11,e21);
			}
			break;
		case 17:
			var el = _g.el;
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < el.length) {
				var e1 = el[_g2];
				++_g2;
				_g1.push(this.evalExpr(e1));
			}
			d = hxsl_TExprDef.TArrayDecl(_g1);
			break;
		case 18:
			var e1 = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			var e2 = this.evalExpr(e1);
			var _g1 = [];
			var _g2 = 0;
			while(_g2 < cases.length) {
				var c = cases[_g2];
				++_g2;
				var _g3 = [];
				var _g4 = 0;
				var _g5 = c.values;
				while(_g4 < _g5.length) {
					var v1 = _g5[_g4];
					++_g4;
					_g3.push(this.evalExpr(v1));
				}
				_g1.push({ values : _g3, expr : this.evalExpr(c.expr,isVal)});
			}
			var cases = _g1;
			var def1 = def == null ? null : this.evalExpr(def,isVal);
			var hasCase = false;
			var _g1 = e2.e;
			if(_g1._hx_index == 0) {
				var c = _g1.c;
				if(c._hx_index == 2) {
					var val = c.v;
					var _g1 = 0;
					while(_g1 < cases.length) {
						var c1 = cases[_g1];
						++_g1;
						var _g2 = 0;
						var _g3 = c1.values;
						while(_g2 < _g3.length) {
							var v1 = _g3[_g2];
							++_g2;
							var _g4 = v1.e;
							if(_g4._hx_index == 0) {
								var cst = _g4.c;
								switch(cst._hx_index) {
								case 2:
									var k = cst.v;
									if(k == val) {
										return c1.expr;
									}
									break;
								case 3:
									var k1 = cst.v;
									if(k1 == val) {
										return c1.expr;
									}
									break;
								default:
								}
							} else {
								hasCase = true;
							}
						}
					}
				} else {
					throw haxe_Exception.thrown("Unsupported switch constant " + Std.string(c));
				}
			} else {
				hasCase = true;
			}
			d = hasCase ? hxsl_TExprDef.TSwitch(e2,cases,def1) : def1 == null ? hxsl_TExprDef.TBlock([]) : def1.e;
			break;
		case 19:
			var cond = _g.e;
			var loop = _g.loop;
			var normalWhile = _g.normalWhile;
			var cond1 = this.evalExpr(cond);
			var loop1 = this.evalExpr(loop,false);
			d = hxsl_TExprDef.TWhile(cond1,this.ifBlock(loop1),normalWhile);
			break;
		case 20:
			var name = _g.m;
			var args = _g.args;
			var e1 = _g.e;
			var e2;
			if(name == "unroll") {
				var old4 = this.unrollLoops;
				this.unrollLoops = true;
				e2 = this.evalExpr(e1,isVal);
				this.unrollLoops = false;
			} else {
				e2 = this.evalExpr(e1,isVal);
			}
			d = hxsl_TExprDef.TMeta(name,args,e2);
			break;
		}
		return { e : d, t : e.t, p : e.p};
	}
	,__class__: hxsl_Eval
};
var hxsl__$Flatten_Alloc = function(g,t,pos,size) {
	this.g = g;
	this.t = t;
	this.pos = pos;
	this.size = size;
};
$hxClasses["hxsl._Flatten.Alloc"] = hxsl__$Flatten_Alloc;
hxsl__$Flatten_Alloc.__name__ = "hxsl._Flatten.Alloc";
hxsl__$Flatten_Alloc.prototype = {
	__class__: hxsl__$Flatten_Alloc
};
var hxsl_ARead = $hxEnums["hxsl.ARead"] = { __ename__:"hxsl.ARead",__constructs__:null
	,AIndex: ($_=function(a) { return {_hx_index:0,a:a,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AIndex",$_.__params__ = ["a"],$_)
	,AOffset: ($_=function(a,stride,delta) { return {_hx_index:1,a:a,stride:stride,delta:delta,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AOffset",$_.__params__ = ["a","stride","delta"],$_)
};
hxsl_ARead.__constructs__ = [hxsl_ARead.AIndex,hxsl_ARead.AOffset];
hxsl_ARead.__empty_constructs__ = [];
var hxsl_Flatten = function() {
};
$hxClasses["hxsl.Flatten"] = hxsl_Flatten;
hxsl_Flatten.__name__ = "hxsl.Flatten";
hxsl_Flatten.prototype = {
	flatten: function(s,kind) {
		this.globals = [];
		this.params = [];
		this.outVars = [];
		this.varMap = new haxe_ds_ObjectMap();
		this.allocData = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.gatherVar(v);
		}
		var prefix;
		switch(kind._hx_index) {
		case 0:
			prefix = "vertex";
			break;
		case 1:
			prefix = "fragment";
			break;
		case 4:
			prefix = "compute";
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		this.pack(prefix + "Globals",hxsl_VarKind.Global,this.globals,hxsl_VecType.VFloat);
		this.pack(prefix + "Params",hxsl_VarKind.Param,this.params,hxsl_VecType.VFloat);
		var allVars = this.globals.concat(this.params);
		var textures = this.packTextures(prefix + "Textures",allVars,hxsl_Type.TSampler2D).concat(this.packTextures(prefix + "TexturesCube",allVars,hxsl_Type.TSamplerCube)).concat(this.packTextures(prefix + "TexturesArray",allVars,hxsl_Type.TSampler2DArray));
		this.packBuffers("buffers",allVars,hxsl_BufferKind.Uniform);
		this.packBuffers("rwbuffers",allVars,hxsl_BufferKind.RW);
		var _g = [];
		var _g1 = 0;
		var _g2 = s.funs;
		while(_g1 < _g2.length) {
			var f = _g2[_g1];
			++_g1;
			_g.push(this.mapFun(f,$bind(this,this.mapExpr)));
		}
		var funs = _g;
		return { name : s.name, vars : this.outVars, funs : funs};
	}
	,mapFun: function(f,mapExpr) {
		return { kind : f.kind, ret : f.ret, args : f.args, ref : f.ref, expr : mapExpr(f.expr)};
	}
	,mapExpr: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var a = this.varMap.h[v.__id__];
			if(a != null) {
				e = this.access(a,v.type,e.p,hxsl_ARead.AIndex(a));
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g1.e;
			var _g3 = _g1.t;
			if(_g2._hx_index == 1) {
				var v = _g2.v;
				var vp = _g1.p;
				var eindex = _g.index;
				var _g = eindex.e;
				var e1;
				if(_g._hx_index == 0) {
					var _g1 = _g.c;
					if(_g1._hx_index == 2) {
						var _g = _g1.v;
						e1 = true;
					} else {
						e1 = false;
					}
				} else {
					e1 = false;
				}
				if(!e1) {
					var a = this.varMap.h[v.__id__];
					if(a != null) {
						var _g = v.type;
						if(_g._hx_index == 15) {
							var _g1 = _g.t;
							var _g2 = _g.size;
							var t = _g1;
							if(hxsl_Tools.isSampler(t)) {
								eindex = this.toInt(this.mapExpr(eindex));
								e = this.access(a,t,vp,hxsl_ARead.AOffset(a,1,eindex));
							} else {
								var t = _g1;
								var stride = this.varSize(t,a.t);
								if(stride == 0 || (stride & 3) != 0) {
									throw haxe_Exception.thrown(new hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p));
								}
								stride >>= 2;
								eindex = this.toInt(this.mapExpr(eindex));
								e = this.access(a,t,vp,hxsl_ARead.AOffset(a,stride,stride == 1 ? eindex : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,eindex,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), t : hxsl_Type.TInt, p : vp}), t : hxsl_Type.TInt, p : vp}));
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
				}
			} else {
				e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
			}
			break;
		default:
			e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
		}
		return this.optimize(e);
	}
	,mkInt: function(v,pos) {
		return { e : hxsl_TExprDef.TConst(hxsl_Const.CInt(v)), t : hxsl_Type.TInt, p : pos};
	}
	,readIndex: function(a,index,pos) {
		var offs = a.t == null ? a.pos : a.pos >> 2;
		return { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a.g), t : a.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a.t), p : pos};
	}
	,readOffset: function(a,stride,delta,index,pos) {
		var index1 = (a.t == null ? a.pos : a.pos >> 2) + index;
		var offset = index1 == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
		return { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a.g), t : a.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a.t), p : pos};
	}
	,access: function(a,t,pos,acc) {
		var _gthis = this;
		switch(t._hx_index) {
		case 6:
			var tmp = this.access(a,hxsl_Type.TMat3x4,pos,acc);
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), t : hxsl_Type.TFun([]), p : pos},[tmp]), t : hxsl_Type.TMat3, p : pos};
		case 7:
			var tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4);
			var tmp1 = hxsl_Type.TFun([]);
			var tmp2;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = a1.t == null ? a1.pos : a1.pos >> 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp3;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 1;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp4;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp5;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp5 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 3)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 3;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp5 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall({ e : tmp, t : tmp1, p : pos},[tmp2,tmp3,tmp4,tmp5]), t : hxsl_Type.TMat4, p : pos};
		case 8:
			var tmp = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4);
			var tmp1 = hxsl_Type.TFun([]);
			var tmp2;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = a1.t == null ? a1.pos : a1.pos >> 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp2 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp3;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 1;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			var tmp4;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = (a1.t == null ? a1.pos : a1.pos >> 2) + 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall({ e : tmp, t : tmp1, p : pos},[tmp2,tmp3,tmp4]), t : hxsl_Type.TMat3x4, p : pos};
		case 15:
			var _g = t.size;
			if(_g._hx_index == 0) {
				var len = _g.v;
				var t1 = t.t;
				var stride = a.size / len | 0;
				var _g = [];
				var _g1 = 0;
				var _g2 = len;
				while(_g1 < _g2) {
					var i = _g1++;
					var a1 = new hxsl__$Flatten_Alloc(a.g,a.t,a.pos + stride * i,stride);
					_g.push(this.access(a1,t1,pos,hxsl_ARead.AIndex(a1)));
				}
				var earr = _g;
				return { e : hxsl_TExprDef.TArrayDecl(earr), t : t1, p : pos};
			} else {
				if(hxsl_Tools.isSampler(t)) {
					var e;
					switch(acc._hx_index) {
					case 0:
						var a1 = acc.a;
						var offs = a1.t == null ? a1.pos : a1.pos >> 2;
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					case 1:
						var a1 = acc.a;
						var stride = acc.stride;
						var delta = acc.delta;
						var index = a1.t == null ? a1.pos : a1.pos >> 2;
						var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
						break;
					}
					e.t = t;
					return e;
				}
				var size = this.varSize(t,a.t);
				if(size > 4) {
					return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
				}
				var e;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a1 = acc.a;
					var stride = acc.stride;
					var delta = acc.delta;
					var index = a1.t == null ? a1.pos : a1.pos >> 2;
					var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				}
				if(size == 4) {
					if(a.pos == -1) {
						return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
					}
					if((a.pos & 3) != 0) {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					var sw = [];
					var _g = 0;
					var _g1 = size;
					while(_g < _g1) {
						var i = _g++;
						sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
					}
					e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
				}
				switch(t._hx_index) {
				case 1:
					e.t = hxsl_Type.TFloat;
					e = this.toInt(e);
					break;
				case 5:
					if(t.t._hx_index == 0) {
						var size = t.size;
						e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat);
						e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][size - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
					}
					break;
				default:
				}
				return e;
			}
			break;
		default:
			if(hxsl_Tools.isSampler(t)) {
				var e;
				switch(acc._hx_index) {
				case 0:
					var a1 = acc.a;
					var offs = a1.t == null ? a1.pos : a1.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				case 1:
					var a1 = acc.a;
					var stride = acc.stride;
					var delta = acc.delta;
					var index = a1.t == null ? a1.pos : a1.pos >> 2;
					var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
					break;
				}
				e.t = t;
				return e;
			}
			var size = this.varSize(t,a.t);
			if(size > 4) {
				return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
			}
			var e;
			switch(acc._hx_index) {
			case 0:
				var a1 = acc.a;
				var offs = a1.t == null ? a1.pos : a1.pos >> 2;
				e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			case 1:
				var a1 = acc.a;
				var stride = acc.stride;
				var delta = acc.delta;
				var index = a1.t == null ? a1.pos : a1.pos >> 2;
				var offset = index == 0 ? delta : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(a1.g), t : a1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,a1.t), p : pos};
				break;
			}
			if(size == 4) {
				if(a.pos == -1) {
					return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
				}
				if((a.pos & 3) != 0) {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				var sw = [];
				var _g = 0;
				var _g1 = size;
				while(_g < _g1) {
					var i = _g++;
					sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
				}
				e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
			}
			switch(t._hx_index) {
			case 1:
				e.t = hxsl_Type.TFloat;
				e = this.toInt(e);
				break;
			case 5:
				if(t.t._hx_index == 0) {
					var size = t.size;
					e.t = hxsl_Type.TVec(size,hxsl_VecType.VFloat);
					e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][size - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
				}
				break;
			default:
			}
			return e;
		}
	}
	,toInt: function(e) {
		if(e.t == hxsl_Type.TInt) {
			return e;
		}
		return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TFun([]), p : e.p},[e]), t : hxsl_Type.TInt, p : e.p};
	}
	,optimize: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				if(_g3.g._hx_index == 52) {
					if(_g2.length == 1) {
						var _g1 = _g2[0];
						var _g2 = _g1.e;
						var _g3 = _g1.p;
						var _g3 = _g1.t;
						if(_g2._hx_index == 8) {
							var _g1 = _g2.e;
							var _g3 = _g1.e;
							var _g4 = _g1.p;
							var _g4 = _g1.t;
							if(_g3._hx_index == 2) {
								if(_g3.g._hx_index == 51) {
									var args = _g2.args;
									var rem = 0;
									var size = 0;
									while(size < 4) {
										var t = args[args.length - 1 - rem].t;
										size += this.varSize(t,hxsl_VecType.VFloat);
										++rem;
									}
									if(size == 4) {
										var _g1 = 0;
										var _g2 = rem;
										while(_g1 < _g2) {
											var i = _g1++;
											args.pop();
										}
										var emat;
										var _g1 = e.e;
										if(_g1._hx_index == 8) {
											var _g2 = _g1.args;
											var e1 = _g1.e;
											emat = e1;
										} else {
											throw haxe_Exception.thrown("assert");
										}
										return { e : hxsl_TExprDef.TCall(emat,args), t : e.t, p : e.p};
									}
								}
							}
						}
					}
				}
			}
			break;
		case 16:
			var _g1 = _g.e;
			var _g2 = _g.index;
			var _g = _g1.e;
			var _g3 = _g1.p;
			var _g3 = _g1.t;
			if(_g._hx_index == 17) {
				var _g1 = _g2.e;
				var _g3 = _g2.p;
				var _g3 = _g2.t;
				if(_g1._hx_index == 0) {
					var _g2 = _g1.c;
					if(_g2._hx_index == 2) {
						var i = _g2.v;
						var el = _g.el;
						if(i >= 0 && i < el.length) {
							return el[i];
						}
						hxsl_Error.t("Reading outside array bounds",e.p);
					}
				}
			}
			break;
		default:
		}
		return e;
	}
	,packTextures: function(name,vars,t) {
		var alloc = [];
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Param};
		var pos = 0;
		var samplers = [];
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var count = 1;
			if(v.type != t) {
				var _g1 = v.type;
				switch(_g1._hx_index) {
				case 15:
					var _g2 = _g1.size;
					if(_g2._hx_index == 0) {
						var n = _g2.v;
						var t2 = _g1.t;
						if(t2 == t) {
							count = n;
						} else {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 17:
					var _g3 = _g1.size;
					if(t != hxsl_Type.TSampler2D) {
						continue;
					}
					break;
				default:
					continue;
				}
			}
			var a = new hxsl__$Flatten_Alloc(g,null,pos,count);
			a.v = v;
			if(v.qualifiers != null) {
				var _g4 = 0;
				var _g5 = v.qualifiers;
				while(_g4 < _g5.length) {
					var q = _g5[_g4];
					++_g4;
					if(q._hx_index == 12) {
						var name = q.name;
						var _g6 = 0;
						var _g7 = count;
						while(_g6 < _g7) {
							var i = _g6++;
							samplers[pos + i] = name;
						}
					}
				}
			}
			this.varMap.set(v,a);
			alloc.push(a);
			pos += count;
		}
		g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(pos));
		if(samplers.length > 0) {
			var _g = 0;
			var _g1 = pos;
			while(_g < _g1) {
				var i = _g++;
				if(samplers[i] == null) {
					samplers[i] = "";
				}
			}
			if(g.qualifiers == null) {
				g.qualifiers = [];
			}
			g.qualifiers.push(hxsl_VarQualifier.Sampler(samplers.join(",")));
		}
		if(alloc.length > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return alloc;
	}
	,packBuffers: function(name,vars,kind) {
		var alloc = [];
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TVoid, kind : hxsl_VarKind.Param};
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var _g1 = v.type;
			if(_g1._hx_index == 16) {
				var _g2 = _g1.t;
				var _g3 = _g1.size;
				var k = _g1.kind;
				if(kind == k) {
					var a = new hxsl__$Flatten_Alloc(g,null,alloc.length,1);
					a.v = v;
					alloc.push(a);
					this.outVars.push(v);
				}
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0),kind),hxsl_SizeDecl.SConst(alloc.length));
		this.allocData.set(g,alloc);
	}
	,pack: function(name,kind,vars,t) {
		var alloc = [];
		var apos = 0;
		var g = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TVec(0,t), kind : kind};
		var _g = 0;
		while(_g < vars.length) {
			var v = vars[_g];
			++_g;
			var tmp;
			if(!hxsl_Tools.isSampler(v.type)) {
				var _g1 = v.type;
				if(_g1._hx_index == 16) {
					var _g2 = _g1.t;
					var _g3 = _g1.size;
					var _g4 = _g1.kind;
					tmp = true;
				} else {
					tmp = false;
				}
			} else {
				tmp = true;
			}
			if(tmp) {
				continue;
			}
			var _g5 = v.type;
			if(_g5._hx_index == 15) {
				var _g6 = _g5.size;
				var t1 = _g5.t;
				if(hxsl_Tools.isSampler(t1)) {
					continue;
				}
			}
			var size = this.varSize(v.type,t);
			if(size == 0) {
				var a = new hxsl__$Flatten_Alloc(g,t,-1,size);
				a.v = v;
				this.varMap.set(v,a);
				continue;
			}
			var best = null;
			var _g7 = 0;
			while(_g7 < alloc.length) {
				var a1 = alloc[_g7];
				++_g7;
				if(a1.v == null && a1.size >= size && (best == null || best.size > a1.size)) {
					best = a1;
				}
			}
			if(best != null) {
				var free = best.size - size;
				if(free > 0) {
					var i = alloc.indexOf(best);
					var a2 = new hxsl__$Flatten_Alloc(g,t,best.pos + size,free);
					alloc.splice(i + 1,0,a2);
					best.size = size;
				}
				best.v = v;
				this.varMap.set(v,best);
			} else {
				var a3 = new hxsl__$Flatten_Alloc(g,t,apos,size);
				apos += size;
				a3.v = v;
				this.varMap.set(v,a3);
				alloc.push(a3);
				var pad = (4 - size % 4) % 4;
				if(pad > 0) {
					var a4 = new hxsl__$Flatten_Alloc(g,t,apos,pad);
					apos += pad;
					alloc.push(a4);
				}
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst(apos >> 2));
		if(apos > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return g;
	}
	,varSize: function(v,t) {
		switch(v._hx_index) {
		case 1:case 3:
			if(t == hxsl_VecType.VFloat) {
				return 1;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 5:
			var n = v.size;
			var t2 = v.t;
			if(t == t2) {
				return n;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 7:
			if(t == hxsl_VecType.VFloat) {
				return 16;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 6:case 8:
			if(t == hxsl_VecType.VFloat) {
				return 12;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 15:
			var _g = v.size;
			if(_g._hx_index == 0) {
				var n = _g.v;
				var at = v.t;
				return this.varSize(at,t) * n;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		default:
			throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
		}
	}
	,gatherVar: function(v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.gatherVar(v1);
			}
		} else {
			switch(v.kind._hx_index) {
			case 0:
				if(hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject)) {
					this.params.push(v);
				} else {
					this.globals.push(v);
				}
				break;
			case 2:
				this.params.push(v);
				break;
			default:
				this.outVars.push(v);
			}
		}
	}
	,__class__: hxsl_Flatten
};
var hxsl_GlobalSlot = {};
hxsl_GlobalSlot._new = function(name) {
	return hxsl_Globals.allocID(name);
};
hxsl_GlobalSlot.toInt = function(this1) {
	return this1;
};
hxsl_GlobalSlot.set = function(this1,globals,v) {
	globals.map.h[this1] = v;
};
hxsl_GlobalSlot.get = function(this1,globals) {
	return globals.map.h[this1];
};
var hxsl_Globals = function() {
	this.channels = [];
	this.map = new haxe_ds_IntMap();
};
$hxClasses["hxsl.Globals"] = hxsl_Globals;
hxsl_Globals.__name__ = "hxsl.Globals";
hxsl_Globals.allocID = function(path) {
	if(hxsl_Globals.MAP == null) {
		hxsl_Globals.MAP = new haxe_ds_StringMap();
		hxsl_Globals.ALL = [];
	}
	var id = hxsl_Globals.MAP.h[path];
	if(id == null) {
		id = hxsl_Globals.ALL.length;
		hxsl_Globals.ALL.push(path);
		hxsl_Globals.MAP.h[path] = id;
	}
	return id;
};
hxsl_Globals.getIDName = function(id) {
	return hxsl_Globals.ALL[id];
};
hxsl_Globals.prototype = {
	set: function(path,v) {
		var this1 = this.map;
		var key = hxsl_Globals.allocID(path);
		this1.h[key] = v;
	}
	,get: function(path) {
		var this1 = this.map;
		var key = hxsl_Globals.allocID(path);
		return this1.h[key];
	}
	,fastSet: function(id,v) {
		this.map.h[id] = v;
	}
	,fastGet: function(id) {
		return this.map.h[id];
	}
	,resetChannels: function() {
		this.maxChannels = 0;
	}
	,allocChannelID: function(t) {
		var _g = 0;
		var _g1 = this.maxChannels;
		while(_g < _g1) {
			var i = _g++;
			if(this.channels[i] == t) {
				return i;
			}
		}
		if(this.maxChannels == 1 << hxsl_Tools.MAX_CHANNELS_BITS) {
			throw haxe_Exception.thrown("Too many unique channels");
		}
		var i = this.maxChannels++;
		this.channels[i] = t;
		return i;
	}
	,__class__: hxsl_Globals
};
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hxsl_GlslOut = function() {
	this.outIndex = 0;
	this.uniformBuffer = 0;
	this.exprIds = 0;
	this.varNames = new haxe_ds_IntMap();
	this.allNames = new haxe_ds_StringMap();
};
$hxClasses["hxsl.GlslOut"] = hxsl_GlslOut;
hxsl_GlslOut.__name__ = "hxsl.GlslOut";
hxsl_GlslOut.compile = function(s) {
	var out = new hxsl_GlslOut();
	out.glES = 1;
	out.version = 100;
	return out.run(s);
};
hxsl_GlslOut.prototype = {
	get_isES: function() {
		return this.glES != null;
	}
	,get_isES2: function() {
		if(this.glES != null) {
			return this.glES <= 2;
		} else {
			return false;
		}
	}
	,add: function(v) {
		this.buf.b += Std.string(v);
	}
	,ident: function(v) {
		var v1 = this.varName(v);
		this.buf.b += Std.string(v1);
	}
	,decl: function(s) {
		var _g = 0;
		var _g1 = this.decls;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			if(d == s) {
				return;
			}
		}
		if(HxOverrides.cca(s,0) == 35) {
			this.decls.unshift(s);
		} else {
			this.decls.push(s);
		}
	}
	,addType: function(t) {
		switch(t._hx_index) {
		case 0:
			this.buf.b += Std.string("void");
			break;
		case 1:
			this.buf.b += Std.string("int");
			break;
		case 2:
			this.buf.b += Std.string("bool");
			break;
		case 3:
			this.buf.b += Std.string("float");
			break;
		case 4:
			this.buf.b += Std.string("string");
			break;
		case 5:
			var size = t.size;
			var k = t.t;
			switch(k._hx_index) {
			case 0:
				this.buf.b += Std.string("i");
				break;
			case 1:
				break;
			case 2:
				this.buf.b += Std.string("b");
				break;
			}
			this.buf.b += Std.string("vec");
			this.buf.b += Std.string(size);
			break;
		case 6:
			this.buf.b += Std.string("mat3");
			break;
		case 7:
			this.buf.b += Std.string("mat4");
			break;
		case 8:
			this.decl(hxsl_GlslOut.MAT34);
			this.buf.b += Std.string("_mat3x4");
			break;
		case 9:
			var n = t.size;
			this.buf.b += Std.string("vec");
			this.buf.b += Std.string(n);
			break;
		case 10:
			this.buf.b += Std.string("sampler2D");
			break;
		case 11:
			this.buf.b += Std.string("sampler2DArray");
			if(this.glES != null) {
				this.decl("precision lowp sampler2DArray;");
			}
			break;
		case 12:
			this.buf.b += Std.string("samplerCube");
			break;
		case 13:
			var vl = t.vl;
			this.buf.b += Std.string("struct { ");
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				this.addVar(v);
				this.buf.b += Std.string(";");
			}
			this.buf.b += Std.string(" }");
			break;
		case 14:
			var _g = t.variants;
			this.buf.b += Std.string("function");
			break;
		case 15:
			var t1 = t.t;
			var size = t.size;
			this.addType(t1);
			this.buf.b += Std.string("[");
			switch(size._hx_index) {
			case 0:
				var _g = size.v;
				if(_g == 1) {
					if(this.intelDriverFix) {
						this.buf.b += Std.string(2);
					} else {
						var v = _g;
						this.buf.b += Std.string(v);
					}
				} else {
					var v = _g;
					this.buf.b += Std.string(v);
				}
				break;
			case 1:
				var v = size.v;
				var v1 = this.varName(v);
				this.buf.b += Std.string(v1);
				break;
			}
			this.buf.b += Std.string("]");
			break;
		case 16:
			var _g = t.t;
			var _g = t.size;
			var _g = t.kind;
			throw haxe_Exception.thrown("assert");
		case 17:
			var n = t.size;
			this.buf.b += Std.string("channel" + n);
			break;
		case 18:
			this.buf.b += Std.string("mat2");
			break;
		}
	}
	,addVar: function(v) {
		var _g = v.type;
		switch(_g._hx_index) {
		case 15:
			var t = _g.t;
			var size = _g.size;
			var old = v.type;
			v.type = t;
			this.addVar(v);
			v.type = old;
			this.buf.b += Std.string("[");
			switch(size._hx_index) {
			case 0:
				var _g1 = size.v;
				if(_g1 == 1) {
					if(this.intelDriverFix) {
						this.buf.b += Std.string(2);
					} else {
						var n = _g1;
						this.buf.b += Std.string(n);
					}
				} else {
					var n = _g1;
					this.buf.b += Std.string(n);
				}
				break;
			case 1:
				var v1 = size.v;
				var v2 = this.varName(v1);
				this.buf.b += Std.string(v2);
				break;
			}
			this.buf.b += Std.string("]");
			break;
		case 16:
			var t = _g.t;
			var size = _g.size;
			var kind = _g.kind;
			if(kind != hxsl_BufferKind.Uniform) {
				throw haxe_Exception.thrown("TODO");
			}
			this.buf.b += Std.string((this.isVertex ? "vertex_" : "") + "uniform_buffer" + this.uniformBuffer++);
			this.buf.b += Std.string(" { ");
			v.type = hxsl_Type.TArray(t,size);
			this.addVar(v);
			v.type = hxsl_Type.TBuffer(t,size,kind);
			this.buf.b += Std.string("; }");
			break;
		default:
			this.addType(v.type);
			this.buf.b += Std.string(" ");
			var v1 = this.varName(v);
			this.buf.b += Std.string(v1);
		}
	}
	,addValue: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var el = _g.el;
			var name = "val" + this.exprIds++;
			var tmp = this.buf;
			this.buf = new StringBuf();
			this.addType(e.t);
			this.buf.b += Std.string(" ");
			this.buf.b += Std.string(name);
			this.buf.b += Std.string("(void)");
			var el2 = el.slice();
			var last = el2[el2.length - 1];
			el2[el2.length - 1] = { e : hxsl_TExprDef.TReturn(last), t : e.t, p : last.p};
			var e2 = { t : hxsl_Type.TVoid, e : hxsl_TExprDef.TBlock(el2), p : e.p};
			this.addExpr(e2,"");
			this.exprValues.push(this.buf.b);
			this.buf = tmp;
			this.buf.b += Std.string(name);
			this.buf.b += Std.string("()");
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buf.b += Std.string("( ");
			this.addValue(econd,tabs);
			this.buf.b += Std.string(" ) ? ");
			this.addValue(eif,tabs);
			this.buf.b += Std.string(" : ");
			this.addValue(eelse,tabs);
			break;
		case 20:
			var _g1 = _g.m;
			var _g1 = _g.args;
			var e1 = _g.e;
			this.addValue(e1,tabs);
			break;
		default:
			this.addExpr(e,tabs);
		}
	}
	,addBlock: function(e,tabs) {
		this.addExpr(e,tabs);
	}
	,getFunName: function(g,args,rt) {
		switch(g._hx_index) {
		case 20:
			if(rt == hxsl_Type.TInt && this.glES != null) {
				this.decl("int _imod( int x, int y ) { return int(mod(float(x),float(y))); }");
				return "_imod";
			}
			break;
		case 33:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:case 11:
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			case 12:
				if(this.glES != null && this.glES <= 2) {
					return "textureCube";
				}
				break;
			case 17:
				var _g1 = _g.size;
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			default:
			}
			break;
		case 34:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:case 11:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			case 12:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "textureCubeLodEXT";
				}
				break;
			case 17:
				var _g1 = _g.size;
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			default:
			}
			break;
		case 35:
			return "texelFetch";
		case 36:
			var _g = args[0].t;
			switch(_g._hx_index) {
			case 10:
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			case 11:
				this.decl("vec3 _textureSize(sampler2DArray sampler, int lod) { return vec3(textureSize(sampler, lod)); }");
				break;
			case 12:
				this.decl("vec2 _textureSize(samplerCube sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			case 17:
				var _g1 = _g.size;
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			default:
			}
			return "_textureSize";
		case 50:
			if(args[0].t == hxsl_Type.TMat3x4) {
				this.decl(hxsl_GlslOut.MAT34);
				this.decl("mat3 _mat3( _mat3x4 v ) { return mat3(v.a.xyz,v.b.xyz,v.c.xyz); }");
				return "_mat3";
			}
			break;
		case 52:
			this.decl(hxsl_GlslOut.MAT34);
			if(args.length == 1) {
				this.decl("_mat3x4 mat_to_34( mat4 m ) { return _mat3x4(m[0],m[1],m[2]); }");
				return "mat_to_34";
			}
			break;
		case 54:
			this.decl("vec4 pack( float v ) { vec4 color = fract(v * vec4(1, 255, 255.*255., 255.*255.*255.)); return color - color.yzww * vec4(1. / 255., 1. / 255., 1. / 255., 0.); }");
			break;
		case 55:
			this.decl("float unpack( vec4 color ) { return dot(color,vec4(1., 1. / 255., 1. / (255. * 255.), 1. / (255. * 255. * 255.))); }");
			break;
		case 56:
			this.decl("vec4 packNormal( vec3 v ) { return vec4((v + vec3(1.)) * vec3(0.5),1.); }");
			break;
		case 57:
			this.decl("vec3 unpackNormal( vec4 v ) { return normalize((v.xyz - vec3(0.5)) * vec3(2.)); }");
			break;
		case 58:
			this.decl("vec2 screenToUv( vec2 v ) { return v * vec2(0.5,-0.5) + vec2(0.5,0.5); }");
			break;
		case 59:
			this.decl("vec2 uvToScreen( vec2 v ) { return v * vec2(2.,-2.) + vec2(-1., 1.); }");
			break;
		case 60:case 61:case 62:
			if(this.isVertex) {
				throw haxe_Exception.thrown("Can't use " + Std.string(g) + " in vertex shader");
			}
			if(this.version < 300) {
				this.decl("#extension GL_OES_standard_derivatives:enable");
			}
			break;
		case 73:
			if(this.version < 330) {
				this.decl("#extension GL_ARB_shader_bit_encoding :enable");
			}
			this.decl("int _floatBitsToUint( float v) { return int(floatBitsToUint(v)); }");
			this.decl("ivec2 _floatBitsToUint( vec2 v ) { return ivec2(floatBitsToUint(v)); }");
			this.decl("ivec3 _floatBitsToUint( vec3 v ) { return ivec3(floatBitsToUint(v)); }");
			this.decl("ivec4 _floatBitsToUint( vec4 v ) { return ivec4(floatBitsToUint(v)); }");
			break;
		case 72:case 74:
			if(this.version < 330) {
				this.decl("#extension GL_ARB_shader_bit_encoding :enable");
			}
			break;
		case 75:
			if(this.version < 330) {
				this.decl("#extension GL_ARB_shader_bit_encoding :enable");
			}
			this.decl("float _uintBitsToFloat( int v ) { return uintBitsToFloat(uint(v)); }");
			this.decl("vec2 _uintBitsToFloat( ivec2 v ) { return uintBitsToFloat(uvec2(v)); }");
			this.decl("vec3 _uintBitsToFloat( ivec3 v ) { return uintBitsToFloat(uvec3(v)); }");
			this.decl("vec4 _uintBitsToFloat( ivec4 v ) { return uintBitsToFloat(uvec4(v)); }");
			break;
		default:
		}
		return hxsl_GlslOut.GLOBALS[g._hx_index];
	}
	,addExpr: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			switch(c._hx_index) {
			case 0:
				this.buf.b += Std.string("null");
				break;
			case 1:
				var b = c.b;
				this.buf.b += Std.string(b);
				break;
			case 2:
				var v = c.v;
				this.buf.b += Std.string(v);
				break;
			case 3:
				var f = c.v;
				var str = "" + f;
				this.buf.b += Std.string(str);
				if(str.indexOf(".") == -1 && str.indexOf("e") == -1) {
					this.buf.b += Std.string(".");
				}
				break;
			case 4:
				var v = c.v;
				this.buf.b += Std.string("\"" + v + "\"");
				break;
			}
			break;
		case 1:
			var v = _g.v;
			var v1 = this.varName(v);
			this.buf.b += Std.string(v1);
			break;
		case 2:
			var g = _g.g;
			this.buf.b += Std.string(hxsl_GlslOut.GLOBALS[g._hx_index]);
			break;
		case 3:
			var e1 = _g.e;
			this.buf.b += Std.string("(");
			this.addValue(e1,tabs);
			this.buf.b += Std.string(")");
			break;
		case 4:
			var el = _g.el;
			this.buf.b += Std.string("{\n");
			var t2 = tabs + "\t";
			var _g1 = 0;
			while(_g1 < el.length) {
				var e1 = el[_g1];
				++_g1;
				this.buf.b += Std.string(t2);
				this.addExpr(e1,t2);
				this.newLine(e1);
			}
			this.buf.b += Std.string(tabs);
			this.buf.b += Std.string("}");
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var _g1 = e1.t;
			var _g2 = e2.t;
			switch(op._hx_index) {
			case 1:
				if(_g1._hx_index == 5) {
					if(_g1.size == 3) {
						if(_g1.t._hx_index == 1) {
							if(_g2._hx_index == 8) {
								this.decl(hxsl_GlslOut.MAT34);
								this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
								var tmp;
								if(op._hx_index == 20) {
									var _g3 = op.op;
									tmp = true;
								} else {
									tmp = false;
								}
								if(tmp) {
									this.addValue(e1,tabs);
									this.buf.b += Std.string(" = ");
								}
								this.buf.b += Std.string("m3x4mult(");
								this.addValue(e1,tabs);
								this.buf.b += Std.string(",");
								this.addValue(e2,tabs);
								this.buf.b += Std.string(")");
							} else {
								this.addValue(e1,tabs);
								this.buf.b += Std.string(" ");
								var v = hxsl_Printer.opStr(op);
								this.buf.b += Std.string(v);
								this.buf.b += Std.string(" ");
								this.addValue(e2,tabs);
							}
						} else {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" ");
							var v = hxsl_Printer.opStr(op);
							this.buf.b += Std.string(v);
							this.buf.b += Std.string(" ");
							this.addValue(e2,tabs);
						}
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 5:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 6:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 7:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 8:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 9:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 10:
				if(_g1._hx_index == 5) {
					var _g3 = _g1.t;
					if(_g2._hx_index == 5) {
						var _g3 = _g2.size;
						var _g3 = _g2.t;
						var n = _g1.size;
						this.buf.b += Std.string("vec" + n + "(");
						var v;
						switch(op._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += Std.string("(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(",");
						this.addValue(e2,tabs);
						this.buf.b += Std.string("))");
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 18:
				this.decl("int _ushr( int i, int j ) { return int(uint(i) >> uint(j)); }");
				this.buf.b += Std.string("_ushr(");
				this.addValue(e1,tabs);
				this.buf.b += Std.string(",");
				this.addValue(e2,tabs);
				this.buf.b += Std.string(")");
				break;
			case 19:
				if(e.t != hxsl_Type.TInt) {
					var tmp;
					if(op._hx_index == 20) {
						var _g3 = op.op;
						tmp = true;
					} else {
						tmp = false;
					}
					if(tmp) {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" = ");
					}
					this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[e1,e2]), t : e.t, p : e.p},tabs);
				} else {
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			case 20:
				switch(op.op._hx_index) {
				case 1:
					if(_g1._hx_index == 5) {
						if(_g1.size == 3) {
							if(_g1.t._hx_index == 1) {
								if(_g2._hx_index == 8) {
									this.decl(hxsl_GlslOut.MAT34);
									this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
									var tmp;
									if(op._hx_index == 20) {
										var _g1 = op.op;
										tmp = true;
									} else {
										tmp = false;
									}
									if(tmp) {
										this.addValue(e1,tabs);
										this.buf.b += Std.string(" = ");
									}
									this.buf.b += Std.string("m3x4mult(");
									this.addValue(e1,tabs);
									this.buf.b += Std.string(",");
									this.addValue(e2,tabs);
									this.buf.b += Std.string(")");
								} else {
									this.addValue(e1,tabs);
									this.buf.b += Std.string(" ");
									var v = hxsl_Printer.opStr(op);
									this.buf.b += Std.string(v);
									this.buf.b += Std.string(" ");
									this.addValue(e2,tabs);
								}
							} else {
								this.addValue(e1,tabs);
								this.buf.b += Std.string(" ");
								var v = hxsl_Printer.opStr(op);
								this.buf.b += Std.string(v);
								this.buf.b += Std.string(" ");
								this.addValue(e2,tabs);
							}
						} else {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" ");
							var v = hxsl_Printer.opStr(op);
							this.buf.b += Std.string(v);
							this.buf.b += Std.string(" ");
							this.addValue(e2,tabs);
						}
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
					break;
				case 19:
					if(e.t != hxsl_Type.TInt) {
						var tmp;
						if(op._hx_index == 20) {
							var _g1 = op.op;
							tmp = true;
						} else {
							tmp = false;
						}
						if(tmp) {
							this.addValue(e1,tabs);
							this.buf.b += Std.string(" = ");
						}
						this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[e1,e2]), t : e.t, p : e.p},tabs);
					} else {
						this.addValue(e1,tabs);
						this.buf.b += Std.string(" ");
						var v = hxsl_Printer.opStr(op);
						this.buf.b += Std.string(v);
						this.buf.b += Std.string(" ");
						this.addValue(e2,tabs);
					}
					break;
				default:
					this.addValue(e1,tabs);
					this.buf.b += Std.string(" ");
					var v = hxsl_Printer.opStr(op);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string(" ");
					this.addValue(e2,tabs);
				}
				break;
			default:
				this.addValue(e1,tabs);
				this.buf.b += Std.string(" ");
				var v = hxsl_Printer.opStr(op);
				this.buf.b += Std.string(v);
				this.buf.b += Std.string(" ");
				this.addValue(e2,tabs);
			}
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			var v;
			switch(op._hx_index) {
			case 0:
				v = "++";
				break;
			case 1:
				v = "--";
				break;
			case 2:
				v = "!";
				break;
			case 3:
				v = "-";
				break;
			case 4:
				v = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string(v);
			this.addValue(e1,tabs);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.locals.h[v.id] = v;
			if(init != null) {
				var v1 = this.varName(v);
				this.buf.b += Std.string(v1);
				this.buf.b += Std.string(" = ");
				this.addValue(init,tabs);
			} else {
				this.buf.b += Std.string("/*var*/");
			}
			break;
		case 8:
			var _g1 = _g.e;
			var _g2 = _g.args;
			var _g3 = _g1.e;
			var _g4 = _g1.p;
			var _g4 = _g1.t;
			if(_g3._hx_index == 2) {
				var _g4 = _g3.g;
				switch(_g4._hx_index) {
				case 35:
					var g = _g4;
					var args = _g2;
					var v = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string("(");
					this.addValue(args[0],tabs);
					this.buf.b += Std.string(", ");
					this.addValue(args[1],tabs);
					if(args.length != 2) {
						this.buf.b += Std.string(", ");
						this.addValue(args[2],tabs);
						this.buf.b += Std.string(")");
					} else {
						this.buf.b += Std.string(", 0)");
					}
					break;
				case 36:
					var g = _g4;
					var args = _g2;
					var v = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += Std.string("(");
					this.addValue(args[0],tabs);
					if(args.length != 1) {
						this.buf.b += Std.string(", ");
						this.addValue(args[1],tabs);
						this.buf.b += Std.string(")");
					} else {
						this.buf.b += Std.string(", 0)");
					}
					break;
				case 53:
					if(_g2.length == 1) {
						var e1 = _g2[0];
						this.buf.b += Std.string("clamp(");
						this.addValue(e1,tabs);
						this.buf.b += Std.string(", 0., 1.)");
					} else {
						var v = _g1;
						var args = _g2;
						var _g3 = v.e;
						if(_g3._hx_index == 2) {
							var g = _g3.g;
							var v1 = this.getFunName(g,args,e.t);
							this.buf.b += Std.string(v1);
						} else {
							this.addValue(v,tabs);
						}
						this.buf.b += Std.string("(");
						var first = true;
						var _g3 = 0;
						while(_g3 < args.length) {
							var e1 = args[_g3];
							++_g3;
							if(first) {
								first = false;
							} else {
								this.buf.b += Std.string(", ");
							}
							this.addValue(e1,tabs);
						}
						this.buf.b += Std.string(")");
					}
					break;
				default:
					var v = _g1;
					var args = _g2;
					var _g3 = v.e;
					if(_g3._hx_index == 2) {
						var g = _g3.g;
						var v1 = this.getFunName(g,args,e.t);
						this.buf.b += Std.string(v1);
					} else {
						this.addValue(v,tabs);
					}
					this.buf.b += Std.string("(");
					var first = true;
					var _g3 = 0;
					while(_g3 < args.length) {
						var e1 = args[_g3];
						++_g3;
						if(first) {
							first = false;
						} else {
							this.buf.b += Std.string(", ");
						}
						this.addValue(e1,tabs);
					}
					this.buf.b += Std.string(")");
				}
			} else {
				var v = _g1;
				var args = _g2;
				var _g1 = v.e;
				if(_g1._hx_index == 2) {
					var g = _g1.g;
					var v1 = this.getFunName(g,args,e.t);
					this.buf.b += Std.string(v1);
				} else {
					this.addValue(v,tabs);
				}
				this.buf.b += Std.string("(");
				var first = true;
				var _g1 = 0;
				while(_g1 < args.length) {
					var e1 = args[_g1];
					++_g1;
					if(first) {
						first = false;
					} else {
						this.buf.b += Std.string(", ");
					}
					this.addValue(e1,tabs);
				}
				this.buf.b += Std.string(")");
			}
			break;
		case 9:
			var e1 = _g.e;
			var regs = _g.regs;
			if(e1.t._hx_index == 3) {
				var _g1 = 0;
				while(_g1 < regs.length) {
					var r = regs[_g1];
					++_g1;
					if(r != hxsl_Component.X) {
						throw haxe_Exception.thrown("assert");
					}
				}
				switch(regs.length) {
				case 1:
					this.addValue(e1,tabs);
					break;
				case 2:
					this.decl("vec2 _vec2( float v ) { return vec2(v,v); }");
					this.buf.b += Std.string("_vec2(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				case 3:
					this.decl("vec3 _vec3( float v ) { return vec3(v,v,v); }");
					this.buf.b += Std.string("_vec3(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				case 4:
					this.decl("vec4 _vec4( float v ) { return vec4(v,v,v,v); }");
					this.buf.b += Std.string("_vec4(");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(")");
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
			} else {
				this.addValue(e1,tabs);
				this.buf.b += Std.string(".");
				var _g1 = 0;
				while(_g1 < regs.length) {
					var r = regs[_g1];
					++_g1;
					var _this = this.buf;
					var _this1 = _this.b;
					var tmp;
					switch(r._hx_index) {
					case 0:
						tmp = "x";
						break;
					case 1:
						tmp = "y";
						break;
					case 2:
						tmp = "z";
						break;
					case 3:
						tmp = "w";
						break;
					}
					_this.b = _this1 + Std.string(tmp);
				}
			}
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buf.b += Std.string("if( ");
			this.addValue(econd,tabs);
			this.buf.b += Std.string(") ");
			this.addExpr(eif,tabs);
			if(eelse != null) {
				if(!this.isBlock(eif)) {
					this.buf.b += Std.string(";");
				}
				this.buf.b += Std.string(" else ");
				this.addExpr(eelse,tabs);
			}
			break;
		case 11:
			this.buf.b += Std.string("discard");
			break;
		case 12:
			var e1 = _g.e;
			if(e1 == null) {
				this.buf.b += Std.string("return");
			} else {
				this.buf.b += Std.string("return ");
				this.addValue(e1,tabs);
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.locals.h[v.id] = v;
			var _g1 = it.e;
			if(_g1._hx_index == 5) {
				if(_g1.op._hx_index == 21) {
					var e1 = _g1.e1;
					var e2 = _g1.e2;
					this.buf.b += Std.string("for(");
					this.buf.b += Std.string(v.name + "=");
					this.addValue(e1,tabs);
					this.buf.b += Std.string(";" + v.name + "<");
					this.addValue(e2,tabs);
					this.buf.b += Std.string(";" + v.name + "++) ");
					this.addBlock(loop,tabs);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 14:
			this.buf.b += Std.string("continue");
			break;
		case 15:
			this.buf.b += Std.string("break");
			break;
		case 16:
			var e1 = _g.e;
			var index = _g.index;
			this.addValue(e1,tabs);
			this.buf.b += Std.string("[");
			this.addValue(index,tabs);
			this.buf.b += Std.string("]");
			break;
		case 17:
			var el = _g.el;
			var _g1 = e.t;
			if(_g1._hx_index == 15) {
				var _g2 = _g1.size;
				var t = _g1.t;
				this.addType(t);
			} else {
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string("[" + el.length + "]");
			this.buf.b += Std.string("(");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buf.b += Std.string(", ");
				}
				this.addValue(e,tabs);
			}
			this.buf.b += Std.string(")");
			break;
		case 18:
			var _g1 = _g.e;
			var _g1 = _g.cases;
			var _g1 = _g.def;
			this.buf.b += Std.string("switch(...)");
			break;
		case 19:
			var _g1 = _g.e;
			var _g2 = _g.loop;
			if(_g.normalWhile == false) {
				var loop = _g2;
				var e = _g1;
				var old = tabs;
				tabs += "\t";
				this.buf.b += Std.string("do ");
				this.addBlock(loop,tabs);
				this.buf.b += Std.string(" while( ");
				this.addValue(e,tabs);
				this.buf.b += Std.string(" )");
			} else {
				var loop = _g2;
				var e = _g1;
				this.buf.b += Std.string("while( ");
				this.addValue(e,tabs);
				this.buf.b += Std.string(" ) ");
				this.addBlock(loop,tabs);
			}
			break;
		case 20:
			var _g1 = _g.m;
			var _g1 = _g.args;
			var e = _g.e;
			this.addExpr(e,tabs);
			break;
		}
	}
	,varName: function(v) {
		if(v.kind == hxsl_VarKind.Output) {
			if(this.isVertex) {
				return "gl_Position";
			}
			if(this.glES != null && this.glES <= 2) {
				if(this.outIndexes == null) {
					return "gl_FragColor";
				}
				return "gl_FragData[" + this.outIndexes.h[v.id] + "]";
			}
		}
		var n = this.varNames.h[v.id];
		if(n != null) {
			return n;
		}
		n = v.name;
		if(v.kind == hxsl_VarKind.Var) {
			n += "_varying";
		}
		if(Object.prototype.hasOwnProperty.call(hxsl_GlslOut.KWDS.h,n)) {
			n = "_" + n;
		}
		if(Object.prototype.hasOwnProperty.call(this.allNames.h,n)) {
			var k = 2;
			n += "_";
			while(Object.prototype.hasOwnProperty.call(this.allNames.h,n + k)) ++k;
			n += k;
		}
		this.varNames.h[v.id] = n;
		this.allNames.h[n] = v.id;
		return n;
	}
	,newLine: function(e) {
		if(this.isBlock(e)) {
			this.buf.b += Std.string("\n");
		} else {
			this.buf.b += Std.string(";\n");
		}
	}
	,isBlock: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 4:
			var _g1 = _g.el;
			return true;
		case 13:
			var _g1 = _g.v;
			var _g1 = _g.it;
			var loop = _g.loop;
			return this.isBlock(loop);
		case 19:
			var _g1 = _g.e;
			if(_g.normalWhile == true) {
				var loop = _g.loop;
				return this.isBlock(loop);
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	,initVar: function(v) {
		switch(v.kind._hx_index) {
		case 0:case 2:
			var _g = v.type;
			var tmp;
			if(_g._hx_index == 16) {
				var _g1 = _g.t;
				var _g1 = _g.size;
				var _g1 = _g.kind;
				tmp = true;
			} else {
				tmp = false;
			}
			if(tmp) {
				this.buf.b += Std.string("layout(std140) ");
			}
			this.buf.b += Std.string("uniform ");
			break;
		case 1:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "attribute " : "in ");
			break;
		case 3:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "varying " : this.isVertex ? "out " : "in ");
			break;
		case 4:
			break;
		case 5:
			if(this.glES != null && this.glES <= 2) {
				this.outIndexes.h[v.id] = this.outIndex++;
				return;
			}
			if(this.isVertex) {
				return;
			}
			if(this.glES != null) {
				this.buf.b += Std.string("layout(location=" + this.outIndex++ + ") ");
			}
			this.buf.b += Std.string("out ");
			break;
		case 6:
			return;
		}
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				if(q._hx_index == 6) {
					var p = q.p;
					switch(p._hx_index) {
					case 0:
						this.buf.b += Std.string("lowp ");
						break;
					case 1:
						this.buf.b += Std.string("mediump ");
						break;
					case 2:
						this.buf.b += Std.string("highp ");
						break;
					}
				}
			}
		}
		this.addVar(v);
		this.buf.b += Std.string(";\n");
	}
	,initVars: function(s) {
		this.outIndex = 0;
		this.uniformBuffer = 0;
		this.outIndexes = new haxe_ds_IntMap();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.initVar(v);
		}
		this.buf.b += Std.string("\n");
		if(this.outIndex < 2) {
			this.outIndexes = null;
		} else if(!this.isVertex && (this.glES != null && this.glES <= 2)) {
			this.decl("#extension GL_EXT_draw_buffers : enable");
		}
	}
	,run: function(s) {
		this.locals = new haxe_ds_IntMap();
		this.decls = [];
		this.buf = new StringBuf();
		this.exprValues = [];
		if(s.funs.length != 1) {
			throw haxe_Exception.thrown("assert");
		}
		var f = s.funs[0];
		this.isVertex = f.kind == hxsl_FunctionKind.Vertex;
		if(this.isVertex) {
			this.decl("precision highp float;");
		} else {
			this.decl("precision mediump float;");
		}
		this.initVars(s);
		var tmp = this.buf;
		this.buf = new StringBuf();
		this.buf.b += Std.string("void main(void) {\n");
		var _g = f.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			var _g = 0;
			while(_g < el.length) {
				var e = el[_g];
				++_g;
				this.buf.b += Std.string("\t");
				this.addExpr(e,"\t");
				this.newLine(e);
			}
		} else {
			this.addExpr(f.expr,"");
		}
		if(this.isVertex) {
			this.buf.b += Std.string("\tgl_Position.z += gl_Position.z - gl_Position.w;\n");
		}
		this.buf.b += Std.string("}");
		this.exprValues.push(this.buf.b);
		this.buf = tmp;
		var locals = Lambda.array(this.locals);
		locals.sort(function(v1,v2) {
			return Reflect.compare(v1.name,v2.name);
		});
		var _g = 0;
		while(_g < locals.length) {
			var v = locals[_g];
			++_g;
			this.addVar(v);
			this.buf.b += Std.string(";\n");
		}
		this.buf.b += Std.string("\n");
		var _g = 0;
		var _g1 = this.exprValues;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			this.buf.b += Std.string(e);
			this.buf.b += Std.string("\n\n");
		}
		if(this.glES != null) {
			this.decl("#version " + (this.version < 100 ? 100 : this.version) + (this.version > 150 ? " es" : ""));
		} else if(this.version != null) {
			this.decl("#version " + (this.version > 150 ? 150 : this.version));
		} else {
			this.decl("#version 130");
		}
		this.decls.push(this.buf.b);
		this.buf = null;
		return this.decls.join("\n");
	}
	,__class__: hxsl_GlslOut
};
var hxsl__$Linker_AllocatedVar = function() {
};
$hxClasses["hxsl._Linker.AllocatedVar"] = hxsl__$Linker_AllocatedVar;
hxsl__$Linker_AllocatedVar.__name__ = "hxsl._Linker.AllocatedVar";
hxsl__$Linker_AllocatedVar.prototype = {
	__class__: hxsl__$Linker_AllocatedVar
};
var hxsl__$Linker_ShaderInfos = function(n,v) {
	this.name = n;
	this.uid = hxsl__$Linker_ShaderInfos.UID++;
	this.vertex = v;
	this.processed = new haxe_ds_IntMap();
	this.usedFunctions = [];
	this.readMap = new haxe_ds_IntMap();
	this.readVars = [];
	this.writeMap = new haxe_ds_IntMap();
	this.writeVars = [];
};
$hxClasses["hxsl._Linker.ShaderInfos"] = hxsl__$Linker_ShaderInfos;
hxsl__$Linker_ShaderInfos.__name__ = "hxsl._Linker.ShaderInfos";
hxsl__$Linker_ShaderInfos.prototype = {
	__class__: hxsl__$Linker_ShaderInfos
};
var hxsl_Linker = function(mode) {
	this.debugDepth = 0;
	this.mode = mode;
};
$hxClasses["hxsl.Linker"] = hxsl_Linker;
hxsl_Linker.__name__ = "hxsl.Linker";
hxsl_Linker.prototype = {
	debug: function(msg,pos) {
	}
	,error: function(msg,p) {
		return hxsl_Error.t(msg,p);
	}
	,mergeVar: function(path,v,v2,p,shaderName) {
		switch(v.kind._hx_index) {
		case 2:
			if(!(shaderName != null && hxsl_Tools.hasBorrowQualifier(v2,shaderName))) {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 0:case 1:case 3:case 4:case 5:
			break;
		case 6:
			throw haxe_Exception.thrown("assert");
		}
		if(v.kind != v2.kind && v.kind != hxsl_VarKind.Local && v2.kind != hxsl_VarKind.Local) {
			this.error("'" + path + "' kind does not match : " + Std.string(v.kind) + " should be " + Std.string(v2.kind),p);
		}
		var _g = v.type;
		var _g1 = v2.type;
		if(_g._hx_index == 13) {
			if(_g1._hx_index == 13) {
				var fl2 = _g1.vl;
				var fl1 = _g.vl;
				var _g = 0;
				while(_g < fl1.length) {
					var f1 = fl1[_g];
					++_g;
					var ft = null;
					var _g1 = 0;
					while(_g1 < fl2.length) {
						var f2 = fl2[_g1];
						++_g1;
						if(f1.name == f2.name) {
							ft = f2;
							break;
						}
					}
					if(ft == null) {
						fl2.push(this.allocVar(f1,p,shaderName).v);
					} else {
						this.mergeVar(path + "." + ft.name,f1,ft,p,shaderName);
					}
				}
			} else if(!Type.enumEq(v.type,v2.type)) {
				this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
			}
		} else if(!Type.enumEq(v.type,v2.type)) {
			this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
		}
	}
	,allocVar: function(v,p,shaderName,path,parent) {
		var _gthis = this;
		if(v.parent != null && parent == null) {
			parent = this.allocVar(v.parent,p,shaderName);
			var p1 = parent.v;
			path = p1.name;
			p1 = p1.parent;
			while(p1 != null) {
				path = p1.name + "." + path;
				p1 = p1.parent;
			}
		}
		var key = path == null ? v.name : path + "." + v.name;
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				if(q._hx_index == 4) {
					var n = q.n;
					key = n;
				}
			}
		}
		var v2 = this.varMap.h[key];
		var vname = v.name;
		if(v2 != null) {
			var _g = 0;
			var _g1 = v2.merged;
			while(_g < _g1.length) {
				var vm = _g1[_g];
				++_g;
				if(vm == v) {
					return v2;
				}
			}
			var tmp;
			var borrowed = hxsl_Tools.hasBorrowQualifier(v2.v,shaderName);
			if(!(v.kind == hxsl_VarKind.Param && !borrowed && !hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared) && !_gthis.isBatchShader || v.kind == hxsl_VarKind.Function || (v.kind == hxsl_VarKind.Var || v.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private))) {
				var v1 = v2.v;
				var borrowed = hxsl_Tools.hasBorrowQualifier(v,v2.rootShaderName);
				tmp = v1.kind == hxsl_VarKind.Param && !borrowed && !hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared) && !_gthis.isBatchShader || v1.kind == hxsl_VarKind.Function || (v1.kind == hxsl_VarKind.Var || v1.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private);
			} else {
				tmp = true;
			}
			if(tmp || v.kind == hxsl_VarKind.Param && v2.v.kind == hxsl_VarKind.Param) {
				var k = 2;
				while(true) {
					var a = this.varMap.h[key + k];
					if(a == null) {
						break;
					}
					var _g = 0;
					var _g1 = a.merged;
					while(_g < _g1.length) {
						var vm = _g1[_g];
						++_g;
						if(vm == v) {
							return a;
						}
					}
					++k;
				}
				if(v.kind == hxsl_VarKind.Input) {
					var _this = this.varMap;
					if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
						delete(_this.h[key]);
					}
					this.varMap.h[key + k] = v2;
					v2.v.name += k;
					v2.path += k;
				} else {
					vname += k;
					key += k;
				}
			} else {
				v2.merged.push(v);
				this.mergeVar(key,v,v2.v,p,v2.rootShaderName);
				this.varIdMap.h[v.id] = v2.id;
				return v2;
			}
		}
		var v2 = { id : hxsl_Tools.allocVarId(), name : vname, type : v.type, kind : v.kind, qualifiers : v.qualifiers, parent : parent == null ? null : parent.v};
		var a = new hxsl__$Linker_AllocatedVar();
		a.v = v2;
		a.merged = [v];
		a.path = key;
		a.id = v2.id;
		a.parent = parent;
		a.instanceIndex = this.curInstance;
		a.rootShaderName = shaderName;
		this.allVars.push(a);
		this.varMap.h[key] = a;
		var _g = v2.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = [];
			var _g1 = 0;
			while(_g1 < vl.length) {
				var v = vl[_g1];
				++_g1;
				_g.push(this.allocVar(v,p,shaderName,key,a).v);
			}
			v2.type = hxsl_Type.TStruct(_g);
		}
		return a;
	}
	,mapExprVar: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			if(!this.locals.h.hasOwnProperty(v.id)) {
				var v1 = this.allocVar(v,e.p);
				if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
					if(!this.curShader.readMap.h.hasOwnProperty(v1.id)) {
						this.curShader.readMap.h[v1.id] = v1;
						this.curShader.readVars.push(v1);
					}
					if(this.curShader.vertex == null && v1.v.kind == hxsl_VarKind.Var) {
						this.curShader.vertex = false;
					}
				}
				return { e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p};
			}
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			var _g1 = e1.e;
			switch(op._hx_index) {
			case 4:
				switch(_g1._hx_index) {
				case 1:
					var _g2 = _g1.v;
					var v = _g2;
					if(!this.locals.h.hasOwnProperty(v.id)) {
						var e21 = this.mapExprVar(e2);
						var v1 = this.allocVar(v,e1.p);
						if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
							this.curShader.writeMap.h[v1.id] = v1;
							this.curShader.writeVars.push(v1);
						}
						return { e : hxsl_TExprDef.TBinop(op,{ e : hxsl_TExprDef.TVar(v1.v), t : v1.v.type, p : e.p},e21), t : e.t, p : e.p};
					} else {
						var v = _g2;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
								this.curShader.writeMap.h[v1.id] = v1;
								this.curShader.writeVars.push(v1);
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g3 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g3._hx_index == 1) {
						var v = _g3.v;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
								this.curShader.writeMap.h[v1.id] = v1;
								this.curShader.writeVars.push(v1);
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			case 20:
				var _g2 = op.op;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					if(!this.locals.h.hasOwnProperty(v.id)) {
						var e11 = this.mapExprVar(e1);
						var e21 = this.mapExprVar(e2);
						var v1 = this.allocVar(v,e11.p);
						if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
							this.curShader.writeMap.h[v1.id] = v1;
							this.curShader.writeVars.push(v1);
						}
						return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
					}
					break;
				case 9:
					var _g2 = _g1.e;
					var _g3 = _g1.regs;
					var _g1 = _g2.e;
					var _g3 = _g2.p;
					var _g3 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						if(!this.locals.h.hasOwnProperty(v.id)) {
							var e11 = this.mapExprVar(e1);
							var e21 = this.mapExprVar(e2);
							var v1 = this.allocVar(v,e11.p);
							if(this.curShader != null && !this.curShader.writeMap.h.hasOwnProperty(v1.id)) {
								this.curShader.writeMap.h[v1.id] = v1;
								this.curShader.writeVars.push(v1);
							}
							return { e : hxsl_TExprDef.TBinop(op,e11,e21), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 7:
			var _g1 = _g.init;
			var v = _g.v;
			this.locals.h[v.id] = true;
			break;
		case 11:
			if(this.curShader != null) {
				this.curShader.vertex = false;
				this.curShader.hasDiscard = true;
			}
			break;
		case 13:
			var _g1 = _g.it;
			var _g1 = _g.loop;
			var v = _g.v;
			this.locals.h[v.id] = true;
			break;
		default:
		}
		return hxsl_Tools.map(e,$bind(this,this.mapExprVar));
	}
	,addShader: function(name,vertex,e,p) {
		var s = new hxsl__$Linker_ShaderInfos(name,vertex);
		this.curShader = s;
		s.priority = p;
		s.body = this.mapExprVar(e);
		this.shaders.push(s);
		this.curShader = null;
		return s;
	}
	,sortByPriorityDesc: function(s1,s2) {
		if(s1.priority == s2.priority) {
			return s1.uid - s2.uid;
		}
		return s2.priority - s1.priority;
	}
	,buildDependency: function(s,v,isWritten) {
		var found = !isWritten;
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var parent = _g1[_g];
			++_g;
			if(parent == s) {
				found = true;
				continue;
			} else if(!found) {
				continue;
			}
			if(!parent.writeMap.h.hasOwnProperty(v.id)) {
				continue;
			}
			if(s.vertex) {
				if(parent.vertex == false) {
					continue;
				}
				if(parent.vertex == null) {
					parent.vertex = true;
				}
			}
			s.deps.set(parent,true);
			this.debugDepth++;
			this.initDependencies(parent);
			this.debugDepth--;
			if(!parent.readMap.h.hasOwnProperty(v.id)) {
				return;
			}
		}
		if(v.v.kind == hxsl_VarKind.Var) {
			this.error("Variable " + v.path + " required by " + s.name + " is missing initializer",null);
		}
	}
	,initDependencies: function(s) {
		if(s.deps != null) {
			return;
		}
		s.deps = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.readVars;
		while(_g < _g1.length) {
			var r = _g1[_g];
			++_g;
			this.buildDependency(s,r,s.writeMap.h.hasOwnProperty(r.id));
		}
		if(s.vertex == null) {
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.vertex == false) {
					s.vertex = false;
					break;
				}
			}
		}
		if(s.vertex) {
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.vertex == null) {
					d1.vertex = true;
				}
			}
		}
	}
	,collect: function(cur,out,vertex) {
		if(cur.onStack) {
			this.error("Loop in shader dependencies (" + cur.name + ")",null);
		}
		if(cur.marked == vertex) {
			return;
		}
		cur.marked = vertex;
		cur.onStack = true;
		var _g = [];
		var d = cur.deps.keys();
		while(d.hasNext()) {
			var d1 = d.next();
			_g.push(d1);
		}
		var deps = _g;
		deps.sort($bind(this,this.sortByPriorityDesc));
		var _g = 0;
		while(_g < deps.length) {
			var d = deps[_g];
			++_g;
			this.collect(d,out,vertex);
		}
		if(cur.vertex == null) {
			cur.vertex = vertex;
		}
		if(cur.vertex == vertex) {
			out.push(cur);
		}
		cur.onStack = false;
	}
	,link: function(shadersData) {
		this.varMap = new haxe_ds_StringMap();
		this.varIdMap = new haxe_ds_IntMap();
		this.allVars = [];
		this.shaders = [];
		this.locals = new haxe_ds_IntMap();
		var dupShaders = [];
		var _g = [];
		var _g_current = 0;
		var _g_array = shadersData;
		while(_g_current < _g_array.length) {
			var _g_value = _g_array[_g_current];
			var _g_key = _g_current++;
			var i = _g_key;
			var s = _g_value;
			if(shadersData.indexOf(s) < i) {
				var s2 = hxsl_Clone.shaderData(s);
				dupShaders.push({ origin : s, cloned : s2});
				_g.push(s2);
			} else {
				_g.push(s);
			}
		}
		shadersData = _g;
		this.curInstance = 0;
		var outVars = [];
		var _g = 0;
		while(_g < shadersData.length) {
			var s = shadersData[_g];
			++_g;
			this.isBatchShader = this.mode == hxsl_LinkMode.Batch && StringTools.startsWith(s.name,"batchShader_");
			var _g1 = 0;
			var _g2 = s.vars;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				var v2 = this.allocVar(v,null,s.name);
				if(this.isBatchShader && v2.v.kind == hxsl_VarKind.Param && !StringTools.startsWith(v2.path,"Batch_")) {
					v2.v.kind = hxsl_VarKind.Local;
				}
				if(v.kind == hxsl_VarKind.Output) {
					outVars.push(v);
				}
			}
			var _g3 = 0;
			var _g4 = s.funs;
			while(_g3 < _g4.length) {
				var f = _g4[_g3];
				++_g3;
				var v1 = this.allocVar(f.ref,f.expr.p);
				v1.kind = f.kind;
			}
			this.curInstance++;
		}
		var priority = 0;
		var initPrio_init = [-3000];
		var initPrio_vert = [-2000];
		var initPrio_frag = [-1000];
		var _g = 0;
		while(_g < shadersData.length) {
			var s = shadersData[_g];
			++_g;
			var _g1 = 0;
			var _g2 = s.funs;
			while(_g1 < _g2.length) {
				var f = _g2[_g1];
				++_g1;
				var v = this.allocVar(f.ref,f.expr.p);
				if(v.kind == null) {
					throw haxe_Exception.thrown("assert");
				}
				switch(v.kind._hx_index) {
				case 0:case 1:
					if(this.mode == hxsl_LinkMode.Compute) {
						var e = v.kind;
						throw haxe_Exception.thrown("Unexpected " + $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name.toLowerCase() + "() function in compute shader");
					}
					this.addShader(s.name + "." + (v.kind == hxsl_FunctionKind.Vertex ? "vertex" : "fragment"),v.kind == hxsl_FunctionKind.Vertex,f.expr,priority);
					break;
				case 2:
					var prio;
					var status;
					switch(f.ref.name) {
					case "__init__fragment":
						prio = initPrio_frag;
						status = false;
						break;
					case "__init__vertex":
						prio = initPrio_vert;
						status = true;
						break;
					default:
						prio = initPrio_init;
						status = null;
					}
					var _g3 = f.expr.e;
					if(_g3._hx_index == 4) {
						var el = _g3.el;
						var index = 0;
						var _g4 = 0;
						while(_g4 < el.length) {
							var e1 = el[_g4];
							++_g4;
							this.addShader(s.name + "." + f.ref.name + index++,status,e1,prio[0]++);
						}
					} else {
						this.addShader(s.name + "." + f.ref.name,status,f.expr,prio[0]++);
					}
					break;
				case 3:
					throw haxe_Exception.thrown("Unexpected helper function in linker " + v.v.name);
				case 4:
					if(this.mode != hxsl_LinkMode.Compute) {
						throw haxe_Exception.thrown("Unexpected main() outside compute shader");
					}
					this.addShader(s.name,true,f.expr,priority).isCompute = true;
					break;
				}
			}
			++priority;
		}
		this.shaders.sort($bind(this,this.sortByPriorityDesc));
		var uid = 0;
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.uid = uid++;
		}
		var entry = new hxsl__$Linker_ShaderInfos("<entry>",false);
		entry.deps = new haxe_ds_ObjectMap();
		var _g = 0;
		while(_g < outVars.length) {
			var v = outVars[_g];
			++_g;
			this.buildDependency(entry,this.allocVar(v,null),false);
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.hasDiscard || s.isCompute) {
				this.initDependencies(s);
				entry.deps.set(s,true);
			}
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(s.vertex != null) {
				continue;
			}
			var onlyParams = true;
			var _g2 = 0;
			var _g3 = s.readVars;
			while(_g2 < _g3.length) {
				var r = _g3[_g2];
				++_g2;
				if(r.v.kind != hxsl_VarKind.Param) {
					onlyParams = false;
					break;
				}
			}
			if(onlyParams) {
				s.vertex = false;
			}
		}
		var v = [];
		var f = [];
		this.collect(entry,v,true);
		this.collect(entry,f,false);
		if(f.pop() != entry) {
			throw haxe_Exception.thrown("assert");
		}
		var _g = 0;
		var _g1 = this.shaders;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			s.marked = null;
		}
		var _g = 0;
		var _g1 = v.concat(f);
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var d = s.deps.keys();
			while(d.hasNext()) {
				var d1 = d.next();
				if(d1.marked == null) {
					this.error(d1.name + " needed by " + s.name + " is unreachable",null);
				}
			}
			s.marked = true;
		}
		var outVars = [];
		var varMap_h = { };
		var addVar = null;
		addVar = function(v) {
			if(varMap_h.hasOwnProperty(v.id)) {
				return;
			}
			varMap_h[v.id] = true;
			if(v.v.parent != null) {
				addVar(v.parent);
			} else {
				outVars.push(v.v);
			}
		};
		var _g = 0;
		var _g1 = v.concat(f);
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = s.readVars;
			while(_g2 < _g3.length) {
				var v1 = _g3[_g2];
				++_g2;
				addVar(v1);
			}
			var _g4 = 0;
			var _g5 = s.writeVars;
			while(_g4 < _g5.length) {
				var v2 = _g5[_g4];
				++_g4;
				addVar(v2);
			}
		}
		var cleanVar = null;
		cleanVar = function(v) {
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				if(v.kind != hxsl_VarKind.Input) {
					var vout = [];
					var _g = 0;
					while(_g < vl.length) {
						var v1 = vl[_g];
						++_g;
						if(varMap_h.hasOwnProperty(v1.id)) {
							cleanVar(v1);
							vout.push(v1);
						}
					}
					v.type = hxsl_Type.TStruct(vout);
				}
			}
		};
		var _g = 0;
		while(_g < outVars.length) {
			var v1 = outVars[_g];
			++_g;
			cleanVar(v1);
		}
		var build = function(kind,name,a) {
			var v = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TFun([{ ret : hxsl_Type.TVoid, args : []}]), kind : hxsl_VarKind.Function};
			outVars.push(v);
			var exprs = [];
			var _g = 0;
			while(_g < a.length) {
				var s = a[_g];
				++_g;
				var _g1 = s.body.e;
				if(_g1._hx_index == 4) {
					var el = _g1.el;
					var _g2 = 0;
					while(_g2 < el.length) {
						var e = el[_g2];
						++_g2;
						exprs.push(e);
					}
				} else {
					exprs.push(s.body);
				}
			}
			var expr = { e : hxsl_TExprDef.TBlock(exprs), t : hxsl_Type.TVoid, p : exprs.length == 0 ? null : exprs[0].p};
			return { kind : kind, ref : v, ret : hxsl_Type.TVoid, args : [], expr : expr};
		};
		var funs = this.mode == hxsl_LinkMode.Compute ? [build(hxsl_FunctionKind.Main,"main",v)] : [build(hxsl_FunctionKind.Vertex,"vertex",v),build(hxsl_FunctionKind.Fragment,"fragment",f)];
		var _g = 0;
		while(_g < dupShaders.length) {
			var d = dupShaders[_g];
			++_g;
			var _g1 = 0;
			var _g2 = d.cloned.vars.length;
			while(_g1 < _g2) {
				var i = _g1++;
				this.allocVar(d.cloned.vars[i],null).merged.unshift(d.origin.vars[i]);
			}
		}
		return { name : "out", vars : outVars, funs : funs};
	}
	,__class__: hxsl_Linker
};
var hxsl_Output = $hxEnums["hxsl.Output"] = { __ename__:"hxsl.Output",__constructs__:null
	,Const: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["v"],$_)
	,Value: ($_=function(v,size) { return {_hx_index:1,v:v,size:size,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Value",$_.__params__ = ["v","size"],$_)
	,PackNormal: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackNormal",$_.__params__ = ["v"],$_)
	,PackFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackFloat",$_.__params__ = ["v"],$_)
	,Vec2: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec2",$_.__params__ = ["a"],$_)
	,Vec3: ($_=function(a) { return {_hx_index:5,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec3",$_.__params__ = ["a"],$_)
	,Vec4: ($_=function(a) { return {_hx_index:6,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec4",$_.__params__ = ["a"],$_)
	,Swiz: ($_=function(a,swiz) { return {_hx_index:7,a:a,swiz:swiz,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Swiz",$_.__params__ = ["a","swiz"],$_)
};
hxsl_Output.__constructs__ = [hxsl_Output.Const,hxsl_Output.Value,hxsl_Output.PackNormal,hxsl_Output.PackFloat,hxsl_Output.Vec2,hxsl_Output.Vec3,hxsl_Output.Vec4,hxsl_Output.Swiz];
hxsl_Output.__empty_constructs__ = [];
var hxsl_Printer = function(varId) {
	if(varId == null) {
		varId = false;
	}
	this.varId = varId;
};
$hxClasses["hxsl.Printer"] = hxsl_Printer;
hxsl_Printer.__name__ = "hxsl.Printer";
hxsl_Printer.opStr = function(op) {
	switch(op._hx_index) {
	case 0:
		return "+";
	case 1:
		return "*";
	case 2:
		return "/";
	case 3:
		return "-";
	case 4:
		return "=";
	case 5:
		return "==";
	case 6:
		return "!=";
	case 7:
		return ">";
	case 8:
		return ">=";
	case 9:
		return "<";
	case 10:
		return "<=";
	case 11:
		return "&";
	case 12:
		return "|";
	case 13:
		return "^";
	case 14:
		return "&&";
	case 15:
		return "||";
	case 16:
		return "<<";
	case 17:
		return ">>";
	case 18:
		return ">>>";
	case 19:
		return "%";
	case 20:
		var op1 = op.op;
		return hxsl_Printer.opStr(op1) + "=";
	case 21:
		return "...";
	case 22:
		return "=>";
	default:
		return "??" + Std.string(op);
	}
};
hxsl_Printer.toString = function(e,varId) {
	if(varId == null) {
		varId = false;
	}
	return new hxsl_Printer(varId).exprString(e);
};
hxsl_Printer.shaderToString = function(s,varId) {
	if(varId == null) {
		varId = false;
	}
	return new hxsl_Printer(varId).shaderString(s);
};
hxsl_Printer.check = function(s,from) {
	try {
		var vars = new haxe_ds_IntMap();
		var regVars = [];
		var regVar = null;
		regVar = function(v,reg) {
			if(reg) {
				if(vars.h.hasOwnProperty(v.id)) {
					throw haxe_Exception.thrown("Duplicate var " + v.id);
				}
				vars.h[v.id] = v;
				regVars.push(v);
			} else {
				vars.remove(v.id);
			}
			var _g = v.type;
			if(_g._hx_index == 13) {
				var vl = _g.vl;
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					regVar(v,reg);
				}
			}
		};
		var checkExpr = null;
		checkExpr = function(e) {
			var _g = e.e;
			switch(_g._hx_index) {
			case 1:
				var v = _g.v;
				if(!vars.h.hasOwnProperty(v.id)) {
					throw haxe_Exception.thrown("Unbound var " + v.name + "@" + v.id);
				}
				break;
			case 4:
				var el = _g.el;
				var old = regVars;
				regVars = [];
				var _g1 = 0;
				while(_g1 < el.length) {
					var e1 = el[_g1];
					++_g1;
					checkExpr(e1);
				}
				var _g1 = 0;
				while(_g1 < regVars.length) {
					var v = regVars[_g1];
					++_g1;
					regVar(v,false);
				}
				regVars = old;
				break;
			case 7:
				var v = _g.v;
				var init = _g.init;
				if(init != null) {
					checkExpr(init);
				}
				regVar(v,true);
				break;
			case 13:
				var v = _g.v;
				var it = _g.it;
				var loop = _g.loop;
				checkExpr(it);
				regVar(v,true);
				checkExpr(loop);
				regVar(v,false);
				break;
			default:
				hxsl_Tools.iter(e,checkExpr);
			}
		};
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			regVar(v,true);
		}
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = f.args;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				regVar(v,true);
			}
			checkExpr(f.expr);
			var _g4 = 0;
			var _g5 = f.args;
			while(_g4 < _g5.length) {
				var v1 = _g5[_g4];
				++_g4;
				regVar(v1,false);
			}
		}
	} catch( _g ) {
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(typeof(_g1) == "string") {
			var e = _g1;
			var msg = e + "\n    in\n" + hxsl_Printer.shaderToString(s,true);
			if(from != null) {
				var _g1 = [];
				var _g2 = 0;
				while(_g2 < from.length) {
					var s = from[_g2];
					++_g2;
					_g1.push(hxsl_Printer.shaderToString(s,true));
				}
				msg += "\n    from\n\n" + _g1.join("\n\n");
			}
			throw haxe_Exception.thrown(msg);
		} else {
			throw _g;
		}
	}
};
hxsl_Printer.prototype = {
	add: function(v) {
		this.buffer.b += Std.string(v);
	}
	,shaderString: function(s) {
		this.buffer = new StringBuf();
		var _g = 0;
		var _g1 = s.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.addVar(v,null);
			this.buffer.b += Std.string(";\n");
		}
		if(s.vars.length > 0) {
			this.buffer.b += Std.string("\n");
		}
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.addFun(f);
			this.buffer.b += Std.string("\n\n");
		}
		return this.buffer.b;
	}
	,varString: function(v) {
		this.buffer = new StringBuf();
		this.addVar(v,null);
		return this.buffer.b;
	}
	,funString: function(f) {
		this.buffer = new StringBuf();
		this.addFun(f);
		return this.buffer.b;
	}
	,exprString: function(e) {
		this.buffer = new StringBuf();
		this.addExpr(e,"");
		return this.buffer.b;
	}
	,addVar: function(v,defKind,tabs,parent) {
		if(tabs == null) {
			tabs = "";
		}
		if(v.qualifiers != null) {
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				var v1;
				switch(q._hx_index) {
				case 0:
					var max = q.max;
					v1 = "const" + (max == null ? "" : "(" + max + ")");
					break;
				case 1:
					v1 = "private";
					break;
				case 2:
					v1 = "nullable";
					break;
				case 3:
					v1 = "perObject";
					break;
				case 4:
					var n = q.n;
					v1 = "name('" + n + "')";
					break;
				case 5:
					v1 = "shared";
					break;
				case 6:
					var p = q.p;
					v1 = $hxEnums[p.__enum__].__constructs__[p._hx_index]._hx_name.toLowerCase() + "p";
					break;
				case 7:
					var min = q.min;
					var max1 = q.max;
					v1 = "range(" + min + "," + max1 + ")";
					break;
				case 8:
					v1 = "ignore";
					break;
				case 9:
					var n1 = q.v;
					v1 = "perInstance(" + n1 + ")";
					break;
				case 10:
					var s = q.s;
					v1 = "doc(\"" + StringTools.replace(s,"\"","\\\"") + "\")";
					break;
				case 11:
					var s1 = q.source;
					v1 = "borrow(" + s1 + ")";
					break;
				case 12:
					var s2 = q.name;
					v1 = "sampler(" + s2 + ")";
					break;
				}
				this.buffer.b += Std.string("@" + v1 + " ");
			}
		}
		if(v.kind != defKind) {
			switch(v.kind._hx_index) {
			case 0:
				this.buffer.b += Std.string("@global ");
				break;
			case 1:
				this.buffer.b += Std.string("@input ");
				break;
			case 2:
				this.buffer.b += Std.string("@param ");
				break;
			case 3:
				this.buffer.b += Std.string("@varying ");
				break;
			case 4:
				this.buffer.b += Std.string("@local ");
				break;
			case 5:
				this.buffer.b += Std.string("@output ");
				break;
			case 6:
				this.buffer.b += Std.string("@function ");
				break;
			}
		}
		this.buffer.b += Std.string("var ");
		if(v.parent == parent) {
			this.buffer.b += Std.string(v.name + (this.varId ? "@" + v.id : ""));
		} else {
			this.addVarName(v);
		}
		this.buffer.b += Std.string(" : ");
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			this.buffer.b += Std.string("{");
			var first = true;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addVar(v1,v1.kind,tabs,v1);
			}
			this.buffer.b += Std.string("}");
		} else {
			var v1 = hxsl_Tools.toString(v.type);
			this.buffer.b += Std.string(v1);
		}
	}
	,addFun: function(f) {
		this.buffer.b += Std.string("function " + f.ref.name + "(");
		var first = true;
		var _g = 0;
		var _g1 = f.args;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(first) {
				this.buffer.b += Std.string(" ");
				first = false;
			} else {
				this.buffer.b += Std.string(", ");
			}
			this.addVar(a,hxsl_VarKind.Local);
		}
		if(f.args.length > 0) {
			this.buffer.b += Std.string(" ");
		}
		var v = ") : " + hxsl_Tools.toString(f.ret) + " ";
		this.buffer.b += Std.string(v);
		this.addExpr(f.expr,"");
	}
	,addVarName: function(v) {
		if(v.parent != null) {
			this.addVarName(v.parent);
			this.buffer.b += Std.string(".");
		}
		this.buffer.b += Std.string(v.name);
		if(this.varId) {
			this.buffer.b += Std.string("@" + v.id);
		}
	}
	,addConst: function(c) {
		var _this = this.buffer;
		var _this1 = _this.b;
		var tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "null";
			break;
		case 1:
			var b = c.b;
			tmp = b;
			break;
		case 2:
			var i = c.v;
			tmp = i;
			break;
		case 3:
			var f = c.v;
			tmp = f;
			break;
		case 4:
			var s = c.v;
			tmp = "\"" + s + "\"";
			break;
		}
		_this.b = _this1 + Std.string(tmp);
	}
	,addExpr: function(e,tabs) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			this.addConst(c);
			break;
		case 1:
			var v = _g.v;
			this.addVarName(v);
			break;
		case 2:
			var g = _g.g;
			var v = hxsl_Tools2.toString(g);
			this.buffer.b += Std.string(v);
			break;
		case 3:
			var e = _g.e;
			this.buffer.b += Std.string("(");
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(")");
			break;
		case 4:
			var el = _g.el;
			this.buffer.b += Std.string("{");
			tabs += "\t";
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				this.buffer.b += Std.string("\n" + tabs);
				this.addExpr(e,tabs);
				this.buffer.b += Std.string(";");
			}
			tabs = HxOverrides.substr(tabs,1,null);
			if(el.length > 0) {
				this.buffer.b += Std.string("\n" + tabs);
			}
			this.buffer.b += Std.string("}");
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			this.addExpr(e1,tabs);
			var v = " " + hxsl_Printer.opStr(op) + " ";
			this.buffer.b += Std.string(v);
			this.addExpr(e2,tabs);
			break;
		case 6:
			var op = _g.op;
			var e = _g.e1;
			var v;
			switch(op._hx_index) {
			case 0:
				v = "++";
				break;
			case 1:
				v = "--";
				break;
			case 2:
				v = "!";
				break;
			case 3:
				v = "-";
				break;
			case 4:
				v = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buffer.b += Std.string(v);
			this.addExpr(e,tabs);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.addVar(v,hxsl_VarKind.Local,tabs);
			if(init != null) {
				this.buffer.b += Std.string(" = ");
				this.addExpr(init,tabs);
			}
			break;
		case 8:
			var e = _g.e;
			var el = _g.args;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string("(");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += Std.string(")");
			break;
		case 9:
			var e = _g.e;
			var regs = _g.regs;
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(".");
			var _g1 = 0;
			while(_g1 < regs.length) {
				var r = regs[_g1];
				++_g1;
				this.buffer.b += Std.string(hxsl_Printer.SWIZ[r._hx_index]);
			}
			break;
		case 10:
			var cond = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.buffer.b += Std.string("if( ");
			this.addExpr(cond,tabs);
			this.buffer.b += Std.string(" ) ");
			this.addExpr(eif,tabs);
			if(eelse != null) {
				this.buffer.b += Std.string(" else ");
				this.addExpr(eelse,tabs);
			}
			break;
		case 11:
			this.buffer.b += Std.string("discard");
			break;
		case 12:
			var e = _g.e;
			this.buffer.b += Std.string("return");
			if(e != null) {
				this.buffer.b += Std.string(" ");
				this.addExpr(e,tabs);
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.buffer.b += Std.string("for( ");
			this.addVarName(v);
			this.buffer.b += Std.string(" in ");
			this.addExpr(it,tabs);
			this.buffer.b += Std.string(" ) ");
			this.addExpr(loop,tabs);
			break;
		case 14:
			this.buffer.b += Std.string("continue");
			break;
		case 15:
			this.buffer.b += Std.string("break");
			break;
		case 16:
			var e1 = _g.e;
			var e2 = _g.index;
			this.addExpr(e1,tabs);
			this.buffer.b += Std.string("[");
			this.addExpr(e2,tabs);
			this.buffer.b += Std.string("]");
			break;
		case 17:
			var el = _g.el;
			this.buffer.b += Std.string("[");
			var first = true;
			var _g1 = 0;
			while(_g1 < el.length) {
				var e = el[_g1];
				++_g1;
				if(first) {
					first = false;
				} else {
					this.buffer.b += Std.string(", ");
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += Std.string("]");
			break;
		case 18:
			var e = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			this.buffer.b += Std.string("switch( ");
			this.addExpr(e,tabs);
			this.buffer.b += Std.string(") {");
			var old = tabs;
			var _g1 = 0;
			while(_g1 < cases.length) {
				var c = cases[_g1];
				++_g1;
				this.buffer.b += Std.string("\n" + tabs);
				this.buffer.b += Std.string("case ");
				var first = true;
				var _g2 = 0;
				var _g3 = c.values;
				while(_g2 < _g3.length) {
					var v = _g3[_g2];
					++_g2;
					if(first) {
						first = false;
					} else {
						this.buffer.b += Std.string(", ");
					}
					this.addExpr(v,tabs);
				}
				tabs += "\t";
				this.buffer.b += Std.string(":\n" + tabs);
				this.addExpr(c.expr,tabs);
				tabs = old;
			}
			if(def != null) {
				this.buffer.b += Std.string("\n" + tabs);
				tabs += "\t";
				this.buffer.b += Std.string("default:\n" + tabs);
				this.addExpr(def,tabs);
				tabs = old;
			}
			this.buffer.b += Std.string("\n" + tabs + "}");
			break;
		case 19:
			var _g1 = _g.e;
			var _g2 = _g.loop;
			if(_g.normalWhile == false) {
				var loop = _g2;
				var e = _g1;
				var old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string("do {\n" + tabs);
				this.addExpr(loop,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + tabs + "} while( ");
				this.addExpr(e,tabs);
				this.buffer.b += Std.string(" )");
			} else {
				var loop = _g2;
				var e = _g1;
				this.buffer.b += Std.string("while( ");
				this.addExpr(e,tabs);
				var old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string(" ) {\n" + tabs);
				this.addExpr(loop,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + tabs + "}");
			}
			break;
		case 20:
			var m = _g.m;
			var args = _g.args;
			var e = _g.e;
			this.buffer.b += Std.string("@");
			this.buffer.b += Std.string(m);
			if(args.length > 0) {
				this.buffer.b += Std.string("(");
				var first = true;
				var _g = 0;
				while(_g < args.length) {
					var c = args[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buffer.b += Std.string(", ");
					}
					this.addConst(c);
				}
				this.buffer.b += Std.string(")");
			}
			this.buffer.b += Std.string(" ");
			this.addExpr(e,tabs);
			break;
		}
	}
	,__class__: hxsl_Printer
};
var hxsl_LinkMode = $hxEnums["hxsl.LinkMode"] = { __ename__:"hxsl.LinkMode",__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"hxsl.LinkMode",toString:$estr}
	,Batch: {_hx_name:"Batch",_hx_index:1,__enum__:"hxsl.LinkMode",toString:$estr}
	,Compute: {_hx_name:"Compute",_hx_index:2,__enum__:"hxsl.LinkMode",toString:$estr}
};
hxsl_LinkMode.__constructs__ = [hxsl_LinkMode.Default,hxsl_LinkMode.Batch,hxsl_LinkMode.Compute];
hxsl_LinkMode.__empty_constructs__ = [hxsl_LinkMode.Default,hxsl_LinkMode.Batch,hxsl_LinkMode.Compute];
var hxsl_AllocParam = function(name,pos,instance,index,type) {
	this.name = name;
	this.pos = pos;
	this.instance = instance;
	this.index = index;
	this.type = type;
};
$hxClasses["hxsl.AllocParam"] = hxsl_AllocParam;
hxsl_AllocParam.__name__ = "hxsl.AllocParam";
hxsl_AllocParam.prototype = {
	clone: function(resetGID) {
		if(resetGID == null) {
			resetGID = false;
		}
		var p = new hxsl_AllocParam(this.name,this.pos,this.instance,this.index,this.type);
		if(this.perObjectGlobal != null) {
			p.perObjectGlobal = this.perObjectGlobal.clone(resetGID);
		}
		if(this.next != null) {
			p.next = this.next.clone(resetGID);
		}
		return p;
	}
	,__class__: hxsl_AllocParam
};
var hxsl_AllocGlobal = function(pos,path,type) {
	this.pos = pos;
	this.path = path;
	this.gid = hxsl_Globals.allocID(path);
	this.type = type;
};
$hxClasses["hxsl.AllocGlobal"] = hxsl_AllocGlobal;
hxsl_AllocGlobal.__name__ = "hxsl.AllocGlobal";
hxsl_AllocGlobal.prototype = {
	clone: function(resetGID) {
		if(resetGID == null) {
			resetGID = false;
		}
		var g = new hxsl_AllocGlobal(this.pos,this.path,this.type);
		if(this.next != null) {
			g.next = this.next.clone(resetGID);
		}
		if(resetGID) {
			g.gid = 0;
		}
		return g;
	}
	,__class__: hxsl_AllocGlobal
};
var hxsl_RuntimeShaderData = function() {
};
$hxClasses["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData;
hxsl_RuntimeShaderData.__name__ = "hxsl.RuntimeShaderData";
hxsl_RuntimeShaderData.prototype = {
	__class__: hxsl_RuntimeShaderData
};
var hxsl_ShaderInstanceDesc = function(shader,bits) {
	this.shader = shader;
	this.bits = bits;
};
$hxClasses["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc;
hxsl_ShaderInstanceDesc.__name__ = "hxsl.ShaderInstanceDesc";
hxsl_ShaderInstanceDesc.prototype = {
	__class__: hxsl_ShaderInstanceDesc
};
var hxsl_RuntimeShader = function() {
	this.id = hxsl_RuntimeShader.UID++;
};
$hxClasses["hxsl.RuntimeShader"] = hxsl_RuntimeShader;
hxsl_RuntimeShader.__name__ = "hxsl.RuntimeShader";
hxsl_RuntimeShader.prototype = {
	get_compute: function() {
		return this.vertex;
	}
	,set_compute: function(v) {
		return this.vertex = v;
	}
	,hasGlobal: function(gid) {
		return this.globals.h.hasOwnProperty(gid);
	}
	,getShaders: function() {
		if(this.mode == hxsl_LinkMode.Compute) {
			return [this.vertex];
		} else {
			return [this.vertex,this.fragment];
		}
	}
	,__class__: hxsl_RuntimeShader
};
var hxsl_Serializer = function() {
	this.tid = 1;
	this.uid = 1;
};
$hxClasses["hxsl.Serializer"] = hxsl_Serializer;
hxsl_Serializer.__name__ = "hxsl.Serializer";
hxsl_Serializer.run = function(s) {
	return new hxsl_Serializer().serialize(s);
};
hxsl_Serializer.prototype = {
	writeArr: function(arr,f) {
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f(v);
		}
	}
	,readArr: function(f) {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return _g;
	}
	,readVarInt: function() {
		var b = this.input.readByte();
		if(b < 128) {
			return b;
		}
		if(b == 255) {
			return this.input.readInt32();
		}
		return (b & 127) << 8 | this.input.readByte();
	}
	,writeVarInt: function(id) {
		if(id < 128) {
			this.out.addByte(id);
		} else {
			var n = id >> 8;
			if(n >= 127) {
				this.out.addByte(255);
				this.out.addInt32(n);
			} else {
				this.out.addByte(n | 128);
				this.out.addByte(id & 255);
			}
		}
	}
	,writeID: function(id) {
		var id2 = this.idMap.h[id];
		if(id2 == null) {
			id2 = this.uid++;
			this.idMap.h[id] = id2;
		}
		this.writeVarInt(id2);
	}
	,readID: function() {
		return this.readVarInt();
	}
	,writeTID: function(t) {
		var tid = this.typeIdMap.get(t);
		if(tid != null) {
			this.writeVarInt(tid);
			return false;
		}
		tid = this.tid++;
		this.typeIdMap.set(t,tid);
		this.writeVarInt(tid);
		return true;
	}
	,writeType: function(t) {
		this.out.addByte(t._hx_index);
		switch(t._hx_index) {
		case 5:
			var size = t.size;
			var t1 = t.t;
			this.out.addByte(size | t1._hx_index << 3);
			break;
		case 9:
			var size = t.size;
			this.out.addInt32(size);
			break;
		case 0:case 1:case 2:case 3:case 4:case 6:case 7:case 8:case 10:case 11:case 12:case 18:
			break;
		case 13:
			var vl = t.vl;
			if(this.writeTID(t)) {
				var f = $bind(this,this.writeVar);
				this.writeVarInt(vl.length);
				var _g = 0;
				while(_g < vl.length) {
					var v = vl[_g];
					++_g;
					f(v);
				}
			}
			break;
		case 14:
			var variants = t.variants;
			break;
		case 15:
			var t1 = t.t;
			var size = t.size;
			this.writeType(t1);
			switch(size._hx_index) {
			case 0:
				var v = size.v;
				this.out.addByte(0);
				this.writeVarInt(v);
				break;
			case 1:
				var v = size.v;
				this.writeVar(v);
				break;
			}
			break;
		case 16:
			var _g = t.t;
			var _g1 = t.size;
			var _g2 = t.kind;
			if(_g2._hx_index == 0) {
				var size = _g1;
				var t1 = _g;
				this.writeType(t1);
				switch(size._hx_index) {
				case 0:
					var v = size.v;
					this.out.addByte(0);
					this.writeVarInt(v);
					break;
				case 1:
					var v = size.v;
					this.writeVar(v);
					break;
				}
			} else {
				var kind = _g2;
				var size = _g1;
				var t1 = _g;
				this.out.addByte(kind._hx_index + 128);
				this.writeType(t1);
				switch(size._hx_index) {
				case 0:
					var v = size.v;
					this.out.addByte(0);
					this.writeVarInt(v);
					break;
				case 1:
					var v = size.v;
					this.writeVar(v);
					break;
				}
			}
			break;
		case 17:
			var size = t.size;
			this.out.addByte(size);
			break;
		}
	}
	,readType: function() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Type.TVoid;
		case 1:
			return hxsl_Type.TInt;
		case 2:
			return hxsl_Type.TBool;
		case 3:
			return hxsl_Type.TFloat;
		case 4:
			return hxsl_Type.TString;
		case 5:
			var bits = this.input.readByte();
			var v = hxsl_Serializer.TVECS.h[bits];
			if(v == null) {
				v = hxsl_Type.TVec(bits & 7,Type.createEnumIndex(hxsl_VecType,bits >> 3,null));
				hxsl_Serializer.TVECS.h[bits] = v;
			}
			return v;
		case 6:
			return hxsl_Type.TMat3;
		case 7:
			return hxsl_Type.TMat4;
		case 8:
			return hxsl_Type.TMat3x4;
		case 9:
			return hxsl_Type.TBytes(this.input.readInt32());
		case 10:
			return hxsl_Type.TSampler2D;
		case 11:
			return hxsl_Type.TSampler2DArray;
		case 12:
			return hxsl_Type.TSamplerCube;
		case 13:
			var id = this.readVarInt();
			var t = this.types[id];
			if(t != null) {
				return t;
			}
			var f = $bind(this,this.readVar);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			t = hxsl_Type.TStruct(_g);
			this.types[id] = t;
			return t;
		case 14:
			return hxsl_Type.TFun(null);
		case 15:
			var t = this.readType();
			var v = this.readVar();
			return hxsl_Type.TArray(t,v == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v));
		case 16:
			var tag = this.input.readByte();
			var kind = hxsl_BufferKind.Uniform;
			if((tag & 128) == 0) {
				var fh = this.input;
				fh.set_position(fh.pos - 1);
			} else {
				kind = Type.createEnumIndex(hxsl_BufferKind,tag & 127,null);
			}
			var t = this.readType();
			var v = this.readVar();
			return hxsl_Type.TBuffer(t,v == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v),kind);
		case 17:
			return hxsl_Type.TChannel(this.input.readByte());
		case 18:
			return hxsl_Type.TMat2;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,writeString: function(s) {
		var bytes = haxe_io_Bytes.ofString(s);
		this.writeVarInt(bytes.length);
		this.out.add(bytes);
	}
	,readString: function() {
		var len = this.readVarInt();
		var s = this.input.read(len).getString(0,len);
		return s;
	}
	,writeVar: function(v) {
		if(v == null) {
			this.out.addByte(0);
			return;
		}
		this.writeID(v.id);
		if(this.varMap.h.hasOwnProperty(v.id)) {
			return;
		}
		this.varMap.h[v.id] = v;
		this.writeString(v.name);
		this.writeType(v.type);
		this.out.addByte(v.kind._hx_index);
		this.writeVar(v.parent);
		if(v.qualifiers == null) {
			this.out.addByte(0);
		} else {
			this.out.addByte(v.qualifiers.length);
			var _g = 0;
			var _g1 = v.qualifiers;
			while(_g < _g1.length) {
				var q = _g1[_g];
				++_g;
				this.out.addByte(q._hx_index);
				switch(q._hx_index) {
				case 0:
					var max = q.max;
					this.out.addInt32(max == null ? 0 : max);
					break;
				case 4:
					var n = q.n;
					this.writeString(n);
					break;
				case 6:
					var p = q.p;
					this.out.addByte(p._hx_index);
					break;
				case 7:
					var min = q.min;
					var max1 = q.max;
					this.out.addDouble(min);
					this.out.addDouble(max1);
					break;
				case 1:case 2:case 3:case 5:case 8:
					break;
				case 9:
					var v = q.v;
					this.out.addInt32(v);
					break;
				case 10:
					var s = q.s;
					this.writeString(s);
					break;
				case 11:
					var s1 = q.source;
					this.writeString(s1);
					break;
				case 12:
					var s2 = q.name;
					this.writeString(s2);
					break;
				}
			}
		}
	}
	,writeFun: function(f) {
		this.out.addByte(f.kind._hx_index);
		this.writeVar(f.ref);
		var arr = f.args;
		var f1 = $bind(this,this.writeVar);
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f1(v);
		}
		this.writeType(f.ret);
		this.writeExpr(f.expr);
	}
	,writeConst: function(c) {
		this.out.addByte(c._hx_index);
		switch(c._hx_index) {
		case 0:
			break;
		case 1:
			var b = c.b;
			this.out.addByte(b ? 1 : 0);
			break;
		case 2:
			var v = c.v;
			this.out.addInt32(v);
			break;
		case 3:
			var v = c.v;
			this.out.addDouble(v);
			break;
		case 4:
			var v = c.v;
			this.writeString(v);
			break;
		}
	}
	,writeExpr: function(e) {
		var _gthis = this;
		if(e == null) {
			this.out.addByte(0);
			return;
		}
		this.out.addByte(e.e._hx_index + 1);
		var _g = e.e;
		switch(_g._hx_index) {
		case 0:
			var c = _g.c;
			this.writeConst(c);
			break;
		case 1:
			var v = _g.v;
			this.writeVar(v);
			break;
		case 2:
			var g = _g.g;
			this.out.addByte(g._hx_index);
			break;
		case 3:
			var e1 = _g.e;
			this.writeExpr(e1);
			break;
		case 4:
			var el = _g.el;
			var f = $bind(this,this.writeExpr);
			this.writeVarInt(el.length);
			var _g1 = 0;
			while(_g1 < el.length) {
				var v = el[_g1];
				++_g1;
				f(v);
			}
			break;
		case 5:
			var op = _g.op;
			var e1 = _g.e1;
			var e2 = _g.e2;
			if(op._hx_index == 20) {
				var op1 = op.op;
				this.out.addByte(op1._hx_index | 128);
			} else {
				this.out.addByte(op._hx_index);
			}
			this.writeExpr(e1);
			this.writeExpr(e2);
			break;
		case 6:
			var op = _g.op;
			var e1 = _g.e1;
			this.out.addByte(op._hx_index);
			this.writeExpr(e1);
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			this.writeVar(v);
			this.writeExpr(init);
			break;
		case 8:
			var e1 = _g.e;
			var args = _g.args;
			this.writeExpr(e1);
			var f = $bind(this,this.writeExpr);
			this.writeVarInt(args.length);
			var _g1 = 0;
			while(_g1 < args.length) {
				var v = args[_g1];
				++_g1;
				f(v);
			}
			break;
		case 9:
			var e1 = _g.e;
			var regs = _g.regs;
			this.writeExpr(e1);
			if(regs.length == 0) {
				throw haxe_Exception.thrown("assert");
			}
			var bits = regs.length - 1;
			var k = 2;
			var _g1 = 0;
			while(_g1 < regs.length) {
				var r = regs[_g1];
				++_g1;
				bits |= r._hx_index << k;
				k += 2;
			}
			this.out.addByte(bits & 255);
			this.out.addByte(bits >> 8);
			break;
		case 10:
			var econd = _g.econd;
			var eif = _g.eif;
			var eelse = _g.eelse;
			this.writeExpr(econd);
			this.writeExpr(eif);
			this.writeExpr(eelse);
			break;
		case 11:
			break;
		case 12:
			var e1 = _g.e;
			this.writeExpr(e1);
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.writeVar(v);
			this.writeExpr(it);
			this.writeExpr(loop);
			break;
		case 14:
			break;
		case 15:
			break;
		case 16:
			var e1 = _g.e;
			var index = _g.index;
			this.writeExpr(e1);
			this.writeExpr(index);
			break;
		case 17:
			var el = _g.el;
			var f = $bind(this,this.writeExpr);
			this.writeVarInt(el.length);
			var _g1 = 0;
			while(_g1 < el.length) {
				var v = el[_g1];
				++_g1;
				f(v);
			}
			break;
		case 18:
			var e1 = _g.e;
			var cases = _g.cases;
			var def = _g.def;
			this.writeExpr(e1);
			this.writeVarInt(cases.length);
			var _g1 = 0;
			while(_g1 < cases.length) {
				var v = cases[_g1];
				++_g1;
				var arr = v.values;
				var f = $bind(_gthis,_gthis.writeExpr);
				_gthis.writeVarInt(arr.length);
				var _g2 = 0;
				while(_g2 < arr.length) {
					var v1 = arr[_g2];
					++_g2;
					f(v1);
				}
				_gthis.writeExpr(v.expr);
			}
			this.writeExpr(def);
			break;
		case 19:
			var e1 = _g.e;
			var loop = _g.loop;
			var normalWhile = _g.normalWhile;
			this.writeExpr(e1);
			this.writeExpr(loop);
			this.out.addByte(normalWhile ? 1 : 0);
			break;
		case 20:
			var m = _g.m;
			var args = _g.args;
			var e1 = _g.e;
			this.writeString(m);
			var f = $bind(this,this.writeConst);
			this.writeVarInt(args.length);
			var _g = 0;
			while(_g < args.length) {
				var v = args[_g];
				++_g;
				f(v);
			}
			this.writeExpr(e1);
			break;
		}
		this.writeType(e.t);
	}
	,readConst: function() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Const.CNull;
		case 1:
			return hxsl_Const.CBool(this.input.readByte() != 0);
		case 2:
			return hxsl_Const.CInt(this.input.readInt32());
		case 3:
			return hxsl_Const.CFloat(this.input.readDouble());
		case 4:
			return hxsl_Const.CString(this.readString());
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	,readExpr: function() {
		var _gthis = this;
		var k = this.input.readByte();
		if(k-- == 0) {
			return null;
		}
		var e;
		switch(k) {
		case 0:
			e = hxsl_TExprDef.TConst(this.readConst());
			break;
		case 1:
			e = hxsl_TExprDef.TVar(this.readVar());
			break;
		case 2:
			e = hxsl_TExprDef.TGlobal(hxsl_Serializer.TGLOBALS[this.input.readByte()]);
			break;
		case 3:
			e = hxsl_TExprDef.TParenthesis(this.readExpr());
			break;
		case 4:
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TBlock(_g);
			break;
		case 5:
			var op = this.input.readByte();
			e = hxsl_TExprDef.TBinop(op >= 128 ? haxe_macro_Binop.OpAssignOp(hxsl_Serializer.BOPS[op & 127]) : hxsl_Serializer.BOPS[op],this.readExpr(),this.readExpr());
			break;
		case 6:
			e = hxsl_TExprDef.TUnop(hxsl_Serializer.UNOPS[this.input.readByte()],this.readExpr());
			break;
		case 7:
			e = hxsl_TExprDef.TVarDecl(this.readVar(),this.readExpr());
			break;
		case 8:
			var e1 = this.readExpr();
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TCall(e1,_g);
			break;
		case 9:
			var e1 = this.readExpr();
			var bits = this.input.readUInt16();
			var swiz = hxsl_Serializer.TSWIZ.h[bits];
			if(swiz == null) {
				var _g = [];
				var _g1 = 0;
				var _g2 = (bits & 3) + 1;
				while(_g1 < _g2) {
					var i = _g1++;
					_g.push(hxsl_Serializer.REGS[bits >> i * 2 + 2 & 3]);
				}
				swiz = _g;
				hxsl_Serializer.TSWIZ.h[bits] = swiz;
			}
			e = hxsl_TExprDef.TSwiz(e1,swiz);
			break;
		case 10:
			e = hxsl_TExprDef.TIf(this.readExpr(),this.readExpr(),this.readExpr());
			break;
		case 11:
			e = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			e = hxsl_TExprDef.TReturn(this.readExpr());
			break;
		case 13:
			e = hxsl_TExprDef.TFor(this.readVar(),this.readExpr(),this.readExpr());
			break;
		case 14:
			e = hxsl_TExprDef.TContinue;
			break;
		case 15:
			e = hxsl_TExprDef.TBreak;
			break;
		case 16:
			e = hxsl_TExprDef.TArray(this.readExpr(),this.readExpr());
			break;
		case 17:
			var f = $bind(this,this.readExpr);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TArrayDecl(_g);
			break;
		case 18:
			var e1 = this.readExpr();
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				var f = $bind(_gthis,_gthis.readExpr);
				var _g3 = [];
				var _g4 = 0;
				var _g5 = _gthis.readVarInt();
				while(_g4 < _g5) {
					var i1 = _g4++;
					_g3.push(f());
				}
				_g.push({ values : _g3, expr : _gthis.readExpr()});
			}
			e = hxsl_TExprDef.TSwitch(e1,_g,this.readExpr());
			break;
		case 19:
			e = hxsl_TExprDef.TWhile(this.readExpr(),this.readExpr(),this.input.readByte() != 0);
			break;
		case 20:
			var e1 = this.readString();
			var f = $bind(this,this.readConst);
			var _g = [];
			var _g1 = 0;
			var _g2 = this.readVarInt();
			while(_g1 < _g2) {
				var i = _g1++;
				_g.push(f());
			}
			e = hxsl_TExprDef.TMeta(e1,_g,this.readExpr());
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		return { e : e, t : this.readType(), p : null};
	}
	,readVar: function() {
		var id = this.readVarInt();
		if(id == 0) {
			return null;
		}
		var v = this.varMap.h[id];
		if(v != null) {
			return v;
		}
		v = { id : hxsl_Tools.allocVarId(), name : this.readString(), type : null, kind : null};
		this.varMap.h[id] = v;
		v.type = this.readType();
		v.kind = hxsl_Serializer.VKINDS[this.input.readByte()];
		v.parent = this.readVar();
		var nq = this.input.readByte();
		if(nq > 0) {
			v.qualifiers = [];
			var _g = 0;
			var _g1 = nq;
			while(_g < _g1) {
				var i = _g++;
				var qid = this.input.readByte();
				var q;
				switch(qid) {
				case 0:
					var n = this.input.readInt32();
					q = hxsl_VarQualifier.Const(n == 0 ? null : n);
					break;
				case 1:
					q = hxsl_VarQualifier.Private;
					break;
				case 2:
					q = hxsl_VarQualifier.Nullable;
					break;
				case 3:
					q = hxsl_VarQualifier.PerObject;
					break;
				case 4:
					q = hxsl_VarQualifier.Name(this.readString());
					break;
				case 5:
					q = hxsl_VarQualifier.Shared;
					break;
				case 6:
					q = hxsl_VarQualifier.Precision(hxsl_Serializer.PRECS[this.input.readByte()]);
					break;
				case 7:
					q = hxsl_VarQualifier.Range(this.input.readDouble(),this.input.readDouble());
					break;
				case 8:
					q = hxsl_VarQualifier.Ignore;
					break;
				case 9:
					q = hxsl_VarQualifier.PerInstance(this.input.readInt32());
					break;
				case 10:
					q = hxsl_VarQualifier.Doc(this.readString());
					break;
				case 11:
					q = hxsl_VarQualifier.Borrow(this.readString());
					break;
				case 12:
					q = hxsl_VarQualifier.Sampler(this.readString());
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				v.qualifiers.push(q);
			}
		}
		return v;
	}
	,readFun: function() {
		var tmp = hxsl_Serializer.FKIND[this.input.readByte()];
		var tmp1 = this.readVar();
		var f = $bind(this,this.readVar);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return { kind : tmp, ref : tmp1, args : _g, ret : this.readType(), expr : this.readExpr()};
	}
	,unserialize: function(data) {
		this.input = new haxe_io_BytesInput(haxe_crypto_Base64.decode(data,false));
		if(this.input.readByte() != (hxsl_Serializer.SIGN & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 8 & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 16 & 255)) {
			throw haxe_Exception.thrown("Invalid HXSL data");
		}
		this.varMap = new haxe_ds_IntMap();
		this.types = [];
		var tmp = this.readString();
		var f = $bind(this,this.readVar);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		var tmp1 = _g;
		var f = $bind(this,this.readFun);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.readVarInt();
		while(_g1 < _g2) {
			var i = _g1++;
			_g.push(f());
		}
		return { name : tmp, vars : tmp1, funs : _g};
	}
	,serialize: function(s) {
		this.varMap = new haxe_ds_IntMap();
		this.idMap = new haxe_ds_IntMap();
		this.typeIdMap = new haxe_ds_EnumValueMap();
		this.out = new haxe_io_BytesBuffer();
		this.out.addByte(hxsl_Serializer.SIGN & 255);
		this.out.addByte(hxsl_Serializer.SIGN >> 8 & 255);
		this.out.addByte(hxsl_Serializer.SIGN >> 16 & 255);
		this.writeString(s.name);
		var arr = s.vars;
		var f = $bind(this,this.writeVar);
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f(v);
		}
		var arr = s.funs;
		var f = $bind(this,this.writeFun);
		this.writeVarInt(arr.length);
		var _g = 0;
		while(_g < arr.length) {
			var v = arr[_g];
			++_g;
			f(v);
		}
		return haxe_crypto_Base64.encode(this.out.getBytes(),false);
	}
	,__class__: hxsl_Serializer
};
var hxsl_ShaderList = function(s,n) {
	this.s = s;
	this.next = n;
};
$hxClasses["hxsl.ShaderList"] = hxsl_ShaderList;
hxsl_ShaderList.__name__ = "hxsl.ShaderList";
hxsl_ShaderList.addSort = function(s,shaders) {
	var prev = null;
	var hd = shaders;
	while(hd != null && hd.s.priority < s.priority) {
		prev = hd;
		hd = hd.next;
	}
	if(prev == null) {
		var l = new hxsl_ShaderList(s,shaders);
		hxsl_ShaderList.checkSize(l);
		return l;
	}
	prev.next = new hxsl_ShaderList(s,prev.next);
	hxsl_ShaderList.checkSize(shaders);
	return shaders;
};
hxsl_ShaderList.checkSize = function(list) {
	if(hxsl_ShaderList.MAX_LIST_SIZE <= 0) {
		return;
	}
	var hd = list;
	var count = 0;
	while(hd != null) {
		if(!hxsl_ShaderList.ALLOW_DUPLICATES && hd.next != null && hd.next.s == hd.s) {
			throw haxe_Exception.thrown("Duplicate shader " + Std.string(hd.s));
		}
		++count;
		hd = hd.next;
	}
	if(count > hxsl_ShaderList.MAX_LIST_SIZE) {
		throw haxe_Exception.thrown("Too many shaders");
	}
};
hxsl_ShaderList.prototype = {
	clone: function() {
		return new hxsl_ShaderList(this.s.clone(),this.next == null ? null : this.next.clone());
	}
	,iterator: function() {
		return new hxsl__$ShaderList_ShaderIterator(this,null);
	}
	,iterateTo: function(s) {
		return new hxsl__$ShaderList_ShaderIterator(this,s);
	}
	,__class__: hxsl_ShaderList
};
var hxsl__$ShaderList_ShaderIterator = function(l,last) {
	this.l = l;
	this.last = last;
};
$hxClasses["hxsl._ShaderList.ShaderIterator"] = hxsl__$ShaderList_ShaderIterator;
hxsl__$ShaderList_ShaderIterator.__name__ = "hxsl._ShaderList.ShaderIterator";
hxsl__$ShaderList_ShaderIterator.prototype = {
	hasNext: function() {
		return this.l != this.last;
	}
	,next: function() {
		var s = this.l.s;
		this.l = this.l.next;
		return s;
	}
	,__class__: hxsl__$ShaderList_ShaderIterator
};
var hxsl_ShaderInstance = function(shader) {
	this.id = ++hxsl_ShaderInstance.UID;
	this.shader = shader;
	this.params = new haxe_ds_IntMap();
};
$hxClasses["hxsl.ShaderInstance"] = hxsl_ShaderInstance;
hxsl_ShaderInstance.__name__ = "hxsl.ShaderInstance";
hxsl_ShaderInstance.prototype = {
	__class__: hxsl_ShaderInstance
};
var hxsl_ShaderGlobal = function(v,gid) {
	this.v = v;
	this.globalId = gid;
};
$hxClasses["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal;
hxsl_ShaderGlobal.__name__ = "hxsl.ShaderGlobal";
hxsl_ShaderGlobal.prototype = {
	__class__: hxsl_ShaderGlobal
};
var hxsl_ShaderConst = function(v,pos,bits) {
	this.v = v;
	this.pos = pos;
	this.bits = bits;
};
$hxClasses["hxsl.ShaderConst"] = hxsl_ShaderConst;
hxsl_ShaderConst.__name__ = "hxsl.ShaderConst";
hxsl_ShaderConst.prototype = {
	__class__: hxsl_ShaderConst
};
var hxsl_SharedShader = function(src) {
	this.instanceCache = new haxe_ds_IntMap();
	this.consts = null;
	this.globals = [];
	if(src == "") {
		return;
	}
	this.data = new hxsl_Serializer().unserialize(src);
	var _g = 0;
	var _g1 = this.data.vars;
	while(_g < _g1.length) {
		var v = _g1[_g];
		++_g;
		this.initVarId(v);
	}
	this.data = hxsl_SharedShader.compactMem(this.data);
	this.initialize();
};
$hxClasses["hxsl.SharedShader"] = hxsl_SharedShader;
hxsl_SharedShader.__name__ = "hxsl.SharedShader";
hxsl_SharedShader.compactMem = function(mem) {
	return mem;
};
hxsl_SharedShader.prototype = {
	initialize: function() {
		var _g = 0;
		var _g1 = this.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.browseVar(v);
		}
	}
	,getInstance: function(constBits) {
		var i = this.instanceCache.h[constBits];
		if(i == null) {
			return this.makeInstance(constBits);
		} else {
			return i;
		}
	}
	,makeInstance: function(constBits) {
		var $eval = new hxsl_Eval();
		var c = this.consts;
		while(c != null) {
			var c1 = c.v;
			var _g = c.v.type;
			var tmp;
			switch(_g._hx_index) {
			case 1:
				tmp = hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1);
				break;
			case 2:
				tmp = hxsl_Const.CBool((constBits >>> c.pos & 1) != 0);
				break;
			case 17:
				var _g1 = _g.size;
				tmp = hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			$eval.setConstant(c1,tmp);
			c = c.next;
		}
		$eval.inlineCalls = true;
		$eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS;
		var edata = $eval.eval(this.data);
		edata = hxsl_SharedShader.compactMem(edata);
		var i = new hxsl_ShaderInstance(edata);
		this.paramsCount = 0;
		var _g = 0;
		var _g1 = this.data.vars;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			this.addParam($eval,i,v);
		}
		this.instanceCache.h[constBits] = i;
		return i;
	}
	,addSelfParam: function(i,v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.addSelfParam(i,v1);
			}
		} else if(v.kind == hxsl_VarKind.Param) {
			i.params.h[v.id] = this.paramsCount;
			this.paramsCount++;
		}
	}
	,addParam: function($eval,i,v) {
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v1 = vl[_g];
				++_g;
				this.addParam($eval,i,v1);
			}
		} else if(v.kind == hxsl_VarKind.Param) {
			i.params.h[$eval.varMap.h[v.__id__].id] = this.paramsCount;
			this.paramsCount++;
		}
	}
	,initVarId: function(v) {
		v.id = hxsl_Tools.allocVarId();
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var v = vl[_g];
				++_g;
				this.initVarId(v);
			}
		}
	}
	,browseVar: function(v,path) {
		if(path == null) {
			path = hxsl_Tools.getName(v);
		} else {
			path += "." + v.name;
		}
		var _g = v.type;
		if(_g._hx_index == 13) {
			var vl = _g.vl;
			var _g = 0;
			while(_g < vl.length) {
				var vs = vl[_g];
				++_g;
				this.browseVar(vs,path);
			}
		} else {
			var globalId = 0;
			if(v.kind == hxsl_VarKind.Global) {
				globalId = hxsl_Globals.allocID(path);
				this.globals.push(new hxsl_ShaderGlobal(v,globalId));
			}
			if(!hxsl_Tools.isConst(v)) {
				return;
			}
			var bits = hxsl_Tools.getConstBits(v);
			if(bits > 0) {
				var pos = this.consts == null ? 0 : this.consts.pos + this.consts.bits;
				var c = new hxsl_ShaderConst(v,pos,bits);
				c.globalId = globalId;
				c.next = this.consts;
				this.consts = c;
			}
		}
	}
	,__class__: hxsl_SharedShader
};
var hxsl__$Splitter_VarProps = function(v) {
	this.v = v;
	this.read = 0;
	this.write = 0;
};
$hxClasses["hxsl._Splitter.VarProps"] = hxsl__$Splitter_VarProps;
hxsl__$Splitter_VarProps.__name__ = "hxsl._Splitter.VarProps";
hxsl__$Splitter_VarProps.prototype = {
	__class__: hxsl__$Splitter_VarProps
};
var hxsl_Splitter = function() {
};
$hxClasses["hxsl.Splitter"] = hxsl_Splitter;
hxsl_Splitter.__name__ = "hxsl.Splitter";
hxsl_Splitter.prototype = {
	split: function(s) {
		var _gthis = this;
		var vfun = null;
		var vvars = new haxe_ds_IntMap();
		var ffun = null;
		var fvars = new haxe_ds_IntMap();
		var isCompute = false;
		this.varNames = new haxe_ds_StringMap();
		this.varMap = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = s.funs;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			switch(f.kind._hx_index) {
			case 1:
				this.vars = fvars;
				ffun = f;
				this.checkExpr(f.expr);
				break;
			case 0:case 4:
				this.vars = vvars;
				vfun = f;
				this.checkExpr(f.expr);
				if(f.kind == hxsl_FunctionKind.Main) {
					isCompute = true;
				}
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		var vafterMap = [];
		var _g = 0;
		var _g1 = Lambda.array(vvars);
		while(_g < _g1.length) {
			var inf = [_g1[_g]];
			++_g;
			var v = [inf[0].v];
			if(inf[0].local) {
				continue;
			}
			switch(v[0].kind._hx_index) {
			case 3:case 4:
				var fv = fvars.h[inf[0].origin.id];
				v[0].kind = fv != null && fv.read > 0 ? hxsl_VarKind.Var : hxsl_VarKind.Local;
				break;
			default:
			}
			switch(v[0].kind._hx_index) {
			case 3:case 5:
				if(inf[0].read > 0 || inf[0].write > 1) {
					var nv = { id : hxsl_Tools.allocVarId(), name : v[0].name, kind : hxsl_VarKind.Local, type : v[0].type};
					this.uniqueName(nv);
					this.varMap.set(inf[0].origin,nv);
					var ninf = new hxsl__$Splitter_VarProps(nv);
					ninf.read++;
					vvars.h[nv.id] = ninf;
					var p = vfun.expr.p;
					var e = [{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(v[0]), t : nv.type, p : p},{ e : hxsl_TExprDef.TVar(nv), t : v[0].type, p : p}), t : nv.type, p : p}];
					vafterMap.push((function(e) {
						return function() {
							_gthis.addExpr(vfun,e[0]);
						};
					})(e));
					if(v[0].kind == hxsl_VarKind.Var) {
						vafterMap.push((function(v,inf) {
							return function() {
								_gthis.varMap.set(inf[0].origin,v[0]);
							};
						})(v,inf));
					}
				}
				break;
			default:
			}
		}
		vfun = { ret : vfun.ret, ref : vfun.ref, kind : vfun.kind, args : vfun.args, expr : this.mapVars(vfun.expr)};
		var _g = 0;
		while(_g < vafterMap.length) {
			var f = vafterMap[_g];
			++_g;
			f();
		}
		var finits = [];
		var inf1 = fvars.iterator();
		while(inf1.hasNext()) {
			var inf2 = inf1.next();
			var v1 = inf2.v;
			switch(v1.kind._hx_index) {
			case 1:
				var nv = { id : hxsl_Tools.allocVarId(), name : v1.name, kind : hxsl_VarKind.Var, type : v1.type};
				this.uniqueName(nv);
				var i = vvars.h[inf2.origin.id];
				if(i == null) {
					i = new hxsl__$Splitter_VarProps(v1);
					vvars.h[inf2.origin.id] = i;
				}
				i.read++;
				this.varMap.set(inf2.origin,nv);
				var ninf = new hxsl__$Splitter_VarProps(nv);
				ninf.origin = inf2.origin;
				fvars.h[inf2.origin.id] = ninf;
				vvars.h[nv.id] = ninf;
				this.addExpr(vfun,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(nv), t : v1.type, p : vfun.expr.p},{ e : hxsl_TExprDef.TVar(v1), t : v1.type, p : vfun.expr.p}), t : v1.type, p : vfun.expr.p});
				break;
			case 3:
				if(inf2.write > 0) {
					var nv1 = { id : hxsl_Tools.allocVarId(), name : v1.name, kind : hxsl_VarKind.Local, type : v1.type};
					this.uniqueName(nv1);
					finits.push({ e : hxsl_TExprDef.TVarDecl(nv1,{ e : hxsl_TExprDef.TVar(v1), t : v1.type, p : ffun.expr.p}), t : hxsl_Type.TVoid, p : ffun.expr.p});
					this.varMap.set(inf2.origin,nv1);
				}
				break;
			default:
			}
		}
		var v1 = vvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			this.checkVar(v2,true,vvars,vfun.expr.p);
		}
		var v1 = fvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			this.checkVar(v2,false,vvars,ffun.expr.p);
		}
		if(ffun != null) {
			ffun = { ret : ffun.ret, ref : ffun.ref, kind : ffun.kind, args : ffun.args, expr : this.mapVars(ffun.expr)};
			var _g = ffun.expr.e;
			if(_g._hx_index == 4) {
				var el = _g.el;
				var _g = 0;
				while(_g < finits.length) {
					var e1 = finits[_g];
					++_g;
					el.unshift(e1);
				}
			} else {
				finits.push(ffun.expr);
				ffun.expr = { e : hxsl_TExprDef.TBlock(finits), t : hxsl_Type.TVoid, p : ffun.expr.p};
			}
		}
		var _g = [];
		var v1 = vvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			if(!v2.local) {
				_g.push(v2);
			}
		}
		var vvars = _g;
		var _g = [];
		var v1 = fvars.iterator();
		while(v1.hasNext()) {
			var v2 = v1.next();
			if(!v2.local) {
				_g.push(v2);
			}
		}
		var fvars = _g;
		vvars.sort(function(v1,v2) {
			return (v1.origin == null ? v1.v.id : v1.origin.id) - (v2.origin == null ? v2.v.id : v2.origin.id);
		});
		fvars.sort(function(v1,v2) {
			return (v1.origin == null ? v1.v.id : v1.origin.id) - (v2.origin == null ? v2.v.id : v2.origin.id);
		});
		if(isCompute) {
			var _g = [];
			var _g1 = 0;
			while(_g1 < vvars.length) {
				var v1 = vvars[_g1];
				++_g1;
				_g.push(v1.v);
			}
			return [{ name : "main", vars : _g, funs : [vfun]}];
		} else {
			var _g = [];
			var _g1 = 0;
			while(_g1 < vvars.length) {
				var v1 = vvars[_g1];
				++_g1;
				_g.push(v1.v);
			}
			var tmp = { name : "vertex", vars : _g, funs : [vfun]};
			var _g = [];
			var _g1 = 0;
			while(_g1 < fvars.length) {
				var v1 = fvars[_g1];
				++_g1;
				_g.push(v1.v);
			}
			return [tmp,{ name : "fragment", vars : _g, funs : [ffun]}];
		}
	}
	,addExpr: function(f,e) {
		var _g = f.expr.e;
		if(_g._hx_index == 4) {
			var el = _g.el;
			el.push(e);
		} else {
			f.expr = { e : hxsl_TExprDef.TBlock([f.expr,e]), t : hxsl_Type.TVoid, p : f.expr.p};
		}
	}
	,checkVar: function(v,vertex,vvars,p) {
		switch(v.v.kind._hx_index) {
		case 3:
			if(!vertex) {
				var i = vvars.h[v.origin.id];
				if(i != null && i.v.kind == hxsl_VarKind.Input) {
					return;
				}
				if(i == null || i.write == 0) {
					throw haxe_Exception.thrown(new hxsl_Error("Varying " + v.v.name + " is not written by vertex shader",p));
				}
			}
			break;
		case 4:
			if(v.requireInit) {
				throw haxe_Exception.thrown(new hxsl_Error("Variable " + v.v.name + " is used without being initialized",p));
			}
			break;
		default:
		}
	}
	,mapVars: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return e;
			} else {
				return { e : hxsl_TExprDef.TVar(v2), t : e.t, p : e.p};
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TVarDecl(v2,init == null ? null : this.mapVars(init)), t : e.t, p : e.p};
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			var v2 = this.varMap.h[v.__id__];
			if(v2 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TFor(v2,this.mapVars(it),this.mapVars(loop)), t : e.t, p : e.p};
			}
			break;
		default:
			return hxsl_Tools.map(e,$bind(this,this.mapVars));
		}
	}
	,get: function(v) {
		var i = this.vars.h[v.id];
		if(i == null) {
			var nv = this.varMap.h[v.__id__];
			if(nv == null) {
				if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
					nv = v;
				} else {
					nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : v.kind, type : v.type};
					this.uniqueName(nv);
				}
				this.varMap.set(v,nv);
			}
			i = new hxsl__$Splitter_VarProps(nv);
			i.origin = v;
			this.vars.h[v.id] = i;
		}
		return i;
	}
	,uniqueName: function(v) {
		if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
			return;
		}
		var n = this.varNames.h[v.name];
		if(n != null && n != v) {
			var prefix = v.name;
			while(HxOverrides.cca(prefix,prefix.length - 1) >= 48 && HxOverrides.cca(prefix,prefix.length - 1) <= 57) prefix = HxOverrides.substr(prefix,0,-1);
			var k = prefix == v.name ? 2 : Std.parseInt(HxOverrides.substr(v.name,prefix.length,null));
			while(Object.prototype.hasOwnProperty.call(this.varNames.h,prefix + k)) ++k;
			v.name = prefix + k;
		}
		this.varNames.h[v.name] = v;
	}
	,checkExpr: function(e) {
		var _g = e.e;
		switch(_g._hx_index) {
		case 1:
			var v = _g.v;
			var inf = this.get(v);
			if(inf.write == 0) {
				inf.requireInit = true;
			}
			inf.read++;
			break;
		case 5:
			var _g1 = _g.op;
			var _g2 = _g.e1;
			var _g3 = _g.e2;
			switch(_g1._hx_index) {
			case 4:
				var _g4 = _g2.e;
				var _g5 = _g2.p;
				var _g5 = _g2.t;
				switch(_g4._hx_index) {
				case 1:
					var v = _g4.v;
					var e1 = _g3;
					var inf = this.get(v);
					inf.write++;
					this.checkExpr(e1);
					break;
				case 9:
					var _g5 = _g4.e;
					var _g6 = _g4.regs;
					var _g4 = _g5.e;
					var _g6 = _g5.p;
					var _g6 = _g5.t;
					if(_g4._hx_index == 1) {
						var v = _g4.v;
						var e1 = _g3;
						var inf = this.get(v);
						inf.write++;
						this.checkExpr(e1);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			case 20:
				var _g4 = _g1.op;
				var _g1 = _g2.e;
				var _g4 = _g2.p;
				var _g4 = _g2.t;
				switch(_g1._hx_index) {
				case 1:
					var v = _g1.v;
					var e1 = _g3;
					var inf = this.get(v);
					if(inf.write == 0) {
						inf.requireInit = true;
					}
					inf.read++;
					inf.write++;
					this.checkExpr(e1);
					break;
				case 9:
					var _g2 = _g1.e;
					var _g4 = _g1.regs;
					var _g1 = _g2.e;
					var _g4 = _g2.p;
					var _g4 = _g2.t;
					if(_g1._hx_index == 1) {
						var v = _g1.v;
						var e1 = _g3;
						var inf = this.get(v);
						if(inf.write == 0) {
							inf.requireInit = true;
						}
						inf.read++;
						inf.write++;
						this.checkExpr(e1);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			default:
				hxsl_Tools.iter(e,$bind(this,this.checkExpr));
			}
			break;
		case 7:
			var v = _g.v;
			var init = _g.init;
			var inf = this.get(v);
			inf.local = true;
			if(init != null) {
				this.checkExpr(init);
				inf.write++;
			}
			break;
		case 13:
			var v = _g.v;
			var it = _g.it;
			var loop = _g.loop;
			this.checkExpr(it);
			var inf = this.get(v);
			inf.local = true;
			inf.write++;
			this.checkExpr(loop);
			break;
		default:
			hxsl_Tools.iter(e,$bind(this,this.checkExpr));
		}
	}
	,__class__: hxsl_Splitter
};
var hxsl_ChannelTools = function() { };
$hxClasses["hxsl.ChannelTools"] = hxsl_ChannelTools;
hxsl_ChannelTools.__name__ = "hxsl.ChannelTools";
hxsl_ChannelTools.isPackedFormat = function(c) {
	return c.format == h3d_mat_Texture.nativeFormat;
};
var js_html__$CanvasElement_CanvasUtil = function() { };
$hxClasses["js.html._CanvasElement.CanvasUtil"] = js_html__$CanvasElement_CanvasUtil;
js_html__$CanvasElement_CanvasUtil.__name__ = "js.html._CanvasElement.CanvasUtil";
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name = "experimental-webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	return null;
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
$hxClasses["js.lib._ArrayBuffer.ArrayBufferCompat"] = js_lib__$ArrayBuffer_ArrayBufferCompat;
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = "js.lib._ArrayBuffer.ArrayBufferCompat";
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
Math.__name__ = "Math";
var seq_Gameover = function() {
	Fx.call(this);
	new fx_h2d_Flash(Game.me,16711680);
	var e = new fx_h2d_Flash(Game.me.snowman,16711680,0.03);
	var _g = this;
	var n = 0;
	e.onFinish = function() {
		_g.explode(n);
	};
	this.ks = 0;
	Game.me.loop.kill();
	Game.me.loop = null;
	Game.me.fxScoreMark(false);
	var b = Game.me.lifebar;
	if(b != null) {
		new fx_Move(b,b.x - 16,b.y);
	}
	var b = Game.me.malusbar;
	if(b != null) {
		new fx_Move(b,b.x,b.y + 20);
	}
	switch(Game.me.mode) {
	case 1:
		if(Game.me.level + 1 > Main.profile.hiscoreChallenge) {
			Main.newRecord = 1;
			Main.profile.hiscoreChallenge = Game.me.level + 1;
			Main.saveProfile();
		}
		break;
	case 2:
		if(Game.me.score > Main.profile.hiscoreSurvival) {
			Main.newRecord = 2;
			Main.profile.hiscoreSurvival = Game.me.score;
			Main.saveProfile();
		}
		break;
	}
};
$hxClasses["seq.Gameover"] = seq_Gameover;
seq_Gameover.__name__ = "seq.Gameover";
seq_Gameover.__super__ = Fx;
seq_Gameover.prototype = $extend(Fx.prototype,{
	explode: function(n) {
		if(n == 3) {
			this.gvy = 0;
			this.showTitle();
			return;
		}
		Game.me.snowman.explode(n);
		var _g = this;
		var n1 = n + 1;
		new fx_Wait(15,function() {
			_g.explode(n1);
		});
	}
	,showTitle: function() {
		this.step = 1;
		this.logo = new h2d_Element();
		this.logo.goto(null,"gameover");
		var _this = this.logo;
		_this.posChanged = true;
		_this.x = Main.WIDTH * 0.5;
		var _this = this.logo;
		var _this1 = this.logo.getSize();
		_this.posChanged = true;
		_this.y = -(_this1.yMax - _this1.yMin) * 0.5;
		Game.me.addChild(this.logo);
		var mc = new h2d_Graphics();
		mc.beginFill(16777215);
		mc.drawRect(0,0,Main.WIDTH,80);
		mc.posChanged = true;
		mc.y = Main.HEIGHT;
		Game.me.scene.addChild(mc);
	}
	,update: function() {
		Fx.prototype.update.call(this);
		this.gvy += 6;
		this.gvy *= 0.98;
		switch(this.step) {
		case 0:
			break;
		case 1:
			var fh = this.logo;
			fh.posChanged = true;
			fh.y += this.gvy;
			if(this.logo.y > Main.HEIGHT * 0.46) {
				var _this = this.logo;
				_this.posChanged = true;
				_this.y = Main.HEIGHT * 0.46;
				var _this = Game.me.scene;
				_this.posChanged = true;
				_this.y = 0;
				new fx_h2d_Shake(Game.me.scene,0,this.gvy * 0.5,0.5);
				if(this.gvy > 6) {
					if(this.ks++ < 5) {
						Main.playSound("ground_game_over");
					}
					this.gvy *= -1;
				} else {
					Game.me.makeBut($bind(this,this.leave));
					this.nextStep();
				}
			}
			break;
		}
	}
	,leave: function() {
		var _gthis = this;
		Main.playSound("leave_game_over");
		Game.me.removeBut();
		var e = new fx_Move(this.logo,this.logo.x,-Main.HEIGHT);
		e.curveIn(2);
		e.onFinish = function() {
			_gthis.kill();
			Game.me.reset();
		};
	}
	,__class__: seq_Gameover
});
var seq_Menu = function() {
	Fx.call(this);
	this.content = new h2d_Drawable(js_Boot.__cast(Game.me , h2d_Object));
	this.olympio = new h2d_Element();
	this.olympio.goto(null,"olympio");
	var _this = this.olympio;
	_this.posChanged = true;
	_this.x = Main.WIDTH * 0.5;
	var _this = this.olympio;
	_this.posChanged = true;
	_this.y = 120;
	this.content.addChild(this.olympio);
	this.selectDone = false;
	this.doors = [];
	var el = new h2d_Element();
	el.goto(1,"doors");
	el.posChanged = true;
	el.x = Main.WIDTH * 0;
	el.posChanged = true;
	el.y = 48;
	el.posChanged = true;
	el.scaleX = 1;
	this.content.addChild(el);
	this.doors.push(el);
	var el = new h2d_Element();
	el.goto(1,"doors");
	el.posChanged = true;
	el.x = Main.WIDTH;
	el.posChanged = true;
	el.y = 48;
	el.posChanged = true;
	el.scaleX = -1;
	this.content.addChild(el);
	this.doors.push(el);
	var el = new h2d_Element();
	el.goto(null,"doors");
	el.posChanged = true;
	el.x = Main.WIDTH * 0;
	el.posChanged = true;
	el.scaleX = 1;
	this.content.addChild(el);
	this.doors.push(el);
	var el = new h2d_Element();
	el.goto(null,"doors");
	el.posChanged = true;
	el.x = Main.WIDTH;
	el.posChanged = true;
	el.scaleX = -1;
	this.content.addChild(el);
	this.doors.push(el);
	this.title = new h2d_Element();
	this.title.goto(null,"title");
	this.content.addChild(this.title);
	this.medals = [];
	var s = Game.me.snowman;
	var i = 0;
	var _g = 0;
	var _g1 = s.hands;
	while(_g < _g1.length) {
		var h = _g1[_g];
		++_g;
		h.posChanged = true;
		h.x -= 8;
		h.posChanged = true;
		h.y -= 8;
		h.posChanged = true;
		h.rotation = (i * 2 - 1) * 4.71;
		++i;
	}
	var el = new h2d_Element();
	el.goto(null,"press_start");
	el.posChanged = true;
	el.x = Main.WIDTH * 0.5;
	el.posChanged = true;
	el.y = 150;
	Game.me.addChild(el);
	this.start = el;
	Game.me.makeBut($bind(this,this.enter));
};
$hxClasses["seq.Menu"] = seq_Menu;
seq_Menu.__name__ = "seq.Menu";
seq_Menu.__super__ = Fx;
seq_Menu.prototype = $extend(Fx.prototype,{
	update: function() {
		Fx.prototype.update.call(this);
		Game.me.snowman.dance();
		if(Main.t % 10 == 0) {
			new fx_Snow();
		}
		if(this.step == 0) {
			var _this = this.start;
			var v = 150 + (Math.sin(h2d_MAll.cmod(Main.t,128) * 6.28) * 6 | 0);
			_this.posChanged = true;
			_this.y = v;
			if(hxd_Key.isPressed(32)) {
				this.enter();
			}
		}
	}
	,enter: function() {
		var _gthis = this;
		if(this.step == -1) {
			return;
		}
		Game.me.removeBut();
		Main.playSound("press_start");
		this.step = -1;
		this.start.goto(1,"press_start");
		this.start.blendMode = h2d_BlendMode.Add;
		var spc = 0.1;
		new fx_Wait(10,function() {
			new fx_Alpha(_gthis.start,0,0.1);
		});
		new fx_Glow(this.start);
		var e = new fx_Move(this.start,this.start.x,this.start.y - 32,0.05);
		e.curveIn(2);
		e.onFinish = function() {
			_gthis.start.kill();
			_gthis.spawnMenu();
		};
		var _g = 0;
		while(_g < 32) {
			var i = _g++;
			var el = new h2d_Element();
			el.play("twinkle");
			el.anim.gotoRandom();
			el.blendMode = h2d_BlendMode.Add;
			Game.me.addChild(el);
			var p = new fx_h2d_Part(el);
			p.onFinish = ($_=el.anim,$bind($_,$_.stop));
			p.setPos(this.start.x + Math.random() * 192 - 100,this.start.y - Math.random() * 64);
			p.weight = -0.02 - Math.random() * 0.1;
			p.life = 10 + Std.random(20);
			p.fadeType = 2;
			p.vy = -Math.random() * 5;
		}
	}
	,spawnMenu: function() {
		Game.me.removeBut();
		this.buts = [];
		var _g = 0;
		while(_g < 3) {
			var i = _g++;
			var ww = 96;
			var el = [new h2d_Element()];
			el[0].goto(i * 2 + 1,"menu_buts");
			el[0].posChanged = true;
			el[0].x = Main.WIDTH >> 1;
			var ty = [164 + i * 36];
			Game.me.addChild(el[0]);
			el[0].posChanged = true;
			el[0].y = ty[0] + 100;
			this.buts.push(el[0]);
			el[0].alpha = 0.5;
			if(i <= Main.profile.level) {
				el[0].alpha = 1;
				el[0].makeButton((function(_g,i,el) {
					return function() {
						_g[0].select(el[0],i[0]);
					};
				})([this],[i],[el[0]]),(function(_g,i,el) {
					return function() {
						_g[0].rover(el[0],i[0]);
					};
				})([this],[i],[el[0]]),(function(_g,i,el) {
					return function() {
						_g[0].rout(el[0],i[0]);
					};
				})([this],[i],[el[0]]));
			}
			var go = (function(ty,el) {
				return function() {
					var e = new fx_Move(el[0],el[0].x,ty[0],0.1);
					e.curveIn(0.5);
				};
			})(ty,el);
			new fx_Wait(i * 8,go);
		}
	}
	,select: function(el,i) {
		var _gthis = this;
		if(this.selectDone) {
			return;
		}
		this.selectDone = true;
		Main.playSound("select",0);
		var next = function() {
			el.kill();
			_gthis.launch(i);
		};
		var e = new fx_h2d_Blink(el,32,next);
		var i1 = 0;
		this.buts.reverse();
		var sens = Std.random(2) * 2 - 1;
		var _g = 0;
		var _g1 = this.buts;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			b.removeButton();
			if(b == el) {
				continue;
			}
			var e = new fx_Alpha(b,0);
			var e1 = new fx_Move(b,b.x + sens * 32,b.y);
			e1.curveIn(2);
			e1.onFinish = $bind(b,b.remove);
			sens *= -1;
			++i1;
		}
	}
	,rover: function(el,i) {
		if(this.selectDone == true) {
			return;
		}
		el.goto(i * 2,"menu_buts");
		Main.playSound("over");
	}
	,rout: function(el,i) {
		el.goto(i * 2 + 1,"menu_buts");
	}
	,launch: function(id) {
		var _gthis = this;
		this.kill();
		var spc = 0.05;
		var e = new fx_Move(this.olympio,this.olympio.x,this.olympio.y - 160,spc);
		e.curveIn(2);
		var d = this.doors[0];
		var sens = -1;
		var e = new fx_Move(d,d.x + sens * 128,d.y,spc);
		e.curveIn(2);
		var d = this.doors[1];
		var sens = 1;
		var e = new fx_Move(d,d.x + sens * 128,d.y,spc);
		e.curveIn(2);
		var e = new fx_Move(this.title,this.title.x,this.title.y - 128);
		e.curveIn(2);
		Game.me.snowman.lookMode = -1;
		var vy = 0.0;
		var vx = 0.0;
		var sm = Game.me.snowman;
		var scroll = function(e) {
			if(e.step == 1) {
				if(sm.head.trg.y < 0.1) {
					sm.head.trg.y += 0.05;
					sm.majBody();
				} else {
					e.kill();
					Game.me.launchMode(id);
				}
				return;
			}
			var end = false;
			vy -= 0.25;
			var d = _gthis.doors[2];
			var v = d.y + vy;
			d.posChanged = true;
			d.y = v;
			d.posChanged = true;
			d.y = d.y | 0;
			if(vy < -8) {
				vx += 0.25;
				var v = d.x + -1 * vx;
				d.posChanged = true;
				d.x = v;
			}
			if(d.y + 516 < Main.HEIGHT) {
				end = true;
			}
			var d = _gthis.doors[3];
			var v = d.y + vy;
			d.posChanged = true;
			d.y = v;
			d.posChanged = true;
			d.y = d.y | 0;
			if(vy < -8) {
				vx += 0.25;
				var v = d.x + vx;
				d.posChanged = true;
				d.x = v;
			}
			if(d.y + 516 < Main.HEIGHT) {
				end = true;
			}
			sm.head.trg.x = 0;
			sm.head.trg.y = vy / 16;
			sm.majBody();
			if(end) {
				e.nextStep();
				Game.me.snowman.lookMode = 3;
			}
		};
		new fx_Call(scroll);
	}
	,__class__: seq_Menu
});
var seq_Tuto = function(a) {
	Fx.call(this);
	this.sm = Game.me.snowman;
	this.stack = a;
	if(a == null) {
		this.stack = seq_Tuto.SCENARIO.slice();
	}
	this.next();
};
$hxClasses["seq.Tuto"] = seq_Tuto;
seq_Tuto.__name__ = "seq.Tuto";
seq_Tuto.__super__ = Fx;
seq_Tuto.prototype = $extend(Fx.prototype,{
	next: function() {
		if(this.stack.length == 0) {
			this.kill();
			return;
		}
		var cmd = this.stack.shift();
		if(cmd == null) {
			haxe_Log.trace("todo",{ fileName : "src/seq/Tuto.hx", lineNumber : 125, className : "seq.Tuto", methodName : "next"});
		} else {
			switch(cmd._hx_index) {
			case 0:
				var str = cmd.str;
				var snd = cmd.snd;
				Game.me.displayText(str,$bind(this,this.next));
				if(snd != null) {
					Main.playSound(snd);
				}
				break;
			case 1:
				var _g = this;
				var coords = seq_Tuto.HELLO.split(",");
				new fx_Call(function(e) {
					_g.sayHello(coords,e);
				});
				this.sm.lookMode = 3;
				break;
			case 2:
				var hid = cmd.id;
				Game.me.giveBall(hid);
				new fx_Wait(20,$bind(this,this.next));
				break;
			case 3:
				this.sm.hands[1].setHint("mouse_move",true);
				var h = this.sm.hands[1];
				this.movecount = { n : 0.0, ohx : h.x, ohy : h.y};
				Game.me.play();
				new fx_Call($bind(this,this.testMove));
				break;
			case 4:
				this.sm.hands[0].setHint("spacebar");
				Game.me.play();
				new fx_Call($bind(this,this.testCatch));
				break;
			case 5:
				this.sm.hands[0].setHint("spacebar");
				this.sm.hands[1].setHint("mouse_clic");
				this.certif = false;
				Game.me.play();
				new fx_Call($bind(this,this.testSwap));
				break;
			case 6:
				this.sm.hands[0].setHint("spacebar");
				this.sm.hands[1].setHint("mouse_clic");
				Game.me.setScore(0);
				Game.me.play();
				new fx_Call($bind(this,this.testJuggle));
				break;
			case 7:
				if(Main.profile.level == 0) {
					Game.me.displayText("you have unlocked the Challenger mode",$bind(this,this.next));
					Main.profile.level++;
					Main.saveProfile();
				} else {
					this.next();
				}
				break;
			}
		}
	}
	,sayHello: function(coords,e) {
		var h = this.sm.hands[1];
		var mpx = coords.shift();
		var mpy = coords.shift();
		var x = Std.parseInt(mpx);
		var y = Std.parseInt(mpy);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		var this1 = new h2d_col_PointImpl(x,y);
		this.sm.recMouse = this1;
		if(coords.length == 0) {
			this.sm.recMouse = null;
			e.kill();
			this.next();
		}
	}
	,update: function() {
		Fx.prototype.update.call(this);
	}
	,testMove: function(e) {
		var h = this.sm.hands[1];
		var dx = h.x - this.movecount.ohx;
		var dy = h.y - this.movecount.ohy;
		this.movecount.n += Math.sqrt(dx * dx + dy * dy);
		this.movecount.ohx = h.x;
		this.movecount.ohy = h.y;
		if(this.movecount.n > 450) {
			Game.me.stop();
			e.kill();
			this.sm.hands[1].removeHint();
			this.next();
		}
	}
	,testCatch: function(e) {
		if(this.sm.hands[1].balls.length > 0) {
			e.kill();
			this.sm.hands[0].removeHint();
			Game.me.stop();
			Main.playSound("tuto_success",0);
			new fx_Wait(20,$bind(this,this.next));
			return;
		}
		if(Game.me.balls.length == 0) {
			Game.me.giveBall(0);
		}
	}
	,testSwap: function(e) {
		if(!this.certif) {
			var n = 0;
			var _g = 0;
			var _g1 = this.sm.hands;
			while(_g < _g1.length) {
				var h = _g1[_g];
				++_g;
				if(h.balls.length > 0) {
					++n;
				}
				var _g2 = 0;
				var _g3 = h.balls;
				while(_g2 < _g3.length) {
					var b = _g3[_g2];
					++_g2;
					b.from = h;
				}
			}
			this.certif = n == 2;
		} else {
			var n = 0;
			var _g = 0;
			var _g1 = this.sm.hands;
			while(_g < _g1.length) {
				var h = _g1[_g];
				++_g;
				if(h.balls.length > 0 && h.balls[0].from != h) {
					++n;
				}
			}
			if(n == 2) {
				var _g = 0;
				var _g1 = this.sm.hands;
				while(_g < _g1.length) {
					var h = _g1[_g];
					++_g;
					h.removeHint();
				}
				Game.me.stop();
				Main.playSound("tuto_success",0);
				e.kill();
				this.next();
			}
		}
		if(Game.me.balls.length < 2) {
			this.certif = false;
			var ok = true;
			var _g = 0;
			var _g1 = Game.me.balls;
			while(_g < _g1.length) {
				var b = _g1[_g];
				++_g;
				if(!b.hand) {
					ok = false;
				}
			}
			if(ok) {
				var h = this.sm.hands[0];
				if(h.balls.length == 0) {
					Game.me.giveBall(0);
				}
				var h = this.sm.hands[1];
				if(h.balls.length == 0) {
					Game.me.giveBall(1);
				}
			}
		}
	}
	,testJuggle: function(e) {
		if(Game.me.score >= 10) {
			e.kill();
			Game.me.stop();
			Main.playSound("tuto_success",1);
			new fx_Wait(40,$bind(this,this.next));
			Game.me.scoring = false;
			var _g = Game.me;
			var erase = true;
			new fx_Wait(20,function() {
				_g.fxScoreMark(erase);
			});
			var _g1 = 0;
			var _g2 = this.sm.hands;
			while(_g1 < _g2.length) {
				var h = _g2[_g1];
				++_g1;
				h.removeHint();
			}
			return;
		}
		if(Game.me.balls.length < 3) {
			Game.me.giveBall(0);
			Game.me.setScore(0);
		}
	}
	,__class__: seq_Tuto
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : $hxClasses["String"] = String, enumerable : false, writable : true});
String.__name__ = "String";
$hxClasses["Array"] = Array;
Array.__name__ = "Array";
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
haxe_Resource.content = [{ name : "R__DS_Store", data : "AAAAAUJ1ZDEAABAAAAAIAAAAEAAAAAIJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAcAAAABAAAQAABzZHNjbGJvb2wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAFAGYAbwBuAHQAc2RzY2xib29sAAAAAAYAcwBvAHUAbgBkAHNid3NwYmxvYgAAALpicGxpc3QwMNYBAgMEBQYHCAcICwhdU2hvd1N0YXR1c0JhcltTaG93VG9vbGJhcltTaG93VGFiVmlld18QFENvbnRhaW5lclNob3dTaWRlYmFyXFdpbmRvd0JvdW5kc1tTaG93U2lkZWJhcggJCAlfEBp7ey03NSwgMTE2OX0sIHs5MDAsIDEwNTV9fQkIFSMvO1Jfa2xtbm+MAAAAAAAAAQEAAAAAAAAADQAAAAAAAAAAAAAAAAAAAI0AAAAGAHMAbwB1AG4AZABzZHNjbGJvb2wBAAAABgBzAG8AdQBuAGQAc2xnMVNjb21wAAAAAAAAAAAAAAAGAHMAbwB1AG4AZABzbW9ERGJsb2IAAAAIWRx5RtF3xkEAAAAGAHMAbwB1AG4AZABzbW9kRGJsb2IAAAAIWRx5RtF3xkEAAAAGAHMAbwB1AG4AZABzcGgxU2NvbXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAgLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAABAAAAQAAAAAEAAACAAAAAAQAAAQAAAAABAAACAAAAAAEAAAQAAAAAAAAAAAEAABAAAAAAAQAAIAAAAAABAABAAAAAAAEAAIAAAAAAAQABAAAAAAABAAIAAAAAAAEABAAAAAAAAQAIAAAAAAABABAAAAAAAAEAIAAAAAAAAQBAAAAAAAABAIAAAAAAAAEBAAAAAAAAAQIAAAAAAAABBAAAAAAAAAEIAAAAAAAAARAAAAAAAAABIAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAEAsAAABFAAACCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBERTREIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAIAAAAGAAAAAAAAAAAQAAAIAAAAABAAABAAAAAAAAAAABAAAEAAAAAAIAAAgAAAAYAAAAAAAAAAABAAAgAAAAAAEAAEAAAAAAAQAAgAAAAAABAAEAAAAAAAEAAgAAAAAAAQAEAAAAAAABAAgAAAAAAAEAEAAAAAAAAQAgAAAAAAABAEAAAAAAAAEAgAAAAAAAAQEAAAAAAAABAgAAAAAAAAEEAAAAAAAAAQgAAAAAAAABEAAAAAAAAAEgAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_screens_sc_4_png", data : "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"},{ name : "R_sounds__gameOver_impact0_wav", data : "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UwPrApkDFgR3BA8GpAV2BvIEYgUFA+IEZwF8BXYCigSEA4MDgQM1BFICfAX5ApAGiwJYBcUCVgRaA0sEZQOHBaYD2wZ2BAsHhwOVBr4ClAbGA0QHkgO4BcEDeQROBCQF/QQWBgMG8gYxBmUGRAWyBcgFoAblBZoGDgblBGYFOAbbBJEHpgWQBysGqAavBScG6gXNBuYGuQhwB8YIUQfCB7cGpQclBnEGewVYBlQF/wY4Ba8GSwS3BsgDUAZcBEEEhQRrAukDkwKLBLkEXwXkBsoGXwhUCBYL8woPD+0MKA9NDZ8ONwyIDmALig0JC04LfglcCG4HbghwB2oJjwe+B+kFKAY0BEYHEgXICbcG8QpIB1ULggbRCXwF5AihBIMHlwNVBjME1QUzBFYGaQSCBbwDRgUgA10G+gMhB28FswajBcIGPQZSB1AHRAhIB/IIAAd7B0wGFgYFBd8EWwN2A0gDiQPaBDoEOQU1BNIErAVtBXYGigbiBaEGCAbuBtUGFAYSB5EFnQUVBLQDawIYArgB7AHJAc8CSgJiAwoDngHjAnsBswJHAgIDMgSWA8AGiwS8B/gEdgYEBIYFbgJUBpcABQVV/y4CCv6ZAFj+9/91/1UA2gCmACsC3ABVAjEC+QKgAgoCVwHDAWEAlQB6AMX/RwH4/0EBq/+wANr/5P/3/50A2wAfAwwDmwRzA+QDRwP8AtYE4QGcBbABbwTDAdYCnAEHAkEBjQHz/wUBbv9zATwAdAIMAUUD+ACsAl4AFAKCAEcB9gG+AEgC3ADIAqABbANCAz0EwQOjBF8EQATaBB8EOgRGBZkEugRaAzQCiAJhAnwCtwNdAwQFLgN1BXoCGwQ2AYkCyP5QA6H+TAKM/7UBAwCrAHsAMgCIAKQCFgH8A28C2QQ1A2YFKQRrBV4FoQXXBWIHgAX2B1sFMAcGBaMF8QO6BHoDigTgA2cE+AJIBAID6AMBBDoDkgQUBFEFuwTyBQ8FfAVBBVYFvAZnBhwHsgbtB28GDwmqBpsITQZcCMgG+giKBsYHogViBmcFnQY4BpoGpQbfBG4GIgRBBrQFywZoBRgGcQQkBSIEBwXpA20FgQPCBoACZQd7ABIHQAHOBhADcAclA2wHxAKkB6ECfAdqAokG5AOqBbwF3QZOCOEHfAgfB28H/AZuBncH9gYHBzcIcQepCIoH6AjiB1IJXgi8CL8HDgioBqQGqwZ5BmcHeAblBzUG5ggxBgAHmwbWBHcGLQSHBrYETQe4BZsIBAf2Cm0HOQuqBx4KVAdgCdgGMAhPBuEH5AVnCEwGLAnEBXoIUAZhBxYHYwclCH4H9wg2CD4JkwhiCfwISAiSCH4H2wg4CJQJAAkeC80IIQtICS4LWQpPCkEJLgm5CAAIpQkKCNYJlQcDCa8GNQjxBXcH9wVZCIEFqgiEBs0INAfvB1IHegYZB2kFEwX4BKoCrAOXAaECQgAlAbn/8AD3/5oCVAHVA4sB6AORATkDrQA0A3sAUgM+ABcENQAbBSMAHgRhAF8DJwAJA48AWQN0AeQDxgCIA+v/TwPpAPEC7AATAnMAJQK6/xwCbv5iAyD+NgTw/kIDOQDEAhMAVwOxAH0ErAH/BI0B4wTNANwEeQDGAyoBSgLeAdoBTAHRAW3/FQGA/+UA/wGFADYCSQBNAeQAMwCbADwArv98/4r++v14/o79Xf6//ef9Q/4t/4n+1f+p/o7/zf0z/9H9qf/Q/tz/Lf8zAJMAygBHAfAAjABOAN/+GAAi/xIA2//O/7r/xP9q/zoA/P3k/1D9ev5S/vD91v7p/pX+KP94/d/9B/61/bb/Zv+a/9n/qf7M/yz+av9k/1r/Pf89AE7/uwD3/ssAif7KABH+RADI/AEAe/yT/9H93//C/qz/nv4D/7v8vv1m+xT9QPs8/VH6B/za+rL67/zx+tj9//xG/Lr9wfoG/oz6i/4M+4v+rvvh/k78p/78+5n+8fs3/2D77f/9+V7/nfo8/0X89f7Q/MH/8Pw6/0T8Y/7x+v38R/mI+274+vn19yX6Hfku+gT6zPlK+lD5hvgq+fD39/km+oH6C/vJ+qT6lfoc+ub6XvmD+uv53fqF+pX7oPqp+7D5BPya+Sf8Wvlh+/X2EPou9Vj51PRH+Zf0jflp9VL6p/bs+nj3IfsD+AT7qfim+tb4wvke+PP43Pc4+H733feP9m/3jPUg9iL2b/eW94v4qvZs9wn28vYJ9hL3jfVc9sX0FvZn9Kv1U/SY9Y/0F/b59MP1EfXh9bP09vVT9Hj11vOn9ebz//Xh9NT1E/Ux9ov00/UR8y72KPMh9irzPfUR85D01fKD9M7yq/S08iT1Y/T09PP03vRZ8970rfLW9Nz0FvVd9k31VvZ89X32+fbE9zD3d/fU9q72gPaQ99T2gfeU99L2A/hR9hX4o/Y2+M/2P/mf9hr63fbI+qP27vmU9WD5kvaU+YH2Z/pE9aL6PfV/+V/1Efnb9DP5dPQc+S31mfj+9PX3IvXs+Cb2Pvrb9SX6ZPaK+Qb37Pjv9ij4uPZo+Ez3S/kU+Lb5ivlI+QT6sPjK+uD4avuL+QD7gvpo+vv5wPlQ+ef4mPmI+Gf5XPhA+aH3hPnZ+Hn5aPoP+g77Y/oG+l36dfjK+jr4uPrI+Ln5afmR+GP5A/h++KP3J/cs90P3jfdK+E34Gvns+Jn5zfmC+u759vsT+sD8Fvqr/B76dPx9+nz8Cfo8/CD6IvxV+sX8Y/qz/az6/v3M+iz9fPt8/Kr7wvzp++37efy7+5f8bvwE/gn9KP///QoAD/6GABH+QADQ/HT//vt+//38Ef+y/S0Acf1YAJP9+P8g/nYAjP7c////rQCA/3EBz/4GAS7+bQBG/v7/Jf8PAB3/BwCJ/0EABwAZAPn/ZAA8/60ANv4aAAb+oP+V/hEA4v6TAJ//rgDFAHgAFQOlAKIEEAGyBOEAWAOAADwCygCdAnwB7QMiAsIDmwHeAogAFwJTAB4BdwBzARQB2QFZAd4BvgEfAzsCdwNQArMC3AHpAfgBSwFIAq8ByQI5A8ADFQRwBNQE7QS/BGgEMwQEBWYEDwVDBEkE5AQ9AyUGhAIVB54CQQfLAscFPQIHBWQB5QRzABQFGAC9BNIAuATHAEsFnQEGBgQDrgV/Ar4FAAKvBYQC5QSGAoIElAJ/BO8CRAUiBOAFXgR9BsgDTgbAA1UFHQRUBB4E0AM8A8wDxAG2AxkBTQN6AaQC3gElAjEAKwNZAJsDVAJSA/8DNgNdBGMDNwSCBPoE6QSMBI0DlAMtA/AC3gMDBPwDDQR5A5YDFgO2AiwDzQITA7sC3gLEAuoC9AJqAl0CSwEjAuoB0QL/AeIBRAF8ASEBBALnAPgBjAGvAL0B//9BAm0ACQSdACkEGQHsAw4BAQQNAXkEZwHJA9ABQwTTAX8DgAG9Ar8BPgO1AdYCPQHlAbQBDgEPAgQBcQMfAbYD7wCnAuMA4gHbAKoBDgBiAQMAIwIeAGICWwAaASwANwAWAPL/uwBAADoAIAAB/oD/kf0c/h39uP0X/RD+Cf51/gX+T/9U/cn/VvweALX8QwCL/b//9f2f/0j/NQCiAL8AcgG7ADABAAAbAUMATADZ/yIAUv9f/3//LP5x/xH+N/4j/jX9XP7v/B/+5v3h/lj/Xf+z/53/Ov+cABIAOAGBAFcBUQArAWMAvwBWAFcAOgGa/0oCjwC6AqMBUgJ1ARECDALCAlICfANyARgDfwByAlsA9gGvAEIB/AELAe0CowGrA2sCyAP8AkUEYgQ1BZAFYAb8BVoHrQWAB0UGWwenBrkGkgfNBtkHSga8B0AFAwe0BCkGaAbWBl8HGQgWCDUIAgj+B4wHhAcJCPsGpAfwBugGVAbtBuoFWwYHBmgEkgVGBO4FZAM1BUoCAQXgAc4EtgLBBJwDlQSTBK0E8ARMBMMDWgQSA4IEAwOJBDYDKgTkA78DVASSA0sEpAMDBAoDkAN1AxQDwgQsA5YEmALCA8UCcwJMBOYBrwSLAk8ErgPqA1kDMAPfAoMDcAIMBG4CKASxAmwDmQKTA7YCTwObAvsCJgKTAtwB7wGMAkECLQP1AgMDmwP3AgwEkgNWA4MD9AExAvwAuwGKAeMBLgJHApoCNwI0An8BmAEYAZEB8gAzAgUCswKhAqIBwALYAZ8CjwJkAxED/AN3AoEEnQE3BAgCggO2AlQDsQJwA3wCvwLCAW4C3ACHAl0A4wE8AIEBxADxAF0AfADI/6b/g/+O/3//i/82ABH/Yf/R/lz+RP6//eb9Cf1I/Vb9W/2f/R79oP3K/JT+/PyR/z/99/9a/bD/cvzr/5/8ZgEq/kwDIgALBGkAtQPU//ICCQCzAm4AJwPTAIkDcgDiAikAVQPQ/3oDUf95Aun+0QEa/lEAY/2x//n8qwDX/ZwCwv4yAgn/aAEy/+4B5f/nAhcANwP0/7kCRgAsAqMATgG+//EAv/5/Aef++AB6/+D/pf8D/8z/5f7Z/z3/kf9i/x7/zf9x/ur/pf7Y/3v/LP9r//j+TP5Z/g79h/20/Nb9Y/zq/d37kv0e+/P7Yvo7+1X6U/yW+lz9pftH/bX8pv2T/Vb+r/2+/qX9u/3n/E78E/zh+vT7yPqF+0r7Wfvo+j77/flq+hH6J/pv+9T6Tvx5+kP8EPpX/Kj6x/x9+5r9WvyV/Sv8Ov11/OH8zPzm/Rj91P4N/r//u/5b/6/+q/44/q3+iP3D/oD8xf7m+9X99Pqb/LD6ZPxS+sX8Evqj/WP6Vv6T+8j+A/3t/bP9yPyc/f37cvzH+yH8efsj/FP84Pzv/NX8BP00/Ir9APya/VH8C/5C/Fv9Qftf/RD74/0P+9n+cPvB/vX7wP5W/C7/SP0W/8D+Wf/k/4r/gACt/4AATADs/+AAsv8sAS4A+v9fAHj+l//a/Y7+nP0f/tL94v0c/kv9p/0d/XT9RP24/bv95P2e/nz9V/4S/av9e/1X/fX+WP21/8T9ff+O/nz+jv4O/4b+qf+N/u//qf5JAOb+ZQEv/94B8P+MAqIANAOAAOICWQBrAub/ewKc/2YBhv9oAED/RQDd/nwAQ/9QAC8A7v8PAQgAMQFzABkB1wABAcYAMAGQAAIBhAD4AHMA3AHhAJUCGAEBAvgAxQH0AN4B3wEdAmkCMQIyAl4CPgIQAtMBrAHlAa8BFQILApkC4AGPApcAUAIWAIEChQBPA2wAFQTEAEAE7QAIBMcBAwQRAs4D7QGHAwgBCAMTAMcBCgAmAcAAHAJUAREDUgF4A7IBawOQAR8D2QHjA08CLQR8AmkDKQKiAj8CeAM8A6oDywN8A98DaAM/A7ADcwOtA0gD4gIWAz4CxQIyAqECggFNAukASgJaAakBeQGFAS0B+QFqAa0CogGPAmQBigERAX8BzADqAWUAMQLKAPMB6QGCAaQCsgElA7cBmgLnAfICrAE4A4MB4QLaAZACpgJIAswCiQLKAugCkAKcAsMCEgNcA6YEJwR1BbwE+ASKBCsENgSIAwgEEgPNAxMD1wNiA+kDPAMwBBIDVgT0AhAEBQPjA2sERgT4BHMEBQYFBb4GRgXIBpwF9wXDBeMFJAYNBhgGkgZjBd8GxQQdB/UEvgdMBRkIzwTvB5QE0gcSBJAGdgNVBZoCnwQEAmwEcwFtBCABswSAATgFrQL4BSwDbQasA/0FIgQoBv8DfAVZA94EegMKBf0D+wRdBDIFEwXsBIMFYQSvBWMEBwblBE4GOQWLBnUFjQYyBb0G6wSyBnIESwbrA4cFbAMUBSsDOASjA2YDVAQPA+gEfAMYBX8D0wR8A9cEbwRUBYgEwgWVBNwF1gS/Bd8EhgVyBGoF6ANeBAsDtwN3AusC/wHLAnUCPARIA0wFRAQuBvEEEgZrBbIF9QSDBcUEHAVNBT8FNwZGBUoGWwVhBuYEygWEBJkFYgR7BmUFXQdDBpUHCQdHB6wHmwZdBxMGwwbrBaYGzwQUBwkE/AbcAxsGMwP0BIcCiAMfAukCsAFBAxQCuwMgA/MDGgRUA2wEAwN6BEIDKwSYAyID6QNCAjkEegLKBFgDqwQnBE0DGAQ/AfYCcgDuARsANAL3/4YBRQCpAQsA3QH5/1wCIwDrAbwAiQFFASwB3AD/AGkAnwCVAAoAzgC+/1QBtv/1AVj/TgJ3/1sCM/8TAr/+/AGN//ACcgBwA50AnwLd/2MBsf5hAM79sv/O/cj/cf3//9b9vP+T/rL/Cv8XADr/VQDg/sn/LP4Z/zH9tv41/XT/mv0NAPz9wP9l/lb/Tv5K/4L+1//d/q3/4/42/zL/Mf+B/8D/6f99AIEAkwDoAC8AOABe/y7/PP+d/g7/Vv6a/s7+Uf4A/zT+2v4f/rX+r/47/wT/gf/4/r//uf8PAKn/uv9k/4L/Of9r/6X9Ef/d/In+7/yV/sH93/6x/n/+uf5k/l7+W/5L/kX+lv40/tP+R/5B/kH+0P3k/bb9Pf19/Wn88fys+2b8Z/q/+wD6zvsd+wv81fvg+xX8ePyA/Kz8evwV/AD8Fvun+yH72fu1+0P8xfvn/Eb76PwW++H8evs1/SX8pf3h/L/9vvxB/X38T/2r/EL9/vyk/Ab8mvuh+w77Gvwz+2T88Pu/+6n8EPtn/NL69/tg+8X72vtg+3v7rfrs+pX6ivqL+lr6Tfo++kP6GPoi+kP6bvrK+jn6f/sH+tb7w/kG/Mb5Zvv1+Xv6P/ru+Tb6Lvp2+dH5OPhI+rz3PvqT+DH6APlx+nL5PfqP+W766/l7+vb5Gfo9+pb5/fmk+en5R/oG+pz6rvrw+mb72vqd+/35gvtt+cX6UPle+kz58fmU+dj5cfoz+gT7Ofoz+xf7ZPuk+wH74fpt+jL5x/lU+Hz5iPgk+TL5RvmE+d34fflA+Ln4UPhz+Fj4IPkF+bz5L/kK+jL5Vvpf+Yb6rvmx+nD6zfoc+676OPvY+hH7+/r3+g/7BfvR+iL7bvu2+jv7G/om+6r69vpd+3P7pvvA++r73vvx+6X7Yvxe/PH8tvwi/ej8uP0K/er9Wvw//az7AfxW+8D7+/r++3X64vwY+kn9Xvq5/Z360P3v+rz9LfuW/ZT70/3m+0395Pv6/OL7Gf0P/FP9jPy4/Jf88PtC/DP8lfvK/Hj77/yM+4D95vvV/RD82v3e+5n9pfuy/R38c/1z/Kz8hfyM/OX8HfwS/f/73vyt+4X83vvE/Jr75vwO/Dz9C/xU/cX7yvzc+xH8KPy0+9D83fv3/Ib8P/3l/Av9wPzN/Lb8R/1Y/WL+UP5y//H+rv8h/63/Gv+R/kL+7v3+/Kr9CPyt/QH84v2j/Aj/mP0EAJr9BgCE/Wb/cP0f/6z9of5w/XD+Af5N/hr/C/6B/4b9D//u/AX+ofzp/Kf8f/zw/M78lP1+/aj9z/3u/RL+wv2j/q39T/7x/fH9cP7o/UD+xf3g/fH9I/41/pr+Ef64/sn9lP5A/UP+Iv0F/iv9/P3k/Gz9yPz//CL9nP0a/er9+Py9/bj84/0D/AT+jPxG/mr9qv5G/nL+a/4h/gf++/3q/bf94P1h/Zz9Kv3q/GL9d/wx/e77L/3a+xv96vud/I77DPz3+rb7TfvB+xb8Z/uq/K/62vwV+q/85Plk/GD6Dv20+nT9GvoA/cX5Lv12+jj9bftZ/Zb7JP3W+t/8gPpd/a/68v1n+0D+L/yG/nT8c/7B/A7+/vwN/iX99/00/dD9+/y1/Ur9VP7W/ST/bf6Q/4r+nf/h/vj/LP8lAEj/PABN/+H/sv5s/1T9y/5M/YX+mf2I/uz9sf6G/tj+A/4M/zP9sP5R/SX+sf3D/Yj9Cv5X/Y/+Hf2Y/vn8iP7O/AH+/PxX/Vr9rv1P/UX+Af1m/r78l/5V/Mn+aPxD/1T8sP+q/K//SP2g/6b9oP92/fr/4/2NAI3+CwEf/6gATf4LALH9u/8+/f3+MP27/vj8Pf6Y/Bv+bvwF/vz71P3A+939KPtb/Rr70vyv+278UPxp/NL8nvx6/AP9dPxO/cT8m/0k/QT+3f2I/pD+tv68/sn+qv6z/uz+3f5E/5r+eP8F/2T/VP9i/17/YP+S/yn/T//D/8j+OwCY/jEA3/7u/+L+nv8u/p3+E/3g/Vb80f1k/FD+QP0+/u39ZP4Q/mL+UP5D/rn+Vv7o/lD+If8U/hL/Mf4X/2b+Bf+6/i7/If+U/0L/5v9b/yoAk/91ANr/mgC8/5MAQf8hAJP/4v+V/+j/Bf+6/6T+UP96/gH/k/1s/un8If7e/Cf+yPyw/nv9ZP9P/hYAu/7b/+f+Xf/1/t7+Hv8x/0P/c/9R/7b/B//J//v+uv9P/+b/gP/L/2L/tv+c//f/r//CAPX/PwGc/5IBn/9yAWb/RwFL/2kBp//WAZ0APQK0AaYChAHyAkMBDwMjARED+ACZAl4A6QEqAHgBWgBqATsAngG+/+YB3P/6AfX/6wFT/4YBNf99AYv/rQGr/8oBBv92ASr//QCt/3MAGwARABgAuf/Y/3f/vf+c/8X/lf/I/0f/iv8i/zz/Bf+K/zD/k/9T/4v/IP+A/w3/hf9a/1r/OP8v/7T+IP/N/gn/gv8e/0cAtP/GAM//NAHi/04BVAB6AXcAmwGlAH8B3QCPAbwAuQFnAPEBlP/SAdD+oACc/or/mf5J/x/+G/9D/dj+l/za/n38QP8n/QQAxP1YACP+xP9K/gb/Jv96/p//uP4k/1r+nv7b/b/+yP0y/9L9iv/L/Un/wv22/iv++P3+/ur9Mf9l/hf/j/7r/vH9bP5X/cn9vf2W/Wv+E/7P/nX+qP7A/kL+1P4A/pb+pP3p/cH9V/2K/Uz9lP3C/df91P0z/sb9D/5C/kP+vP7P/h7/QP9S/6D/mv9Y//H/Ev8zABT/XwD4/vj/5v4g/47+Xv4Z/ir+6P0V/kD+Pf5//p3+nf6r/hX/wP7p/y7/VACn/2YABwC2/7n/pP7z/jX+Yv5z/hj+nf6K/tL+jP8x/+r/AADU/24Alf8yADT/ov+M/6b/FgCu/64Aef8gARr/PQFc/yAB7f/CAOn/mACL/5oAsf9sAX4AiAJ8AQQDHgIAAzMCMAM4ArIDtAK9A+oCegPBAoUCqgL5AWgC+gERAhQCjQHWAbsAhQEVAIgBUQBxAfIADwJ7AWICwgFlAu0BjwL5AegC+AHKAisCaQIzAgwCzQHrAZEB1gGBAfUBDgL7AaICGQLmAkMCygKCAs8C5AI2AxADxwIQA1kCHwONArECVwJaAtIBVwJoAZUCuQFEA+sB2APCAQ8ElAGUA/gB5QIDAloCCwLbATsCNgJPAr8CbwJFA3YCXwOZAiED9AIbA9MCPwP9AngDqAKjA/sBcgOxAUUDiwEgAzIBiQK1AfABwQGyAZ4CswGWA1QCcwRPA58ELQRiBE0EFwRJBFAE9gNJBF4DFgTPAn0DMAK9AtQB6AFQAVwB5wBGAfMADAEjAScBVQFtAXYBDQKeAcsCxAGtA9wBvQPVAY8DZwLRA0cDfwQYBHIFqARPBiYFhAYLBXQG2QQsBkUEPwW9A5METAPDA0MDnQN6A7QDawPsAwIDdASIAqUEiAJSBNQCUgT9AkEE6AJrBCMDvwSZAwcFIQQoBWIEMwWMBC4FwwTUBKIEfwQ7BGgEkQRABL0EkgT+BBcFcgVVBZQFLwWYBfwEaQUtBSYFywUPBRoG+ARNBj4FlQbWBScHhQZEB8YG0AZzBusF3QV/BW8FUgUdBbYF7wQmBm4FNQbEBSEG2gW3BbQFfwWvBZoFpgUHBsIFUAbMBVQGBQaJBlMGOgZPBmQFYAW+BI8EuQRABPIEdAQUBVsEowRbBAoEOwQsAwAExgINBPsCIgScAx8EqgSjBLsFFAWwBRIFiwWzBFwFcwQ1BXUE0wSzBAwFnAV7BWsGuwWkBvcFmgYjBnEG/gXLBZMFNgWUBQ8FmgUVBXEFuQSpBYMEbAUABaEFsQUdBkgGQwZqBjEGWwbOBVEGhQUuBugF8wUVBnYFIwbUBFkG3wRjBk8FVgZoBVsGiAWcBocFuwZaBSsHLAXLB8oFFwjgBacHxwUnB60FzQYTBqkGkwavBuYGkQbFBngGrgb7Bq0GOQedBuwGIAYVBjYGfgVgBk4FeQZuBWoG+wQCBpIESgWzBLQE+ARuBFQFzARkBS8FUwVjBWwFOgWnBYUFjAWTBVwF8QRXBfAEwAU4BVYGpwWpBvAFxgbYBQgHDQblBjIGAgcxBiUHogbOB9QGHwjmBvIHEgc5ByAHrQbhBiUGmQb/BXkGaQbjBlYHNwcbCC8HfwgRB24IDQcqCAwH8gd4Bq0HNgYTBxwGIAdFBv4GNAb3BtQF+AbFBfYG2wXmBuMFwwYUBo4GZwYbBikGzgX7BbAF3AWkBT4GGAVRBnIEYAYyBPsFWQSeBQoFugWgBesF5wWvBYEFbgVXBdwEYAWZBDcFiwRbBbkEtgVFBXYGAAaLBm4GGgbiBYIFIQVBBW4EaQTsAyUEXwS6BJUE3wR/BN0EUASNBGEEWAR3BDoENQRTBP0DsgRGBDIF2gRZBSkFGAUEBU4FuQSuBXAE0gUbBIkFCwQDBXIDAQWGA5UFtgNABscDIgZSAyoFowIPBBgCvQN7AcsDIQEBBG0BDwT8AQgEtwIBBFwD8QOFA2YDYwNTA5EDTAPvA6sDfQTrA6YEYAQiBFIEIQPkA7ICjQOzAkgDwgIyA+0CbgNDA60DLgPLA70CcQN8AgsDLwLPAhsC7QKvAkgDKwNsA2cDuwNNA7MDwQJBA14C0gKKAoIC3QL5AWcCoAG4AaABrgG6AQcCAgKGAjgCbgJbAi0CUQLrAT8CZAEVAvQAFgJnAHMCNwCuAngARQKNAGcBIgDQACoApAD7/0EA3v+b/5X/Pf+c/yH/zv86/zUAfP+mAOf/qgBQAKcAdQDDAB8AyADY//YAfP/GAEv/MAAm//f/Kf/j//L+of/p/lj/vf79/gf+Z/6Z/Rz+if0c/qz92f3A/Yb9//2G/eL9tv3p/fz9Ev4P/gr+/f0Z/tD9Lv7k/Sv+K/7b/Uf+jf1Q/kn9JP7V/KT9e/zm/Hb8RfyR/Pz7y/wg/Ef9YPxO/aX8DP3H/AP9Z/wi/Qn8Ufya+1n7NvvI+s76CPqJ+lj5a/rA+AH6p/h++cv4UPmy+E35uvi2+f34QPpU+aX6sfm5+u75hPoa+p/6Qfr1+mX6lvup+pX73/oq+w/77voo+5P66fp8+jv6gfob+mD6gfpf+in7dPpY+6X6Z/vN+nb7Lvvz+zv72/vi+nX7xPq5+rP6VPq++m36kPpW+hT6Qvrm+TP6o/m2+a35M/m5+Rr5kvk3+V75jfkV+Q/6FPlU+jT5xvpd+ef6hPlI+or5lPno+Rv5/fnu+Nb5y/h5+af4Ifl/+Hj4bvhC+Hz4M/jO+DD4NPl5+Ab5x/j7+Cr59/hS+en4VPmq+Pz4u/iV+L74Gvix+BD4qvhO+LT4ePjf+Kz49Pjk+Af52Pjo+Jn4v/id+JP4oPhw+ID4MvgJ+OD3uffw9833T/gL+IX4afi7+Av53PiV+U75u/ma+a35ivnS+WH58fk1+f/5H/nm+cT4t/l0+Fz5xvg6+Uj5Z/nM+cr54/n2+ev5DPo/+ij6I/oT+vD5H/op+gj6cPrB+YX6yvk5+on5OPp3+ff5kPn7+aL5UfrX+dH6jPor+x77W/uT+6n7CvwB/F38JPyt/DH81PwM/Nb8HPzY/G/86vzn/P786/z9/JH8Y/yB/Cv8qPwf/AT9NPxD/T78WP0q/Cj94vvh/NL73fz7+xD9Cvzr/Nz7LfzT+7T74vuK+2380/uU/GT89/xb/Hn9J/zQ/Un8If4F/Sv+sP36/d39X/4B/gT/Dv5c/2f+gP+Y/mb/qv4n/4r+Dv+j/gj/3v6t/gL/N/46/9f9mv+t/en/pv02ALn9VgD7/T0AOv5dAJj+fgDb/lwAEP8AACj/mP/6/mv/zP5E/8z+RP/8/kn/af9p/3v/tf/x/9b/SAACAFQAcwBeAJ4AWAC8AD4ASAFfANUBmgA/AuIAggIxAagCdwF4AnAB0gEfAYUBlwBHAYQAIAGxAAUBpQDvAOcA7gDpAE0B3wDhAQgBGAI8AdwB+gAjAX4AxAA0AKEALQBRAAoAzf+t/0r/b/8l/5X/Tv/2/5r/WQC5/6QA1v/TADEANwFxAHMBBAHuASgBVQJUAYICggF1AogBdwJ5AY4CWwGGAj4BbQJEAdQCaQHxAuQB4QJcAsoCigIRA6MCjwN0Ar8DsgIxBBwDigQ3A0gE+ALDA30CNwODAsECiQJZArACVALUAhkCyQLZAcACxAGIAlgBZgIVAZMCRwH4Ap0BhgMiAtMDpAIoBNsCPwT/ApcEzALFBO4CjARCA4wE1gNPBDcETgRCBEsE8APJA1gDZAOpAuQCVQJSAjcC/QFKAvgBHAIzAkICagJPAqUCmwKFArQC2wIEA2MDeAOrA1kExgOoBPMDqATeA1QEpgPoA8MDrwPaA7ADgQOyA18DmwMUA3IDowIAA40C0wIBA+wCrwMmA+cDRQP3A+AD7QMYBD0D6AOzAlgDYwLsAkACuQIGArQC+QHEAi0C5gJXAvwCrwITA8oCbwPCAmMDtwILA6UC/gKaAgwDyQIPAywDHQPrAz4DhQRzA/4EaAMvBYcD3QW1AxkGFAQ2BogEJQaoBEMGegQuBgsEVwV3AzMEsAI+A5wBKgKpAAwB5v/l/0z/gP8I/6X/Iv/A/xv/2/8//1MAn//dADYAvAH/AIcCyAExA14CZgPHAnED/wKEA2wDjgPtA5sDcgSDA3gE6wJCBJYCCQSPAu8DgAIaBEwCvgMhAigD9gGFAhQCIgJOAtcBcwK+AT8CwwEPAt8BCAK7AR4CZQEqAjUBCgIlAfQBKgEqAgYBaQLWAA8CtwC6AawAsAGQAC0ClAC7AvsA4QKYAYYCLAJxAs4CjQJEA8ICoAOfApMD8QH0AoABSAJYAdwBagF9ARIBMgF1APcAwP+KAKb///8MANj/hQAnALUApACoAL0AkwC9AIkAtACsAOsA/gD4ACMB2QAOAc4A8wCeACUBdQBPAWIAYAGLAP8AlQAGAX0ACAGNANwASwCIACsAgwAnAEIAFgAdABMAEAAjALz/NgB6//L/xP+e/wEAif86AHL/PwCF/zwAg/88AFv/kwBi/8wAT/9pAA3/2v+R/qn/ov7A/+H+l//E/h//Zf66/gL+fv4M/n3+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wAD6ANAA0gDzAL8ARwGkAIgBlwCgAXUAlAFRAG8BQgBCAUkAGwFWAAYBOwD8AN3/1gB+/7UAR/+tADr/oQBU/2EAfv8eALT/7P/x/8P/MgC1/2MAsv98ALD/bwC5/3gA0P9+AOL/kQDd/6EA4f+gAO3/ngARAIkAKQCBAGQAjgCaAI4AuQB6AMAAVQCsAFUAngBhAJQAjgCTAMcAowAJAbQARQHwAGsBIwFsASYBWQEAAT4B+gBWARkBgQFmAZwBmwGWAbEBcAGtAXcBzAGOAdQBxAHFAfABvAHhAbQBxQGZAb4BjgHgAZEB5QGJAdsBYAG5AUsBqQFUAbgBiQHyAbUBIQKzAToCsQFdArEBgQLYAaQCDgKXAisCWgIVAhoC8AEZAtIBQQLEAVkCzQFbAuMBZAL7AXQCBgJhAh0CUgIxAmACWgJ0AngCdAJZAlsCUQJFAj0CJwJGAhUCTQIqAkQCIgIzAg4CBwLjAcQBtgF4AZgBKAGRAe4AwgEJAQcCNAEjAl4BGAKIAfIBrwHOAdABuQHxAbEB7AG1AdUBwgHhAfUBKwI+AmkCWgJrAlUCHAJIAr4BVAKRAUwChAE1Al0BNwIlAUUCBgF9Ag0BoQIjAaUCQQGxAmgBtwKMAa8CkwGOAn8BiAKFAZgCmAG+AsMB7ALUAQkDvQHwAqsBqwKGAWsCZgE5Ak0BCAJRAdwBZgHYAX0BAwKmARgC1AEkAvABCAICAuwB9gHbAQoC+AEJAh4CFQImAhQCNAIlAisCUAIvAkMCPwIPAmICwwFMAlkBGwIKAewB6QDvAecABAIAARsCBwEGAvkA7AHvAOoB9gAFAvIAKgIDAUoCJQFoAnMBawK0AWkC6AFiAv8BNQIFAvAB4AGnAb8BbQGrAVoBngFaAYoBXwF3AYABjgGnAZ0BxAGnAdQBqAHNAbYBxAHNAbgB4QGgAfQBlwEGAqsBFQLQARAC7AEAAhMCAQI7AhACbgJIApUChAKSApACZAJyAioCUQIJAjMC/AEYAi8CIQI6AhkCMwIXAiICFwIJAhUCIQIZAh8CHAIRAggCEgL6ATUCBgJNAgICYAL5AXYC5QGYAvoB0AIUAvkCCAIZA/4BMAMNAjkDHQIVAykC9QJQAvgCXQLnAl8C7QI/AuoCHgLkAvgBzgLgAZQC8wFfAhsCLQJIAh8CSQIPAiwC9AHzAdwB1wHYAeUB/wEjAisCLAJNAiMCNwL8Af0BzgG6Ab0BoQGIAaQBZAG6AVIBtQE6AYwBJQFeAQABWgHnAHUB0wCFAdEAiwHaAIwB4gCaAeEAuQH1ANoBLAEHAmgBEQKlARYCqgEWApkBHQJ0AQ8CVAHdARwBtAHdAIUBrABKAXIADQFpAAIBhAAWAcMAJgH+AEgBOQFhAVEBZQFRAUQBKwH2AP4ApwDSAGYAsgBOAMMAPQDrACcABQEfAA0BTgAWAYgAGQGtAB8BpAAmAXsARQFLAG0BKwCaARIAngEfAKMBMQCnATwAnwFnAJQBjgCDAbkAfAHWAG0B5gBYAesASQH0AEABCAE9ASYBPQEfATEBDQEUAd4A3QCpAJUAfABUAHEASAC4AFUADwFnAGABfQCpAZUA1QGxAMUBxACaAbYAYwGeADgBmAAwAZwAPgG5AEkBzAAxAccA9wCYANMASAC4AAUAmgDV/5UAy/+gANv/nADu/4wA8/9xABUAaABZAGAAhgBOAIQASgBlAEoAYwBaAHMAdwCMAKMAtADCANYAygDtAL4ABQGMAN0ASACYAAUAVgDd/y8A9v8bACIA/v84APj/SAATAGYAGwBzABcAjwAiALYATgDSAJIA4ADDAOgA2ADfALAAtAB5AJgAawCDAG8AYgCAACgAbgDy/0EAz/8OANT/CwDx/yAACAA8ACoAVgBGAE4AYwAxAJYAGACuAAkApwD6/48A6f+NANn/fwC7/34Aq/+ZAKf/tgC2/9gAyv/kANv/4AD6/8IACQCfABQAYwANAB0A9//f/7//of+A/3v/hP+D/5z/l//k/77/LwDv/3YAAgCHAOj/XwC7/yIAmf/9/4r/BQB8/zQAhP9zAJ3/pgC3/+UAu/8DAaT/BgGF/wgBVv/8AFT/8gCA/+MAvf/VAPL/zQAWANUAGgDOAPv/wgDI/40AmP9UAG//EwBm//L/fP/o/53/2//I/97/1f/t/8z/5v+n/87/i/+9/3z/0P+e//3/5v8lAD0AVACJAH8AqwCXAMUAiQDWAHUA0ABiALQAUgCGAFYAXgBhAEMAcAA+AGkAGQBEAPP/HwDe//n/4//W/+j/1P/1/+f/DAATADcAYABoAKAAjADLAHYAvABBAKsA9v+dALb/eQCb/2EAmf9RAJv/RQCi/ykAtv8YAMv/GADx/ywABgBVACYAigAwALEAKADBACIA1wASAOQADwDsAB8A2AAxALMANwBzAEAAPgBEAC0AcwBPAJgAhwCoAMAAvwDqAPAA+gAiARsBLQE4ASMBXgEXAX4BBAGPAeYAdgGrADwBZAD5ABwAqQDu/34A5f9dAPX/UwATAEsAPwBkAEMAgwBSAI8AZACBAH0AYQCVAFoAkgBZAIkAWgCEAFwAoABhAM8AVgDeADYAxQAHAKAAxP98AIj/WgBS/1IAS/9aAHD/PQCo/y8A7f8sADAAZABtAJ4AlgCxALcAqgDSAKoAzwCZALIAlQCuAJEAuACcANsApwDxAMEABgHSACgBxwAyAcMAFwHLAPkA8QDkAAYB8AASAfcACgEAAQsB+gAOAeMA5wCuAJ4AdwBeAGYAUQCOAIIA7QDxAGQBdgHDAcwB/QHeAQ4C1gH7AcUB2wG2AawBjgFuAU4BHwENAc4A2gCLAKQAdgCDAIcAaQCqAGkAwwBwAMUAXACrAFQAjwBCAHYANQB3ADQAnwBDANAAYQATAaIAZgHPAKYB0gC7AboAmQGwAG0BrgA1AaUAGgGQAPsAjADbAH4AuwCNAK4AowC4AMoA0QDvANQA8wDFAPsAwgAQAdgANAENAVYBSgFrAXABegFhAV8BLAE4AeMA/wCVAMYASgCfAB4AcAAUAFsAQABoAIsAoADaAN0AIQERATEBLwEpATkBQgEjAUYB7ABDAbMAHgFzAOcAPwCcAB4AaAAWAFcALwBbAFkAbgCSAIgAygCVAOcAmQAOAZgANQG9AFoB4ABnAfQAVQH5AD8B5AAdAbEA5gB1AMAAOwCzAAoAjQDU/2kAw/9TANb/XAAEAF0ARABQAG4AQwCrAEUA4QBXAPMAYQALAV4ALgFUAF0BaABwAWgAgwFfAIIBKgBhAdz/MAGN/+oAWv+dAD//dwBB/30AZ/+lALb/3gAaABkBUgA/AW4AVwFyAFgBgABGAYEAIQGOABABfwDvAIgA5QChANcAtQDHALMAwQCfALAAggCWAHMAeQCDAGMAnABXAJoANQCBAAkAWADd/wwAwf/D/6r/j/+u/3//r/+i/7v/9/+t/2IAoP+mAJD/vwCW/8sAof/JAMf/ugDy/6QAFQCIAA8AVgD3/w0A2P/V/8b/n//J/3T/3P9e//j/P/8aAC3/PwA6/1wAaP+HAKj/qAD+/8wAQADbAFsAxgBMAKAAHQB+APz/ZgADAGYAGgBUACEAMAD9/+7/0/+c/8r/Yv/W/0L/9/85/xUAQP8mAGT/NQCC/ycAiv8FAIX/0f9s/6T/XP9+/03/Z/9W/0z/bv9A/4z/Uv+g/3X/o/+s/6D/2f+o//X/rv/e/5v/x/+L/7H/ff+q/3f/u/96/63/eP+R/3L/V/9b/yT/Sf8A/zL/8/4q//3+Mv8p/0z/Rv90/0D/h/8t/2z/GP9B/wX/JP/1/hr/Bf8Q/xT/H/8r/zf/Rf9S/23/Vv96/1v/bv9L/zz/Nf8N/yn/3P7+/qb+wf52/or+af56/o3+dP68/n7+1/6Z/t/+n/7O/pj+uf6E/pj+dv5a/mP+4f1H/lH9F/7s/PX9qfzd/Z/84f3F/BP+C/1a/mv9pf6o/db+vP3j/sH93v7e/dP+7/27/gD+rP4B/qP+/f2b/vb9j/7p/V/+wv35/Zj9gf2A/Rf9k/3f/KT9t/zN/Z/89v2R/BP+ufw+/gX9Vf5O/Uv+gP0z/p39Fv6r/RH+mf0S/mf9Fv5P/Qn+QP32/UH93P1J/db9Vv3c/WD95f1S/dH9Rv2m/TL9iv0l/Vf9Ef0j/f/89/zW/M/8pfy1/Hb8k/xD/Gn8Efxo/PT7bvza+2j8v/tZ/Lj7UPzV+2L8BfyH/EP8ufyP/O382fwO/RT9KP1B/Ub9Z/19/Xz9vf2N/dv9jP3d/Xb9q/1e/Wr9Tf1M/V79Sv15/Uf9dv1O/VD9Rf0V/SP9yfzs/IX8t/xH/Iz8JPx0/AP8W/z6+zL8DPwA/Ab86fv9+9T7DPyx+yv8r/tP/Nf7YvwN/If8NPyg/EX8rPxT/Kr8YvyN/Hr8Y/yd/Ef8v/xT/ND8ePzT/Kb8w/ze/JX88fxj/PP8S/zw/Ef8z/xe/Kb8ivyQ/Lr8i/zg/Kz8AP3c/CH9G/0h/UP9AP1u/dz8Z/23/Cf9qPzU/JL8d/x7/Cb8cfzX+3b8nPuE/H77mfxy+7v8kvvj/L/7CP0E/B39Ufwa/Yn8E/2i/AL9qvwD/a/8E/2r/Db9tvxi/db8gP30/LD9Gf3t/Tn9PP52/Xr+nv2K/rb9Xv7F/Q/+tv3O/ZX9cv1i/QH9IP2c/OD8WPyy/DX8rfwk/Kv8F/yw/CL8xPwt/OL8S/wR/WT8Ov2D/Gv9pfyX/dH80/37/BH+J/0+/mD9Q/6I/Rn+ov3h/Zf9l/2N/Vz9jv09/Zj9MP24/Tb93f0t/ev9Kf38/Uj9+/1Z/fb9aP38/Xf9D/6M/S7+oP0h/o/9+f15/db9Xv2v/Ur9pf1F/Z/9Nf2G/T39WP1Z/RP9a/3e/GT9rfxN/Yv8Pf19/E/9gfyD/Z38vv3O/NX9Bv35/Uz9D/6G/SD+mf0z/p39Lv6Z/R/+rf39/bj96f20/eT9ov3S/Yn9qv1p/YH9Q/1M/TP9Jv1B/SP9O/04/TX9Wv0q/Wf9JP18/TH9ff1I/Y79Uf2A/Tf9Z/0u/UL9Ov00/VX9QP19/VH9oP1m/cn9ev3x/YT9E/6B/Rn+cf0I/lb98v1Y/dP9ZP25/XX9j/2D/Yv9gP2b/XP9tP1v/bz9eP2+/X79wP2a/dj9xf3i/er99/3v/fv99/39/Q/+Av4y/u/9Rv7W/W3+vf2E/sn9lP7h/YX+Av5d/hv+N/5D/jr+iv5g/sT+f/7p/pr+A/+Q/vv+af7X/ib+qf7x/ZP+5v2N/gn+n/42/rn+Wv7M/lr+4v5L/vL+Sf7i/l3+y/53/tH+pv7Q/sP+u/7I/pz+yf52/rj+Y/6w/kz+r/5P/qn+av6q/o3+sP6t/sT+4f7z/g3/Pf9F/3T/cP+X/17/rf9F/6f/M/+T/yf/fv8Y/3T/CP9p/w7/Zv83/3r/Wf+M/2//lv9k/5f/Uf+V/z7/iv88/3T/R/9a/1f/Yv9g/3n/cv+a/5L/qv+y/6f/uP+O/6f/hf+I/4f/Z/+E/1X/d/9i/2b/ef9p/5T/Zv+k/2T/tv9X/8L/Pf/L/xj/0f8E/9T/DP/h/zL/+f9b/x0AhP9gAKf/mwDC/8AAz//UAOT/1QAMALUAOQCNAGgAfwBkAGgAZABbAFEAUQA6AE4APgA0AFQALQBuAEgAgQB6AIgAqgB5ANMAcwDwAJ0A/gDKAPUA3wD2ANkAEAHEACsBvwA5AcUAKAHNABEBwwDiAJYA0wBHANIACgDWAOz/0QDj/8wACADRAEoA4wCRAAYByAAhAQMBLwE5AUIBZQFlAX4BiQF+AY8BbAF9AVABWgFNATABVQEcAVoBGAFkATsBhgFYAaYBYgGkAUkBjAEdAVUBFAEpAR8BFQFDAQoBWgHyAGAB0ABgAbkAWAGmAC4BjgD+AIcA6ACYAP0AvQA7AeoAdgERAaMBNQHOAWUB7gGrAQkC9QEgAjQCQAJeAlMCfwJfAoECRAJzAvoBVQKhASoCVwH1ATcBzQE2Aa8BPwGsAVsBswGMAdUBwQH+AeABFAL6AT0CBgJeAvYBbwLUAWMCugFSAqUBQgKaAUYCkAE+AqwBSgLKAU4C4gFbAuwBYwLJAW8ChwFpAlQBZwI2AVICLgFbAj4BbAJvAYQCogGiAtABsAL0AbgCIQLOAlIC0AKEAsYCuQKrAugCkwIGA3wCDQNxAgoDWQICAy4C/AIHAgUD4wEAA94BCQP3AQADHwL0AlgC2gJvAsICaQKoAkICgQIRAlUC9wE7AgYCPQIxAlICbgJhApsCZgKrAmcCuQJqArsCZgKtAl4CtgJRArgCYgLGAnsC1wKPAvYCpQIIA7MCCgOwAv4CpQLrApsC2wKCAtECoALiAsQC3ALXAvQCxgL5ArECAQOjAgUDnwL2ApUC5gKIAtACcwLDAnACrAJzApQCjgJ2ApwCSQKfAi0ClAIXAo0CFAJ/AiECdAIsAmwCMAJlAiYCSQIQAjcCDAItAiYCOQJHAk4CWgJnAnkChQKeAqYCygK7AtECuQKwAq8CeQKgAksCfQItAkcCFQInAgACFwLmASkCygE9Aq0BPwKjASoCmwEEAqIB7QGuAdABsAG1AbsBogG3AZsBvAGOAb4BhwHAAYMBvAGRAboBrwG/AcsBzQHmAfYBEgIhAjMCSQJHAl8CVgJmAl8CVQJUAioCPQL7ASkCzgEbArABDwK6AQcCyQEHAusBCAIWAgkCQAIUAkwCKAJKAkACXQJHAnICKAKDAvwBgALlAWwCygFCAscBFALOAQUC1wEAAtABFALKASECtAEoAqkBKAKnAR4CtQEXAsYBBwLjAfoBBQIGAhcC+QE3AvcBKwLrARIC2AHxAcUBzAGmAakBjwGbAWABlwErAZYBFAGkAQ4BowEHAY0B9AB9AfEAhAH6AJIBFAGKASUBhQEwAXwBMAGNAS0BngElAboBHAHMAR0ByAEnAa4BIwGKASwBbQEyAVYBLwEuAR0BDwH5AP4A+QAJARwBFwFIARoBdwEBAZcB3wCwAcgApQG1AKcBoQCsAZgAtgGJALcBjgC5AYsApgGaAKUBmACZAYsAfwGJAGYBkQBMAagAPQG8AEMBxQBMAdYASQHSACkBygALAc0A+ADlAPQABAEJARkBHQEPASsB9gAoAekAEQHrAP4A6QD9AOwA8gDrAP0A8AADAfUADAEFARgBAQEgAQwBJgEMASQBAgEiAfkACQHzAPYA7ADoAO0A7gADAfIAIgH1AD0B+QBCAQ0BJAEFAQgB9AAEAdgABQHCACEBtgAwAasAOQG0AB4BzAD3APEA0wD4ALgA+gC/APIAwADwAMsA7wDOAOkAvgDrAKMA5wB/ANMAZAC1AFUApwBGALcAQgC8AD0AvABHALEASACqAFMAogBgAKYAawCyAHYArAB1AJcAcQB7AGMAcABhAHoAZgCKAH8AmgCfAJUArgCQALsAfADIAG8AyQBgAMUAWwCxAEcAiQA5AHUAKQBkAAoAZgD5/2sA8P9tAO//egDf/3wA1v97AMj/dgDD/2AAxP9ZANb/OQDh/zAA5f8bAOX/EgDU/w0Auv8JAK3//v+w/+T/x//J/+L/t//7/63/GwCx/y8Auv86AND/HgDr/wsADgALACYAEQBJABIAdAARAJMACQCpAAgAqAADAKwAAAC1AAMAvwD+/7QAAACkABEAmAAkAJIAOgCPAFkAdwBoAFYAcAAxAGwAFQBnAP7/UADq/zcAy/8WAKn/BgCd//3/qv8SAK7/HQC4/zcAuf9DALP/QACb/yUAeP8NAHH/AgB9////hf/7/4v//v+O/wAAmP8PAJ//CQCk/wwAlf8VAHn/IwBi/x8AT/8XAFn/9/94/+z/sP/s/+D/+//2/xIA8f8mAPP/KgD4/xkAFAD8/ycA4f8+ANL/SgDJ/1EAxP9PALX/XgCt/3IAsv+HAK7/lQC1/4wAtf+BALv/bAC3/2AAxv9IANH/MwDj/xYA9v/+/+v/7//a/+H/wv/N/8r/v//X/7b/2/+j/9T/iP/N/3X/1v9r//L/YP/2/1X/5/9I/8H/RP+P/1X/dv9V/2n/VP9f/2j/W/9z/1z/gv9e/4H/Xf9x/2n/bv93/3T/hv+M/5X/mf+e/6//nP+9/6X/z/+f/+z/nv/8/6T/DACq/wIAuv/6/83/7v/g/+//9P/x//7/2//7/8z/8f+6//H/uf/t/6f/y/+Z/6v/mv+D/53/Zf+1/0//vv9J/8H/Ov+v/z3/p/9D/6j/WP+x/2P/sP94/7b/gf+//4P/yP+E/9T/dv/e/2b/0P9T/8L/V/+f/2H/jf9x/4z/iP+W/5P/mf+h/5P/rv+H/6P/fP+K/3f/fP9z/3j/b/+E/2j/nv9g/6D/YP+c/1L/g/9A/3T/Kv9e/x//Tv8f/07/Hf9K/xr/PP8U/zj/D/86/xb/Pf8q/0X/Nf8x/zr/Kf84/yX/Nf8t/zf/P/8z/0j/L/9G/zP/Tf9B/1z/YP93/3H/hf9s/4f/Zf+G/2b/ev9u/4P/gf+F/47/gv+x/4j/sf+c/7X/oP+y/7X/pP+t/4z/qv95/6H/c/+O/33/fv+G/3T/lf9y/6L/fP+t/37/o/+D/5b/ff+S/4b/k/+n/6r/tf/B/77/3P+v/+b/of/r/5f/0v+L/8L/jv+3/6D/tP+0/7n/vP/B/8X/t//I/6b/x/+I/8b/dP/D/2D/0f9W/9X/Sf/W/y//yP8O/6n/8P6E/+H+Y//Z/ln/2v5X/9n+X//U/mX/yv5V/8f+Rf/P/ib/3f4f/+P+Gf/n/iL/8P4r/wP/Pf8R/0//N/9k/1j/ef+A/4n/lf+Z/6H/m/+o/5r/qv+e/5P/nf+C/6f/h/+m/5z/t/+x/8D/wP/C/8H/s//V/6n//f+X/yMAhv9FAHT/SwBh/0QASv8mADr/BgBC/+L/Q//P/0X/wP9G/7v/Rv+u/0j/qP84/6j/JP+q/xj/qf8b/6z/Lv+i/y3/kv8s/4z/Nf+F/1n/j/9n/5P/Z/+W/2L/jP9a/3n/T/92/0r/eP9F/3j/S/9m/03/WP9b/0j/bv9E/33/PP+M/0T/jP9N/4f/RP+F/zj/fv8Y/3f/Cv9n/w//Y/8j/2//Pf+B/0//lf9a/6T/U/+t/1H/of9X/5n/Y/+d/23/mv9m/5v/av+V/23/i/90/3z/c/9//2b/ev9U/3b/Sv9u/2H/cf95/3r/nf+I/7r/lf+x/5r/p/+h/6f/qv+4/7P/xv/D/8//wv/E/8r/s//A/6T/uP+e/6P/tv+r/9L/uv/x/73/GgC2/zMAtf9GALz/OgC9/x8AwP8GALP/8/+W/+r/d//o/2L/3f9b/9P/Yv/H/3z/tv+L/67/n/+U/4//dv9+/2P/bf9l/2//dv98/43/nf+j/7T/t//O/7v/0/+5/83/t//D/7X/tP+p/6T/tP+g/7D/oP+u/6T/qv+k/5z/pP+X/57/i/+N/4L/hf9y/3b/Z/9l/1H/VP9D/0f/LP9H/yP/Sv8W/13/Ef90/wv/ff8S/3H/If9w/zv/a/9L/3D/VP9y/13/hP9b/5b/X/+T/2D/kv9p/5z/eP+1/4b/y/+L/+z/l//6/5v/BwCU//7/kf/4/5X/9f+U/wMAr/8OAMT/IgDQ/yEAyv8aAMP//v+1/93/tv/b/77/yv/I/87/1//E/9n/wP/d/6X/1f+G/8r/b//L/1L/w/9F/63/Pf+W/zH/jv8l/6L/Mv+t/1P/rv9z/5v/iv+H/6n/c/+v/2f/vP91/8X/hf/b/5f/6f+W//H/j//x/4j/5/+F/9j/gf/K/5L/y/+d/7//p/++/5n/vP+T/7//df+2/33/nv+I/4f/qf+C/73/fP+4/33/sv9//7H/gP+y/3L/xP9p/9P/YP/Q/2X/xv91/8H/kv/A/6P/3v/A//7/2P8gAOH/LQDg/ywA1v8hAMb/DgC4//b/qP/f/7D/3P+7/+X/zv/q/97/8P/f/+f/z//a/8j/xv+8/7b/rv+z/5T/qv90/6H/Wv+e/07/rv9j/77/if/f/6v/8f/N//7/3v/2/9r/7P/e/9L/5f/Q/9//zv/h/9X/y//W/77/1v+z/9X/tP/Y/8X/5//h//b/8v8CAAEA/P////L/9f/p/93/8P/C/wQAqf8PAJ//FACV/wYAi//w/33/4/+D/+b/iv/k/5D/5v+M/+j/hf/o/4T/3/+R/+D/j//W/4z/z/+E/9P/h//a/4j/4f+S/+X/o//n/8H/6//c/+j/8v/o/xAA3v8wAOn/TQDm/0EA3v8jAM3/DQDO//j/2v/g/+//4v/7/+P/CQDr/xIA8/8VAAAAEAAGAPv/DQDm/wMA3P/y/9j/6v/k/+L/6v/u//L//v/y/xIA5v8eAM7/LAC8/zMArf8vAKz/HgC2/xkAu/8RAMb/CADM//j/zP/2/97//P/Y/wIA4P8UAOj/JQDv/yYA+P8iAP7/KQD9/yYA/P8vAOn/NQDT/zoAwv8wALj/KAC//yAAvv8jAMf/JwDB/ygAwv8gAMP/HQDP/w0A1v8EANr/BADZ/wwA2/8PAN3/CQDa/wUA2v8LANP/GQDY/zEA3v9EAOv/QwACAEgAEABFACIASQAoAFEAIwBWABkAUgASAEkADgA6ABMAKgAOACQACwAiAP7/LAAEACwAGgAxACsANQA0ADMAJwAnABwAFgAPAAkAEAD7/xQAAAAXAAYAFQATABEAHQAJABwACwAVABIAFgAhABEAJQAVAC4AGQAyAB4AKgAcACQAHgAWAB4AFwAiABUAJwAYAC4AEgAsAAYAIwABAB0ABgAgAAAAHQD7/yAA9f8aAO7/GgDl/xQA6f8VAO//GAD9/xwADAAbABoAHgAXAB4AEwAcAA4AGwAUABYAFgARAB4AGQAcABsAFwAfABUAHAASABcADQATAAwAEwAEABIAAgAQAP//BwAEAPz/BgD0/wsA8/8QAPX/EgDy/xAA+P8SAAAAEwD//w4AAgANAP//CQAGAAEABwACAAoACAAEAA8AAgAXAAQAEwAGABUACQAYAAgAGwAPABwADQAhAA4AJAARACYAEwAnABIAJQAMACkACwAoAA4AKgAPACkAEQArABIAJwAaACAAGgAcABoAGQAVABsAFgAfAA8AIAAQACQAEgAgABAAHwASAB4AFAAgABYAIAARAB4AEQAcABMAFwAVABkAFAAdABcAHwAbAB8AHAAiAB4AHgAbAB0AGgAaABgAGgAaABYAHQAYACAAFgAgABcAHwAcAB4AGwAaABkAHQAYABwAHQAeABwAGQAZAB8AHAAZAB0AGwAfABgAHgAaAB0AGgAdABwAHgAbACEAIAAfAB0AJAAgACEAHgAhAB4AIAAdACAAHAAhACAAIwAhACAAIAAhACAAIAAgAB8AHgAfACEAIQAfACEAHgAgABwAJAAdACIAHwAjAB4AHwAhACAAHwAiAB8AJAAdAB8AIwAlACAAIQAcACIAIQAiACEAIgAgACAAIQAdACEAIgAhACQAIQAfAB8AIwAfACEAIgAiAB8AIQAfACMAIAAgACEAJgAjACMAIQAhAB0AHAAgACEAHQAgACAAIwAdACUAHwAjACEAIgAhAB8AHgAiAB0AIgAdACEAHgAiAB8AIgAiACMAIAAjAB4AJAAgACEAHAAkACAAIAAeACUAIQA"},{ name : "R_gfx_png", data : "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"},{ name : "R_sounds__gameOver_impact2_wav", data : "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"},{ name : "R_sounds__pass0_mp3", data : "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feCHspolmJ0qEVHs/+tdz9yJtkooqJSQdc4usyyVbGWGig1FBHYd8gL03W2uMsRUuUoqt7KV7s+5QAzFgkEosCljCCCALWHmF4lupwBeYiFo2LHaizUWA1pusnpTr9V2+i8XIna6FjXRlwTdQsd5wGQlzoJefyLPNPuzgXCEKdvYHrt3M3tVX6ggq9YgNUs7btEMTkoocdRqtrZ+o2Z1HiPvJR7SFp/FamBycHUjg1Saf3fXjSWxu9595YMx5l3eWtYVHBTVmhZj4ljVg7xEiR+xyTR3jqaSDncsHdYPb6SbpietaRbRu/vbxJd1rHlva+4lsSf//////////////21P//////////////+1zRAAGdYiHZJU0JdrG242yiSRcg34e8sHAIg4GsRIxqikQh2DRqPS3k615mnOjgwJWnSVnWANimBVg9g5UudDgZBeiYImOf9oOBql//uUROMAAqwb0/08YAhQ4qn+rJgAGs4FL5m3gAMwLqd/NPAA0F4oqtyLL6XR4kkOVhbg5D/O8Uljhq1wfLl9KomFnYU+r19autv3a4Uc7ihq1Alns242sIM8E42Ky7LRlbLOMPdmyLFgRaPlY9c4jkzttp/BrDg19MxX+d2jRpdx/HtF3JqzzfpAxbz4tDzjdKVrHvn7rmJeJaPq+74lNnP////8sAYBOEAAUY3gvgUwSIlzs/ScmirkKu9VqGq1Wq0CoCAgIlfqqq7BgINKBoGg4WBoO1A08SgtWCoKxKGnRKdUDR2IgaPKBo9g1WdyoK1/g1qBo8oGviUN6wVrBXWAK8XC1gSBkxEkxW8IQEjJae0nLLly4TAIGolBo9Ep3grBX//UDUGtv//UDR7/iKJQVlTtTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uUZGyP8tESTM88YAAzgVl85gwBAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"},{ name : "R_screens_sc_1_png", data : "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"},{ name : "R_sounds__tuto_success0_mp3", data : "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VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkiY/zGjcxkeNMMC6AFoYEIgAAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"},{ name : "R_screens_sc_3_png", data : "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"},{ name : "R_sky_png", data : "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"},{ name : "R_anim_bird_png", data : "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"},{ name : "R_sounds__DS_Store", data : "AAAAAUJ1ZDEAABAAAAAIAAAAEAAAAAQKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAsAAAABAAAQAABsAG8AZwAwAC4AdwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAwAXwBkAGkAYQBsAG8AZwAwAC4AdwBhAHZJbG9jYmxvYgAAABAAAAEdAAAALv///////wAAAAAADABfAGQAaQBhAGwAbwBnADIALgB3AGEAdklsb2NibG9iAAAAEAAAAfkAAAAu////////AAAAAAAMAF8AZABpAGEAbABvAGcAMwAuAHcAYQB2SWxvY2Jsb2IAAAAQAAAAQQAAAJ7///////8AAAAAAA4AXwBkAHIAbwBwAF8AYgBhAGwAbAAuAHcAYQB2SWxvY2Jsb2IAAAAQAAAArwAAAJ7///////8AAAAAABUAXwBnAGEAbQBlAE8AdgBlAHIAXwBpAG0AcABhAGMAdAAwAC4AdwBhAHZJbG9jYmxvYgAAABAAAAEdAAAAnv///////wAAAAAAFQBfAGcAYQBtAGUATwB2AGUAcgBfAGkAbQBwAGEAYwB0ADEALgB3AGEAdklsb2NibG9iAAAAEAAAAYsAAACe////////AAAAAAAVAF8AZwBhAG0AZQBPAHYAZQByAF8AaQBtAHAAYQBjAHQAMgAuAHcAYQB2SWxvY2Jsb2IAAAAQAAAB+QAAAJ7///////8AAAAAAAkAXwBvAHYAZQByAC4AbQBwADNJbG9jYmxvYgAAABAAAAEdAAABDv///////wAAAAAADABfAHMAZQBsAGUAYwB0ADAALgB3AGEAdklsb2NibG9iAAAAEAAAAR0AAAF+////////AAAAAAAMAF8AcwBlAGwAZQBjAHQAMQAuAHcAYQB2SWxvY2Jsb2IAAAAQAAABiwAAAX7///////8AAAAAAAoAXwB0AGgAcgBvAHcALgBtAHAAM0lsb2NibG9iAAAAEAAAAfkAAAF+////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAgLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAABAAAAQAAAAAEAAACAAAAAAQAAAQAAAAABAAACAAAAAAEAAAQAAAAAAAAAAAEAABAAAAAAAQAAIAAAAAABAABAAAAAAAEAAIAAAAAAAQABAAAAAAABAAIAAAAAAAEABAAAAAAAAQAIAAAAAAABABAAAAAAAAEAIAAAAAAAAQBAAAAAAAABAIAAAAAAAAEBAAAAAAAAAQIAAAAAAAABBAAAAAAAAAEIAAAAAAAAARAAAAAAAAABIAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAEAsAAABFAAAECgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBERTREIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAIAAAAGAAAAAAAAAAAQAAAIAAAAABAAABAAAAAAEAAAIAAAAAAAAAAAIAAAgAAAAYAAAAAAAAAAABAAAgAAAAAAEAAEAAAAAAAQAAgAAAAAABAAEAAAAAAAEAAgAAAAAAAQAEAAAAAAABAAgAAAAAAAEAEAAAAAAAAQAgAAAAAAABAEAAAAAAAAEAgAAAAAAAAQEAAAAAAAABAgAAAAAAAAEEAAAAAAAAAQgAAAAAAAABEAAAAAAAAAEgAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_sounds__pass3_mp3", data : "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"},{ name : "R_sounds__select0_wav", data : "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"},{ name : "R_sounds__dialog0_wav", data : "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"},{ name : "R_sounds__new_ball_mp3", data : "SUQzBAAAAAACD1RDT00AAAAKAAADOTlTb3VuZHMAVFhYWAAAABAAAANUT1RBTFRSQUNLUwA5OQBUWFhYAAAAEgAAA3RpbWVfcmVmZXJlbmNlADAAVERSQwAAAA8AAANKdW5lIDNyZCAyMDIwAFRYWFgAAAAUAAADVFlFUgBKdW5lIDNyZCAyMDIwAFRBTEIAAAASAAADOTkgU291bmQgRWZmZWN0cwBUUEUxAAAACgAAAzk5U291bmRzAFRQRTIAAAAKAAADOTlTb3VuZHMAVFhYWAAAAB4AAANjb21tZW50AERlc2lnbmVkIGJ5IDk5U291bmRzAFRTU0UAAAAOAAADTGF2ZjYxLjkuMTAwAAAAAAAAAAAAAAD/+5BkAABzKGm7qGEawizgB8AAIwAJVIcNIIRLwQ4AYSAQjAABAAGldEDjoaV5WwIbkA0bl9euYQn6Yc0R3NCThO8SpvEeFmhBzAFc3yNLCcq8Tw5gZoIrxCQny/y/+vBcSuYQnL6aUyJ4TnC+EHYRTIny0r7nOE5lmhOfpCeE/xgCu8QnQOOjp9NQ0+cy5RMnLo7U8gQqCL/59xQui7lCbH9pzVn9COwIgQnRs/1o584cq/UsCKEKorKi2FuZIVMyQyA0OMqX6aNkrN7P7I9r2IxwTXhlAmQkypE5HnzJyGzicT0H7VXMdsMrNthZ884uEOcQ9h9QaAk0xZoDEnvajIAEXkFoD7k4XSs9ARLF3iBqBxNsGRZym31AADqgM+CZx96FBKtiB6kFA8UZiYbeNfUtiIqzC1lWMMyCC6XV22ELyZoDQAAAAbneA0SJt9SKFcSOhMW04G+5udIsUnmMJUmHvvqIsBsxmm5oN3RyNWwZt23XnHHNJPkdERN98FLlP32Ox23vfJ3Xb+aS/0NVfsjIZSRkEGMsmiGRyLoaCQP/+5JkLodybT5CQCEU8lFI2DAEI45JzD0GAYRiiUqgYNQwiyOaGSQxowBjFOyEtyIWEyAacyjYuZ2wr72FxvvI57JF6WDuV8ua/GIb/Z3r97tKuGYUzF+yzU7b+zNn5pYXIPblS8otxKuV65HbmEytjQPcP8L1nzAQT/jVzBvpehDcsRY+wz37eVezxXVa/t5+47ffv8LDd8jYyVr9T/xmug7dHX/5kuuz+AQ+5ffryL8Lld8EVhApKW02zIsxnrEcO78X/Hfp6MsAQh0FCHVgz4U6jEAKVGcIoElEEseTJSMWcOxFzn0UbtLw5tvT7VfZ8hisXTwn88co02OU2nHvfL3/3/WLSAgLKqgCEd7sj5jsR2Kq6K55VV0ZxOrIfadNjtsyrZjIne9sdrUzv7LmTZkuquk2qLK6y+7XVKu/RHcY0oGqSImBRIWaWeledy22s/cg4IlAzNqVEkkmZjkbJs1JkToyPv7+XulOw1kBJIJ6l+K9ldn6Zvx0m6xvNOv0mrkr0M3PecW/NCwcpSJAAzwY7C4m6e5IGN3st4tMJBFx//uSZE2EAntGwrChFaA4A3iqBCNOCYg3BiSEwMEZDaFgMI4YAHkkx6wiGGMYEUluIa88TqZDyyTKXnlipkJkohr7kvDbBhbS4vACZLW0kOJTC2AGWWQM2idoo114CBAOJRQh107uXU+LxzLBVlNlYI6bKMxHoInXvBhzyHYgUdahCZ1WA7DTjuONKdPOqSYWKFhzxKl+6craTy6HdNj3i09sOQwQT5iKYbX5IgSMKhirnpwaWiG0MiQYiNKqHYQTH0rzyWX5lG4dy7eF+Uby79SmTv7+xEZTX8/v9BRHL+XE9ny66cX6pwk7XhuS2/6DZdjfjjDt77QPxvZ+FhxBBORdO7a6DLH+EqoJzgPnaaQ/7HPthiwXeyv1rzgCGKTUzK23bkxZpeSKUZZyktA1JCp7njG5tbLfUZLMPA9HrKioHyQGVR2IK1wTNXDERia9RB4Sk4YepUGReOSTXmS5WGm3dKXxwFaHBUWBhh8QonWvWLHrkovtPsK20Mx58iaQUi6QUSVfd0rAEjYseJhl84o/cOHh10wbIJYnIkTNnBmmtv/7kmR/jMLXPUEBhhrCQENoQSAjaAsgbwhGIMDAwwOhhGEMAF7kQI4+tGtbAAYeXYMUN9fquNcZR6p5HWsjp7PUjVwucoaST7PcFhNQ0GaCTJSmBMCawDmiukATU0VsCdgshlQDqmTWEwoNOc5rLQQjUvN/EGvzMfCR3jOZo/7zbiQaqv4otTKaX/HebdOD/Mvv8RfsoVaAsi5/+h7U13Wn/Ti/tsmT7nXHX3h/0ECEB4CAToQiocWK3kCRwVA4jEQ2lslav6bkDMrGQSzOL1qwVLZietUt+7QcQxFLiqTIyKBsaQLK4+V3dC9rmrdlE9I0YBRHoK15zS7UCRomxrTyAtsHwQaJCPJuBcuOOGnig9craMPLvG21Woo0wKmjeYkHJei1fcxTtaC6gqBSVkG1hxyY9bWpWwFaGojuLat61iot5nHC0m7ctPyyobbT1l2LHjMProMFF1qaHZgWqFdUmpm4OYzLdee/3I/F1u9T0uZ/UXWuxK2o/R1G6gHtpVURBWZiSFgrjp9+8kJYuOCkY3VozWiw5UGS1dAwfNHate//+5JkrAzDJh3AgeNIgkMDaEEkwwIK+G8IRhkvANuNYYSRiKj8axO646/kXZxu1ni8PBwos2JCtRe5jTYGi9K2P2BI+EMFmpLINHnjA6KA7jhVLe5DocbQjSnWlwqKreoitjWsXCKh8XtPdXlohtgVu9qBJo4tksXtyLbpc7BmneGZlc6sfiJKtoqFz4gLUJRRNiD0Lf5Pvf9lvsu3qe9vZkdfKJ3rV2EA0Eaa8OVZNfeN+pdLuLaEo9HPksxubEpTuRLenLFvQ9NyKTM7LXLajFQ2MDE31pLVmsilIBnR9w8szSUY6Ha9plFaCgES0y6t5gwwVNsUeipVzBJF5xAVYjCp4mVFGtipA8KtJtaSU1l1AhlkDqkN0mecACBsTJMkypW5kiH7KKSC6RuU1kZ45Z5qs6GJt+Z9VdhIAa8qH3o1fVqT0+W6R39n6/6pvQA6fudjkAABhQ6vxkDKMh5Dv7w92amiRJxZSKCQ0Kkll3kK5ubbBAjTathjN+Vbeab3EHJE7K5R8UlkpvxTpcH2jWNGOIPLqx0mZXfHLxZdE2PA//uSZM+Mww0bwhHsenBDA1hAMSI+DiiRBAw8y8DwDWGEkZpQ70uY08rnRqjrmmUK6HbZUrnkGQABW4luw7s6d19FV0en61zkHPuSBvMGvqLCLABTHK0MsIl074qdcHrAbejYqv+r//2cZ9Xd92j/1Aaiy6BtpbMveu9m7ruW4bcW7xJw1TygcghCIRhL1s3E0pEMAkyb1PNQNxyMzcxvn6dudajOOy4RCFuShWHTASgBvNFUF8U5zGgzzk4cV0uLKGxHOeuJMK4w+8taDeQJU/BA7sZc5Rv7L0l9O1rmn2A3RfKWcOc7edTlP+kzfqZ6dIQZIHb8tKu7AWHzzynfQAIVFwEISiMWLszcwP2eVT/UmalsjWH6LTw6Xw7pgMwiixvab28248H7hOD4jEAnYAD4SExdoggHbRT/ehsY09txfTmV9dn93XsMUxwMeQmnPpQtRDDOYdBgyOzAVxOUUOoULwTiTkQCqIpcLYUbXYDUVMTAFaGQCiRSlaiyA2FMqV2zJWdQBCyVrNWEdZjMrgaLuc/zLG4JGimpQNDqp1B1nP/7kmTliIMAIURJ6XpwOONYqTDDPhH42QZMPS3JLQ2iCPMhoNxaC0hgcHUjgSmiI4CBwLBwctk9ePQJlcRjQhxnZ42uKh5EWSspOC0cNowwhd3CB5glZGkM51h4EERvtalV7t8Pfue3Qff09Zf4ArqN6bd3/IY2HsVK1fHrHgQAlQB0AVitNcjeSB8oHXg+bxL4bq156RcfnIHBEQuOFRVQykogLJg2vXmECcT09Dlclu4/A84shu4g2PYF8BqlLZaNzKowN8KGFhjoALFCMADBEirw0ffc1gwgD4rAYffA7GkHkZ/S1Q72X++/bVsrs1dlIDhKAAr8lWuksvKncdxQJWZuFRuODXGP0rpJvEQ4MZjOShb1At0WVeg4USIyskHKVhKDUfySYb2f+AHAzdxrmkSHfX8DAt2U7sfHIx6dPLNXPhXftZ7kcQy0/08hYnUcmdKHWft79n+tQnurSsiZywAABuSgN4/mxUp46QhxKGA+GJJDMkh2IbDN8ffYb7y66qTuZA2QRSzW9LVvERlAQQsL9QHJuRoVgZNiSZiszun/+5Jk6oIFhz3BiywfFnSGWIZhg24NnPcdjDxtwUyWJLT2DOn3LjJj70/bTVH4amtE//5+CgKnWgAAGnLaGIIGBccQNcapskjHOYAakBOnG6hx6MrmYmqMOBROUUYVYPKPKqQNiOfJl/GfZu5QBQCfRYqKkbSFOWpJuVaWTiahXrJhTgk6TMmCoRKLDMUEp2hCmhvknCY+q21dxXZQt3q+7XWgidWxgAFuXANTxiZdPhKlMC5UFpWDs1YdKzxaOFJgGCbvaqqzXeqWRjIVZC5asco7MX0Jsx32czdWzozXXpGVhhoYXUhFTjPQoBIAAHCxAVCNul7y4btv8ulOVpBbsDALvR+Yw02EoL0kRRBh1ryVsCy+zASeEXhp4J13n6dhkyQj8515pyMuwxZno8+L1BQaEX4YFCY/MYXOJnV2ELCxxYubiIy/mKlKZIQsNpiMnBpvKWNDyDjTS7yHqt//6/JApmkAAABJ2BaCB6xHAf1mz3PG0GQBUaxXIt2dWUcSPLHjqstkMhAEKPQWCb4yj/kckMl4rn4xmZWGHUaZzOuf//uSZLaAA24sSWnpG+BIxoldPYI4DtzNGQykegFimeS1gw2oEL9L3S+fEBWFkk4wgOOgIJDmFVyCphnJawABg1KswQsRUjFBEUHwWKpuODkw0D1JMyGkrttcSJRXkreMbAAJfjJ2fw88YkFZNQTpkmyqFGEQkQ1YwFOdb06DBP4+E+iB0XcxA0/aMCgXFZUTRaoeBwlDZO0gQRJIuYnw35duLaNhgNv/9vjcF8gg1jA0QWfOR58ToaGDrwwwp3Wkns9kmFCiAABKlBegYgdo5z3IwSQuAfyiJebyRPBsOGgoHmDxwECRC3imzgXNQ1xcXSajLLoWZXCIQJjelC8WVMjDdUWSeTiG5yDWipF+AYft27OVA2DF0sNp6T7Mz/9v/l8KvPHv/MwBQFahKMYU6m7dmixteiAeKNKXkegFtFmKK80Rpi7kLJmIHGUhxjXRqHHYdb43mRRNpHPX0VcoxW0Uq0uFarm0dsZka06ZjjNNhPI4OcX5h6Qmrp9vdbfrlQ+f/PJ4MUjgzhpQTFQaS+qs1mHkmEDfFltcxWEmgQASnP/7kmSyhgQ1NMYTT00gY6WZKj0jak50zSLsvMvBaBJltPMOCMAcgkYYBbBhByjPJ0QOKoyanMharUJ/m9t0r0atXssLlNTtvmDMRQgn5wyLLJEpVL5pT544SD6RdLEraRFTaHtcCQ54uxDhRgUfRenzj6BhK0/TAgAAAAAA4aICHpvySB8QYO8CvysBjiHBZ6tFSoWEJALCTsnAR8jyGBoIYjT0VjWO4vUhKVEr1QWA6E4cLQlDrURuqFwb2GGfZ3iJxWUbI5AgRWSOCGw2rDF38SZDEA0OxhSbWY/19jFPZQwJXrKpnDqWjqqPSg0zUd3BYiYNtBAApS8EHsLGh5BhDwGQ7wQgTNjXU/OSEZmOGaD0VJsWMmLS10myS98rsHM+OZ9/KImNDISMBwESbhI1FCRw1osLtSkddHB8e8038UsL1bbAgFQByZvUrlVmgt2UjS3S/xAA05+Uw35f1kLOpfHm8bCIQlRplRlPvEgojjSh4H4TgyDQGEtM+D+PuZ1BTiwkms1SBkmhr4hEhdAfCodeokeYYQOFQkUQFVfqUob/+5JklYcD3DLI4y8y8FMEaZ09gzwQEM0lDL0yyXCaprWEianeL4omVU2eUxHf7k4uTtQiwXrDVwNOg8zk4kxj7jGUZ5Z3bfvBTGNAhAku8F6VopcT7Dn2XfbBWkaqvZxmznkg2jBiDMDSJRzlUUZYxUVHMqUugbgq2mXsrHmIPld2Q6sZVy1ZdNEt22Sy42epKfqZaD+3WvxyR375np97ziv9yqoAwAAAAAABPDKXoApqdO+LqHJ9IfvEm1O2w4ERf9068Jrt3U0Y8uCOrXlL3TUVrwqG4HrUsPsCa46DsRWIQ3Q0RlxWOIByu1sVCR80bNuUYSGKPL24n1CSJuO695UhuH2roEwWuZIfz/j3uSb4ImgeuEIMFxafckPhCr/rFigZ0I2O/QxbImgCQUncG8GmdbmhwaBuGWEtmLmhW5dS1YX8rH9zhbyy08gp0rNz45ne/NMaaJvWIvZm3Pz5R6tws8QDBYMUl3NWHz4QvISlH09IVgLmFEO2W1bg4GaYlgzQUyUyhM9AsCPc+cWbRkEGx5brT5h+BIcLo9nrA/j4//uSZH6GBBs/S2sMHiBMRZntPGKKDwz5M0ww0sFfmecphI0gQFgfmA6qA5OmY1kLB8vOVAnwrnzyCk7JBaswsndSQSt0eg8yGZmjUqQ95sZ4zl0bttm/f//sMnUUijYGCBOSfAZMkTL3vt7O1BTrV/FAAAFOgUFDSxGPNMh9fr/BYEuC4jMugfH1lhQ5gn2Ebph8DOAKCVocHrkzJhBNezVwSgjohXLxdU7ly9rn78y2WexwXAYCaTyibCAIxVLXl7vCLWuV0wZAAAAABcbUiIgibqkM/DS4MRPnmtMpeZu0rjLk33VXO9jANLekDqUkvgdr9+A2Xujm8rlr7rcnLcslGZOOiRsViUzJAp2lhRZ9A9HCOWugm0lnqFxOd1tUdjkUydquYrL6/bVzrZ7d/2/zEUPJAmbEySkLPUOgcyK226qopKmmyCUk4AtdoDvt+5jnxZxhk7A88IdieH58wleEbuSfV5vctyJNB1SPswGMLihm2uMn+1ADgmy94RXiFC4siBU2uTUq5KAKlJxhUK11BGZy1lzigAUXYHcVOqxlQv/7kmRtggPkS03TCRYkRKZqfWAinJANXT9MMG3ZJh+pdPCOevCIvA0qSrmJFffEAZMLWjgBi0uLRwF7tkTX1TH94sXnTMDNkl73Z9frUzdQ7vijfMzlLPiIbERz/mYIYOZW3e6Irqy77vKc5JTK3yc0iV2CCgAPdASUfR1P0InIIsizBfrHnP13v8RabiKAABJcrUMRZNsgrawbPBQCzshKyWGXAfYv75YY0CIX1sI18+pfcav9uzGDgolHN7RHxsDOD/8uqTII6WBRykya1sJ6O72pBmAAAAAFQyVihcxuqmECKQZs4bK18OE0x1YFcNyJVNU8BRqS0ULwfiLw1WiccicMNglDAxUIMUg2T4dXSRmhAMK1CCBJiJHrEvbdkkExR/OFKkewdicU4odUQtuk4k0ZdMynJlS4tA++R82Lh+RokzMzz4XmWc/h6fyBDN9XOf92lZzLAAFidJoqiHIGiIsLPHEDRIwbUVLIWicYNtzhNmC6JnSUgRMwbmJEAwykYbLCWDMpGTh0JPx/UFHoKkZo5fZEVP6rKL0zwge4eFX/+5JkZwYkFlbP0wkdtlVGegY9Iz4PDStDTDB2wQcJKTT2CGBhoLnyZod0E6voDXAc4c5lyANdia6pGVxh86qDC/alt4JVBrtT9NjGo9dt26GH4OlEplsjoJxjbcFy1lR7p+2PBxjJy8B9ph9RdJDp3llMeMQPpd9Ivgv3ZsuQkp1jIlv20yN0XLy7c2EF44gziO0JZfpHJj/TUFiZKrchwgfNWv1TEaLTAIAMALcCyFwLEtd4zIxZFCAwcvDidhwgV86kyHcYScBMBoUID4DJBEXXNMUAyjx4ulNgLIG40XP/d4Y2/6LVKiMQEAAAAADME4EMC2i000Eg6GhgSG3Qj5ZD8rCUXR3Kw5CtMO4NDxecJiYpqdFpUH4kSHqfXx7VuYeKCu8pYgfpcwhgtwdKx+rXRhDU1YT8H0rHKQLM3Xjvd5Z08qJu7b/3HdfMMDA0cjn2yNQZPjQqkTmifZCTr9IEBjAAOVmNdHEjJ4tugILAVFgIHo9/RbIrtmpSD0nuodD1UFOJdMg4fdsgghIdIzOiy5QoLhEXSmZ7JR3tfWL0//uSZFyCI8c50esMMvA+hHpkPMM+D3E1UUwkzVEXHqp08YpgoJKcLLLRBoVBFDn/LqgJzR3abWHH3aZFcJgAReeHRGj6lW0Sm3OKtHuE18hK2rMA3rphifup1ZSgmlleIwhhZBHtmtfgpIYUfIO2W0Phs6IGHp2z/+J6GNqr7ZufqvXyHn1naEHvWqD2jO6Z4VeKGCbXNiceBF1HNtBSLcCQAcBdk+G4gjbOiZnfwmpGKNEIn4mibmUjlq+dOzRLzvLkR37C5Z14hHwY3ZKEJd89O6N0bOf+3/67B58cOQqZoXDFJcbTSJBJKcw5TTKhaJyeJasBCCDsZmsx8qBwN9lbYEB4Mn2nMd8IT9nMYGuV/AFQoTGVZ5CZKE+HQUtzdzKZFnqemeZ2rvtU82fv+CLzRCUsolMtNzfc0PkBFXggy6e+ZC3yy5kGANTiCA5gDmAABMccQYYvB9N5VACCSnKl6VdyxDMVCGGWLm2JW0NEKJ5yegO8M0vwkc3d/3znXJzaTPy//2jaWy3puWEOAALFGLIFhA4VSihsqh6wtD+3rv/7kmRfAAOyXdjp6Ru0V2VK+jzDVpNZmWdHmTeakrCrKYekuFAxWOAZ/EFRwuFz4RKOqJvVsySSCm6D4NICREMViBLo7OdUt6XeofObhdTSftzLc82pVvMwGtzpSSCtsLq6XsnGRQZB4SQ8qtYhA/Re3fxon/ve571k2PT8/d9EC0/bSIcQhi3bmYfrg6a4iENg+tCARWGrgIFpHnAaZgEaYAA22j20lGGF6Y6+1uTmUJIWplIxUOvIywY7GyUikR6yjFAoucLY2FZCCmNhhgCAAAAEOvWZStOEY4235NmUegbjInBNMQRsFwcUJS7CxMh3o4/EowKheZAuREjJwBDIbOIYIDqU9NCRR1nWyAkYXn1ISNkbSAgFB01aBiKwYQOhPP4WjN0UNyTr3KckaiBjsMCi4vcKzjDoVF6BiMIzkjexteE/NeeQYnOZcnyZAzqOkbRJzZJBBcLqDuu3RZlHao/DUdtIGMLo2/NjMQIW44uNFOJoR+UIcUynkqlT9Ng0UcLIDcQ0OtUDZ4Ri5KMLwaGVFmGEaGAllHKOyYxmeUr/+5JkF4ADhz7ZhT0gAl+o+2WnoAAQ3WV/uMQACQYZbicecAAl1UBLrfuGoWrUghW1mDb4oDUcXg+k037XlBeS+SdO8q9uMpSTa1e9hUZzue7Vo8kzISPTn2weZbOpiS3fzfvlv/TkQHhiEDnUrVEnQpIxYq6jq9WM07idAseuQE7DSA/Ucz6uLjYXPiKanocxKY5bPhp1q4tZGTEpA233vVuDGTmu+bi7vnm7mb4uvmLuuT425m9+lH9zQx7i6UWsXr322JTZJLdj0OabDZlDYrOpWQCWmPoRQcDy6nfYG4knsxg2GAAROLCc4WKBoBQEAeVBxo808QwjgW1qIiYQzCABPsoq2K7ahYExSWBoN4KrGTFa4qgeB2IoRijf3k1U/HuLn3EJFNCwv+Tdc8bROLlGehRoNw5C7a/+S029cX1XX+AEBk08GMVuxiEBfhhgggBBBgN2cTacyYmXm7f3gKamNlxWy4DRgXIi8CJgORqs1fRig8SSd/dXdX//Wci06f+OloEb6/nMtt/71hlgACAAAAAAmdmtG19OVKkkA2EO//uSZAoCA8ZP1/9hAAA2A1se54wBEKE/VbWVgAj/py2yniAHoZhLCosTbsya5L4YtAFawwHxQghACkwOzQ/PFhKHpjIycOe6yLCMdpGgqOMK9auZ+OBCq7vmhBD27v1VV5/bkx/4ZmZOGblfVa2la+a2EI6P/+f9ma1pbVZJF0Ee1odiGu153m2tAADEAJlCAEdFqFdR0lc/UN/vPh2pbv+8BiWEHxTADIWjnT/lPCIUEwxwtpSrFv+HyC3jnE3oAAAAknkamDIo0rZFmJlD6RIiDlw5F6Xdex8H2XzHQPE4+RTaDpaPIDobi5cpMSKOk0Kyk6WHFyeVomxmZmdLGhQk1JxdCSjDrlGVMvnY5/GxtrvVRbCClxFz6Rs6aa2F/3Nqf43O/qJa74dahLr//237r4daprtRZMVi//hXdhWLuP1ydgBhJBIJAnz0OhDsKfdneZOqdNuZ+jsGowYUWW1H/92lysUxS/Qrf/0f//6sVN5qIY3/+6f//rR9QoMYz4IMxYGY3KsZxbCA5Wk5OQdaQDCgKSKdT8MVoFhwKIwloP/7kmQPAAONO9OGZYAAU8VqdcysAA983UwZl4ABEotsNxjQAn6wNQDJjhO6fEQwJq0+Xlb1y0xERSrjk8YW2Xp34SQWHRAJjsxs93T+/lXG38WXmLsr0MzPbsVX/jmX5/fmZ1ZP9k9OXfA8LBF7tLj1SgvfY4b/dQeReeBAkfnaaV3gMKEaksBaOAkUm9TA6mnTIdAI2DsYMya46VlLoWKT5PlxxaZhrYekcNzjZq50p0o74+2dct2/PM07QvJhpsAjnxrFO1/0t6fx0OFUidf+BVU5AKDhrah53FIwjwCsxWkpEWRcYcSjU6GsVgEA1R6zuokZ3bYE4kBMU5PAZk9Efw7I0ox6bofuChr5vzFmhzF4IS8urncSBXGXuvrOMLk5UgcbE/cIMa2fi3+NYmgMuH2M4xGl1OAksQBWthVLFCcXf03yhuNkAlSUEkpBAICARyAAWh2fwdCVDFCRq0ygUxEpkDoXkewLUeDqSbKrS1qTqQbqc3hEPMzAz+7/LgRpf/g3df1fPN5QNt8ACCACCinM0JnLEkx3ZJRP+YRus/L/+5JkCwADOU3Tb2EAAECi2zzsGAGOHT9DrCRuwQCHqDGBiciYt1sMhlL1xGThLBR8msQPZhzqMXVloaxPZifEXVyrF8m+rZms8+PZoj5/h6uk9lf+khI9ve3SL3/+Y50el/j+bmP/i1GexBIwTEStKdVdSQL96lJW/s2BAEQhdmcYWZjsQafZzzmmX0dM1SvNBB9vmmLKjtwZGDc3mnY3xcsWnigOiUqdFv5EKpc6xRxH/4POoXQAIQBABATtpa6YLlQC2z+LUjg0oTFAbWr9AmihMtCGmhOw3DkyEsiIdOHJ43kwRjBiaRwdFViCIwZ2qHWLJ/jLSkM9nbpEXgv8ijL6jFqR+cpfvNTUZr+u356Tilk7JxlVwau6lhQkfZaBCNstJ2C75AAAAAASGIwYn0mpqNOu6qdLxxC0gdL5xsAca6FAAyBgqPExzQGAQ5BUZgkLvcRWqaOsezs+6KfZ/V//IuRNpllAAQAhEAAglVjCqTDwqJdSfckUtHCT0UeVLGpnADKZYS6hRzTWILe8iappJ9XOU1tktm3JmN7cMLHJ//uSZB2AA5Rbz3sJE+BJY5m7YMN0DiE9N5WEAAE6H+bysHAA1Ot9zHdS5prOqvZHqVFBiUhlSYzGDCJAozMdag/r62J9ujpRvRVG0EO9F37/SnnSMoaPbmWwpoWJQAZIBN2ctGFDGzMpqr6cmGyYKOqsE5WUqB9bKiIWATMwpaRIlMZBzkgpLvI0FCd11xhKeAwlaK2tFaa1p6jT1cv/PN/+57g2oAAAAAACudlbOG5U1h0GKFyggKELhERYElCCRiM+OAOPHiNYch8OEpquorxRSIhubBeNm5tC5GjndqrWxpV8vEfdxHpK3fcVcyN56lbEMdyS/zf1+33H2nj3+44vWqjviYuR34ircjmE9Na6KSyP+ta8IYBBQAKIDqPGoe1ptmGJypePovuEosOJJWElaaZjAmVkOE6KOF0PPHR5EdZzG91HEsmax057KhR6a30q7/T/X7a///ziypi3+maMCMJVtvhLmV0MZX+0BkokC6iwQkILnDxoQYROqxh/QiR3Oye5vQm9QxTuh1tM1PodJ5Y8WNesZtf7jM/hwrQKWv/7kmQegAQNUEyGZeAAZaVZzce8AAxpATwY9gABYxLmszMwADTOr2xWR/HpiFGmZ7Xvv2as6t6Yhy5l1beoOMp2O+xXfzhug2vb/PXWZrb1rWb/Fv9yV3f3+t7/1vXn/t/6ak0j9C6vQ7EiALsVHa047AASAAAY56jvSJ6QwWQdQvALiFBSA/RThmjpVAkZAzEjjNHC0wI9rM3YWZwfxIt0MWUayeaBqZwlkb7W3CZsXexX75uy9y341Fl1hi3FdXvJnUetWC+T0ehWl7P76XxftadVB4WfLohLGRwcTOoQMDoyuWxGixZBBtJvEZvu3xs96kzjne3krZXZPTz5MhfhM8afZajnO17Fe2WH9Iq1RLfxqe6f/Tg8iWRXiXr5aMutNvZ3pmZmZiuPe8yWH67equSQoaQFoItsIAABKBU9I8E48AIMJIkA7lP6hJowKULNmkihcX6A1yNwBwlsW4gxxFjJ6BaPOkmmeSeX9JlKSTN6J43c3M0zZaHWkk75mZn3hjIdBJIHorqVNiZBZJRJBcGSexDSHZXE4fEJUVScjoP/+5JkC4AirE7ObzDgAFVEOTnsJAAL1TszjBhvQRAQJJWEjdBQrSg5Fg2HaER0gPMpcw0qjtIsxzKcrVNQpuhutFQ9Db6GWrZUm7NMp051q9etO+zed3Rtb/frWbMmKVevLJHABAAAwufqs4T+PYnSsdqzqptgqDcnZQ4ugz0qabPsajEp5HExG3iWbUUR6Kz04SrKni1p1NNJpaH2ttVZ7gbIKLAjEZSYy4VS2NexvwMJEwpVrb5RFQggkKgnlS1lnVbu+zD21pnpZi8eq0QGB4h0aFuIqsYxItpNNd0dflk52fzkTUszts4wXTOVlLh3/6pJgnMG+HKrSXvJD5T75H+fWqTQoUZym5Z/ZW/jO1OkCaOrrSwA0GY0l2B7rSpKnM2j3QyPBc3GGTeRJMFxOu+klyp5FBaZqMPDpv2qcWTKHbniTeYoOAlHICkv4znhVE2//tyX92LdCjfa040iCipRN3GUACoGA3DgDJKDUAmHKZten53UhVo4wrwTgnoVWO9ip5YlQ2WRgJzkZLtSkvpXaZUkq79Eehs5v30arVa0//uSZCOAYrROzmmDFKJOQ7jwJwkaCpR/MaS8Z0EnD+QZhI3QrrNIX8t1vK5LSDfx2pSQ4REwSKqPvWgODHORCmuQydxr/dYKAFPDwwmPFQjhGwwGArStYulcITxAhVZy/b/iccVtWlJCygdE6jANHA6RQgwb2RKIkAI3e7+G//5OODjaJbAIBJUHhbhGuwXQCuTqwQVULRVKNaZYtY7AeUbJ0nVYTjIAipstaqzwLBRfSEmFMS1B0aFBqI0Ng0aPAE006dgFxZtZpJ64X7ldrVQ0DCCQ7URI9yxnnSrRiqYjE7EbHQiFEjkIhMXab4WWuKMXlJxLNnKDSrsdR1K5tYFFw9Q6E5UKKi6DuiROh00KkyVImf4af+r//cn//Z/0VQaAgGy96VExOKB2VVbPUUWK3w8+idxeRZ0ihF60KHbdm66INVKSZZGKftN4U9HAI9mSNhzXNZ3et3605TxXlIOhq8RHg7BJQiBokeng101PU8Nf9wQAAAKzPRFATRpStZRPq+X0cQr6vsnuIiJqEANEtFRJNIojLiWEpx0IvH3tNf/7kmRAgHKhKMhBmDHATCOo1icmKApEoxQk5MOBFBAigGwYcPMVf0ssiJToRNHECo5ZQR2BoetxafX/+3//d/p9/0oiFVANqRJ3VyqeU2kUFF5zxQV+lSVTDOGVc06m5YBtsiEgBppSZ53Mo+f+2uxS86JMbOFz39V9rOg0+srzp6CJJMagZllV9fpq6fs7P9atF6f9x4KgU6Tpp9KucxajkmCBcdMKOqLm+aQTuwxDMmg5IgSQDVccKraov2XD9m/3BVJY8y1NKJrnlXBqkTvAXRgVVnZ/6P+9yqCIyG23XNy1ZaWKv6SKj9kNtwU5CApEqePRqXNLhCGiSbWCLc+3KObdlpSkOg9xJhQ9mDD4idNIAzsUT2pWM3///rbpf1o7m/6b6gCDHjLrMzGr6akSXfA0nLfB4NrT8kgseCjz9yXFpKrdRpwE21Oh+fMoNGt4dzmntgzqUjPGHIbeAwzFkM7ix6z/so/gPp1fVXXR6ukCYK3JGkk4yuo6sXM8dRnKElxU9R0OCX8GJHrUwomxbFUVnQlV5tM107VPrHIGWfz/+5BkY4CCWB/EgygcMEwEOKVow4QIfHsdQbzFQToMogjMjKhZ6sFRlId/wlo/7Lfq2fv/7dEhHDAAFzrEQpqqnG2IzEADBZ0MOK/Q4SUHhn1PCOwMmopRzVVUkyqwd5mCeKKBQVJBAOpQoDBSYVN6KqklB6VajtTte9tX/0qf29CNTtqu7XUABGvumUrtYMFHCBWMKlAFirOVhGgwvXHxtU2yiM0ZUATM43ew2e/FZyoCu/QYWKEGnrkhPv9b9W/in+t37rqf+gGNqgjKC6QKkkDQxGAsddxCw2inmRl3XEB4VlOWumdhklw1NixuOUpBVbpECnVvcZLi7S139ra6qv10a/7f6fqt/VF0MoABaX1APCARCEbbZ0BEBtJ5MQwFIrQ5TVpSW4XU0khwmpGySDjgwpgFEx9o8O12OaMTvopSX0V7Va+svp1N1sx1Xvv2f7wABCulUK6kmpmYFs3JxOLYzVj4z8GiKGgIfk731hiqeuxKuXCT5pV68Zn+MsaDZFZ7zFdexSlD/VS5sU/9/7K/6vT//UoAAAm5aW+kkKD/+5JkjQgCCh/GSM8aQENCuKYvCEQI6FsQxOBowRKN4qTMGYCYPsGkmqBwpWOTwlSMCAGzSnASCnY+OWQYRU8Fhd4TaPj/p2V75F7GjnPpodU7Y1h9BrnN/va/r1K1N+gALMAJnM6NRbDAyJZ5Ns8CMVZUo6JHHmhMCRLOmzkjqqKTS8m6fqPjurOA4NhQFBKRQp6tU3u1advY3R1hjv6S6LcygbRZ9436r7LyQACGwkRDgTkXYJweRRd6/wVuu0QDJmatybXfIInARMIUeFS64F3dQDIJaerGpQi6pO37suqrF4p2sqHJF1LH/QzdtNSWXWEgAagSqLaS5j0PtP5ms8so0nQWgiLqds4yRHdBdPvkuWW3SYyglynmCQNhxilVruvgnFam4e710alvHo001O2W8geFqUL+9rshemhLKgDPTU0gJRQCAg0WnqBCoPtU5e1a83X5j9tyLPtKq43rV+9Mhgm0oJj0IxFPIMxcVWFRPC4okvKSLUjbxwBAIBu0Dx88YJIniyzFAu603cWVaFxZj1svirQBXzSzu9CQMUWl//uSZMOIgigPxUkvEpBLg1iGMwhECNxPDkTgqkEzjSGIPAyoAc0AwVr87S0PEEG/9T7mSbrCXWG9YMPCpsHy5WQEvi9jU9pMmLyjUZ8WfT1r3nO1DdiaO0hPe42LPFbpjIh1QikBS9GaqBudlk5aiSWpa6Ds5aVFj427yqtkvtpcnvFpmgNQYbcgqHx0sPJSC9X30Zfs0/jJ/e+n35/rtD3bjkKpvpGOxvSSBJp/+F9adU61rcr00/u/Z5/8/3YW/4xyxAaw1XjtZSFyZ1EmxsGQLqdf83RX88lHbssDZddDVdakyM++yUegh8xzbhGUtpG88z/7CY6ubmVyU/zzQ+X5fzuZwiYolXvYUz4598p0ew5xroXBlm+QncwOO/WUrbrrejaO82HVoCr81LZW+6qjK4k4MkZkcwi6MMO2YRQTh2FuTWydCaNlq3W9pDJnpHPJGlD2Oyiy4zarL1z0XRKCYGLILQa3YE55NDFwUj7tXULkxKMZhXc3h6JqRGZmlxSk9BhTFtuQTqzBOSORYlMJmuhI9E2AUSwh23iksQILg//7kmTwCIK+GsQweBowSaL4lhnjUgwAfwjGYGjJkyWgxPwNUQdjDAnR8w9aP0jzDAjGgAMiKN22+sdvYLiH6gQjsRks25MayPZMhVhsaXLmUPQ4rtkFp6FlKB6UmfHtXUXFh1rx61aFitBxbJa6QQ9Fcqsxi9ehekNSor4XS6EZbTUuvgPPlV2lQnEVpm5/50uIVem3jBECRfFGNdMV1mZ29hHMVJbhPOrAm2XND/iyX+Xt9eS9/+/rp2mdhcmqWc1WvRrzdxyOl8bha+eOLcX3fk///BPEmebEIrI1oITnfPKgWsRQfbDzeQL/RJ+Xovh8PmX5y/PD5hIjRyL6wSh9PJUmpOxfcaDeo75QW4POCxkJvaNO+0zvvzVVvq1+P5j/uee+KHUO39Sn76rZ63hOFCiNGZQiAQ6yheg2gAQPDN7uhRwrUy5SooQR03J7d4ZMsp32gtv0OFes+S+RJHacNHyPLpPZDIpys58VyQklctXhNGzvJmXYkBmPor0jLfSV+7rGhw3ColLYG1UFzzQjaKVEAAOKXZqvigqrYO4ILLb/+5Jk+4hEOGu/i0kcQEZBWGYFjyQLoF8IxOBoyVyFIMQTYBmRkJ0MX8YpWM++cztLzNYZeSXnHWJ/D6ufbP6e4gPPfMyhyQukvmXnJqd884pLZH9DyM5uUSO38/1vSK2WfNIMUmPf1euTzjhbh6jKje/ygGUpSix2Cxhtvhuo7Om8LEWJz+UulwuMdyT4phSUzqV2+T/51u570ohJLlbkUtyv2Z40hCVKRUrvjnlLen2CBDY3imK4JNIMeu/1bQgbN79HcO0Ev3zzVtBe3eW0gMSKAmFlUjvdtvC2tHEzh7E08JlZu0PMrHhBX5b7MZVz9sou9Kreerdmcy5OG1f9Vz95FMu957aGZWp9+Y+UuC/gdZbv8ze9iyCnWoeXJH8fC//0Oz4mxvGWKnx5WSJHZhpOx2G6yqrtBdKMGS9FKLYz2rlFtCpDIWQZ8c2m4fM0DDzdrGI9AYtFyE0xWqXpVsi/5oqkxxa8BZY0oiCz6pjmixqI8LMqLkJGopVpuBEccYTTJbh3uyGYfdReIE9mREowW1MYXstrjbaACo2foQ+q//uSZPmEAzRgwAEvGwJdizhZCeNSS0jTBsG8aIlqI6BAbA1JvMQHGqtKOI/spKXk2TdvVLPz0+JmTRgct5amZ/SO3Yv4LlyKH62yUj3b4baZ3I3UsExTzImH2XWQmei8s1+Pfiug0S5NXxWZRsVIbN6Opr+3E+qh+w2ZWaPCeobeMO2mqm4YwWd3YjZvpN61v+fvHcrNndOMSW3/3vGyrlunqnDbukuVjOtLLvJTzMa+WDuUIqw6mnERZ8YlZMv2Yu3WZlkheRzjS5r1gzNJee19G8EYLDqq1W3HLRsMa8fRqkmOn1DpIkLxhI3eRMEJmBDTtSx4MljQYalaM2MopPERyE8VQKHiSlNUzS8bioOrdeZE6JMiKqMBWNWZOhABjKorusN9K1+pkTj7aA4Xo+qmpIE8wtYzEjpmzCc0Mw1CwiKefIrkedNUpsUVJ6Ws30XFI3Q3VN6W5HVYyAX0hbodGc5oKLh0tSHhGUbN3gbPxRu5TNt0YkJ8qUVzJlvKfLhjhjFnY3mYb0F0gAEC+NtAWBC5DFDCxLGSztQnwESwZv/7kmT8AIOXa78BOBqSW4goFQ2DREuJpQbBvGpBNIThJBGsIDViJXNjO+lIh8hfUV7B0evXMv5EmPwj7j5MRru/Q1pe69cjHX3FYZPpnBnNiUksWkLKXbZEiE7hXMOuzDMhjZpCHLvOA6t0M/m9M8qWObUU7UFP03IAAhUBIa1VuId1gBIPUdtDZYvNJlIVndZO6TTLkmzT5Admb//1a3fyua0jJCLGpflryksLrbm+CsLWDYAbq9qLeJYFXjpbynXzhtclg2InA5xyNeQdaq/0AIkJAAAA1tCmYvVCArs3iJjKhPwmpHke8U2uV2N0XIzhAzziv1gd9JbvtGr5C9yjE3mt/L6iZ5FmCSlf10uj6ql1ieQU6vlblf3hnl8HvP4VI+d4yNM9eq3CBtnZVYHSFvoqEzNk2bjGQ3W0uFEBmL1dyNNEWOVIXCQlYtqDdnuGdH45O0qsWR9WsdLgRqZB5oNkbRJyDnMyh5JaeykQIt4gqE+w7i2OocWArcylyKLYik4lvEnAYvDgtSM4aoUhmotjo0WM5k+YCbvueMCEAAD/+5Jk/wIDTmy/ACwYYGqsd/gN41JLVP0BAKBhiYExn+A2DUmVIzNpyg9/cBWfMhRWl8t8lhk0ZDy+/0yhY9iOt8vOHL53Pj1mmDIqa5un7WXzMpnMuH7hoX/mc0ylOkecM7w6dOy0/lNy3Kc32cfcP+fkRss8DbyozLMDAQkULISyMnGs8P0Yw1LY1751CZkIjOaKeQUg6rHcghmeZ06W/ndUOshGc9TYoSWrqaFM4h+MhVqxyqWaH77aMrOarkurnfDWU13zWkSkYQz7CFF/kTwl83MycypFP8Gds+azo5bMkJ2HfKCnUdUnNDdwfLz3WCyKiOktIu2Gd/KU25iBZSZ25kmaoxlCIiMzzqdzYU3TlFKfxt6KyJ5VdLbUdoRByvlmRcjto6kdLX1GbOn1o5N5HQQx8dhPCHCg2ZFVgAAAAJmE4URTwNzzQBVPJZfIcjipGhf+5L0WTNIsTS9RylrFsXS/u7KWkrZ/x2zNfdVsz+ZkVOJfru2ri5WkPQEd/8iIyNUZi15TOFop6G0TIifNQVy0Dq0P6CbHUWu2cJpu//uSZPYHc1trPoAvGpJa63f1BMNEzEGg/KCwall/sR+ANI1JEs7Y3UygV69riTrxzZYFQVSZVSA1NV91eSJ4a3qurlXMlRQUFAlhG0qI2TORk79JW8Uj+8hyL1R7m5A6UD5M6CHDws6jy0ppCM4s4z7wesiJC6xFWP8JSdyVxjLiT1WOEo5WBABHR6Z46kphBLEgCyYYLU3RExmmxtsRpDNCZSDiCU3DnkZRSZ90JDakfJWjs/2dQunia2f05ZYdQdonEOma+R1mn0vmCN1M3yLVQoWEsHJJsZbH7mhVnEL3hdQlItE3PzAYbIXQuMCLMyqTuxryGg4O/Gzb7FSEhzhtNprLGVm3Qc5b0GGNGQ+Uz2Qz6a+5GbW2V0+/fItKiQSf5EWW+CtLvLnnp59Mm31zhJwk9bC4dVdqfE6lKDFWkbyq2cDqKoAAADlMOEcnKGKoNKEswklMM6WgDSBDmMbBVMnYVQrdmxlRIs0tGzHzCH0iUKLMnLvNMwmLCMRuykk2UxCtvYcMxdWuj0WpM9IhYo6RKVQ2HhmwYDI7NXhA8//7kmTwgwL/Yb9AJhqWZexn0AzDUkzFnvsBhHRJaS9gZDCPAdzvew2IG9Y3tLUpagUYdshgWAODGOHMAEAAEMZxYaDPApQ4QOh2MDMmHMpq6GNjVBzbccLAggKGabkmVXhDmMToVWNXPVociwxjgqSdTUIKIsqJU64NOscIhTh8zZmiujwxooRSGJQ2/1zau91E1GgaKpOonBQasX5XU1DhERVJpyj7FRHFYDiQyBxNplD5TmF5UQL3PjqJSkpMwPL5SlM2KPFFKWZbZkDlGpMIDBcgWKDa9KHlYZq5Z6LegtM2KSvTG8k2mtMjMkpbfsHIiYKv0idUTRypTPKPYishyQ5KaJiVhEhukgKspj9pQ9trMkpSSChEm8JVaPnQ7kWJkWmy124qajbBzcobbo6xtiahOYMtrM0p7lw6rnMFkWZNe74V4UppCru+ZFWLzyyBWjD2N3yyOF9TqM9EkzmWUxc62TXaYU+bxvxUdNmbyggABDV9gpHEMKZMzlEjB2Nlx51PupxwUKynaFyBGOOzKRLqMcMZEHYzY4tJKUImw5v/+5Jk7AGziWW+KGIbgnFth8UM41CMsXr6oZhmyXown0AxjbnaQNDVkIuNcdVrE5lsi41sMbO8EnvbbDwVDIHNypjPXKYNSLhIK7SbdMcYn3szCjEOoQdsjynfBUCIAIBWB0Y6DjKQcIeGo1xQkW9NxciIbIrtYGSIQQramcPjWEx5Hduu31M17CeQ93N5T1lpZP8o9JTlpTezOVSfc9srOlFPetmQM8zJI9h5qXRnCviXHzSVJJKQ7EXlI0d4JsQtBQqvhIgRobuNjS0sw4Lji6pmgN6C2QOpLSzlDZfUtIWHmfXJs4aZTNlrlCfIlcB1c1JoOQ+fG7k2tfuwmRzEx0r9yCUyMjOLdWMjpi6zKqkJ6aasRZQ5tEUp6pkOzKCxKM08WAABCQJFzOuCOMb3Eqc9hwTFwE7tD2KVzc0KnqljZJEUyJ2E+z0cDGBgpStHJuCQymXmdux5WXI753U8oZU6xlvCO+bfzW5k0N0P5lbgs3Lzi089iKaEQxmsuCpDetk6Phq/IuZjKPsQMY0cLSjIZK9hhRrCtuwiUoUPeRYd//uSZNeHA0lgPihjG3JkyufYDEOwTHmQ+AGEYIl7s1+sMI9ReofSbJ7EH8GciSdbVYZIkik+xyGqHXXp9IzdKoOKY2dDGjghX56SBP1ZNyX83lRuFJW5L08manTQ3/ctBRkcYM4xHagVCKDBLRRo1QVCEww3CCFfVwSPyKQlXJ3b4xxFVbAe/HL0aIdrZM5BTUQXwYi3+SBWjPCIWiHYjrSqRxQaDvhNyF5z/evlE3P1Tpna+Zw37ymhk+a//a4fdaPvw6eCBiKJhB0JZGMKmU49K2baayVBdX0chYy09s0OpEFkR6YNVX068uVnSPpbmxNIKBAkdZxZKJ+rqg25khV3gs+TbtwcUqvkOR/nk+HK/nVcnqmxlF1JkBWJW6Uhj3l9ys4DNqAoAcibNAHsmwU9BIDMVGYUg7kz04M5d0y3jv+3w+dm2RJdCQ2MkifnucsOFTuXCkJdL5Sc9Pz+TWFCt0PMvuv09MFVMt+kh6GVpgru8NHH06/IV5dGxnoRqQIh9SMm1mRA3YFVlG12jPa//gzyHrWKO2oWJFO6R4Robv/7kmTOA7L3aL4AYRwyYWxXwAQDAExJpPihhHIJWDYfVBEPAupjlUZU+kTnykTElOptq5Gm9pKqtymsc42h34qFaZbM4TBKDuhL/Jc+kao1dwGJBfZlsll6oQV7jiCIBAhw+7r6lNIZ57l7tjU5CIqgK7E/SeN2cT2I1CtTvXpV5eleMR2+UnubZUFp9LIi95rZ1ZlPh0zl/y4jnkRb0eHaDp2gdZwKkpwn5j5IWkEZlm1wPz+ASCAYkCFWECRs3RoNPuDYc8oBVpdIYJAbk5QxLajArwyTdk82E17dU9IkNGjmZ5XeJuZeXnCprbNMFkbSF5nCg5zgIrxVEHS8s0Qo530u8aNkWtl72X3/VzuvO8YSgECcZB6TJvGTQED2wxDSIYKIysKggqSrYiRdrHls+lfbaaY0MLw+3c8c12NQQnCVXrZGfRsgRmp55EYKTaGf9gpSlo5d5Lqtj2d9FzWVs6y3U/M5yy5As+PJ+hyqxDBuDO5yIAFRMBMwoZMaSYxuBtI5tKJ3r8xHBl6qeLWL56N91FvRTlGDZ1WqrvXRxbr/+5Jk0IMC40u+ACAYAlgJ1+gMI8JLmR75AIRhiYq0HxQwjUFf74KhrxWIF9GwRc2q68TW9vFw8H7gOAPcVUMlkNdu+Svvw05qV09rFGQsjSXgSFSa1bIzFcIb5bmppWLWyHmXuuz2s7N8sD04ep6NxOEiyFWmy+WesbZmJ9a2DOhP7pp19yo5iTnoELvC/e/tFPLhTzCtmpg1CpTFL6Jn7L7b6TQBm834pnY9aytPplLXQtii3FQj/AuAjM8IhLGxJ6KyAI/Smeb6EPr59c8s3MiexC8yqU4/lTLpkfkfNyIk5Uz8qUbJ57wn7TeUQmgQ1Aicd668YrvDaMIG3OuZroSp0zUplSNjzgPyfY0PId5BmFGaoKRSJo2NPEVMKb7Qz08in9JHCXRfQ3pM6U0dHdY/Fetab8nRkKO6Bn5Tcz/6YnpUcvI4a16DtnW63XGBlYQ+4I5TVY0Glf5WftoCLkxKIWRpc5kok95nYDkMf0yin2HZJG0HM3ldLi/Q7WEMmrksypPuZS6Q3UfaAobmWzkW5U/Qj3wa1iCg76FXGRlc//uSZNWDcp8RvqghGXJZq6fAAGMOStlo+qGEeJlNm19gMI7hoOsdrpg8iZmQrvCnFIsM4MiYCStMyQjxUCa131t/NS462yqDOKa05+fRdQIRmrbg2ANy6p3f5Xjvtpi1IJnI2lPmrY1zXbP92jXVDzqf52V156u/N//ai2v2v/W6yHWhWTQrN2DO2aaRA8gm1zcgYsSybtZplV2S5jm6sJYtgaEHIG5Y+eFDsc93ZPMlCPEloRusruput73IE1JD62alaKjQyDR8qCxgTkzqI9Ec4Sx4Qy9tjgiwaRQQ+SG3+JzMjPoIXxjQBTzKRB4CeXydI6hJGxyP4MDJoBJxaiKhgtlMK1mcObmDh51+06pbys0MulxqUNWuM7ZUi+lIeVKwuZ56o2TJMOVIFmERsii1cH7ll8/dzeKx/7kkNis6hsS0M3b7OqUIAAdpn7vEpoUBrDZV1K0OYX6rGCmoz5vRJKrqLfeMXLWDUL0PLv4zbKp5lxofvfd5lN3U1bj73QlKUyLwvxI5Ujs1dviMxlcmXOnTMpFc6lI2M9mOQqa6yP/7kmTojwMba72AAhhCTmAYCQRjAEz9nvQAhGAJd7OewDCNiXmx6V17RyOlFABACQU8bq1c7IZM4snBldNENh/3u8VLehBOTAbpsjrH+HXTjiGufARU5JahBRcZqfs2ZvlWPQHoRQJ7H8H6c1qaQirF6CaVbUEO58LzrWfncR5FjWHP52BtoXcrNWkY0P7ni5/RXSGrEhs9DMmfvSzrXEnq0VVkdq1nen7kxydzo98HfIqV3Iurkqywk3u6sdKlPh0l7Wm1iwxF83yVMjbfsNkUh7nxMqZFXIyBHAmaM9IwtQi9ClgNYBlhAgqzOGDNTUIwt79VQaHdF9jqQka6nFJ0SmUJJ5Ea4N44KvseW2lYqHUNaVQp0ymDSG0vaez1p8I+nC+AcyJLCfY2TufteH0aAN2kzrPlqUe077PlJddfA9QbnxVAAAGWmNWW03sOEYT8UGIuIGM1iDLhLT4gsiF8yMOwJesEBLserKaJYf33aAILbbAKmeV80VXBMF3IxReT5ucVjbetYSgmhdmzQps7GFLpSGocyh+S6hsO4R2XcrH/+5Jk648zD2k9qGIbgmCq97UMIxLLdZ72AYR6CWyoXtQwjNODt6THsqtQm3XGQ7KDtMGQ7swMlGzUS0ZUbSOTZuO1qWc7YcNkMFEsOGhUfESMJNnqkdlj3XRsgwJzb1zRCMSXaZSECbWmpv5rapBAzt7HYE2WpcGCbUrTmwZqxiWGrLvRaKR1yVmhNYjUm7Y9FVPnMFU++xB6zCCEnUXFCYcPGj6htX8JY4xKIW9eENEu5HQbkqxkz0XkeQpkt6nsYuVepk7Oxl26rD2KGUxXlLKXvmpa2lP1I7nsSZnnCg624ZSJXK65AB0mhC6NJHxYLZZdsIgUwnHCGgTQnpeSs7RkbIt1Ws0jXKlleWeV0c9m/J2N9H6UhVH8+cQm3JzVuKlLVK5Nlnrez6RmbErIWMRfiJifx3KruKrYjmbrbhEl9YKwbPOfqVjS6AAGCIEDBCaYNGY6MrE3qHGYiJRL4ysEp0nKME93KmFfQX16DnxaJh0lNOCkOfkZMkcoOVWQ0zRfjGS8JJHZDKbUlpQ1567GX8z7yBUWKqRSHS9bUuad//uSZO2H8zFlPKhhH4Jm7TeQDCOQTBGQ8gCEYElYpp6AEA2Bg37OK0HyYy0XhEFB3jNlkhFtZUY8lPI1BRThaudOiNWUuy2Ttspr1icRvxvG1P92MRhoMn3ze5PmTLGmZF4IxPX6cpzMOjlPYxF1oizMzt5SimZj7a5mpZtJV8pyr9bC+eWHOY/kmIaXSEuTsOpSq2jDSmwR4bkTTJtkYoDO3pzBsXoolOleKCEzOESyPlSRMl8j4sUY00hmRFdCbyzy5DeyQv4aoiUEnUF1OsJ0jWVjFk9k8y6iWublngzpu4Q0Zs6JRAL5nQCl5FoWLrM7U7gjwbiCMgSPEHLDnHVadn6xhqJrro93LeOII3BwuMrQEdz6v1N5IyMpzzLTKNCeayT88jxBT65GetwqipGpc/swT2aNCbJCIic5cyOHKRLCTPyjDzk79dxiKyAAAznKiTaQQ7cacIa50rlc7yRiLwZMxwaM+wMjiO8i0z5eicJuSKRU7y9LJIL/mvDpoX7KG3LR/5qS6vXQ+VsTYoYq6H1UiHaSwtZmpPSkNs2c6v/7kmTqh/MmYrwoYh4CW6yngAwjwEwtiO6hhGoJfLWdwDAMweRoOassPKuqZlcfFiRACQDIU43ZslQ5fqzyhVaWzfD5V2jZzI6udljdyy7C8Nc3xfqAbOCKFwura+2Jq0arXo/TZSSr+x87cu9/59/BQX85SHT5w/8lt2Cvh4X8ZV5ROCiwrbVPnSbNfbQ+pufkMQJjaEDHM/nFzaLDZCI7KkIqqH5VdZ2S9R2sFmZ7BHCk1XdGpeQqtvk6qzRmOvuGMqZGzCpYmCOVaWqNj+ufqxYOwiqNozwyQR0/BZgtcwUFygCtHdtcm4UzFDzpPXEgxJysFrS8gUySHjlT2PeRTKrkFWozm8pszWlM1rlGqlNHeSoWWeZ0oY4mUS+FVUKk0by1JUMvSjBxiYJGsBbeZPN5lI05zyQGVPQ6Sxpc8isM1o+FsJAU4uJJrMPbYLxKLhcoPlX6TGWwwVQRkzDw6Qlcq0O1TOUoDgpjWY+buRxRJt7SwGREpr5fqwmpYDJFiVaDyjHYlR4fY5K/mTHWzI3zhOvtD9Tlb9VGWlNFwe7/+5Jk6QMi/2u7KCAZglPEt4YEIwZMEaTooYh+SYs1XQAQjCHVApRl2RgAAAAZFFWSrLSoMjSrdmJ4QIclZCC62kdyvSI24ZSlbhRV21LeerMapm5ky0xCbi7zvPgZwuzITmcj47YUuvSWZLltmwZbHL4tJ3lbVb13nrlQeqsv3IN87HKSTJQwVWevLSMVHAdpkDLxLk5nNsVb4pFVTtlCVWDIZuayrC2UjePTamE/1WbMakSxj5mhvuxk5aw15lWq7StlsHWEvsZ23ZShLNDmWU9Z1lKa8dDVcjUKFT2XgtTV8sj4ZeGy4mCiCio6x4sOOSEzH4zCkiJqNNgyErajoHzZiaGdKG+1R6GcrObndzpLfUq+eGOxy/NQZKTaimHYjNmtPYVKCiudtQnOXVDuZcL+Fkx5GUomiZSpa2gOkDkpo32hQTLRIQ0SlHFH+vURECQJ2eka8Jq3LKezP3Cs1KqFK/wCaNTKxqqriyYUQQ4pVCBsMX6rM4koyqTN5w1K1VsI1VqGVVgYzUMuUZj/Y/jQ2bZv143LOKsZmareH7kb//uSZOyBAwFeuQAgGIJbrDc4DCP0TH2m3qGYckmbMVwgMI4JrNgJxP7dmTR3Mt9+kCAAcYU+s6VsuCVcyjATfDJmjSqux1aU4ZdZuk2cW/rts1Y1+KJJjlKw9ZrDP/pUiPjGqq0v7MxHzs/qs3DrUuxvq7M6kbN85Vpf9JtVVfUK2pcPp6rnMlLbYCXMOVqP9ZMJzALMMKxVEaEa0EmEmps/8vvzVBVKrFn53+GsPNaWTGFJvb6sPY1jXupQyal67Gu3GpNSaGsbpM1EhjWGtWe1UBBgKAR1SbhqsDNWPBiYFT/8UaAI1mv87O//+XwoTXhi8/yyNfCafEa/xE/wmpPDIYULNHO9JjbWNVJo2sMo0b1XZtuNRM6TWGuuq7NVJc9qJDCoGNVjdakGMBGDMMfCSkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmToAoL0XrVAYR6SW61mpQwjEAspmLQBBG3JNDPXiBCOeKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo"},{ name : "R_sounds__pass1_mp3", data : "SUQzBAAAAAAAd1RQRTEAAAAUAAADd3d3LmxlYmFzdG9uMTAwLmRlAFREUkMAAAAGAAADMjAxNQBUWFhYAAAADAAAA0dFTlIAU291bmQAVENPTgAAAAcAAANTb3VuZABUU1NFAAAADgAAA0xhdmY2MS45LjEwMAAAAAAAAAAAAAAA//uURAAAAf0TxhU9IAA8IlkCphgADLiFQzmTAAmYkyknMGABAECi5qtSGghEFPqtECbjjW2xk0/fwATDb4MWu2oKyfYQuc6Ro9EC3g/h8uf/Pl3xO8P/4f2r//g/g////y7w+EAlCWrYMDyp2rOATEdWws5t9gBhexD3cAMnrR7tjw/w/nxGfl3g/tLvreH8Plz9b/+f6//l3+Ud/KO4fAbrr5f7/qmRZASDZSdDAIdhcERKnuwXK4LoL+GGYoHiRVCBR7v9fmJYeZh+HMx+pT/zMaHiU5J7q4ROTpxtOThCxskU5Xu523r3Q84tKk+OQF/j9X/Tfv+/+vd/CtIVzjI/nd93sC2sv+q+dqZZAIA8ZXi+Jtf+DIlL4pDdPNyinu27Bh8IlMCCkBqJl5RAO5EU+vXPThk8Rd5IryHhb8yKv/fB89ebqK8YiuBYXFzPMnptXA0M1PJt2vdjxyvB/d+5rzJ/F4a93/r/6gZEaGdjNyNNFIi6sxLpcbjuk1y6//uURAoAAqwY0f9gwABYZSoY7JgACox9TSwkZ8lcIynBgwmw/DqP5AkWfSMUMSnCYiyER7LQPWpfssgnp9vmRDHmOeMisXKQ2SJB+TNmw+CDXBchXzhef+6+xVOQ/lYxwvs1r2aSWgQFAnVMwK+j28zlMMguaicklM/MUV2f6DpyCYzfJJhcJ4Wegnyf3xEMbV14wqEScRL9qj/62fPHzWhz3ww5sa2XuAFLi9IfKLW8+OcwT632mr9PpFu70AXxLbAKK8gwAtDlwY4DuvuBgoooCAgJUfgRzU94kgy0zhlJhnV3cgXI9c0L/k32CCIZHAGeF4GhCBG/+u///vHf9vnqV+PYf59Sg+d3qj5BCpnPtwMAo0KtGvtgWEiMdpqTDkQpJ080wHJneVHGQWWDDGnNFt4rGbHPSVbayEO7SnMy0Y+jKyOlznyE7LV/J5J/35GryIQ8jVJSeEZxgIKvIKJvPoe0Ecu9mioAEUkALChcI8hgesAQ2Tk0DHoERTTm//uUZAsAAyMa1KMsM0BCZBr1PMMYDfh/YY09JIkSi+588wyYbi+jcFEANBgU0RXeMDArn1BAEdaIY4FcQykU310BACCeog4JejCBtpBpIgKOcubTlGrJkjAql1xNjXGrkjFOIVd/tF4VeXDik6lp/cx9S//SdlAJCZIgw4YmQxj7TEZvp2FHR2phFhE55IRwPMW8QjfLu50GYZ8gQQlrFtrVZVUTqFblJl1nxO6mEbxIkg1IYAIjABA+JUXEUxNLBNIESFQAFAmQYwrwrA5wLHydHEN95O6BGF5msNj5HSNAycQCJAqq67E5YjRNCObbaz0sQR+sW+cP+P/W7h3tcMYj9vP09I7jh1cdaDUJH2pfSfgW18c/DADrebXmAV/7b9e7/nAJV1RVU7rHEHDQdRmABwArkQgMNvMMyVDVodn2lFlMKFEOKZTggOYTA6rhMJGnCD3EXD2Nr2Nf8h3//0HlLZtFLKGsylUC2uVItyxkuI/lAQYdq1K01qqpXJdM//uURAsAArob22sJGkBZJwtMPYMqCxBrZYwwY2FPDuwxhhjYDg0AwucFwyIkK1dZLba1U2ZyeEGBkyBw35oeKzKRcKHTDQ9KhwkDUVOYibOounk1Rf8kzeJmkQkRvJLdqEqWIZpAraKYCncMElJuB9LEeI/RPBEUiGKhGOlSE8YnQik7MMCavQ29ZqlQgwUYVK02aHjuN5+ULLb82LmaNWYybJ7QxqK8mJnJnLoqA1LFHvG26f5LshoSvkounQA7/rW1/QsCNUiMCfsMRGZBECIHRCL4+2HEqPvtA2FGCDrNypXl3I+ZPGnijSgVMtEq4o5YSfrTOndqACRIsYFWgKWaIqtgdEY40LB04NEVws9VpGvBVWwcAkm7SB6Up8Aa078JjOy70COSJ7o5Mj6lMRqjR9amA1GLlruXwvKeLzdKdDatCnSt27c0NHhdqLBqAvjbGteRewAhlPiYq5+eWMSbTH0qnXJs9fEqAJWRRQXSOpiCOiFzbt6/Ljtgi7pQ//uURAqAAsocVOMJGsBUw1qVZYYqCuhhXaY8wWFcjGt1hI0Y43YEnDfFcRkxKdSOoKk92uyE5bJwJUekjxBWDPocF4VcIVKBY/AgaDRtyzqHPjnBx7C2ss/0vA0sb2vIiXqF7rluFVqAgAIWABjJ0vDw9lmqYhFcSnBqOmBxUmaEVWIwq0gVDYSR3N5ii8pjlYZLc/s/UiceG0AMFohc02GnFyQx6bKTyFsGtDR8kZKuUoc+4w5Ld+K9/6PoAv010jNbZLrgSgW1gupPBc0WSQ/kMcdImLgKokDm2bWJQl5TqXuu1fvHwFhYsVMue9SxVoGHvDhtQOhpF4CUlHMcGNFaR0WqPnDyjbgyRcGUd9C2UPp7aHK9WSi22nKLQYMiXi48sZu8zFHDAIwOiwFqiUxqFUOp1xm1Hwu7cmVKjCTFiSJkWAwOPQ1sFmB5SBhRjziCgtMBgiu0iZYLn2qi9nUWZlmnf10OQ62hVQ6GGpAkGOGVsoTD+nHZ0eCYflFc//uURAoAAm0c0issMMBWgnp9ZeYYCoRvT6ewY8FBj+lhhI04qsOUeQU8IvCZRtYkknumbVem+Xl5DtfaElEGMwk0w9QxaYkGQ4cFDLDin2Uqi4VbgKxphNC2SV1/WA1GQgACAQVFYW2MmdSwcZhj5Wy8p48UmtK5RHBQURakPl05yNdLdTo4/Qo9oaDxweLKsQOFWFGuaVD4+JYCnqhRNTfY0Yx6VdjhXr37c0smwBiQ+Hr1JtTJIEFRtKUF6UZbQXIVDQUDoRwKFwFVxVLJ6jQoYfabtwVPd9m8asM9T46kh8IGCzgQU4eFQ6eQBHpLTQbjweYL+baljEma7qWsolkQtq9aLr6KAVlSHYrA4hIclCpw1eKNSk7uBEgAoBTMRMQJm0bS6KHWgxL9E/XMJ6xi7GWHrIZEWFlKGHKkxIKljAwvWJq3NexjFqVTnmCEeEg5HNM1k1dyBnUIlRtFxPAUcAVNAV/BKZcMRx5QoHj6osTqTwziHNfj1qog4mxT//uURBOAAnEc0tMJElBNgyolZYYcSaRNRSwkxwE2DKow9hikQD0dnWrzEZhIecdhqswLqAh2KrYUKkk1iOmFQCYan7vJBzp31+V1gQAAoYJNDA8W44D4alRcErpgL156fnO1IrASMPC0cCogpY3kfaFbjVSSO2uyabAK9CN6Fb91hoy0KM6+t8jSZIqFrNduUu7/qfl/iv/oH+oCzLg0gR+V4gYzZiU4X1CgDjIKEoEggzSJEo2kAmTlJy9m0NmSEFAGfUDwNHUAyEhGfM2RQXTTeSkXF0966zi2CvJhXsatSzB3JlgFbbCE1CEBuCvD4DsdmkeAVBkuZDg8OShcsmxyE1X198rGpmPnQSt8svX26OSHzzA5ekKbrz48w4TXuuxdxsxmhCQyqD2mfWP3pU1BWioCyAESlgeoO6U1SSYkv9dDvgkmMRPJhkXESY1Yn1JQCSCb+N8MSSEAo9gTEgbBVJFdUBipEWUFSbWgUoo85Dnl2UVx6Na0JXX0j08W//uURCYAAm8SUMsMMaBMBCooYSNYCVxfPQykZ8E5E6p1hI0sHdABAgBWLgUMQZDlP+r9nDzw071V6RgmEw4myjQ564qehvHQygJmCHD0lQ4rllm+797wYiVGBZC0HdW0uOEs+KARJRydBhOzu/9X39HSBIIBFEYIBMGgUATxsskcKWGiYFYAeSIJCs4PqoIAs09FTcJ42mg1VBIMtMhFCRBky17iRe4ZQdctz1IUtqmG66jNmxGjSq9tNhSlh2+xqJORopEWG+n04oNjzcWXOFcBJkyDqFxEjcajDotbflqQrQhqsIlKojQtSJBBbRduhlMuHpHcFT2JYEJMdwBKve9x3dZ1Xin/f//oH9WXHdAlA/jDQGgmKh2WBMbIzyqxcgLtfLKheBngR7E7RBzWSiVugVOJjxcKw01x1a88qBFN6VkpYcLw0MaySQpFJH0p///+sFgEAIBAXJtmI0TDQGpa8LfhYTigHFCdyqQ0ywZaMIHndS1J7HCw4FNUausJ//uURDqAAkQWTgMsMWBL46oJZSM8CaybS6ewY6EfDKmxhgw8jszK0KGTolYLLOFbBLWhoonS9PRyp55dpgwqHNf//QA9tZW0nY0igsRkyESOgHgKh0IQdlMlIjAtH76w5M1rjuR0yeHjkPI44Kkfl1SWfV5RSZ61fNCVAavsS8/fXj9c8LvLNIKXRVo//+mvrQcm0aY8ygRwayNw8EYQjkDQ/F8bDQJYkPn6GcOHcYcVF3CILh7Zqe4Z+ctxSFFGEHrk3NvaXHpOMclDXqQaFdOk1cPWxy/+ugXfInM/0sFDHrUWm2uXlezLkPUuCBDggJERpzGhKRDFbC7jz4TNlYaHBgglBbOsWqLkq4qw5KqXvFIqxiLGGRry5jtYXcgCRhLbQE7Z22++lQrE0diasYOC50aBxKWjwyIQhHy1SGlNwARIzQyPpEJnXyEp4mGAVY9QhKOZAKQfOiq0zjnmWMWb6RfYMxT2DUIDq2IVkav0C/3baRyWRIIHiRk3R+BK//uURFOAAlUPUeMJMhhNgxpsYYMbCVRZS6ewY6E3CKq89I0cbAcPiVdaZKw9HX1on3PXGxjReEQNbUeRdTBseF1tIoMGYWFgUDRUKLDqpAYwZcltcrigR7FIdT//9/+wCp5d3l2stlaSGofJNWkV0wyQJRSHS4JCMMxgQlw2eDEokABExJAoihIHAKPNqNBMNvDZJI9xhbggRrIihBNxYExC11Cj7x/9K6f6v26qBdt8kaTjZJBRBuZQA+BJeAKSCEKl5XFxnVYoXXhXOJmbspw6vqDQ0VLCyR6jZsuRBNYNnE1GMWSyJki7grfagdsNk0WnnIwunfxdVb3BJzMwrqqiKcqLryZ240+yNyFAJEohkb4UBFkwCWfM9Zso4jdf7JYlBcDDA2TXqCDlMQCyw6qLbhdSfOZczckB59YqNW0vd/+lG9y5WsAiv1EjVIBTaXNQiRaU/QKBED9GKUzgUHwmqYxhcoxgwUNVjvq7XIOpM2GzKBYK4TaRBE+XGnxy//uURGkAAmsTUesMGHhM4mosYYY0CThVO4ywZQEsDmhxlgx485ABFJCOCDkQDSed9/V//9HoACbrTS0ygNoMxR/hQRRiATBKNiG8PZIHQxXssNu92oYgmry+MBs9S3c7CUzKGwkrjxKlwupFYCa5ptN0bUgCYZspmy9nRq6v+/3LAjl8jV/9QTktzTXT7UkzRBHYXPKhkdjwO5i7BYIzaZUorzzF57WeRFQ6ksNGb3BMaFiEBhMNkT5RQ0uFSy22aVvrJZai5tV0rXQlCJIGyS1NzTSA+SlqnO09Ub+QE26YVIyWiORoJpgm4EejOlYbWnzh48TikOmx0kJHrGhJceuKnQuVFihdryQ17sWMkTT7mO14rsX////roAGbHdmZbLaiQCikdZPCow3B2mTOK5A3sNBwseegWavZx/3SsRBpEAgjOoVTAoSDigoUMgsDCEDGyTIk6mSSJZqkuhq4ah7G60ljv/oAqtiRMsyAV5KosDd9VZ1AsDQLEZKFAosK//uURH+AAmgTT+MsMUBMwhocZYY2CZBVR+wwaSEzFKgxlIyoVEa0DFPT1hpwEZLc3oMmNss4daG19w/9+/n/lnBIkUGiiBhkjExEgxpl31YqxbEIq/b/mQZYushmfXW1pMLB+ArFYZFDngD4Qk3zaNFPIJAXEBzaArqgpwzkFmCp2NLSx1Crng61bAuHErOBIuoVGNFaGuAKFX9z/7b0Wb7Xf9HqTt21rn/SATYg1PrFiL+QI5DkSQdypYJE6SMwOnNbckFXaKqQUBQbErTiAgwUQGB4uHjZheOASbxELhRpesBCBajCih+53Vvs9mN6A1b9tVdsADeadWKGQwoFYCfHqEOnxJBur89SISxthnczQ3XSkorAIGY0Piww2IScNDluFlIcLEqg6E0KU46qff1dFTBYfIa8caKf+/1qBTttpWyqATwM7J4QDqMUYxXBRxmwgkhUZsqGGHsdx3LeuI6ouVmsR6HFGGAOYhAwYCKowsFcRGJFzEXAZ4f6vd6y//uURJQAAmgXU3npGxhLQkrcYYNHibhPQYwwY+E3DKgxlgw4a/tU25OizrtvdpeuBaiZual9vrW0w7MknORAmqX12VA5oT4Jgm9CTY0NpsPgpOi0EY8FCgiNlAoDgAmHjyo9UmQWpDEkmLeaGrS5zjt19oZMJktyTP+z/3RwNERN27LnKmSQDxjnOQg4z8mMtDDcU6lWkWlj/MOPUKt7pF9yyIE5JAuH8fkQT46K88OxOJcQa2x0cE0GziRpQwxybm3FfpM9yLv9qy3Ja5L9SAAVKA4jdTi2Qk3j/Rw9JhGmYpOirDREXYJlThoMjRQTClKbkSrDKJNzSsHxFJaUV8pm5SqoMOKPK2JffGzvdf5u/wVh1ebd1cjSKDAqUBxIkkBDyWm83uR0oo0yakGE7FQMYGFhkiIEOmmSkiZDQSJFYBIgI0FUHhELG2lbtpUA/nky2uezyF///9P6qkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uURKgAAm0Q0/npGdhMY9qPPMN3CQhbT4Y9IXkoB6o8x5g0qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgBJYE0GyMAhZeEGeKHBUQh4uUXUOnDofKI2H5qz2VlDBQQIGjpZZKhkatbL2LAYMEGH8rlVRVU27TRU9b//IlXTammr////lVNu00VP///6q6bfTVrRWir+VUgAAEABKhKNRXMD9EOInHFlOllBAqGXJorFRZsWF2fiooLfiwuzFW6/FvV/+Kt//9dMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uUZJcP8tUgvxHpGdIwQUe5MMMkAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"},{ name : "R_archive_tuto_2_png", data : "iVBORw0KGgoAAAANSUhEUgAAAEAAAABwCAMAAACZzYZBAAAAB3RJTUUH3gwTADYhpslDpAAAABd0RVh0U29mdHdhcmUAR0xEUE5HIHZlciAzLjRxhaThAAAACHRwTkdHTEQzAAAAAEqAKR8AAAAEZ0FNQQAAsY8L/GEFAAADAFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABXFWMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+/v7u0vPcpebKeNm4SsyMMZ1gF20AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQLy+ZIyNiFhYAAAAAAAAAAAC4SsyXZtV2g99VoOl5n8mdnqjBnYfmnGbGbj6mPxamPxYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABdLhtGIxUuFw4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1I3kvIHMoHGwhGGUaFF4TEFcMDFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADN4/mRwvFVoOlDgsAwZJcdRm0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZIDUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADq7/q3wtuFkKlTXXchKkX/+/AAAACAgIDQLy8A/wD//wAVFUf/oFwA//////+meLxYAAAAAWJLR0QAiAUdSAAAAV5JREFUeJzt102SgyAQBeAcDzoXGU+SG7NyMXaQAbH5Gx5YZfJWYvG+ikJpfKydeUwBfvaMA4xRe3jkjo051mUCA/D01xYH2GM7mgW83iHiEZEdSYCdcU+A3rELZ4wdOcATzyeR1iOAcmiP3uLhmcC66r/4LTYX4KggWMAYrU0UIl60NIEGmAjD9XjBZAID8On4Eo6LJSNIgE/any5vWJnAAvaktFlzCBZoz/UApx/wj+xly7VAmGWp5UYBMnkt4Jj5QOlm4oHW7dQPtEyeC6goM4G4mmfQAE+KX3LuRScjWCBVj5lRQL6cInBATV0iUEBt/UxggJZ6TFwDOAIFtNfDi/hcwN/GfqD0EMkDSn2BL3An4L+PtLsA5b8VOWB/IgGANsJfABKoJ5RCA23EsY4GyoRSY4Ba4lzHAfFnRr7q60gg/6mTqmOBeiLsYIE64thAAyXkPHsEIDOped3AL0d/0DBrHM9jAAAAAElFTkSuQmCC"},{ name : "R_sounds__dialog2_wav", data : "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vwNDABoEmgBbBBwBqgTKAQgFZAJhBbgCpQX0AuQFSQMLBpEDNgalAzoGjgP1BYADoQWBA5EFcQOIBXgDSAVsA+8EMAOiBMECRgQ+AsQDyQE1AzgBtgKsAEoCSQACAhgA2QHk/58BjP9fAfP+MAFS/gUB3f2wAJ/9YwCY/VMAcv19AD/9uQAG/eEA4fz/APj8FAFB/VkBhf3bAaX9WwLB/bwCDv4UA4j+ggP0/v0DL/9vBEH/2gR5/zYF9P+BBZAAxgX3ACEGLwGABooBtgbyAc8GLAL+BjkCOwdSAjwHlgINB+AC6gYDA9sGDgPOBgADkwa9AiUGfgK3BUcCXQUeAhEF8gGyBOgBQwS8AdsDbAF9AxoBFAO6AKMCUQBTAgMACQLE/6UBpf9gAWj/OwEd/wMB8f7mAMD+0wB7/rYAWP6dAF/+swBf/tAASf7UAEj+8ABE/lABWP67AbD+AgI7/zcCd/+UAl//IgNo/5UDtf/VAwYAGARqAFME4QCpBDcBBAVPAXkFaAHbBacBFAbmASQGLgIzBpQCUAbgAm8G/gJ2BgsDcQYbA1UGMwM6BjgDLQYHAxAG0ALJBbECWAXBAg4F3gLwBLICwQRRAmgEFAIJBPgBuAPeAW4DnAEkAzcBxgLfAHACpAA5An4AJwJdAPoBKgCxAeP/ZwGu/y8Bev8SATT/FgHs/jwB2v5QAen+OQHr/iAB5v4oAfD+SgH8/nQBLP+hAVf/0QGV/x8Csv9ZArX/owLO/8wCEwDgAmAACQO0ADUD9gBZA00BkAO6AdgDHgIjBGgCXQSnAncE1QKDBAoDpwRCA74EbAPFBLUDsAQQBKMEPATEBD0EBAVBBCEFhAQRBbAEzQSMBI8ELQRjBOYDQATGAyAEzAP6A84D6AOcA+QDVAPYAxYDqwPiAmUDqwITA0gC0wLpAb0CtwG8An0BjwI2AVACAAElAswAIgKlAC0CkAAKAoAA4wFoAPMBUAAFAkQAAAJEAPUBNQDsATEA/wFhAAwCqAAXAtkAKwLnAFYCGAFwAmQBgQKpAZYCwQGUAuYBmgIVAq0CXQLFAqUC2gLsAu0CGgMIAzwDGgNtAwcDkwPzAp8D9QKpAwADswP6As0D/ALdAwkD1wP3ArwD0gKTA5oCXQNwAiwDPQL6AjkCvQIzAo8CIQJeAgoCNgLoASYCzgHxAasBmQGGAWsBdwFVAW4BKAFnAfQAagHUAGoB6QB2AQkBdAERAYoB/ACZAf4AlgEqAaEBVwHVAZ8BEQLmAUgCLQJoAn4CggLaAqwCJAPOAmsD7gLKAyIDIgRjA1sEpAOdBNAD/ATtA2QF6APFBd8DCQYLBB8GRwRJBm8EegZxBH8GXwRvBkIEcgYrBHkGDQRWBuoDIgbaA/QFzQO1BaUDewVvAz8FPQP4BAoDpQTJAlkEjAISBGECvANCAlwDGQIFA9YB2QKRAaMCbAFeAk8BDAJDAb4BTQGoAU4B2wEvAe4BFQG8ASABkQErAcIBKAEEAicBHQIzASgCTQFSAoUBuAK6ATUD8gF7AycCsQNQAgIEZwJhBHkCygSaAikF3gJ8BSoDwwVvA+UFjAMgBooDXAabA5UGuQPTBr8D7Qa/A+4GvwPhBsQD1ga7A94GnAPWBnsDowZdA2AGPAM1BiADDgb7AsUF6gJ0BbsCLQVkAtYEHQJ0BOYBJgSzAdoDmwF8A38BLwNXAfoCNgHPAhQBnAL0AGoCxQBUArUATALJAEIC2wBMAt0APALeACIC4QBBAuEAjgLrAMgCFgHVAjoBEANTAW0DfwHMA8IBCQTqAT4E+gF0BBsCxwRQAi8FiAKCBa8CpwXFAswF1QIHBtUCOgbgAkYG8AI+Bu0CWAbgAoYG9AKgBvoClgbNAnYGnQJdBpUCNAaDAgAGTQK4BRUCbQXcAToFpwEnBYQBBQVqAacETAFHBBUBAAT3AOAD/ADNA/cAtAPKAIsDqgBJA6MAEQOTAO0CkADRApwA0QKwAPUCvwAdA+YAMwMhAS0DVQEoA3ABTAOYAZQD0AHsAwgCIQQqAjgESgJVBGwCkASPAtME0AIABSADPQVNA38FXwPABXoD8wWhAyUGtANSBrEDdwaqA3YGngNhBo4DUAaFA0oGbANFBkUDNAYuAxIG/gLlBbcC2AWDAtIFVgK3BS0CfAXvATEFtwHTBJ8BnQR/AXMEQAE7BAMBBgTPANQDlgDFA3kAoAN6AFoDewATA2sA7gJjAN4CVgDJAkwAwAJYALUCdAC7ApoA2QKxAAYD4wAZAyEBEwNYAS4DkgFXA7cBgQPmAbMDDgLuA0ECEgSEAhYEzwIpBPQCXgQMA5gEMAO/BFMD7gRlAxkFbQM7BXkDUAWOA1EFkgNZBYMDWAVwA08FUANZBS4DRwUOA0cF/QJhBdwCZQWtAjgFgAL4BE8CvAQPApQEwAF5BI8BVgRoAScEQQH5AwYBxAPVAJADswBNA4wALANZABMDMAD1AiQAtAIcAHYCGwBuAhwAhwIbAIACJwBmAj4AVgJbAGMCbwCBAooAnQK7AK0C+gChAjsBsQJyAdUCigEGA60BJAPTATgDAQJfAzMClQNVAssDdwLwA64CBATaAiME5wJNBPkCegQKA6wEGgPQBCID6wQUAwYFBQMYBf0CJwUCAzcFAgNeBesCdAW8AkkFlAIJBWYC7gQ0AvAEBgLpBNYB0gStAcIEigG0BHkBqARnAZkEPgFwBA4BJQTOAOsDowDMA4sAuAOTAJYDhwBuA20ARwNlACMDcwAqA3sAOAOAADMDnQAGA78A0gLEAMwC0gDcAvMA9wIeARkDOAEpA0kBHANoAR0DmwE7A8sBYAPxAW4DCgKIAxsCtgMtAtoDSwLtA1YC+ANbAg4EXQIvBHYCVwSNAn4EjgKMBHUCnARXAqMETAKlBEwCqgQzArsECwLPBOgB5gTAAfEEpAHkBHwBvgRFAZgEFQF4BAMBXwTfAEYEtgA8BJIANgR2ACMEVgACBDQA3wMhALIDFwCEA/b/VgPq/zoD6v89A/D/LgP7/yMD/v/3Av3/8AIEAPkCDgDtAkUA5QJ0APMCjwAPA6IAKAOsACgDsgAfA7wAGgPXADkDEQFvA1QBnAN/Ab4DmQHdA7UB/gO5ARYErgEzBLMBTATKAVwE5QFzBPYBkwT8Ab4E9wHNBPYB0ATSAcoEswHJBKEBzASWAdwEjgHFBIkBqARsAZoENQGYBAABegTiAGAE2wBOBNcARwS/ADoElgAFBGMAwwNEAJUDJQB5AxkAYAMVAEsDGQA8AxIAMwMQACADEQARAxMABQMNAN4CAQCvAvr/nQIGALACHADKAjcAzwJOAM0CawDXAowA/wKiACgDrABEA7cAUQPMAEcD4QBIA/AAXAP8AH8DDAGXAxsBpwMnAb8DKgHhAygB+wMmAQEEKwEDBDUBEgQsAQ8EEgELBPkA9gPpAOsD1wDpA80A4wPSANoDxQDWA58AwwOCAK0DagCXA1QAiAM8AGADLwA+AykAGwMlAA4DHQAFAxIA+AIRAOACDwDBAhMAqQIZALkCFADIAh8AqwItAIsCNgCXAjkAqAJWAKICaQC2AmoA0QJ7ANcC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5ADQAcEApAGfAGMBdwAZAU4A4AAlAMMA/v+tANr/hwCx/1sAn/9EAJX/TQCM/1oAhP9JAH7/KQCG/yoAg/9FAH3/aQB7/4gAh/+bAJ3/tgC//90A3v8WAf//UwEmAHwBUwCiAXcAxgGHAOcBkQAPAqkANwLPAFQC7AB9AgMBpAIaAccCMgHcAkYB3gJbAeYCZAHtAl0B4QJWAdoCRAHNAjgBswIxAZUCLAF9AhwBYgIGAUUC7AAhAtMA9gGxAMUBkwCYAXAAZQFSADoBQQAXATIA/QAkAOUACwDQAPL/vADa/5oAwP+CAKz/eACo/4AAr/98ALj/bgDG/3wA1P+NAOb/ogDi/7QA5v/IAPH/4wADAAMBFQAuAS0AUwFFAHcBYACMAXMAngF7AL0BhQDPAZYA4AGjAPwBsgAOAr4AIQLFACoCvgAvArcALQK1ACwCrwAtAqoAIQKcAAcCjADwAXYA1AFWAL0BMQCVARgAdwEAAFUB9P83Adz/GAG6//AAmv/JAIj/nABr/3gATf9jADb/TwAq/z8AJ/8iAB//DAAe/wEAFv/0/xr/3P8a/9r/H//p/yT/BwA2/x0AT/8kAGb/NACB/1AAl/9rAK3/fQDL/48A6/+1AAcA2QAcAP4ANgAZAVsANwF5AFEBgABpAYsAgwGZAJQBswCkAcwAtgHYAMkB5wDJAeEAvAHdAK8BzACwAbAApgGWAJUBiwB+AZIAYQGUAD8BgAAlAWEADgFIAPcALQDVAAYApQDj/3oAxf9dALD/TgCe/z8Alv8bAIn/+/98/+T/Zf/b/0v/0P86/7z/M/+r/yz/t/8v/7//Pv/Q/1r/2v9e/9z/av/l/3P//f99/wkAg/8jAJf/OQCp/1MAwv9tAN7/hwAFAJwAGwCwACsAvwA9ANMAVAD3AGkAGAF4ACQBiwAnAaAAKwGpAD8BqgBEAbsAQgHNADQBzwAkAc8AFAHQAAoBzAAMAcsACwHAAPkAqwDeAKEAwwCiALAAjwCTAG0AbwBWAEsAQwAvADgAGwArABIAFQAAAPr/6P/h/9L/2//C/83/sP+5/6X/o/+g/6H/nf+c/5z/k/+e/4P/mf90/5//d//A/3v/4f+D//P/hf/1/53/+P+u/wkAr/8kAKj/PQCx/1kAv/9wANf/gQDo/5wAAgC4ABgAyAAoANEAMgDeADsA7QBAAPIA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z/+QAJ7/igB0/4QAU/92ADb/aAAY/1gA/v5UAOL+WADN/kwAxv5KAND+UgDj/lsA7/5eAO3+WwAC/1sAIP9mAD3/dQBb/4EAj/+GAMH/oADk/7AAAQDIACoA1gBYANMAiwDjAL4A9QDqAAsBBgEcASkBLQFIAUABbQFKAXkBVgGBAVsBigFdAZoBXAGiAV4BpgFiAZsBYAGLAWUBZQFiAS8BUQEBATsB4QAvAcUAJQGuABcBjgAFAVUA+gAYAOcA6f/TALn/twCF/6UAVv+YADv/jgAp/4UAGv93AAf/ZADs/lkA2v5YANj+WgDT/lgA2/5WAO7+WAD7/l0AG/9iAEL/bgBb/4EAb/+LAJP/kwDK/6EA8/+5ABoAygBHANgAegDpAJ4A/QDGABgB8AApASIBRAFDAU0BYgFcAXYBYwGAAXMBlAF6AZkBhAGaAYkBjgGJAYwBjQGGAYYBcwF5AVoBaAEyAVsBFwFeAfkAWAHlAEoBxQA8AZoAMQF0ACgBUgAXATQAAQENAOgA5v/TAMT/wQCy/7YAm/+uAI3/qgB3/58AcP+ZAHP/mQCM/5oAm/+dAJr/mwCb/50Aov+dALv/pgDQ/64A5f+2APv/zQAZAOMASAAAAXUADwGTABwBrwAhAcQAKwHQADcB0wBAAeIATgECAWMBGgFyASIBegEeAYIBFQGRARcBkwEKAYYB8wB8AdUAcgG5AGwBqwBsAaIAZwGJAF0BZABPAUAARgEfADEBAQAYAdz/CAHC//wAsv/1AKH/5QCP/9cAfP/NAGv/wwBY/7wAU/+7AGD/swBw/6MAfP+XAIj/lACR/6EAnf+lAKT/pgDF/7MA8f/AAAwAygApAMsASADVAGkA4AB4AOUAkAD5AKEABgGtABABwQAXAd8AJAH0ADYB9wA6AfMAOAHtADQB5gA2AdkANAHOADgBygA6AboAPgGVADABdwAkAV0AFgE1AA4BEgAIAfj/DAHg//QAv//QAKP/vAB4/7oAWf+4ADX/ogAU/3oAAP9sAPr+eAD7/owAAf90ABX/WwAq/08AIf9ZAA//YgAX/2IAN/9gAFb/XgB1/2kAl/92ALb/hwDl/5IAEACcADoApgBSAK4AYwC8AIoAyAC8AN8A4QDzAO8A+wD1AP8AAQELAQ0BHgEbASgBJAE0AS0BKQEoASIBFAElAfQAIQHcABMB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"},{ name : "R_sounds__select1_wav", data : "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hf9N/6T/Jf96/y3/f/9G/5f/M/+M/9T/NwDA/x4ABABVAOH/FgBGAGkATABwAGcAgQCLAJ4AlAChALQAuQCtAKgADgEJAeMA1gC8AJ4AzQCjAMYAnACvAHgAzgClAK8AhgCgAGoAnQBWAKgAUgCQADYAkgA/AJ8ARABnAAsAiAAsAN7/gf8NALX/zP+E/5b/Z/96/2X/Wf8+/2//R/9Q/x3/Vv8Z/xj/3P4s//L+Lv8G/wH/6/4x/yj/Dv8O/xT/JP/+/iH/Lv9Y/wv/Ov8Q/zz/Ov92/xn/Yf8v/4P/P/+U/1H/rf8T/3v/Pv/B/7z/SACy/0UAyf9MABMAegAFAFcAQwCOAGsAtwBqALgAhADKAJIA1QC1APAAlADPAMcAAwGfAN4A1AAEAZgAvQDRANoA3QDUANwAzAD8AN0A4gCnAPAApQDQAIUAGAHEAOMAkgDgAIkA4AB/AEQAzv9nAPv/WQDw/zMA3P8DALT/GwC6/xcAuP/z/4//BgCo/+T/i/+x/2r/uf+D/7X/fv+u/3f/qf9z/4//Y/+P/3D/i/94/6f/kv+a/4f/of+a/5n/n/+W/5z/tP/C/2H/gP+Z/8b/lv/N/wYARADY/wwALQBRADsAQQBCAEkAZQBrACoAOABlAH4AbwCBAIwAnwBiAHgAiwCjAHsAngBzAKgAmQC9AJkArACEAIwAmACXAK4ArgCTAJIAkgB9AJAAdACDAGwAawBNAJkAgQCGAGMALgD9//T/yP8DANL/4//D/8X/sv/c/8v/s/+d/7X/ov+I/33/fP+B/0H/Uf8w/0j/Sf9m//v+Df82/0L/Kv89/yr/RP8e/zv/Nv9X/03/Y/8o/0P/gP+y/z//hf84/43/O/+U/0//sP9E/67/4f9IAMD/KQDQ/x8A/P82ACwAYAAYAFwAEwBcADAAewAoAHMAYQCmAEMAeQCSAMAAWgCCAHcAnQBvAIoAkQCHAJkAgwCIAG0ApwCCAGEANwCTAFoAjABEAKAAUwCUADMAtwBJAMcAUABGAM//XQDh/3AA8v85ANf/JQDY/zgA6v8gANn/DADO/xYA5f/J/5v/1v+p/+n/w//N/6n/xf+f/87/p/+u/5n/rf+x/7//1P+1/8//pf+7/7n/2P+1/97/pv/g/7D/6/91/8P/of/y/2n/zf8fAIQA8v9jABQAfgAxAIoAOwCLAF4AsAAZAGkAqAD3AFwApgB7ALIAhgCtAJwAvACaALEAoQC0AL0AwgB8AHkAnwCXAKQAoQCPAIIAgABrAHEAQwBEABAAVgAgAFQADgBlAA4AQgDd/9b/Zv/E/0n/n/8p/5X/K/9n/w//Uv8C/y3/3P48/+P+If/C/hX/u/4Q/77+9f6j/g7/xf7b/pv+Iv/p/uT+uv7r/tH+4f7Z/uv+5f7y/u3+3/7w/jj/Tv/B/tn+Ev8p/wv/Lf8B/yb/Sf+F/6z/7v+R/9j/qf/p/xQARQD+/y8A/P87ABsAZQApAHYAKgBzAE8AlgBAAHkAbgCuAE4AjQCbAOIAiADDAJ0AzwCvANsAkwDCAL0A6ACMAJoA6gDbAKkAmADBAKAAwgCTAM4AlgC4AHUALQDh/4wAMgAoAM3/MQDi/zkA5/86ANT/KQDD/yoAx/8oAMb/7v+Q/zEA3/8MAMX/+P+///v/yP8AANr/5f/Y//f/8P8PAA8A0P/V//D/BQD5/yAA6P8ZAOv/JQD1/zsAyP8oAPz/cwA2AL0AWQDsAEIA0QBbAN8AWQDSAFEAyQBfANoAMQCwAJQAEwEbAJsAcADlAGQAzgBoAMcAaQDQAGUAwACDAMwATACEAKIAwwB/AJIAdQBzAIYAZQCUAGQAdAA/AHMAOACJAEEAQgDv//z/n//1/5//2f+I/67/Zv+0/2//kv9B/4r/K/+D/yL/jf8p/1r/9P5X//3+Qv/5/iH/6P40//z+Df/Z/jT/+v77/sr+Df/m/hX/9P4Z/wf/Df8b/wn/H/9P/3b/4f4R/2P/nv9p/7L/hv/f/7//EwDW/yMAAABHAPr/PgBfAJYACQBAAEoAggBiAJ4AXwCoAHUAugCLANEAhQDOAI8A3QCxAPQAwwAHAasA5wDIAPMA0ADjALsAvQDkANMAsACbAO0A1gClAHkAuwB2AJEANwCBABAAXADp/z8Ayv9KANT/CACK/zMAuP8XAJX/BwCB/+z/Xf/p/2P/3f9e/6v/Mv/0/3v/pf8t/6z/Nf+9/0P/tv9D/5b/Nf+Y/1L/qv94/2D/P/+h/5D/jP+E/3X/hP+x/8v/tv/i/7z/8v/2/ykA+v8rABUARwAEAC4ACQA+APj/OgAFAFEADwBkAPL/SwBGAJsA4P83AEsAngAhAHIAIQB5ACYAeQAXAGYARAB+AAMAOABqAJMAJAA0AD0AQQBLAEMAPgA0APv/4/8dAPX/AADn/7T/nP/O/73/zf+9/6H/kP+T/4X/sP+j/3n/dv+I/3//kf+O/4T/ff9p/2T/ef9x/3b/cP9u/2T/e/9w/2//cP9o/3v/Vv9//3b/q/9h/6f/a//B/3L/y/+8/ygA9f9qALb/MQBaAM8AIwCMAFMAxwB6AOIAjgDsAKsAAQGkAPAABwFIAZ0A1wAMATwBCAExAQoBKAEaATQBIQE3ASIBNwEaASUBQgFKATQBIQEXAfoANgEOASIB6AAPAcIAPQHdAL8AVgDXAGQAlwAfAKEAJwBIAM3/PwDC/zgAw//x/5T//P+g/8f/df/l/5X/q/9Z/57/UP+a/0T/lv88/33/Kf9u/xX/Yf8S/wj/w/4+/wn/IP8B/xP/C/8B/wP/Ev8h/wX/G//5/hf/j/+y/zv/av9+/7P/k//C/5P/zf+V/8z/ov/f/8P///+P/9P/tv/s/9n/EADH//j/5/8OAPT/EADg//f/DQAqAMf/7f8sAFAA3f/y//T/8v/y/9v/5v/H/wYA5v/T/5//IgDi/33/N/99/0X/if9Y/1//PP9O/zv/P/8w/07/Rv8s/zX/V/9q/1f/dv9I/2L/XP99/13/gP9K/3P/c/+o/2r/m/9a/4v/cP+q/4H/w/+O/9z/mv/y/7r/EQCv/wQAx/8aAPf/TABKAKQATACkAGMAsQCAANAAiwDXAJQA5gCeAOoA0gAJAZgAvwDvAA4B5gD/AAMBCgELAQoBFQENASsBKAHrAOUAVgFLAQ0B8wAYAfMAEwHhABMBxwANAbIA9ACWAAcBoQCJACEArgBEAG4ABwA2AM//NADM/yYAxP/q/4n///+i/+j/ff/o/4H/sP9b/6f/Uv+S/0z/a/8s/4b/R/9Q/yP/Wv85/y3/EP9A/zP/Uv9H/0L/Qv9N/1r/S/9f/13/c/+J/6L/uP/X/6z/0f/g//3/6f8JAPL/EgD2/w4ACwAsACYARwDp/xIANABYACgASQA7AGUAQABvAFAAegBWAIcAUgCDAIEArABiAIIAZQB8AF8AcABVAGEAYQBlAEsATwAcAB4AFwAYAO//9f8EAAoA2//e/9X/0P/j/9P/zP+u/+X/y/+k/43/8P/U/73/pP+0/5z/u/+l/6v/if+s/4n/oP+J/7D/of+N/4n/pf+t/6//vf+r/7//wv/X//P/EAAEACsALABPAFAAbgBQAGQAcACAAG4AgQCDAJUAdgCJAI0ApACAAJoAhACZAI4AnwCHAJYAngCvAJMAqwCbALwAlwCmAIAAgQBsAF8AgABvAFgAQQBVADwAPwAkAPb/2//L/6b/wf+Y/7j/nP9b/1P/e/9x/2H/Vf9b/0X/V/9A/1T/Nv9L/yr/Lf8X/1j/P/88/yf/P/8r/0D/Kv8p/xj/MP8l/1T/Uf9K/0b/SP9J/0r/Uf9X/2P/bv+G/8j/7P/I/+//0v/4/xcALwAcACkAPgBJAE0AWgA4AEYAUgBkAEMAXABYAG4AewCPAIUAmgB2AI0AjgCjAIwAqwCSAJ4ApgCiAJkAkQCSAIwAiwCLAK4AqACHAIgATgBLACgAIAAbABQA+//8/+z/+v/d/+z/vP/K/87/3P+u/77/xf/R/73/yv+1/8z/rv/A/7H/yP+o/8L/sP/H/7T/yP+6/9T/pv/L/73/2v+4/9D/uf/D/97/4f/k/+n/OwA4AEIAOQBVAEMAfQBfAHgATACGAFMAigBUAKEAbACdAGkAlgBgAKkAdQCKAFsAkwBkAJ8AcwCWAGsAiABgAJcAZACKAEoAjQBNAJIASQCSAE0AfgA/AGsAOAAkAAAAFADs/yAAAgDL/77/w//K/6b/s/+i/6n/kv+d/4D/kv9v/4j/Vv94/1//h/9J/3v/Vf+L/1f/jP9Q/4X/U/+N/2H/nP9a/5b/bf+k/3L/pv93/7T/jP/I/+D/EgDe/wQA6/8MABYAKgAnADoANABFAF0AZgBrAG0AbQBxAI0AjgCZAI8AlgCTAK4ArAClAJwAhwCIAJYAjACSAIcAigBrAIsAcQCSAHEAawBSAI4AcABuAFUAJgAPACAADAAVAA0A7//w/9v/5//Z/9//qf+u/6//rf+C/3v/gf9x/3//bf9W/0f/P/84/0r/Tv8y/zT/H/8p/0L/SP83/0j/Lf84/0b/SP9E/z7/Nv82/2z/a/+T/5P/hf+G/5n/lP/M/7T/wf+p/9P/xP/p/9j/6v/S/wUA9v8dAB4AMgAtAEQAOQBWAEcAXABMAGEAUwBsAGMAXQBHAF4AQgBLAC8AUQAzAE4APgBPAEUARQAxAO//5f8SAA0A5f/s//D/DAD1/yEA0f/7/9L/8//R//T/wv/i/8f/5P+8/9f/lf+y/57/vf+a/7//g/+s/4j/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xP/G/8j/+P/2/+b/4//X/9X/3f/b/+L/3v/e/+L/7f/z/+3/9P/m/+r/4P/k/wEABQD0//b/9v/6//T/+//r//T/7P/5//f/AQATABwA4f/q/+X/7f/4//z/BAAJAAIAAwALAAgABQD4//P/4v8AAPD/BAD0//z/7P/3/+7////0//v/7v8HAPr/GAAAABkA//8RAPj/IQADADkAHgA2ABQAQQAeADYADwAwAAwAKwAQADgAJQA5ACcAOAAmAD8AMAA0ACwALgAoAD0ANgA+ADoAIQAgACgALAAeACsAFAAkAAAADwABABcA7/8JAN//+f/+/xIA7f8FAOz/+f/w//b/5//v/9n/5v/e/+j/8f/7/9//7P/c/+j/3v/p/+H/4//i/+L/6f/u//b/+f/v//H/7//q/wUAAADw/+v/9f/v//7//P/x//b/BQANAA8AFwAfACQADQASABsAHgAcAB8AGAAhACMAKQAkACwAHAAjAAUADAAFABAABAAOAP//DwD8/wsAAgAPAPb/BQAFAAoADgASAAEABQD//wIA//8AAP//AgD///z/BwADAAIA+//3/+3/+v/y//z/+P8OAAYAAwD6/wsA//8DAPn/BwD6/woA+v8RAAUAAgD3/w0AAgAGAAMACQACAA0ACgALAAYABAAEAPX/+P8FAAkA+v8BAP3/AgDy//r/6v/x/+f/7P/q//D/9f/6/+n/7P/v//T/7f/v/+7/6f/q/+z/8v/w/+j/5f/g/9n/6v/k//n/7v/z/+r/+v/t////7//7/+v/DgD9/xQACAAaAA0AFAAIAB8ADgAaAAsAFgANACAAFwAeABMAFwAOABMACwAfABgAFQAQABUAFAAYABcAEwATAAkADwAPABYADQAaAAAADQACAA0A/P8LAPj/BwD4/wkA+/8LAO/////i//D/7P/6/+X/9v/l//L/5P/y/+X/7v/f/+j/5v/t//D/8//v//D/7P/s//X/9P/y//H/8v/z//n/+//4//n/8P/0//D/8f/9//3/9v/3//f/+P/7//n/+f/3//n/+P/+//3/BAACAPT/9//5//j//P/7//f/9f/6//r//v/+//j/+f/2//P/+P/2//v/+P/+//f/+//6//v/+P/6//j//f/8/wMA//8CAP//AAD9/wUA/f8LAAMACAABAA4ABAAQAAUACQACAAoAAwAQAAoADAAHAAwADAAPAAgADQAHABAACQATAA4AEQAQAAoACwAPAA0ADAANAAoACgAEAAgACAAIAAEABQD7//3///8GAP//AQD8//7//f////v//f/4//z//P/9//7////5//v/+v/8//z//f/6//v//P/8//3//f/+/////f////7/+///////AgD//wEA//8CAAAA/v8AAAIAAQADAAIABQAGAAIABQAEAAYABQAFAAQABAAFAAcABgAHAAUABgACAAMABwAEAAQABQAFAAQAAgADAAMAAQABAAQAAwAEAAEAAwACAAMAAgACAAAAAgABAAIAAQABAAEAAgABAAEAAAABAAAAAQABAAEAAgACAAAAAQABAAAA//8BAA"},{ name : "R_sounds__throw_mp3", data : "//PkZAAf4eTCBGT5pYAAA0gAAAAAQnogJAT4IKRRRHaRCWdluBACAowQUhqknYf/K7K3HQELFXuFSwKYcgRkEQwXQMFMwQjYCMmExyDcEMJowAwNOjw1hDQKipFF6FoQ7P//Tv//lRsEjpsqSsVvhV6IS2LtIZSjmyiGGWKVs6Wo+lLbzrxumnLkBNZSvYBAt+A4tAjI1KgggKiqXL0XgraEDrTk+88//69JvPXJXfpZ94GcpXsAituV38/////////////////xtyiW3y+4XANgQy5zLKOQgCGK5efD/////////////m41ArMVAggwKgtCsug/LrqqI2gZcCGFtQUuBDCzoGbAp5bIFMFz2hUUQvakTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVC9S017PLRY7EGYGJgdBL9gIBOXTV+DCGgDatbXepo9K/wY47MS5AI1X2jK82nM6wMtzqBiJhCZ0m4ygqD6scUL/ukjwW0Lpy6WOguxyGuSmJIB2TvAWwSQZGwefqW4mu9nb9wF2niWWV5PwEsE+lz8UDaqVUcghCVVcB6K+AmD8LgvDgT5KDQRikcXxK//PkZI0rBg7yFGH4yAAAA0gAAAAAB6DwLedwKQLsGeAVo5kmP9VLkpC5nOPsWMW85i8YuSAQw8CRhI1UrHkeiIHoWU+nyVmO0spziTiZvng+C8KxeCGDEb51OzK0C4DcE0JY/juQWo0AgGMYKOkOXjeacwZGpfVuu279MvgHErR/GVImJ0JeIoQ6/fwG87kTLts7a2xN6Ei1HkFKXONuGkOX/RIWOl+54WAAiLUlrluI4CREQc1McgEAoJ0KZtehDAFiQJDbYGzLouzambB4kXUT4yZ3Lp2G3bZ3J4YllSwqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqpANHiSoM7FjWaAw8LNLLjHSoMMxAVEhWCi4uwMlBhYiBkeOFRkBgoYGiGHN5kYMIQ8OjDOiYxg/ErIQjiwJ2ztqFVjLoNqQCwmeIKMio48OITDalQ9DnwpQYoil6Eg0RxAKCpDbTDC4fBBRnEQA8TwqojEh8MiSAYuXsLjla4KIQqQQMIFwE3GaNSQRP2kc0hTkOHUsaGgCSCGRpWsIpuNDrrh1hqGiUbUAcGmko+xhgUiUgXcijNa8ZbknwpgmIjhkgnZ0OioPoc1yIgCMZ3V3JHMJX2RALWgF3i+BZWJO2l+mPD6cWoS//PkZOg2ZhDwBK3kAQAAA0gBQAAAnIBhlgmwqwp+I+iAwQliEwQGF2kq1Tj3rog54YHCxoCHGCUfGxxlAaADyEktqWyEnBmAxAUJ5FqaSKA5FNqLO60aWAAhqPDK0Vxa4tsFx1kETplKPClwAqADCGWGkGHIjooYA2NUwyIxB6QEEZZRCGmIDhT1ahIl0CA1VlsBh4YwOhmAwFh1mBYIMEL2KFmEABkjHXRAAzBGCjszgQYQMBkSoewQAHj26NELC7ZfBIteqY5ZhCsyjUBKrWDpAgpBmyO5QCAi0NWVNf1VTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVQAMAALATUI0E06gEhcwoLEhURjACMRGFoEC/ZZESFiyQkLmFDIBnCZ0xSYsgYoWZhMADJmRYBanAMiIyIhQAMGYTFgUAi5YFiWsvoIjACmlki/RWLATJsxZJAmX3AAsv0Bi6E1doCL9Xau0vuVi2yFkUCDZy+7ZECICKIFpsrsFijZS+nrtL6LubMgSbKJFfQIruXYgRXagW9LDiya7F3Pb6BBsntkXeWQXegTQJF+0CPrvXa2Yvq2cv2X5WIhObIlKxB8i/LZ13F+fLJF+i+67y/IBFtlL6tmbO2Vsi7l3NnQmtlQm//PkZOY2Ohb4AM3oAAAAA0gBgAAANlL8rubO2Rs6bK73qbEzBYhflKYvuWTEigkXKxRfYBFyyRfgRCi+i7F3iJoYsyARRfYBFF2LuEYpAkJFRIu2cskX4QJFkSwmAAszAsrFIEl2Fk13owCIyhS9z0iooBaQCKQoATErMLsL8oEUCflkRGKARZAkABSBFAkgQbIYswX0AAoxQpdn/5mTIkzEp5fRs/gIoX3QJiMwX7bKWSApkRmECZfoBFRIt/+Iha7SgsYoWWkL6ITygwYoaKGV0lYtAmw0oKlkjGjSzRZpNcYEEA/zCls5dvML0zRh/2dhUeMLHzIC8sCL4vmZ+vhz+Bi0CC//5jQfGPhEmKYXCxacwsf2cPi+fmbT6ZtJ4cQzF4vMWnQxaLCsW////hgzTEMjGIzERhoQeWBaYtOhnVfGvzozhnLO0k/80amzTZPMIC44OuzPo/Di/5YbBtlsGXmyZeL5l4vtXat7V/auqcwiNTSKRARaN/uM1GBzOhiMtj4sF7ywXzLzZMvF4y+XjLzZao1ZqzV///8y8IDF4vOaOg00TjEIhNNIw0YbDHwAM+Iwy8XzLzZMvl4y+XywXzL5e8y+2P//9NlNlAotIWk9NnzRheKwgYRF5WLz//PkZP85hhUutM3wAAAAA0gBgAAAJxOM2hAy8IDRqNO5Iw0bBzVYRM+k//8sLPzWSzK1l5YWRrNZFay/////02C0n////gYXgYXm/owbkPwEC4GFhhYLmfzKb+MgFJYGMYGFhjAyGZBgYWMgGZBrJZlayLCyLCzNZLIsLI1msv8sLM1ks/8rWf///////////////4GF5n8/mZQsZ+GBn8/mSwv5phMGmDIZLMpzI/AQYlgLAazGflkbMMhrMlpsmFwv/+WFmazWRWszWSz/ywsywsitZ/5rNZGs1l5Wsv8rWSpMQU1FMy4xMDCqqqqqqqqqqqqqqqo4sMpYZDkDsIZwqFBAs+JcoFBzkIQuSWpXaX5EACIAEOAVTtWEACIAEOAA4DLAAHAIgAWds4URSPSRfJRtRtFUyylOfUa8xRDFEKxTFE8xBCsUrPLBx9nGed5YO8zjys4sCeVi+WBPMQUxBTEnLAhiClg//LB3lZxWeZ5xYOM84zzjPOKzyweVn+Z55YOKzyweVnf5YP//LBxWeZ5xn9GceZx5WcWDis8sHmcefR5nHlZ5WcWDzOO8zuz67M7szjyvssHGcf5YO//M44sHFZ5nnf/lg8sHmceffR99H2cffRn9H2cZ/R9n//PkZOg2eg0eUO3kAAAAA0gBwAAAH2d5Wd5YPKzys4zzjP6Pvozjywf5nnlg8zjys4zjzPOKzywcWDys4zjzPPLBxYPPs7ywcZ55YPKziwf5Wd/lZxYOM48rPKziweZx5nHmeeZ3RY7M84r6Kz/LB/lg8sHlZ5Y6LB599Fg4rPLBxnHljs+jz67LB5YOM84zzis/zPOM87/M84zjjPPM84rPLBx99H30fZxYOM88sHn0f5nHn12fXZnHmceZx5WcWDjO7Po8zuzOOKzvM48zjys7yweZx5nHmcf/mceVnFg6TEFNRTMuMTAwqqoyy/N0dCssLA8YWPoqI/FgCIQJFUIFDCgosBRhQUFAotIWBctKVhxnQeVhxhweY2NeVjRqQ35hwcZ0HmHh5WH+YeHpslYsWl9NgtIBBcsJysKYROVhTChDCp/LAU3Q8sDjHjiwOMeOMcPMePLA4xw4zRosGjNGis2WDZWbM0aLFIrNFg0ZqkWFhWsNYsNYsNb1LHU1iw1iwrWlhYaxaa1aVrf//NYsLC0sLDWLDWLSwtK1pYWmtWFhaVrfK1hYWGtWFhYWFpWsLC01nQr6eaxYWFnn0WmsWeWFhrFhYWljqa1aWFh9Fn+VrPNatK1vla0rWmt6//PkZPQ4Ag0MAG9ZngAAA0gAAAAAFhb5WtK1hrFprehYWFhYWFpYWlfQ1q01qwrWGtWFa0sdSwtK1hYWljoa1Ya1aWFvlawrWFa0sLfNasLC01i0r6GtWedtpYt8rtOy07bTttK7SxaWLPK7CuwrsLFpYtO2wrtK7SxZ522li3zssK7fK7Dst8rtLFpYs87LSuw7bPLFnli0sWeV2FdpXYWLCxb52W+V2FdhYtK7TssO2wrtOy3yuzyu3ztsO2wsW+WLSxadtnldv+WLCu3zssK7P//87LCxb//5Xb/ldpYtTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqosE811JiwTzO52MjkYyOFDAJYMdgAsAAsCPzEQiMqi4rF5ggXmRgoVkcwqFDG42NEIksDY0SiDN76M3m4sG8zc+zfT7Ndk4ycTzXS7MnE8sE7ysbmNhuY2G5jdEFY3Mbjfywn+WE4sJxYTywnGnpxp90aenf/mnpxp90addmnJ5pyebc3m3N/+WG429u/zb24rb/LDcVt5t7f/lhvNubzbvs/r7P6b/K242/6Nubzbvs277Nub/LDd5Ybj+2425v//NvbvK24sNxW3lbcVt3m3txt7cbf9G3/Rt7d/lbcWG429uK28//PkZOU2Hgj6AHN0ngAAA0gAAAAAsNxt7cbf9eVt5tzd5Ybzbm//Nvbjb24sN/lbcVtxt7cbe3m3N5W3ebe3G3/Rt7cVt5t7cbe3G3txYbj+/o25vLDebc3m3N///lhvK2/yw3eWG429uNvbv8sNxt7cVt5W3hHeB7t4M3BHeEdwM3BHeB7t/A9+4Gb4R3cI78GboHv3YM38Gb4M3gzfBm78Gb8Gbv+DNwHv3Ae/dCO+B79wHv3BHdBm7A928GbgPdvhHdCO4I7oR3QjuBm/wZuhHcEdwR3Ae/cDN4R3Ae/dTEFNRTMuMTAwVTXVDEryteZXuWCplI6AYrIGmIGWDJjhYODkQMIoByteYkQYkQaPEVoytGaJEVxzjRzjFTjlTKlfK04rTitOLCcaenFhHMUFCsULAqYoKFgU8xQUKxQ0cUK0YxRH8sChigqZsblZsVm5YNiuJKzczc2M3Nis38sG5YNywblZuWDYrNjNzczc2M3NjNjcrbiw3lbd5W3eVtxW3+VtxtzeVtxW3Fhv/zb24rbvNub/Nubyw3lbcbc3lhuK282/6NubytuNubytuK2425v829uNvbitvNvbyw3m3t3lhvNubyw3FhuK2//K28sN5Ybytu8rbzb27ytv//PkZPU4Ggb2AK1sAAAAA0gBQAAANvbjb24sN5tzeVtxW3eVt/m3t3lhvK27yw3G3t5Yb/LDcWG7yw3lhvNvbiw3Fbf5W3Fbf//5Ybyw3lhv8rbituLDcWG829vLDf5W3f//5W3lhvLDf/+Vt3+Vt/////+be3lhu//LDeWG8sN5Ybzbm/ytvK28sN3lbf/lhvNubvNvbiw3+Vt3lhuK27/825vK2425u/yw3FhvK24sN5YbytuNubyw3FhuLDcbe3+bc3lbcWG425vLDf5YbitvLDeVt/+be3m3N/lhuK29TEFNRVVVFvkjwFgaEYXQMdAwAfNVQADFqkq0q0qFGkVnKQYL8NKBgwODDRAwQkWGiw8yR4teWuMSCYEYYyYYNBqYgjGmHDKSkzls3cmDEAyPQgBp6MDg993LT3fdqwNDKHCQxKhAKWuSQLAdIwWGipMwxNAPJmkqHJUFrwUMSNfFI/0kkjw4EYEiqUQACwvMgANAA9UpgABkCAcgLAE3xAILlgUYsWYs+EFywKM+LM+fKzxaUDLUCjLFwMs8tOBlqBXpslpSssWC6bJaYsMTLlgqfCC4UFIqKcqcBQUisFTyKgVFGLFlgugUBl/psoFAZaWmAy7y05acrLpspsoF//PkZPk4ihcIAMzoAAAAA0gBgAAAlpwNiAy1AvywXQKLSgQsWkQKLTFgsWCwGWAZaVlysuWkLTmXLFpECy0hxghYCFYU0wUsBStOVhDChSsJ5WFMInKwhYCFgKVhQKwQLAhYtOWkAy1NgtIWl8ClwKXAjBNkCljLMS0nlZYtKWkKyybBWXTZTZKy4ELegUBSwELlpECysv/+gUZYuBl6bBaVAoDLC0ibHmWLlp0CywXLTJsgQuZdgBln/5WFKwphQhYCFYUsJisKadOVhDCBCwEKwhWnMKmMKELATzCBCwFVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVRJAYuMIAyFDUsQDTap2RgJVdzlKrLubJ6ZUlVLB8GKlHQYclk44DLkoYiAmYIlB5gkA0HcksEhwUhohvAaWi2WXgo8ZocCra/jADkyZM/skHRT+tUZO/vmsHOq6woOMAaDDi7ECABFLtXaX5f1MxNt/2TKnL8mLTnBTiZwBFzMmSwnQDKMlgiDSBpyANIAwiokgGUSQCIBf804oBaDazzn3TTij7pwEXLIH3umuXnUqmJEFgSa6qYhea5ea5eWBPlgT5WIKxJWJ//MXAO4mMWLNqLOBAE65mBRmDBimhphSBEAJzECS//PkZOY2KhESxMzoAAAAA0gBgAAAwILAk1y81y8sLzECTECTErjEiDEiCwIUTUSUSQDAwgowowoyon6iSjIkyLJgKYWDAlNMUKL8l+y/TZiyZfcxRgsggTMWZ//LAgsCPKxBYE/5iBJYEGJEGvXFgSYheomowokokon/qMf5YIIBVElGP8HIzIJiwRN6RNM8NMQMinK6hvU5kU4MImnemnIg0ib16aciZF6acigH//NFjNGiNGiNGi8sIitGWEXlhGWERWj//NEj80SM0SP//ywI/ywI///ysT/lgSWBJWIVTEESQD0xnICCKdKeU96t6towODXKUaUactWByPU4GhhXIYJK5dMEAKSSZipWSJmjQINA6nCsAwGKxwarCyFqipkNEznWLkKIK7QU+DHIViU4TL9qz+slaumKYODGmFBrhQaadmUJiYqYiYyngsLBgeVg6nQYHep9TyYhgCwY6dmOLBnawY4AmOgJjg4VjpYATAQAsAHmAgHlYCWBwwEcKwAzsBLA6Y6AGdDhgA4YqKmjIxiqMVinlgULAqYqKFgV8xQVKxUrFCsVMVFCsV8xVGMAASsdLA6YCOFgAMcADAQEsAJYASwdFY4Vjho4qaMjGKoxijuVo5o6OWEYsI5o//PkZP05DgcOFMxsAAAAA0gBgAAAzuaOjHUIx1Ap/+ZubFg3/ys38rNjNzbywAmAgJjo6YAAeWAEsAHmAgJgAAYAAlgALACVgJWdmAABxMScREFiILESWDb/LBuWDczc2K4griD3Tc9yIM2iDid3ywbf////5m5t/lg2LBsVm5WAmOgPmAAJgICVjpWAFgAMAAPMdATAAEwEBKzsrHDAQEwEB8wAA//LEQcSbGbG5m5uWIkzc2OINiuIOJNz3Ig4iIOJ3TiIg4ncM2iSs3KzczY2//8sG///+Zubf5YNiwbKTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqBhLqAwIsDU+WDLsXfBynKn1PBjPL6NnVO1dq6Z3sgaqYsWX7bKp9MVMaDlY1Y4PDBqY4YPKwxihZYFrsbMyJ/mqydkiGjVkN0N2rqNKxQYrEYMEp71OvDBqnZixZixZfov2gTL7lgOp4w5YMGpihg5MYMG+FwynaYynl3iMWWTbOgRXegQUTQCGRIIBVGEAyAVs7Zl2LsLIl+13ruEiyY6nRhy5qS5uw5ugxhiynRqC3mVjGUK+WIxlCpxo5xo/qMoBlEvUSUZQDIBgcjQDIBvDBiY5hy5qVJqQ5liyn//PkZN41LhcQcMxoAAAAA0gBgAAASnaYgXLmHDmWDFgoZWMZSOcYqZWMZSOZQqZQr5lCpYKGUj+WCCiSiXqMKMoBlGFE1E/UTUT/zAgTOgTdHDAASsCVgDAuzOgTsOjOAPLAEzp0rAmcAGAAmiRlaI0SM8SMsIjRYzxYytEaJGWEflhH5o8RosZ4sfqJ/6jP+ol6jPqMf6AdRNRlRn//wcjOomNMQByDzIkVGQcgQDg5GZBMDkHg5Aowox/qJ//muEmIXmuEmIE+YgSYlcYhea5eViCwJMQJNcJ//8xAkrEVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQSQVOYhJlv76q/ruVw6SpH/auyBXCnmrJmL/LlILJmJksjbMrEEC0NENkMkynzdRfrqmTFploajwZN6NOirl14CcuDWXpzMpZVTMrpfiKqcWSDZ0hohgCRY8lTITNMEDMENcsaCwaMl3WjTqq2vg6YsDL9CIU2Rsy712F+wqCCAzkqNOWNBhoOqu5aqyq6sKsDkDQUIDlky+pZNAkX6EYovquwv2gGQCG8IKJlacHe0AgOmA6Y5aqrkqNKNKNfBjlQeisqsWQL6rsL9IEGzF+0CR//PkZNIzwhcMIMxoAAAAA0gBgAAAfpdxZAsggHUZUZQCg5GWCKAZAIZBMowadOetOp0p5MdTynlO0xVOwsGTGDB6nQYNU8Vh/U7CwYMGhg9MRMcLBlOwwaGDgwYYYMVlkxkxAsGLBA0yY3hAGkTTkQdPUSUSKyIMIA6YdQgZF6ZEib0iZBMmMp2Vh1O1PpiKdpiJihYN4YNU8mKp4sB0xf//9AKgH8rIIB/UTByBRNAIon6ARRL1E1E0A6jP/6AQ3iZAOVkQaRBpFAMadODSCAQyBBRPwcjMgQKyAMIIBwciV5aZMjTUAJGxgM7WJ8G4BHCbMprNoV8XIRQDOdJvEQFESWRtnilEqSVVmCg6LJ2JVFym8YeQglanjZCo5Gm/1/5KM6pLDutnjW6HaHefUXXIr7rZnPRdbsVCm0CEjFAa+l0JfxVYQEgC6IKCMsYGqoNBg5CSCQgUCh4KEiEIBACxAMPBAAvoFwg6vDB4CymbEAIcZ0sZYaYguvUCA2Fo9JPiRIKDH3NAGBIkKCBEeJApiyBmxQIInDMGrTGcJA4mAkRmUppGjDTKlDHlSoYMxpFagsgNCfNKNNChAQI3RIwaoaQmjGkK8EFDKOjViDOFjMjzDjTPEjaiQuDM+0Bw//PkZP86GhkY0MfoAAAAA0gBgAAA8yR8sSjCmAsjNOyNEpMOXJlBpyAjLFt0iBEOMWYMkpESM2QM4KI26g0IlIQzKkqrTOljmCDUgjMKAKTDvpmwYq2N+BNQ+MwJCAoGFmnNF+RgQmGWcCCACLNKJTiZ8OKpGIKmZUAEcX9EmJrm6EBnw6VSFiFBiygOJGeLkAMygsgABUUENwEBCw2Fc//RvN+7MAoLmFYokUg0KZMepaZgQFSiA8MBojl8jIADLjKbD/8xgUcFiwkMPDxZFoZHtzMcMBw5EEdIDIUCFVAF0hiWRybFTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVEazvNIlJL1I33mELZWLDWfqnXaZXScaVehCqRCkZ4vGnnaFz4zyGKszVsVMbuVD8Z+5T3vv0t+nicUl0xGZHyHm+htQmHpdKYy3B8H+hb7uzPfMv83rdGXMqXbAcZn3HZU0prL/UTtQzDxdphzTn//PkZG8nSgkUUOfgAQAAA0gBwAAAhWEa7FUFV2pbMPXI8zAVBVjtwKEL1f5vU+pU2CwXuhpY5duLoDWUwG20wzFTdQNtdt2WQz9MSHVZXBa8jat94W5ETlJI1w2xJm4YZ9Vuv6mQiUyJs6Y0OyhIV4YoBhJvxFFZxW5I3qTuJ+Sl0llOLik7TTSzFLWKUyqrtxqPNdZ+05YsvZO/sceZ3Vit6xFTFcsRlLAHCWDmWjz8xI391ZcuISOONep3AZVHq8ArLWLD8QgF93dgp2Y040pl1pxn5qRF1GVNCbG5ntgVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/E3AWAlAdhppoYgrUNQ8fJNSbCKAVyfhrk5Ps+j6CUHyEkCTkemTRI8YRpD2NEYaaTYxCOQ9DCxr5sj1oeh5pplNdMpnpsYJaCblryzE1/LQtAFA+D6J//PkZFckWg0IAD559gAAA0gAAAAAyTonZOycnyfPPs+z5//LITYTUsyz/LMTYtC1LP8Lb/8LcAjC3C3/C3CjAI+FEAQBFwG9/8GPgx0GOgbnYG50De8GP4M3+EdgzYR1A9aBm4M2DNAzYR1COgZrhF+EXQY+DHcIuA3OwNzgi/+EXgx/8IvBj+Bvf4G52EXwNzgi6BucBucDHBF4MfBjoG94G5wG54G94MeDHBFwMcZ/ZnnmccWDys8rOLBxnHFg//M88rPM44zjis4zzzPP8zjjPP8zjjOOLB5nn/5nHFg5TEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV8sGKzmtbZS+6qynI0VXTp0UmZIoj6qkGKMKMqJoBCwZMcLmDGhY5fVspftAmu5sj/NXf+Tsmf5qnsgkjIpMyeSv42ZAk2Zs7ZGztnbJ6nX+p0p0p0p0p2p2p//PkZFoktgcEAGMTngAAA0gAAAAA5MVMRTtT3qdJjpjf6nXqeU+oyox/oBUAyiaAb1GVEkAqAYGRQCqMf/+VgKwlYDCAwg8+8MIDB0rB5gCYAFjp8AV1OtDrUsUK6+daeWKFdf/yup0r50qWKFip1odKlihYqWKHWnnWn+dKlihYr51p51oV18rodaedaFdf8sV860OtCuoHWn8I1BlAjX//gygHWgHWmEaBGv4Rr4MqEagdKgykGVgdafgyoMrgdKgdK4HWkI08DrQI1gdK4MpA60A60CNcDpUDpXBlYHSqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqCCBRNRlAMAmBYFlhMNGoNRW9MVTwYN9T6sYVBoqeGDFOwsWXeARRfddxflMRMUy00LOissVhlG4OUbU5cqDFV4PRWg+DIP/3LLAKD4Og5y4Pg1y3IFzSFH8hIdCP5CCLRFhcwuYhRc4/xcsf+JWJoJqJWJpE0iahiqGKwxUJXDFODA4RD4MB8IgAwBAwBCIAMIQiAGBAwhCIYRCDABEIRADAwiHhEMGABgIRBBgAMAcIhCIMGABgQMIAMIMIhBnA//PkZMAiogkAcGpwuh2r5P2eKkvAiCBgAEQAwAMDCIAiEGABhBiEQGHCKESEQIoRIRQiAwwYQigxCKEUGPBjwiYRIRQiYRAYwigwwY+DAIgRMIgRAYAa4MODAGPAxhECKDGEWET8GEIgMQhAoSKjcjfyB8eHJJ8nJzvuHCncBAId//qd/JqepiPO5Ooor/qdG+////uahIXNzk4RmxQyjnc5+hSh8Xb7qHxeeEwOr68h3v+utrUDhQ+6mRTnfSIAcSFQHHxACCABu04QAizviAod/u8hBMDjBRa9A4U/86ClTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV8LdmuuASy/DZTQQQDA6IvyWTL6KNOQpyDoFEkA6AYrQUTNBAsmWQXb67yscLLKdBYdTynkCZfovy2dsrZ/Vig73I9yVYHLVjg6D4Og1RpyVYvU5/3Kcr/Ub+D1OX+f6TyZkknk//JH89//bOu9shfRs/rvXf7Z12rtbMX6bKDHgwCJCJBjhFCJwYgxCIEUGIMPAwhFBgBh4RQiAYBFhFwihFCLBiEUIgMAYQigaBFgagxCIDAIvwiAwARDAwhBgIRCDA8IgBgIGAARAEQwiDAwAC//PkZNIjHgT+AGYT5CFD5RQ0Odc8IQiAIgAwBCIQiHCPAiAGAhEIMCBhAEQAwHAwh+DAQMIeDAAYAgwAGEOBhCEQQiD4GEIGAIGAIRBBgYGEMDCHhEIRB+EQhEBBWr4acobCArOFmONMua6nncmWYTAsFL//mnv6EI6X0G6uVDe2XEg/7SoT7bvV/o3Ew7BYk8DQSUCZJ1ffU+LC91PSZIjPYASp73dPo2e092d9+YCSKhn8Qz41QdpkUhqMCDx0GcMyIO1nvvIhNid9wzcxlUYhvMV8PzAQEf/1kQyoy+0gEQWAhYTGnCHGCGFTGFTByA0AArAhQUpyFRSKqKgQUCFQqWWCzXwLSGsua65WKYkxzimKKWBDFmOYQxJjFFKxSwL4cGIARCAHQtWVMqRUxWAqRqvtVVOVgtUaoqRqjVFTtXas1dqnqkVOqcOBDgmrtWVNEUEVxFxFBFBFRFoi8LhRFoi0RURURQRYRURWIrEU/4RXgaLCKAxQioGigxIGi/wNUCKgxANUA1QIqBosDRQigMQIoBquEf/hH+DOBnAz4R4GcEewZ0I+B94M8GfBnQZ4M4D7vhHwZ3CPQZwM4I9wj4M6DOBngf8EeA/7gzwZ4R8GeB/4R8GdBnAzwj/g//PkZP8logj4VGsyTidL5Slqve7cz4R/A+4I8B/wR4GcB90GeB/wH3BHwZwM6EfCPBHsGfCPcGeEf8GdCPgz4R4D7lWYSCDIvThFS8Bil6wRi8wZF5XBkXk0IxeuDFL2EWu3gxS8Bil7wi12vCLXYEWu0DUvFL3/+EVL0ItdnqUDGu2EWuzwY12bAxrs+EVLwGKXv/BkXn+r//BjXZCLXZwi12AxrthFrt//CLXZ/wi12/CMXp////+DGu3//gxrswY124Ma7YRa7fgxrs/gxrt//wY12/VwZF6/8IxeXsRVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVfLDorHG7dGPHFborTGFjGFCmFClhMYQIgWBS/gUsgUWmMIEMKmMKFMImKwppkxWmKwhWFMePN2PLDs3Y8rHFgcgWWlLSAQsBlybKbBaVNgtKmwmwgX/ptFyUk0jXwfF80kUjmrtVau1cQgVTNVVK1b1ThGhGCICNCIhEBHCICNgW4AHIFsC2BbAtwAOwAPwLUVIARxVFcE5xXBOQAggnAJ0KmKorgnQFgCzAsgWPAtQLAFuAB8C3As+BbwZ0I9+DOBnwj+EfCPwPuCPQZ8D/wP+BngfeEf4R8I/A++DOBnAffwPugff//PkZOYmrgr2AGmyxh775RA0KdV4wZ4M/CPgz4H/hH4M4I+Eegzwj4M4D/+EewZwM4I+EfA++EfA+6B/4H3wP/CPAzgPuhHwj0I/A+8D7gZ4M4I/gzgjwM7CPhHsI/A//hH8GcQlaqAv4DB6oFwkPldnoYbxUeoUAQ1v/zlb1DsRxZYqD5ImBL1Gok7J5QJvnean9B8cg+axxyBCWbX0NUXC2cd8bjDshwAXZHXzdWm9vfE4FV7m7WtKAHIKg2wnFShfEtTRJFRfQXjSjr9jaFALjuh1ReFKpprfEYbbYarVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVfMeOKxwUPhGVTgCljLFi0nmePhBUtImyBC/mmjGEClYU0yY0yY0wVNktKZYugUVljHjjdDiwP8xw8rHgQv/mWL+mwWlAUQH8tBNizAVAR4I/g5Acw2RsA5eDlBzctCyLTllxNQFETUTUJKEoPsnHJyfB8BJgkoSgnR8ctfyyLQtCyLLlkWpZgKgD8JuWhZlqWYI4tCzLUBULMtf+WYmhaFoJp/wtwovwowowogCHhbcKPhRcLYLcAh4BD/hHgZ4R7BnAffA++EfA/8GcB/8GcEeA/+EfwPuCPAfeB/2B/+Ee+DP+DOgfdBn//PkZOklrgr2AGnynCHL5OQMMVOQAf8DPgf8B94M+EehH8D7wZ4H3Qj4M4I9Bngf+EfBnQPuhHwPuA+/A/6B/0GfBnfCPwj0I8EeCPAz8GcDOBnAfdCPfCPBWkUl/202ZNajYqkuduUS2cY7SOHLfP////9cij2reckai1WR2CVotzGf9DDRX/+vwiBYdOxpUOAIqY33eAo43SjgKKyxoAnFSl1KWb6Ohv+/V2KXbGNxlccz+MUR0yRNxKhk4KYNSaKiVLfkYkJLW+tzf7/WFSaH/1L2hg1//kYoYIlNWGq1TEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUBY8KD4QeAWYAxaBi8xIHBAOCBMrECwABxEIRAOAWrmCApgoIYICAUWLTIFAYtAhiWkAgumyWlQLTZLTeWmTYMBAFSNUMBAVTKl9nSRr4ekmkmKAyiIhAFTBwAqVqjV//PkZF8lVgr6ZG2y1AAAA0gAAAAAmr+IQBnLOUk2cPmm0XKZwzl8XwVIqRqrV1SNV9UjVGrqnVK1aCdYJxFSKsVBUisKsE5BOBUFSK8VATvioK4riuKgJyKwR8IiERwj4BvhGhEgG+EcIkA3QDfCIwYmEU4MWDFBiAaKEVwigRQGJBihFQioMSEVgf9CPwjwR8I9wZ0GdCP8GdhH4H/cGcEeBn/wj8GeDOwPv8I8EfBngzoH3+EfhH8D7sDVANUgaoBooMQDVQNEwisDRQioGihFAYoGihFQiuDEgaphFAiiTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqjQy8sRywELB8Ki1GjXgTILjQgUVzFnwqLCCiKoQULTgZeVlkCwMsLSFpisIYRP5WEMKnU4U5MWLU5LAtFdRsrPoqhQWpwiv4UFeisWBSnKnJWKRW5almJqWQm4I4TQsi0LU//PkZGIlwgL4ZGnyqAAAA0gAAAAATbloWpalnyyLQteWfLQTUtBNyz5ZFqWgmomhZFoAp8sxNCzLUtRNy1Af+JqWXE1E1LMtCyE0E15a/lp/xN/4ikRWIrEVC4QLhRFQuG8RQRcRcLhQYmDEwimEVwYoRUIpBigargxQYkGKDFBigfeEfBn4H/wPuA+7gzwjwM4D7gZ3/CPgzgj8GeEeCPcI8EeA/8D7wPuhH8I/wZ2EegzwZ4R7BnBHwjwM4GcB/4H3wNEgxANVhFYGqAaoDEA1SBogMUGIBqsIrCK8IoEUTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq8sLFjArKCrxlvIqorhR4xhzGHFR1ShwapC04GtLTIqhUssFIqFpE2QIuWFkCgNaBVy05aQrXTZZyke+T5s6Tb9UjVGrqnar6pvZw+D4vi+TOffNnC0YM9TuDXJcn0xIOcpaLkLTg7/g6//PkZGkmhgj8AGW41gAAA0gAAAAAD4Ncha8GLU/FaK/FeCdxdF8LWFoC1i4LsXBeF8XMXBfFyFp+ER/gG8Ab/hEBGCP/gWgLIFqAB4CyAB0CwAB0CwBaAtwAPwLUADwAHS0haUtIWlQLLTFpUCgLdApNlAv0C0C0Cy05aTyxZApNjy0/oFpsFpP/02AO1AosXQKLToFlpvQKLSoFFpC0/pspsFpU2S0yBabH+gWWlTZLFy05aRAsDtLFi0vlp/LSJsJs+gUB3+mygWmwmymygUWn/0C0C02UC0Ci0/+mwgVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXzLSjlMALLK5Zl2IQUCCoUFmKFmLFGeFpslpSwXMsWArACFwofLAorFmKFAbCBC5li4GwGWLAZeBsJWXQKMuxArEsFywWTYTZAhdNkrLFYpFQIKorepyioiumymx5actL/gUsgV4QV9ThFb0VlGlOUVVOECi0v+gWmwWl9NksFkCkCi0gGXoFJsoFJsgUsWlTYQL9NhApNj/LStWaqqZqntX9qqplTKmaoqZUvtVVKqZU3oFJsf/+gV/+gUWmTY8tP6bBadAotKgWgV//6BXoF//PkZNAzag7yAGtZrgAAA0gAAAAAoFegWWkAywDLkCkCy0xaRNhNgtOWmAhcsFi0haRAsDLUCwMtAy0yzBNky5ctIWmAy9AotKWkApdNhNktKWlK5QGWlgsBsJlyyBfgZYZcsZYsBCybJYLAZaBcC0pr4HiumyBrC0xaYrXA1hYWAi5acrWQLNbErXA15WsWFgIsWmTYA14EWLTlpQNcWFi0hrrga011i0xaVNkCLFpE2AKuBrCwua6wFXTZLSpsFhc1li0ybCbCBZaQsLla6BSBZYXK1jWxLSFhctOWnTZVTEFNRVVVVSwIGItZkzUeMTlg9Bz2VkQd6QDg5CgHQCg0gacgDSBkCBkUxvE5kXoNIA1MDkJvNRkHhYIm91FjUdQgDUxpkwNTG9IqMGhOoygHNFBRlRlRNRgsIA/gHRKJlhE0ECtA0UUA6AX0AyAdRhAOWEExAuOY4wYaWBjGGTHLA6n0xAw0LjFYxWOp0mKmN5WP6naYoXHKxkA6jAOj9RhAKokokgFUTB0HqMqJoBlEyscMMU6TETFTHU+p5ToLDJiBYZTynSnRWOFh1O0xUA6iQOiUYQDqMqMKJKMFaKjKjKiSjKjCjCiYOiUTQCqMIBQdB6iSARRJRJRhAIVo//PkZPg4cgruAG9ZHAAAA0gAAAAAA6FAIDoAdADEUApWgDoQYiDoTRRBqKiaARAOWEVE0ApYQB0fnMiaHpooIBywigEQClhE0ZjnmK5yucrnNFBRkGIqMmggDUTQmNHw0Z/LEwPPQDlhErRUYB0BooKJqMmgicyIPOB0BYmNFAGonPODZywggENBAGIA/gHRKJKMFicHRAxEHQlaKAc0UAdCaCCjANQB5pXODzytArmK5kAgNQB0IOgB0RoIIBwZMDECwgVog80rmLCAOjK0SwgowDEUAiAVRkrQQCmjODo1TEFNRUA5zJ6apXG1kxiLWcE1meKoNPTJxEyYmB1SokZOIGInhWTFgQOCVSw1mTnhYg1GQc8A5CaYgDkQMIlb00xAHIQYnN5qN7VMiRLBA01UHIDTpwchKyKiRYQNH00ZgbODUDm9QCKJIBwaggFQDg6IHmoB0AqjINQLCKAVAOWEFEwYj6jHoBP9AOoz6iSAVRlRNRNAKowgFQCf6iajKiSiSiSiaAXwdEomgFQCA6BAKDofQDoBAdGowowDUFGFEkAiAdAN6iSiajKAVAKoyokokgF9RJAOgGK0CwiWEFGFGfQDKJIBlGAdGokgFQCKMgxH1GQdAgHLCKiYOhBq//PkZPs42g7sAG9ZZAAAA0gAAAAACiSiaiYNQUYNBFAIDZzQRB5qiRWgDolGTQQLCAPOUZNGYHQA1EGoGgh4MRBswPOB0BYQUZ9AIDogYgomaE5XMaHoNmNFAsImhODoAaiowVoA2dAKDzDRRNBArROecHnHNMDECxODJwecDEQdEDZzQ9LEwOgK/QeeVomigaKBoeg1EseH4icyBoIqJAycH8lhE/EQaigGQCmgiDUDRROZArQQDgyY0fVGCwiaCAMRUZQCnMgoyDEfQCn6iomDoAYigHUYK0QagVzlhFRhTEFNRTMuMTAwVVVVVVVVVVVVMGOzksc8aBN0XMsHMO6N2oDFwWDmHLGpdGpDGGdm6UmWDhg0w6g1IYLljdujduju7j33DdujUqDUqDUujUOzdKTUFwu6O7MMOHKxgw7zWpOhdMVTxjjBh5jDqeTFU+WBjXWDLvMcYMOU7LAyYqnvTGMcZMcxhzGHU8p0p2Yw4Yap5MZT/qdJiqdGOMp/0xkxguMY6ynkxlPqdpiqeTGTGU/4WHMYcMNMYcMNU6TGU7TGU/6naYqYpjDhhqnX+mKmKp0p9MVMVToLDmMOp5Mb/9TwXGMZcxh1Pf6YyYyn0xVO0xVPJjemL6YvpimM//PkZO03Hg7iAG9ZDgAAA0gAAAAAOaw5jDmMOp4LjGOMa6ynjHWNeg1xlPpjGOMY4yn1OywMa6xjjJjBcY11jXGU7C4wYcWBzGHU8mKmKp0Y4ynlPpjGON4XGNcZT6nXqdBcY1xjHGNdYrHMYcMNTFLAx00Fa5jDhYY11jXGTGCw4YamKmKFhwww16Ctc1qQw4LDqeTGMZc6B1OvC4ynSY4WHMYcMNCw5rLmsuay5jjJjpiGusa4xjjBh5jDqdBdY1xkx0xVPKfCw5rUn12GXGMOmIGHBYcMNU8FxjHGTFU8TEFNRTMuMTAwqqqqqqqqqqqqqqqqMfIN6jPo9NHKMa3Oo7QKbEYcQYEsKmzBHCJERDRoeZASFShhwBki4FqHXKnuimJqGxKgJKPIDl3jC5D1jDUGRU4aEsk2m2kYFyDkJMNYBLkyIXGFiJfl0TDYMCZ9D9gOlD0uYDhIbJ7S4xqSTFkGMQsKKhciVwEGFhlEBpygreBRqQBrwhCn8AjILDIQ5KhwgaYdPo/qdSSykorD0WTRRuZ2ulCWRFEA0kFdmi6AcIq3dXhd4VKLNYwAlJzAozuvA80SfpP40sEImnOGoCtxSpYwEGh8l8GBfVW5E8HJcBm4AGmWZglrSzpM//PkZOo2thxeAGs4gAAAA0gAAAAAQGoNpHbAAU1SLQLbAaIKWgGcpqMKMA1VFLGRs2ZwIwETkeU4nMCpCtLoGB4kFQcty75wyyACyN7i15syNREZDAErQEiHAjzUnFGVtqEsxLVEiRegHEOBIkJfmQ4ISVKDfwMw8yFNnaKAg10QYOpgIMhkRfMiywBWNcsZAQb6vhWwX+GgO7kB40c8HMIEKzcOON0MJCqlS9OFe4sQzgMYhBFGwBGX4yZEoCPJql2i1phEFLgkaJiP4YlCS2RCI3RCuCgocZ+bNymmXdklTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVe2qTcctsa02F0GDPtC1MVNaL3RcVkSgz3RmAnepFhm5sVBIlRoquqw1qqAVmsqaUps2NvEAyHIHGlcBNFVhZU/67Y+raXhch/21h5eKuW6pCpgugtaAXdisacKC3obmj62JpzotdyZUxJ3nxXSsEv8wHTnWasCxRMZiTjR5MZhRZYvUICjQYGd19pXm6UHxBYzVWav0wFjKAGERq/Mv7OLyLutYa2g66speAu8w4CCjAAOKkTMVc2XB//PkZLkwng5Wf2M45AAAA0gAAAAAdWAWu0rDWsIBkJSEoFBKmMBkwgjVCRlAAYGFcwQkGc+cBojWNkAKDoaGOYPBOKmiqwskQDiUQKhAmX9AhTLI6mHDkxQCgDOWWq0t0sQ1uCoTpUSaFUALQ4EFFSVNlzoMRqFpFyUpgMpO8CkM4En0SQKQHGVnMRUzUbTAFjhe4FCXmXxZ81MKkONCixqeQOAci9ssBgVsjJgaE6NY6zFTWYm32acsKjMmcosX6QSwIIwCwkMUAKYrmKZOukK3cu6g61xAMzNXr9KUu+iqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"},{ name : "R_sounds__dialog3_wav", data : "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oASS/fwEqP1WBdj9pgUy/voFlf5OBvb+rgZC/w8HfP96B7//0QcZABkIfABeCM4AqggPAfoIQQFOCXoBhQnDAaIJHQK3CXACzwm1AvIJ6wITChMDKgo0AygKQAMICkMD3wlIA7UJSwOTCUoDbwlMA0QJSAMLCUYDwghGA3gIKAMpCP4C4AfTAo0HnQIxB2MC1QYiAoIG5QEqBq8B0gV7AXMFSQEXBRUBxgTPAIIEhQA0BEoA6QMQAKkD0v9tA4z/KwNP//UCIf/CAv3+pQLc/owCt/5sAor+UQJk/kMCRP5PAiX+dgIn/pgCPf6uAm3+wAKX/tsCoP4WA4r+YQN9/rQDjf76A8D+MQT8/mUEOP+nBHj/5AS+/zkF/f+TBTAA7wVVAFMGfwCyBrcA/wb5AEQHPQF8B4UBsAfXAfAHKwIxCHYCcQirAqkI3ALNCAUD7gg0AwYJbAMXCaADLwnFA0YJzgNVCcwDSAnNAykJ3gP/CPoD2QggBMsINwS+CCkEpAgFBHcI2gM0CMID8Ae+A7UHtQN7B6MDQAd3AwIHNgOyBvYCYAa8AhUGkgLTBW4CogVHAnAFGgIsBeEB3ASiAYoEYQE8BCwB9gP0AMQDtgCWA28AegMtAGYD9v9NA9n/JwO///UCof/NAn3/rgJY/6UCPP+rAib/qQIb/64CKP+1Aiz/xAI8/+ACR/8EA0b/HwNA/0cDSP9nA17/fwOL/5gDuP+8A+b/5AMWAA8EQwA0BHsAZQTFAJwEDwHVBFwBEwWfAU8F3wF6BSICpQVgAsMFogLwBeUCIgYnA1AGaANsBrADhgYEBJAGWAShBp0EyAbNBPwG8wQyBxwFUgdcBWMHqwVcB+UFSAf7BTEH8QUrB94FLAfUBSIH3wUZB/YFBAcOBu8GFwbfBgsG1QblBc8GwgW6BqMFoAaLBXAGbQU8BkYFBQYOBdgFyAS6BZAEpQVfBIwFMgRnBfsDMQW3A/UEdwPJBDsDrAQDA5oE1AKGBKQCXgR7AjAETQIMBB8C/QP0AfsDygHpA6kB1QOKAbsDaQGlA0cBmQMuAZMDNAGTA0EBkANSAY0DWgGRA1UBmwNYAa4DcQG1A5cBvQPBAcgD4QHQA/EBzwMKAtcDLQLpA1oC+AOVAg8E0AIfBAkDLQQ9A0EEbANVBJMDawTDA3EE/ANzBCwEbgRYBHgEdQSCBJkEkAS+BJsE4QSfBAcFowQuBbAERQWtBFQFowRWBZEEUAV1BEkFXgRABUsEMwU2BCYFKAQNBScE7gQYBNME/wO1BOcDmgTOA4EEsQNpBJgDQASCAwwEYAPPA0IDoQMrA4QDGQNfAwcDLwPzAvgC6gLLAtgCqwLKAp8CwQKYAroChwKzAm0CtwJMArICLwKpAi4CpgI7AqwCRQLAAlsC4wJ1AvsCkQIWA7ECLgPcAj8DDQNPA0MDcQN5A5EDrQOwA+wD1AMxBPoDegQrBLwEYgT+BJYEPwXABI4F5wTpBQIFTQYXBagGKgX7BlIFQQeIBXgHvwW5B+wFBQgMBk0IHQZ/CCQGoAgtBsYINQb0CEAGHQlCBjgJQQZGCT4GQwk/BkIJOwY8CTUGLQkeBh8JAwYKCeUF6gjKBcMIpwWTCH4FYghTBTQILQUECAgFxAflBH4HvgQyB5AE6gZVBK8GGwR9BuYDPQa9A/MFlAOfBXEDRgVWA/4EQQPKBCEDtgT+AqoE1AKABLACQwSeAv8DmALUA4QC0gN1AuEDXgLiA1IC1ANMAr0DUQK5A2EC0wN2AgMEiwJDBJ0CcgS9Ao4E1gKvBPAC4gQDAx8FFwNqBS0DvwVOAwwGewNWBrgDnAbtA+YGIAQoB0oEYQdhBKsHeAT7B5gEQwjABIwI6ATVCAUFEQkcBT8JMQVlCUcFiglaBagJawXNCXEF9QlwBRAKbgUaCmgFDwplBQMKVgX7CU0F+glBBe8JMwXUCSYFqAkQBX4J4QRPCa4EGgl/BN8IVASiCDEEZggMBCkI5QPdB8cDjwebA0cHbgMJB0cD0AYdA48G8AJMBsQCCgaZAssFcAKXBVUCbwVGAkYFNgIfBSkC+wQSAtIE/AGjBO0BhATaAYIE0wGPBMcBnQTQAZ8E2wGTBOMBnATuAb0E+gHuBBICIwU1AksFUAJuBWUCjQVyAroFiwLzBbACPQbcAo4GCAPTBjIDDQdMAzYHZQNrB34DrweaA/QHsAMwCMoDWAjpA3sI+AOcCAYEzwgWBAwJKgRBCUUEZwlIBHkJPgSDCS0EiwkpBJcJLgSaCS8ElgkcBIYJ/ANoCdoDSAm6AzAJmgMeCXwDEglkA/0ISQPLCCsDiAgEA0EI2QILCLIC4gecAsIHjQKkB3UCfQdOAkkHIgITB/4B2AbnAZkG1gFnBsABOgauAQ4GoAHqBZMB0gWNAcwFhwHEBY0BuwWfAacFtAGPBckBeAXWAXAF5QF/BfsBnwUjAsYFRwLpBWwC+gWHAgQGogIXBsACNAbiAl4GDAOUBj4DwQZ4A+YGswMWB+EDSQcABIMHIgS+B00E8wd6BCYIpwRYCMcEjwjcBL8I7gTqCAAFBgkVBRkJIwUsCS4FQQk2BVsJNQVvCTEFgQksBYIJHQV8CQsFcAnqBG4JywR1CbEEewmVBHUJdwRbCVMEMwkkBAgJ+wPYCNcDqAi4A4wIjQNqCFwDPAgkAwsI6gLaB7cCqgeBAoIHVQJjBzUCNQcZAvQGAQKyBt4BdQa5AUgGlgEjBnoBAwZcAdoFRwG2BTwBkwU4AXEFNgFfBTgBWwU6AVUFQwFTBVoBSQV2ATcFjwEvBa4BOAXKAUgF5QFaBQACcwUlAo0FSQKoBXcCwAWuAtEF4gLcBRkD8wVIAxcGaANDBpEDbwbAA5IG6wO3BhgE3wY6BAkHVwQvB3gEUAeZBG0HvASGB9YEnQfjBLgH8QTQB/YE3Qf4BPAH9AQBCPUEBwjwBBkI6wQuCOUEQQjYBEwIuwRCCKIEKQiHBBEIZQT0BzsE5gcLBNkH3QPNB7cDsAeVA48HagNuBz0DTgcJAyMH0wL5BqgCywZ7ApYGSgJxBhkCVwbjAS4GuAEGBpUB0AV5AZAFWAFcBT4BQQUiATYFCQEkBfMAAwXnANoE4QC3BN0AngTgAJIE2gCUBNwAlQTpAI8EAgGEBCEBcQRCAWcEZQFuBHwBggSUAZcEqgGrBNABsgTzAbkEHQLNBEoC8ARvAhIFlwI6BbsCVQXrAnAFGgOIBUgDqgVrA8oFiQP1BakDIgbJA0oG6wNyBgwElwYiBLoGLwTcBjoEAgdIBB8HVwQ/B2kEXQd5BIMHfwSsB3sEzAdnBNYHWgTLB0oEvAc7BLgHIQTKBwgE1wftA+EHygPZB6wD0AeNA8YHcgPBB1kDvgdBA7cHIgOpB/cClgfNAnAHmgJCB2sCIAdBAgoHIQL4BgsC3wb6AcEG2wGWBrUBbgaUAUgGfgElBnEBFAZjAQcGWAH6BUwB4QVIAcEFTAGPBU8BZgVKAU4FRgFLBVEBRwVlAUoFeAFIBY0BSAWSATsFoAEuBbYBIgXSASYF+AEyBRoCQgU6Ak0FVAJWBWkCZgWEAn0FmQKYBbkCrAXcArkF7wLGBQED1wUUA+8FKAMMBkMDLwZmA1AGdgNsBoEDggaCA5YGfQOsBn8DvQaKA88GkAPfBpQD8QaFAwgHcQMiB2IDOwdQA1MHOwNhBy8DZwcSA2MH8AJZB9ICUgesAkwHjwJBB30CPQdYAjIHNAIsBw0CJgfoAR0HxwENB6cB+QZ+AeMGXwHHBj0BqwYkAYgGBwFnBuAASgbGACoGtAAaBqEADwaWAPUFhwDXBXkAvAVsAJcFWAB8BVUAdgVPAGkFVgBSBWsAQQWCADQFjgAxBZMANgWdADkFpQA3Ba0AKwW4ABoFwwAXBdsAGAX4ACwFHgFJBUkBXwVtAXUFiAGGBaIBlwW9AawF0gHEBeUB3QXyAfcFBwISBiICKAY9Aj4GXQJWBnUCewaHApgGlgK9Bp0C2garAukGrQL4BqsCBAeiAhQHoAIqB54COQehAk0HpQJaB6ICUQeWAkwHhwJNB2gCUgdGAlcHKgJPBxkCPQcOAjoHAwIvB/gBKgfcASMHuAERB5YB6wZsAcQGUgGgBjYBhwYbAW0GCAFbBvQAQAbkACYG0wAOBr4A+AWtAN8FoADHBZQArgWJAJsFfAB9BWgAVAVbAC4FUQATBUoABgVQAAYFUgAGBVoA+wRjAOkEaQDYBHcA1QSHANoElgDsBJ8A/AStAAgFtgAOBcYADAXXAAkF7AAJBf0AFwUJAScFGwFBBSsBVgU/AWEFTgFwBV0BfgVoAZoFcQG1BXgBxwWFAdUFjQHiBZ0B7gWlAQIGpgEMBqABFgaVARwGkQEdBo4BHgaIASUGgQEsBn8BLgaCAS8GegEwBmYBLgZRASIGPAEaBi0BEQYeAQkGBwH7BfoA6wXnANAF2QC7BckApAW9AI4FsQCDBaAAdwWSAGcFhABQBX8AMwVxABUFaQABBWYA9ARfAPMEWQDvBFgA2ARaALoEWQCfBFgAmgReAJwEYQCZBG8AkAR2AIsEdwCRBIEAlwSOAJQEogCWBLMAmgS/AJ0ExACkBNMApgTgAK0E8QC0BP0AuwQDAcMEDwHMBBkB1wQfAegEIgH0BCIB9wQgAfgEHwHpBB8B4wQaAekEGgHyBA0B+wT8AAEF7gD4BNgA7QTHAOIEtwDaBKMA0QSOAL4EeACoBFUAkAQzAH4EEwBrBOj/XATD/0QEp/8kBJL/BgR7/+MDXv/BAzP/pQMM/38D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yf+cAKj/pQCL/7IAev/DAHT/2gBx/+8Abv8OAWr/LQFn/1MBZ/96AXP/pwF//9gBlv8BAqz/LgLD/14C2v+OAvj/vgIaAPgCRgAtA3QAaQOcAKQDxwDLA+wA7wMRARcEPAFABGUBZQSIAYsEsQGZBNIBrwTxAcMEEgLUBCwC4gQ/Au4EVgLvBGcC7gR5AuYEhwLWBJACwgSMAqQEiAKIBHoCbARkAksEVwIoBEwCAQQ9AtsDKgK1Aw0CjgPrAV0DwQEnA5kB8QJzAbsCSgGPAiABXwL1ADECzQAEAqQA1wF5AKkBWQCDATMAXwEMAEoB5/8xAb//GAGe/wQBgv/xAGv/5ABd/+IAUf/mAET/6QA3//MALP/8ACb/BgEo/yABKP8zATH/TwE//3EBVP+YAWf/wQF7/+0Bkv8QArP/PQLR/2UC8P+SAhEAvAIwAO4CTgAfA3oATAOdAHcDxQCZA+QAvAMKAeEDLAENBEwBNQRpAVQEhgFpBJ4BdgSvAYQExwGLBNsBlwTuAaAEAAKfBA4CmwQgApMEHQKABBUCcAQIAl0EBgJDBPoBKATuAQ0E3wH2A9IB1wO8AbADpgGLA4wBVQNxAR8DUwHrAjIBxAITAZwC8AB9AssAUgKpACECiADuAWsAxgFVAKkBOgCYASIAhgEHAGkB9P9DAeL/HAHX/wYBxv//ALT/AwGi/wYBlv8GAZL/BQGO/wABlf8HAZr/FQGk/y4BsP9MAcD/cQHQ/4gB6P+iAQAAvAEbANwBKAD7ATgAHgJHAEECYgBoAn0AjAKdALECuwDVAtMAAwPqACoDAwFQAyEBcAM9AY4DVQGjA2wBvgODAdYDjAHoA5YB+QOhAQcEqAERBKsBFgSxARUEuQEQBMABCwS+AQgEvAEBBLQB8QOpAeQDnAHPA48BtwOEAZoDaQF4A1wBWgNAATYDKwETAxoB7wIHAdIC9gCvAuAAlQLPAHgCsABUApkAOwJ/AA8CZgDwAU8AzQE0ALUBIQCiARcAkgENAIEBBQBnAf7/UQH8/0gB9/9FAfX/QwHv/0EB6P9AAef/QgHl/0cB7P9QAfP/XQH8/3QBBgCNARQAngEgALQBMgDHAT8A2wFLAO0BVQAHAmUAIQJvADgCgwBKAo8AZgKiAH8CswCXAsEAsgLMAMUC1ADVAtsA4wLZAPAC4gABA+kACgPuABYD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rgC9AJcAsgB4AKkAXQCdADwAmAAeAJQAAgCPAPD/hQDc/38Ay/90ALH/awCP/2gAd/9rAGj/bABi/28AYv9uAGD/ZgBc/18AVP9cAE3/YwBI/18AU/9nAGD/awBy/3UAgf96AJT/hwCk/5kAuf+nANn/twD0/70AFADGADYA0ABZANUAewDkAJIA7QCpAPcAywACAeUADwEFAR0BKgErAUoBNgFnAT8BhQFGAaABUQGvAVwBwgFnAdABcAHVAXMB5wF2Ae4BewHwAXwB7gGCAesBiQHgAYUB2gGBAdYBfQHHAXoBtgF4AZ0BbwF9AWkBXQFkAT8BYAEjAVQBBwFIAeIAQAHAADUBmQAuAW8AJgFIACEBIgAWAf//CAHc//oAuf/tAJL/4QBs/9oASf/WACf/zAAL/8MA9/68AOr+uADc/roA0f64AML+sgCz/q8Arf6nALH+pgC1/qoAu/6tAMX+twDU/rsA7f69AAj/wwAd/9MAM//fAEj/6gBi//YAhv8BAa3/AgHW/w0BAgAdASQALAFOAD8BcgBQAZUAYQG9AG0B4QB/AQsBkQEvAZ4BSgGtAWUBuwGCAcQBnQHMAbsB2AHTAd8B5wHoAfsB8wEEAvoBCgIBAgsCCwL7AQsC8QEMAuABBQLRAfsBxQH5AbwB9wGsAfIBmgHtAYEB4wFXAdgBMQHSAQcBwgHkAK8BvwCjAZcAkQFpAIEBQAB2ARcAaAH0/1kB1/9OAbf/PwGR/y0Bb/8YAUv/DgEt//8AEf/0AP3+7wDo/uYA1v7dAM7+1gDC/s4Avf7HALz+xgDE/sEAzv7GAND+zADX/s0A4f7RAPH+0AAQ/9QALv/eAEf/7ABe//UAff8AAZ//DAHN/xoB6f8nAQwANAE2AE0BWgBdAYcAbgG1AIEB2QCQAfwAnwEiAa4BQAG/AV0B0QF7AeQBmgHsAbEB+QHFAQsC1wERAuIBHAL1ASgC/gErAgYCMwIEAi4CBgItAvcBLQLsAS4C5AEyAtwBMQLPAS0CwQEnAqwBHgKQARoCdgETAlkBCQJDAQICKQH2AQkB5wHqANUBwwDCAaUAtQGIAKkBbwCbAVMAkAE3AIMBHAB5Af3/awHi/14B2P9UAc7/SwHH/0YBxf88AbT/OQGm/zIBnf8pAZX/JQGZ/yQBpv8iAaj/IgGu/yIBtf8nAb7/LwHP/zsB4/9DAQQAVQEcAGEBMwBjAUkAcAFhAHcBdQCCAYcAjwGeAJkBrAClAb8AsgHbAMQB+QDTARMB4gEnAfABMwH3AT0BCgJCARUCUQEjAloBKQJiASsCXwEvAlUBKwJQAS4CRwE2AkIBPQJAATsCOwE8AiwBPAIYATQC/gAvAucALALSACMCvQAYAqQABwKJAP4BbQDyAVUA6QFDAOEBKwDWARcAyAH8/7gB5P+sAcz/ogG0/5YBnv+LAZH/gwGF/3gBgf9sAXz/XwF3/04Bcf9IAW3/PwFr/z8BZ/8/AWv/NgFu/zIBe/8zAZH/OgGl/zsBsv88AcX/PQHV/zgB7f9BAQcARAEYAE4BLABQAUMAXwFWAGkBZwBsAX8AdgGYAH0BtQCIAc0AlQHdAKEB6gCpAfgArwEAAa4BCgG1ARMBvQEYAcMBHgHHAR8BzgEnAdIBIwHXARoB4gENAd0B/wDTAfIA0gHjAMoBzADFAbcAzAGfAMoBjwDIAXcAvgFhAKgBRACVASwAiQEIAIIB5f+EAcf/eAGn/2cBhv9UAWn/NwFQ/ykBOv8pASn/KAEY/ywBCf8VAQb//QD+/uwA+/7fAOT+3ADQ/uEAw/7fAMf+0wDP/s4A4P7BAOv+ugD0/r4A//7HAA7/ywAk/80AQP/QAF7/0wB3/9oAlv/gAKz/5gDA/+sA2//2AAAAAAEsAAoBUgAeAW8ALQGGADQBmgA7Aa8ARgHLAE8B5gBgAf8AcAEVAX0BKQGFATsBjgFNAY0BVAGTAVgBnAFTAaQBTwGoAVEBpAFSAaIBUQGaAUUBnQExAaABGwGiAQkBoAHyAJcB3ACRAc4AhgG2AH0BlABzAXcAZwFQAFwBMQBMAREAPQHs/zAByv8gAa3/FAGO/w0Bc//+AGH/8wBJ/+MANP/WABz/yQAC/70A8f60AOb+ogDY/p4A0v6TAMr+jADD/oUAvf57AL3+dwC7/nUAy/5xANv+cgDs/nYA+v5yAAL/cQAQ/3IAJ/94AD//fABe/4UAef+QAJL/jwCo/5MAvf+aANT/owDz/6wAEwC6ADcAxABZAMsAeQDQAJAA1ACfANsArQDhALgA5wDKAOwA3wDwAO4A9gD4APwA/gD8AP8A9gACAfgABwHxAAQB8gD6AO0A7ADrANkA6ADMAOEAuwDaAKsA0wCaAMkAgwC8AGgAsABMAJ0A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BgEvAQgBLgEJAS4BAAEtAfwAMgH8ADAB9QAsAewAJwHhACEBzwAgAb4AIQGzAB4BpwAZAZkAEwGIAA0BbQADAVQA/wA+APUAIgDxABQA7gABAOgA7//hANz/4QDF/9wAsf/ZAKn/1wCf/9IAl//KAJL/xgCH/8cAfP/GAHH/xwBu/8YAbf/DAGj/vwBm/70AZP+6AGj/vgBp/74Acv/EAH7/wwCH/8kAnP/NAKj/1gCx/9YAvf/ZAM3/0wDb/9cA4//XAOz/1QDu/9kA///ZAA4A3gAcAOEAMADhADcA5gA7AOsAQQDqAEQA7gBMAOsAVQDjAFgA4wBUANoATwDZAEgA1QBBANkAQwDUAEAA0gA8AMwAMADHACQAwwAXAL8ACQC6AP7/sgDu/6gA3f+dAM3/mAC5/5UArf+UAKL/lACZ/4wAjP+JAH3/hABt/38AWv9/AFD/eABC/3YAO/9yAD//cgA8/3IAM/9wAC//bAAn/2cAKv9qACv/bQAo/3YAJf96AC3/ewAx/4EAPv+IAEz/jQBY/5IAYf+VAHP/ngCB/6EAkv+mAJz/pgCo/6kAuf+wAMP/uwDU/8MA3v/FAOf/xQD3/8cACQDOABwA0wAnANcALgDYADIA1QA5ANYAPwDVAEcA1ABMANMAVQDTAFYAywBWAMsATADIAEMAwQA/AL4ANgC5ADEArwAsAKsAHQChABMAnAAIAJsA/P+VAPD/iADg/3MA0f9kAMD/XQCs/1gAmP9bAIn/VwB3/0sAZf87AFj/LQBM/ycAQP8sADn/MAAo/ykAJP8gACD/DgAZ/wMAEP8CAAT/BwD4/goA9f4SAPn+EAD9/g0ABv8IAAr/CQAN/xEAE/8dABj/IQAi/ygAMv8rAET/MwBW/zMAZ/84AGz/RgB4/0sAhf9OAJX/VwCw/14Axf9oANT/bgDh/3QA6/95APf/fgALAH8AHwCEADAAigA6AI4ARACNAEoAjwBVAI0AWwCTAF8AkwBiAJQAYgCKAGQAhQBgAIAAYQB8AFsAfABXAHYAUgB0AEcAZQA8AFwANgBRACwARgAgAD8AEQA4AAEAMADx/yYA4P8WANT/DADH/wYAtf8FAKf//f+X//b/hf/q/3n/4f9u/9j/Yv/S/1f/1v9L/9D/P//P/zv/xv83/8D/Nv/A/zb/vv8t/8P/Jf/F/yf/x/8i/8b/J//L/zH/z/85/9D/Pf/Z/0b/3v9T/+L/XP/p/2b/8P91//X/gP/8/4r/AwCX/woAof8OAKv/FgC//xkAzv8kANz/IADt/ykA+/8vAAMAMwARADcAFgA3ACAAOQAtADYAMgAyADUAMgA5ADMAPQAwAEUAKwBKACUASwAbAEcAGABBABAAOwAIADUA/f82APr/MQDu/ykA3v8gANf/FADL/wkAw//8/7j/8f+t/+T/oP/Z/5X/wv+M/7P/g/+p/3v/nP9t/5L/YP+K/1v/e/9U/27/Sf9e/0L/T/8//0r/N/89/zP/Of8w/zP/LP8s/yz/Kf8y/yX/L/8g/y3/IP8w/yL/Mf8k/zH/K/88/y//Pf8v/0L/NP9O/zz/Tf9I/1T/WP9b/2D/Z/9q/3H/dP+A/4P/hv+P/5H/l/+V/6X/nf+2/6P/w/+s/83/tP/d/7z/6f/F//n/yP8IANb/FgDW/yEA3f8tAOP/MADk/zgA5v9AAOX/RgDg/08A4/9XAOP/WgDl/1wA4v9ZAN//WADc/1cA1P9VAND/WQDM/1UAx/9MALr/QQCx/zYAqf8xAKH/KQCY/yEAj/8bAIb/EQCA/wIAdf/2/27/7f9m/9//Yv/V/1H/zP9I/73/QP+u/zf/qP80/5v/KP+R/yL/jP8h/4X/Hf99/xf/df8Q/2z/Dv9m/wr/Y/8L/2H/C/9d/wv/Wv8M/1//EP9c/xP/XP8V/1v/F/9i/xn/Y/8d/2j/If9w/yb/dP8u/3z/Nv+E/zn/jf9B/5f/Rf+d/0n/p/9Q/7D/Vf+7/2H/xf9j/9D/Z//X/2//4f9x/+v/ev/y/37//P+D/wUAiP8MAIn/GQCJ/xsAj/8hAIv/IwCP/ycAkv8tAJL/MwCS/zkAk/85AJD/OwCP/z4Ajv88AIn/OgCF/zoAfv87AHz/MwB4/zAAd/8pAHL/IgBu/x0Aav8cAGL/GABe/xQAWP8NAFL/BQBM//r/RP/0/0L/7P89/+j/OP/e/zX/2P8v/9H/MP/J/yj/wP8k/8D/JP+7/xv/tf8g/7H/G/+u/xr/qP8Y/6L/FP+g/xj/nv8b/6H/Gf+d/xb/nP8a/5n/Gf+a/xr/m/8e/6H/H/+j/yb/pf8q/6X/Kf+n/yz/p/8v/6//Mv+0/zr/vP88/77/QP/E/z//y/9B/87/Rf/T/0f/2f9M/93/Uf/j/1L/6f9U/+3/Vv/x/1b/9f9b//X/X//4/13//v9d/wEAXf8HAFj/BgBb/wsAWv8KAFv/CQBd/wgAXP8MAFn/CgBY/woAWP8FAFf/BABS/wYAUf8DAE3/AABK//z/Rf/9/0P/+/9A//b/Qv/w/z3/7/86/+v/N//p/zX/5/8z/+L/Mf/h/yz/4P8r/9v/J//W/yj/1P8m/9b/JP/U/yf/0P8k/9L/If/N/yH/0f8l/9D/JP/Q/yX/zf8m/8z/KP/M/yn/0P8q/9H/K//T/y//1/8w/9j/Lv/X/zT/2/80/+D/OP/k/zr/4f87/+j/QP/q/0P/7/9F//D/Rv/1/0n/9/9M//r/Tf8BAFH/AABS/wMAVP8HAFj/CABa/wkAWv8MAFn/DwBX/xMAW/8UAF7/EwBf/xQAXf8ZAF7/FQBa/xYAW/8XAFr/FQBZ/xQAXP8VAF3/FgBd/xMAWP8TAFX/EABV/wwAUf8NAFT/DgBS/wcAUv8IAFL/BgBP/wQAUf8CAE//AABJ/wEATv/8/03/+f9L//n/T//4/0v/9P9M//X/Sv/1/0j/7v9K//T/T//x/0z/7v9O//L/T//v/1D/7v9Q//D/Uf/u/0//7P9T//P/VP/y/1X/8f9U//P/Vv/y/1b/9v9a//X/X//5/1//+P9h//j/Yf/8/2f//P9k////av/9/2n/AABp/wEAbP8BAG//BQBw/wcAdP8FAHP/CgB2/wsAfP8LAHr/CgB7/wwAe/8PAH3/EQB6/w8Afv8PAID/DwCB/xEAhP8OAIb/FACH/xIAh/8OAIj/EACK/xIAif8PAIj/EACN/wwAiv8LAIz/DgCO/w4AkP8QAJD/DQCS/w4AkP8IAJD/CQCV/wsAkv8KAJP/CgCT/wkAl/8HAJj/CgCV/wgAlv8IAJv/CQCZ/wUAnf8HAJ3/CACd/wUAn/8HAKD/BwCj/wkAof8GAKX/BgCl/wUApP8CAKL/CQCn/wYAqP8IAKn/CACs/wkArf8HAK3/BwCu/wUAs/8EALT/BgCy/wgAtf8IALb/CAC3/wQAt/8KALj/BwC6/wcAv/8IAL3/CgDB/woAv/8HAMP/CQDC/wwAxf8JAMb/CQDE/wcAxP8HAMn/CgDL/woAy/8IAMv/BwDN/wgAy/8GAM//CADO/wgA0v8IANH/CADR/wgA1f8IANT/CgDV/wcA2f8GANb/BwDW/wgA2v8HANr/CQDZ/wgA2v8IANr/BADb/wQA3f8GAN7/BQDd/wUA4P8EAOD/BQDk/wUA4/8FAOT/BgDm/wYA5P8FAOj/AwDl/wIA5v8DAOj/BQDp/wUA6/8GAOj/BADs/wMA7f8EAOr/BADq/wMA7f8GAO3/AgDu/wMA8P8EAPH/AgDy/wIA8f8DAPP/AwD1/wEA+P8DAPT/AQD1/wEA9P8AAPf/AgD3/wQA9/8DAPn/AgD3/wIA9/8EAPf/AwD4/wEA+v8CAPr/AwD4//7/+v8FAPz/AQD8/wMA+/8BAP3/AwD4/////f////3/AgD7/wMA+v8CAP7/AQD7/wIA/f///wAAAAD7/wEA/v8EAP7/AAD8/wAAAQABAAAAAQAAAAAA/v8FAP3/AAAAAP7//f8CAAIAAQAAAP//AAABAP//AAD//wEA/v8AAAAAAQD//wEAAAACAP///f8EAAAA///+////AwABAAAAAAABAA"},{ name : "R_sounds__gameOver_leave_mp3", data : "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TLB/FCkuUx0FY4Kh+OzAQi2QCHxFJ5HLLxiyVCWNS9MvTQnKyFCXO8AJwLiyYKIWWaLQMPX0hihqXtXTFGGoJploTJZdQQPCI1A61XueUQhF4rPE5SNYUD+qKpcXpTAtlRWydE5l49JJCL5dUtbZMfuLaFokqCYwKHBISAnzTBMIqFja0GP5GD0C1EjTuxYhedHUFadNGqShDSWuRxwIYlsLIlLxnJEUWc4KBiztNi5ZjXUkdrkUpLG6cS1HWJjEm7ouiaYsGs1TOaZZxrfSLEiIMC4SbcOLnNKwGEPsiCxHKmFesgIoOROPUlPmnipyjS4BkiEmjECoCIhIkDIoBSISRQwy0BNfFU7AKx3gIJmRY0FSTPHkQkRdWKf//6AqSpU3jAAF//uSRPSOB1ttOgsvYvCybZeBZYaYCSg66ge8wIDLAGC0IIQEE5LLbI7uGDwFFUrYMbmhVNIxuBWOxZHjGaBTqZxTq9n3Yoa1fHsdiyNbHbTWtLu/pUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5BkQQ/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5BkQQ/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kGRBD/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kGRBD/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ"},{ name : "R_sounds__dialog1_mp3", data : "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VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQABsJf/wiMyMvM////mR/mX/kafmdr/I78jJr0Iya9q5ubkF+tvPLUyaGBthtyPs91qFh91c1DBCw+pXQzNWoWL0/+tDSM9Oi6hsNsN0fieahYfRHwkhMDo0jgSyYbkURglB4TCXQMHFQD6xRtQsK/rFRb///ULiMyAgkK6m/xYX/+hksLCwuGRkTBUMgIJC5mAhb9AMipLBkKCwtFlTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uSZI+P80hpJZAhZPI0gAUBBCJuAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ"},{ name : "R_sounds__body_explode0_mp3", data : "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"},{ name : "R_sounds__body_explode1_mp3", data : "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C+aULmWP52EqBnAxcQMTCgsLl80vEKqAKFxzAhqjkmsH1+mElKrWYVVJSY9mq8Y6q9/28MbBRPxmPXh/VPXONQrKTH+FalxjWt/8ZvqhRMOsGYCgq4VcSWAUyWdQekh7jpY0PW6RhIJZGo8lUKnZOFXhFUQjBCizAWR0iEM0s1FXKDpUFXCUNFXNBp4dcsBElukfO/DXPen+qr/SSvv97ud75bnv0ExBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Jk6AyD+UJEi2YdID1CiOZhIygOZQMGDbBrANmC4mSXpAiqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqoBlZACyUyCdSxf7yReUQbBsMSeW1s8O445b1vKrcu3cM+ftbHIyOyX//56sFDAwYR0eUMDBhHQxIoKGBOhkay3/ZQwMHLOWAwccj/////8jstQyNWsKLj+TjRQEegtGpZ3zZqTiym/+ySBRQoWQTx2dmdn70aUUGLJSsQCvYxTAwZDs/JrI5GXf8/ssl/+yVDI1YGDBMz8Cigsg0FRY0aHsywSFSJkFhcRmQEEmOrFBYkaCot1f//5UVFqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZJ4P89hjsJMDNXI/hJYxCANmAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg"},{ name : "R_sounds__drop_ball_wav", data : "UklGRmadAABXQVZFZm10IBIAAAABAAIARKwAABCxAgAEABAAAABkYXRhQJ0AAAAA7P9dBF0ElAzaDSUOzw3eE1YTHBRfEQo3tzOHQLs+pEEbQEtNwUzMPJQ5aFh4V0054jfwDYUORgwSDu70r/Sw4gDhTsfux8u7qb6Hxj3BZaWvpYedFJrcl9yX+ptomqeiE6IqpD+tSbVitW/Fs8P12HPVF+h45LX4ePwyEtQQrCbUKI03qj5BRtBGnlOPUPNaNVpdXoJfqF9MZW5ghWJmWdFZ+U2FUXRBVUQFLxYzhBy+IUoIRw06+KP0neTJ3mfQnNHpwVbB1rYitMCw+KfHo9ui/5mRnqOiyZlGpbagxaxFpw64I7YxxxzIkd2z2CHrre30+on+/BArD+0h+SPkMnEzUEFmQuxOh0l6VW9YNFSnYfdipmv/WEpgMT4NQt5DyEaMQm5HBC91MNMUThnbAhwCkhHwETTnR+eozwjLdsyrx72zpKYwuVGuB6adpoeeR5txtMqvIrRjrADKdMhVsHKs1LL+rPXoCOoB9xT0MgSHBTsE+AUlFJ0TrjdAOXA9XEAFTf9NzFBqW8dVl12HXtFmfk/CV0xK0FGCRzlJgjhwOiUsRy2pG7Qdqw9WDmr5GPf637fec9ZI1KzL18WtvUa+VLK/q8GpAqFuolGdyKSxlVypzqa1slGvLr6GulHFU8ay1uvTcO1I5yL+dvvQC44M3R7mHU81XzXNQFhGcEVlTq5MolVtWV1d4V3kZyNcP2RQVyxdcE3gUK1AOEAkMQYx1CF2IM0U7RFD/af+DetH7WffM9Qpyo7JeLvOv82xTrH+qvKmuKIpmaGcl5tcqY+n1KSVojmrDapRwqq7U9ZK2kL3kvMp64bsKvO48KcWXxHBKm8oqkOmSWQ9YkgxSGJLuloyXbdSNlg7ZaZrhFCeU49MrkytVeRSxESrR1csxCwjBjQEFQlWDGoKbA2L4kTg5c57zfnMf87GynbEUa9kogOWEpn0p+Ko/qasqPGqt6UquKyupLmLvEzEcsR30rfSUepd45H9averBqUILBpiGSIpqypvOfI8AUhtSPZRc1g4VrNhwlhdXqBTPVUfU/BSZ1LrUM9FkkavMGg6XSUfJeAY8xaqA58L9vET93fgruP92MrQBs4Hwrq6gbXcsPSql6oSqMWmb6T6rGOqgbH1rxK8fLdUwC6++s19zfXhy9vL8YLxfP8IBmUU/RRSJ5UkdTHzM3Q6MUGHQ4pMoktsU5ZVCVbTWHpZvk9/Ut5R0FB5SQZPpTe3PmQiFiOAGEkZGxrgGB/y+PGW2QfRT+Lb3Fjf+uDOy1HOO6OWnp+oPJ2htpOs76mYqgitTLH3rj2rKcG6v4fMe8vOysjFWd6m2nr65fwgFDcUTSA5IJ0okiqVMR03ODi+PGpLmU/vWbxYvFIlWMZQbFjjWWlaglRHU6c/oEEtK70uuyVcJzsZ5xZDCX0HovaG8fPjE9/O0qLWMsO1xVu8UbnzsxqxK66treqozanGpkWl7K/Lpla4BLbrwILFXdFQ0A/cStvP7BLt5f+r/HgM/AwcHtkfXS84MSU7+zs1R5ZItUwdT7RQMlUkUH1TvlCmU1BSvVPsSVlHxD6fOM4sTideHvwcexD7EUb6lP9R5XrtIdtz3lPXrs49xCbCfrBctCGzJbU9uBq24alTqf+jp6VNuwi4t8T9vzvIU8iN2j7XJPW69k4DJgnX96X3IxW3EDkoMB5uLyAwNUsuVDhGY0quTaFN60p0SjNLd0zLVGxSsy2mKgMrXi4mNzg6uyp9KZMQew7O6HnqFeao6ejjB+bp1g7WtcqZzELCmb94vhS5ZrBEqq6iCKbIr7e1EMKDvi/I0MJv0RPRWt6O3y7t2+3++tb5hAkdCDAdzxcuKOMlFzMVNfI6bj8rRcFEGEwFSVxMXU/HTatRX0iZSahIa0GKN60zpSgjLQAcDSHLDl4UDQRRA97z/O9b5AvgKNNk28fJ5tAWwoPB7LlTuVS2SbB5tdS0ebeDuAq3kLZxvpHDwsr9zoLXvdjm4ibjbPNZ7MAGdQD3EhUSPxvoIWAomCtWN+o1wD4KP0lGk0Q8TPlKh0ooTbpCEUWpRGxF8TcBMxAvHy+6J2MlryHVFzcO8BK37av2BvEt9y7oK+u2wUG9gsx8yXDYK9nVzF7N26lerRaf/p9IyZrHwcmtyojCVcXA0NLTnOPk5Ij3KPeI8H3rrvaX8xEUOxcaH+MZZTCFLg85aDo9R6RJrD/NRZs5PzTDQe9COTxhPr04ajOaOlQ8YC47LiIhDR4mDj4QtQUXC4/4aQAx6XjtJeZt4cjZq9cIz7nMpse6wybBzr8gvgbDWL8hxG3FGMXSy2nKatWezpDdhNmK6AnmoPRs8NL7BgSgC6UKVxfZEoEfWh8SKTYqYDKgPOI6LT1mPTE8ED3IPbQ+nDrEO1g1azHcLuMq8i00HlIpSRlHGwsNjQoW/Ij7y/OY8fHn8Oc34CvghdKb2CHLzs2UyZXClb4GvobIJsfoyEXHVskKwTLHRsdyzLfZweTU4cLxT+px9iLwKwEFAeYYwRvOHE8erRnqIC8fHSE3NTAvmkFmQ1Qx1DXFPRY/E1BmS6gw0C65Gu4dCRfrGM8iYyO+HJQisB2xGEcJtgKD3wzgbNIP1mjYKtwU4cjcv8tryWHCKMGn2qDQVc53yDS/JMDsxGHIPdPk2A3g9t3v5DDhePCg8CwBgwIuCOcJ6wt6D9MarBr/HIgjqyqdLy4xKDAwNzwvBToyNvg0PzdLM8o6NS+bLQQmQCF4IP0Y5RW4EKUIrhAhAJ4EI/Yy+nLsAOt75GncDN0q1r3We9V40UvQ8c3Hy23KP88ZzMHP8dL+0v7VYdcN6YDeMOld6MLyHPPI9xn+wf7oA5MJJwvmEaoSIx1dHLkj5CW1LCIvUzEvLOIphiUFKPcrlC8BLY8vcCe0Fk0TaxZKGxUn5SjSAr0EpO938T3vvO0B9Or08O7d7GjwmeuT64PsPs+LyrusLbhG1lbeIuAa4LzSC9Je0fPMPAWlBAcEQvyV1SnUVO9x+nkP9Q7/FjUUgQNoBeoGIQvJPBdFrTFaLE8SGhFEIUUjGC2wLRYyXi2qDyIIBRzGGCM0iDerA+YF8u30+ZQX1RU8GOwRo+Lp3dfVeNVa+AH+/+jf6JvBJMZYzuPTS/Ll7PHyNu52yhPHWNEg1HrnuPFL47znaf9s/8v/QPSvBdMBgAUxBiX0NvjjIEsj9yWwJlUavxgQDrQPmigFKK06HT17E1UUrg6bBlYgfx0uNC86XxLtF8PpdOg/ARgAVAqMEOP5Dftm+I/2W+y36F76I/cJ0MTQwtdu1Lj/ywRP6ePma8cAxF7mq+VwBdQIieKm5D7L4Mfl+/v/QyP7KpoV0A/F3ATV3f5FBpQWJyNlA4EJuyDSGq8u5StIGnEZKg4UCtIKrAykKnwr8QxVDLcCUgF4HmUbyxd0GoD8CPlX623tcPF29TcDif75BoYBGuq653jKP8gr8H3ylPtI/ozpN/JQ30zkxwVWABoEfvuO23XWRNvJ3wwHCQ4f/PQBxfVT9DsZBxnMIuEiAvsH/ojxDvRIKGQhtDqgNuzsbfcU93/2zy2sJKAkfxtC8Zf3wwJqBuMjSiMsAC4FEuk88N7+pPidA2D47On567Xrf/GvGncWf/KU9fTJZ9N97fTwdgmqCeDysPY72U7gqv0o9ggO9f7bAZADk/aeANL5BP7w/qH+0AgJB7ge6h9mBB/9BuxN59kPqxA7Fs4W7BPtDukFzwPQA3YLig/0EYH/RPwjCNAFUQoqEfbgZ+eY9pf3PSBBHj4OLg3q0kPRK+gf6NYW3httDX4N0OeA4JrtF+ypCa0OGfV7+BfkMOOSFjMazgcxCqb1nO1xAtT5lBbzFX/76AMS2GPabgXTAT4sRC2hDvcIheqN4Qz1Vu9IGy8a//ZX/o/0GPs9+i0EkP8mAdATowh48Df08P/VCEcE7AgY7mfqIBcAGSsGygy0+L3yAu9G6Jf8lfvfGowjkQ2wCyHz3ew/9Yb9R/6i+qsPJw2H/Vz+HPuH/Jn9qvSYGmUTkACBDT3Pj90a9tLtmRurE+EOQBI99qXyt/f38FUakR6D7+3wXfGo8e4XvhlfCXAWdtWl2sDsQN8MMDAtjgD0AffShtSUELAOAjL4MG4GgAoEvUO9ywDMAIQwbTc36R/oMvgQ9FcNBgimCYsHt+jC7sTvovR4JhYpzfv6/dbhY+CzChwFKiAjGzPynPQM0ULWMhzAGVsb3Rwb+hL8Q/Aw8e/tc+auDqsMO/+7BlICWwXDCB4K7Oxv6fwfAxrjCHAH9+N25Jb4bQGHEJQTiPqV8870+vPyFbUVNgKw/KzgXtxaBUQK6h1EJzQKBwqrwta7rwhlCBEwVTO545DjYemC5uYOYBGvFh4U4QX4AjbnBeP+GDsYjuzE863jW+QuGjkdJQi4CAH2mulu7RLsChDhGL0ZcBy58Zno5fvD9g76PwXjEIsUugORAjnt4O0BDegJFw4f/VUH3gDH+a0HI9pK3zQNMQY0/93+vP85ChcTRg5KATfxPwFTAeX1u/e0AAUB2wSPDMvkHO0FABD6+SCrEKoW8xR31KXb5OoG8XslZCZcA6UGqfa+8V4C+vpoCXwHAAVcBrvjYuSOBYoFmxLvDw3zXPOEFSoVeCK2H8gOshDR74zxOfCG8B8XjRY74fbhEMBcwK3l3+DvBWsFdwN6CnfpTOogDLMIJAwXCooUHBYoBPEItP9tAaQgtBzZ9P/12ACZ+3wNkgoa9O30yvOM9tH1EP2IBv8H5CnmH8He49bq7zrtwga7CIcnyCkf9VHwk/VM8rEW0xubDQYTkvRD+4frL+kADR4ML/5QBZ3sKOw8+eH2OPby+Q3bMOImAAj7Re9j6qYxNTUq8UPyZeSO36ISCBGcHAEiHgJMA0zvZedICssOuSc6KXf0S+sZ+En26vovALAF4A6MAO36HPaA9cAgfSPA/L3uZ/uA9wwPFxvy+h8EL/5V++3NN8qY2gfpWvoe/qXQ7czJxeTNeNjQ240HWwap+xz7gwDUAZQSRQ+IHOIY72O4ZRgWAhnuKCcoY1bYUh4ImwIdE2AXzQMdA8jZ59Zm4r3hEKSSo17Gjcsn77jsb6DdnZm+SMGvFHkTMwceBTnis9w5F0kXBSKTJdQ4hjqcIN0j2xYWH7xYwVyuJd4hYwtqBx1IsUIvAZr+w+5i8nT3fvsO5xjkTerz5nPI88wnt0O/e/A88Bj6Oe6qysvDqOuT6/v2LPkF8UjyXBXEGPzudPbJE6AKOyrCJtgIXw6cKSoikBSuDpbvQ/fxHzImevoj9ivtE/KgB+sNm+n/6n7wNecZEqwZ6fSM/mL67e4JCRwCTxJRD4UogSrwClgLlPUm91hFH00nHm0Zxg+xB4UsQyxREy4WfxJQC/ca3xdK8Wf7jvFZ7zHemNwCxejMR/AD82rJO75iofSc++HC4i3WYtm50n/STu1079vhgublHBIZCDT/NssSYBH4SlRGjS2DL541cDX/Ud5QwChcJ28bCxkeLJYvlQDLA+8Egv+Q9DDr+84J027rR+s24FPdNtLmzDPuUu801KrYQeZ47ZQaMBl++lnzhQMdBd8lOStLDrwNvitmJgEa5xskFKoYaSd3IyMRhApvDn0PWA9TFvX0SO/f8JzpEgkdC6LnSudi4nfjZfQJ9GzfX+j3A3UAjfyo8f3ft+ZpGLwbiRFVB54ExgMAJDwsVAhuDEsa6hAXJpwnxAOWC4cTVg+M/2r8ZuAy5bIG0AajA0X7SNia1VDrs++16qjuu+pE7onxr/K63pvcm/wd+/IV5BN46yvqGgLTAJcJsA6q6U/sQAn2AWn4Cvf958futfy1/y/hJdgt5Nrl4AL7B0fiFeUH5cvcOAaBBAAFlRF8/lQC7xNwDscY4x6tS6RJFTuUMd0cShtXRPNQiigeKj0r0xxoM5UrNwTjDMoSMxH3+/D2yeAh7JHvTvT91erOAswfxuTVRN8DzDLTV8tTw/HUPtdtyNrTR+K93VAC2fb73azfzQKCBVQjlCA6HywakTEXMWwllyi/LZ8w6D0nQSQKjAeHEWcQRA3rE0nc59l14G7O+thv2MvUBuNAx2rGzcqHw772UvzdCIcOMvEC5GkOTAWGOJVBNS1ENikthiriO1JB7za9QRVA0y9sIu4XmBY2Ip8hxyTL8/vri/xY+wj2CwPv2FbTwOf61w/Y5Nka3h3kSPXj8S3iO+DX6hz3cgO3AnISDwhVFXcT2Q5ZFWoV3hECKpUjECHqJnsDRwtUGccXhB9YHDQExwiuDFQRGwBX+xAL9QMBBrAINOfD6VIDJgmTCCEIaexK53EFAARzFacW1gUpCMkB6/4ZCGkFkhZsG0oXzBWL8abveBGuE3Ef/iN+9FbxUwc0//oM/Q4i8ejxSvOt7tDq7+Kn94z/4fLw82rZZ89z+Pv1mQHgBqvs2+0K84f0GvuwAjH8Iv9sCGoE4wTMAK/8M//iFtkWrBDUCgYSRxp9GyciIw6zB5cr4R2+IB8cngvnEEoYYxvj9wbxjf9A/aYNzhFN/fX6EfL87aHgi+DV7SLwGP6xBobeHtxz3eTdewoIDzUK0ArJ/T/6ghHNDvEYiBeKKhgrZCS5I3YLZA++LkUzfhgWE0jxeO0/Eo0SzgJGATnqnOf/6gDg2emG5x4DLQrr7I/szMwkxl79Bv/UALoKVdgf13b5SvP4BgcLpAeaCvAaXRNxEUUJ/iGbLcwmpzJ8Bu8A1ho3ID4ZBB3E9evqqvnh67fqYeqv6Rf1Dvie9mzSact739bpnADJBkXgLNsR4QzdkP9bA2L9yvuKFMcLqvx++evucPQlHSIb2f5w+v/e79+bCvkQpfgO/PztPeRF9APqiPjS+V0K6BKa+Bn3reqg5Tgi0S4hFc0cIuN53qcJcwO/JhM0ygs0FFARdAfmBcsEVhj8HK0e2x2Y6wXudg6LGcMF4Ani4mXR+wZE+W3nyOed5DjeWvZ46ZrskPAKDmcW3AxUCJDvn+PzCesKLxAHGuEFKAWOAfID4Pmw/9/xjPjDGW4igvr//u7sefFFHoUjxAB9AuX7pgFz+YUCzezV750daB/x46jikuGC5HUtCy009+LrOtTBztEO7BFVGiodEQCMAa/18u/JCdQInh2QHnDn1OTYvgm6mQbkCNjmJ+8SwbO9SxdGEkQGmgl88Bf4fQqmDF4H7QLxGFMgn/taBAPsq+xxJGooUxDZFpnyovNQG6EeMA3FDUD6Bf9aMEIxzPzO/kfq5+yFEOQL3u8l7l/zcPDE497gYr5Xt5D7IfSN0DDIesNTxjwNthEw+jb3rARL/y8nhiybHCslSyREKcQQtA5QC2UYEDByP3jvi+YfvyG5bgy4D4HbfuMmp2GfjdyEzknRNNzs1xDc8c9uxVLDhMDpG3YanAPF/FP1puroU2BU8x7TLev/Zv0BOmwxkx0oISQg/SneDx4LYfCs5p8OTRr285QLc8X4xmb2/+t31G/hcbZmuq/qI9cVwQi1krB+t+P5u/7l52HaECRkG9wnsDFqEGEPzVpeVQQ7HENyGFEgskUtQ2ERDRc0+sED+RFsIJDo8u2m2prd7eC65nDAOcs87T3qa+C50hur2qakBHIMWACi//UAJelYSso/kiNoMJg+wS14WmJK6S6hMh9Ijk8ZMLAvOhSfCSwzt0QlEksowNGFyyMEmRXxAysfINxb69cNcwbkAxYF4A1mHG8n4yr/Cur9FzHDLoMvsDdiBN39dikjHIcchBzz8UfmYAni/GPteucC2ajgpOdz7pe2sLFqtNq2kMsC3Jiry7J11FnPg+Rz5NHKctqxC2IUIxKrEmcAhPo2OCI8/DD6MEc/rDJOXilVNSeEJ8ZCYkGsRUdDdBFSD+0zYzpTEH8Vze5I628IbxK/8ZEH7uGw46vml+Kyzsnbzeoh9jnsw+P5uMCtE+699b8VkxsP8JbbEBXICKYisBvIFfELaTAhIo4YYhA6LakoKTcoLyr03fc1DIcP5xvfHXbdZOCf0LbgNOoW/L7fHOJZ5P3tYsMu0EjFJswz+GL8zeFK7ATkuuraE5wJvvXU7wMU9AxALdAfIgZC9cYpAiaSH0Yfo/+y8N8ZSBOd/T0DJ+sj5p/6ePwy6xf2cu279x/nU+jLwaDDP+l9+1cBHQ/j1yvEmPb88hb/6Aoa6rrnlQdj+Mj1EuzG+iT9LBkGE+P1uOlZ/vn/9xCIEQXlx96b5z7nf/UVA9niKOG/9u/to+Ad5NbJLNJ4B5MJN/fP84fZT9ypDQ8ZkAP/BRILTQRDJZcmUA1wCrI8PTmmP/1DoiOQHslCFELhIPgnwwXQCp8p/CutB1wEquPl5j37ev9tzkPNNNwn3ZPdPd/yopegb91F2kHfdebgu860EfHf4n7klOAb9I71cxVVFPQDzwEuMEsxiDlgQ8EVxxDeOWQ44y8sQI/9JAe/FPAQbgDUBd7UrOWv647zCcIBwG681MGR85v9M9FJzvbmVNX1BdMCL/Xl9lQvNiXZKoEi6is4KBBRjE7QNKIwcii2KD0urDrZB2MK3vzM/JcNbBgR8Dv56OSF5m/nxOnPx27TreZi8dfsPuvt32TfFwk9Cyv12fRmDZgHhjJVL8kKuQlqK+wlADfHNukdBRoVKboiKxoCF5UI8BCnDeUVohBoD84HgA+s8F77eNoM5CTyRftxCAYNh9uu4WD3AO8EFfsXU+u49gACLfnwCywDRASsB5oWPxfyBhr/4BFRA5MQxRLC73XwIPNJ7xwCqwTd6fHwntxQ4IXq6eUl0RLVD+IE6EPyse/N1eDf5/ybAE3zgvJ+5VvkkwxBAB3yvu38DKoHliDWIB0IVgvkMF4lZCiTJQsUTxg9Nb41Sil1KFUh8h8iGdscSANtBR3+uwBb+dr2W+A62SjZOttB88/4l86i1WLS6MoK30vYfNTX3R350/a24D3XmO6U63AkCSQ5/XYBExaVCiA1rTBdH94iDylEJP0UvRkJFqkZzBlKFU/6C/m/7qT1aPo6COLdNOnWuSy6eNaV1n7Ivs5kwv/I1OuL5kjbX91o/Tn94Q4lCnf/mwB7LVAfFRQGE7wYTR1DTyRABCudJxkr0iJYKjAklArSCR4EJAU+BJcKmN3j4gTJMcY81VrcPr8Uw53S78UQv0u/Mb+rzUH5Ovjk1n3VDd9b0/MOEgo3/ZL68BaJA88cEhw7D3ASpBy6CWH4tfFt6CHqV/7g/3zyw+nJ2hbaZeQ+8Yfe2+0b7UvqoANh/4DoO/h6Idor80GpPk0lUC1KRhhKu0acUhdAD0RnZrdfPDyhQkM22TM3IBobh/hD/HD/P/PT3ObSwMcxuG/ECcJmvUO9ALNCqlDAx7UDxaTECtr74ZwGTQGx9GXxmw8qFdIkRSblCAAYZD0MOX43U0QvJac5G0YtQu4Xlic9HqAutyZ2JyLtEfOL/hf/w/37BM7XU8+g6W3RdOWU2cfjb+dnDTL4MgO36WP4RQABJNwgBP+0+icIQwyNNo0uUAPVGrsfYC3EJtguUf3BHSAeFyEbDOcJuwEBEEMbwBvC7nzxw+iR4n75debt0w3POurM3EgHyecv51DdpgH6/WIPXgXo9FX68h35GLEMWRMTCokcBTCKLGICDxNmD/MhGhufGuTgDfHlAocLav5V/7TLfNHD5TDdB+Ym6CXileuU/yvqjPJv4qL8AQD9Ht4Sqe/64ocFsvYZGlARveWc8gMQbANmGIIMIO0p/YAIKwmb/5j9H/eIBRcKPhO399r/9vsB+bQJQgD365zvYvlP7sUDpuYi0VjXsvT58bsLNvRz4nPYjQBy9dQCNQVkAewGBR8BDW7rW/9w+3gL6gyTCwHTounS75IAIP7JDPzbAfbX/KUIKP/zFFf9jwfMDOn/cvsG+XUPHhWhM/8YmwC+5qwBz+l2JAILtvSX55oH8OaUDAv5Tfr3DosTDAn/417pgPNCCPUHqR1u0x3whORY9AAMkxuO6K0H2ehq6CQATQLqB/QauxxvGZ0RY/V2A4X4aiMDHUcDUf1iAajr3CIMB3//bg7wAQoFpBKP/rzjYPQI8qkEO/JNAhProvo/BdwNd/XNC1f32ga9B5sHZPAnCCwOrR7mJXIXzQSEAZATuxNzKuIbCgp+/ej/2uqbC4EGDwzFElAKC+9H74fe4ezF+OL//Pvv27Xc7/Fr7qQFMggU4v7zfvTJ7xX53P369AcIbA/0BOcA1PMq+Kj/OAjNBgnvIuLw1zPTCuWx54ncK+tl56Llluq13GPLcOl997sKPu0E8nrilfc/G0Mc3v3wB6wChwN5Gm4IThNCEjEslRdFJHEJJCoJFSFCQSj4PX4dLSBRBZAY0f5XFR4H3AgqAUH0Zd2wycnGedJb84fdzupKse3FJdCM54TiD/170G/67/GoATnyLQS3ALUkMxbMHAIAOv/QK1wtDDF6HxUNX/aNH4AENCZ8ClYQVv6IDwnsGgMN5uT8rAVRCkoJEvJq4XDnsPesCA0hDO33A9Tz8wXWC6YcPPBUGewEURoVBFUHqQpmGbovxSowDa348xXEAzskrA9xBuLuFA9M7gwNdeyd/57yYA4wAiwAjeq75Y3jJ/2wBHD5PQ1L8nYGtQ9KFA764BJw/t0imQa1Et3htO/aDQwZXQb2EAzozuUtEhUHcQ8SCEL8JfaX/yLwLgjD+30cdyC6CSb+g9tiy9z5HgbmBxgULcza1LTzsPUkDeUbquU8AFD/vwD09UX0vQHXD3kOaRCy3Q/TeAOY+aUEgv8FyrS8tugi1Pj/6e+B///9VBchC3gUQ/3ZB2kNIR7RLOAH2QbAB/AKFhQRH6DkxP3KBQsaTBHvEVHYhuQiDP8fLBcZH13vEPNOC9IJc/sQASvqtOrV6PPdoN9c0en5KfV87ZPYmLXdn0DhrONTApr+rtMmx6b3BO+kJUom8yd7MLMp6hyaC8wKRi9NRlcvdzuE4XTfWw93EhYY5iQI0m3YAt1t2djifu6w4Xvqhujb5RbDlLoy8FT2GwxzD67a88y8DXcEeTYjOAcYrB/wOhAvojlSLl0hUTGGNAxCMA6fDZEZ0BaoKMYymuT49db8o/wx/9cFAcTD0GnmIuSQ6UTg8cchvSHyp+ct65HY/+wO2asXWA9nGpkP7EaRN/RW60ShMAUtTWala8BZv1lbEzoL4yhBI54bICd/+okDDgCg+lvJctWP2ffny+Hk5RejR6Ez3OLWcvGA8ufJzcNC+BHvxBvJHNYnWhuUSBE1LzMdKDRMWE4maPppFxqsFaoT7xdGOdZDK+uu7kbtmubR5KPj+atauanC6sFZtI+yyMoRxrzuu+Ohxh68jey12IUciRug82T1OBBCBG41rDaNGz0j9y1xObMsHiqMDIsLqh9KMYr9Nw2P7XfzcwGDA8e/5csWvKLIeN2Z2eOvQ6+61a7T5uFB45rWj86Q+mbuIAO0AKYJrvlWL0gdWRePGdgibyKUTQBIXw1JBGwJ/hLAMQdCzwJf+lX2ZO907X76ldzn5czz6uzwxFPJtM1s1Sn0T/LJv6ex2crbwTb2WvMa4s/QS+Yo14EORBSGCX4BgBCo/EcPOgUKBRkAqhszHwb9k/lB7Uvrqg4wGOLgjO1R3HrmdfoVAuzazOGd7Hfy0QfKEy7vu+vTCgkBchwCHggJLAf9Iloe4yh7KXAlnx5jNAY0+hJ4EDMdRiTsPhNK1QEW/WD6AQJBFmIp8+r59ILz+u424KPhzs+D3CkAlf9S0RLLO9r11JgFpwim5IvaPPSk3lUINw3U+zD7qggP8GD69QGR/LgNhiJKMJ4JfAhC9i3+jisHTVsVxSPxCkQLEhzlMHfteQJXBBUOmwmACbzXhd2SAoT8xO2q5PPZFc/gAc31pe7L3i3nfsxX+TPxJONV5QgILP2CHfMcHPX78wUhYSrTSHJSaxY8FiwwwzV2JUAuLQ6gGAsyTTlt9cD03/l496waqx171W3VkOSQ4Zr5p/rd0ujKj+Z547HqVvSs6UHquw9vFKrzJ/ju/aYJHkj0WJwlgyTCJzImiU99W7Eiqym0MvEvXCqVIf78D/rBJgYhCw/HAWvgVtAODk8FR/QF6d/oItjYEMoPxfE+9R0I6flIGuMT7+ta6xMNRQnfHUsOJO+13H/6YPa28iP0C9alz17lctsith+3YLEutZTkvud9qfC0l7NmuV/YKefixpfhQe3kAPr3mAwZAbgKmyX2MpoUfygQHbMiolTtVeMvLjAJIaAfUkCzQ34l8BytIzYVCwyY/1b8kOu1GZQPNuuz2fnNE7q47W/ds8mlxWnLgcEx8CnmkteC2QLm/eRc6FXwGO1C+IcOCxma+H4F4vet+EsmFjfiGdgmVway/AYpBB/EB74NLQcfB8IbdQ597G7ZmfA46MzzBu282GHIdfs65DTiNtwa15LSNfwC/DfhO/IC5ODxCPv4AvTgIffZ+IkL8BClKTIBKg59ENMW3hYBJZ8GiAzwMyEn0RoHCBH4UunDF9AKGPot6snl5s508/DYO9VIzMvewNCK2qvSxc4H0EbvBOn93YDmp9Vw4WkJQBGHBBMQmea868UUch3WF5YthwlqDqkdxxOIA7EHCg6IEbUIBQVR3IjYaPuG8ijzwfzM24LisQFi+RAAqwnL9wAAJByUHMUdXSolJTQorlNsVpU/WEO9Or826VF2W0cvWzK+RlQz0iqTIlEPLA6yPNUqkA/3/QDgcsoB7gjh788Wzq/ETa76wHG6N6Mkr720M7ZbvNzLGKx/vjrgVebp6kn4Vtkh32gUkSQSHzMyMhggFMU36ziIKc81jUsrSuJDiz9LCPANzSXmK6YTZSNm66ftq/9u+cnix/Gu2ifgsOEP7ALQCOBN4nTjHfKr/4Lgee8a/DUBFiDKMnwVJxz+JscokjD7PjY3pT14WbBPMiRGEgIm+xL6MMQmlQQr8TgHbeBh+VbpodV916/qW9pvzWXOX84X1zruf/fb4a7zYPMoAZkYuyywBecbkRQbGD8kkTbMDLce2jF1KW4tJCdC/2MBfCiIIZYTfwqr+vjjIQ6p+BHbZN6f6onci/B+3W3I38pj5x/eTOj35NrTuNiFA+IDQvuVBzrr9uvuDq0L1/mTB+P44PCZIdUIv+wC65btYuUsDOX+4NxN1SrjiNL43Vndm8av0EDtaeDLyjPQgMwB2doDgQNQ5KTti/2p+NIr5SzYB2wYKRyVF6EpmDUAGVkvsyo7K7YYDyFVCvIaBTN9Nw0RqAg99IfnqBCaDdzgUOWp6YTTbfhQ22vFh8QV8BXZIOtC0WHestLhGHQIAf6W+a//AvlqKM8g3fiLCOH/if5TDJkMI/UPDU4FIRe0CKAYHu/UAKgAyRNm+RkXLPNo/Fca+Q+U9ND9oe+L9OomSAw+83Ph5vd34nsJ4PMl6IDeWPkR5sjqtuxY3CDr4/7e98vhYfcA+eYUyB8BKhj0kgf+58T8NQqXIXXtuwQQ7ljo6gUNCCT1lAkyEPgJUA26/s3xY+5uJx4V1g86Ax4C6+d6KysQRQPuCpz8CO9pABD6oPEQDW0V+xxu9dcFNOR9AXAIGCM+9DAc2N7R6WUCXAda+tYdMuzw9OIT9PwnAKf9EP/L9w0TbQBEA0D1HR/vBA4PUQ4U+fD1HxGB+fHzOwZR9MD/JgqRCyrrewkK3Ejy7/7tF0nwTAQH16/Uv/b2ACoEQAzGFYX8cg3H+skEk/NiO68XJSPNAyAUSurvPZseixlCFhQMLvUW/2T8KfTlB6j6ngHezsrkhMeR5tLqLwOc0K3vvLS7wGXSJ97m4/YAW+/N6s73/egS8QLxyxeNC3glag6uEbDxdDogFAo28CnYLH4Y2SxfD9YGNAz/CGgJ4/oq9WPVI+Wh8zn9y+TO96TCX9v00cTly+VhDBnlr/zD8rrunu1d+vL/+gLtFR8HswPL8uEVKPSIMTMb4CC0FbAxvwiELL8VTiUnHbcmQRWTBXQAXQ0sCcAQvxNy2O7uY9hg4Jzl8Pm54eIF6Otv8x/m1PSB6M0NQB25LUMBIw2C9lb1dC9tKDsf7iVqGwQBnCmmBIYMFQ00HakIVxOX8Hb/hO/8G2sK5P2582zgz9jX+rv6pO4OCGbkfvE183z0Bu1fD/n8nhr3A8UMJekyAewFnxJCGbIeiA2DE40howzjCgsHu/xuBWIUOAdR72/v0v5O+hsSPg675xT2Bfk1+4v31QdA3ckCnumZ9u/tGfu+7PUPlwkLHPHpK/WP22nzvA9FHsz1hv8d+gHmxxba9hUE1wIQHaH8ShLU34AKCvfWLNwS9QMu7E3yLt/yGPkGQuU17OXMXM9F8k3uu+PPBhXkpwVK6DP5hNbeAR31PB9f5fECIN7K8cQGWguf6IQAGOgf8dgU4P6e7/fx4/1O+9Qo/hJIGbYOeSYTFTQlSxfpDooO2hpRDbvxge3j/4X/8RfMCKPSh9Va4g3okBsMErHwpfhk897q3xKgCHAIJRs6Apv+/exx3FTl2/XAFFseGOMd3wTlXdtFHskRDOme9fnjaOGODhP+9RexI6EmYyRHHRYKDzv5ORpOtk/vESwOvwCw+OAk2iMhByMUBuIi32/v79yW37PoxtoX7AXXpcwR1PjTwQSPB4/nPOrW6VzvfSjKIH8CHxB9H0A0g0XmRQ0kSDNVM0lKfCdaMBUJrA6yFG0dDPat/pb64QJPAR32CdFWwczc6NsN+3HmAtePtMnhs8JT/6DWevSk0h8Htt47AfPXBw+a/3ZB0jTxHsgHejdZL7VX0F1ZHS8nQxffILIVBiiC8EYP3+2OAQDCj83Xtj3WQc0i8b2jeavRq4O0/uXH+2bGT9IO0fTFmwG476P2FfviG/UVBzAaEx8nJBmcaONgPDJZIGMUQAUpPsU8gvrI/x3gftsx6/bjo7eOvX7Ep8zFty+zA52ZotDJj9ZW1rTYptcn0nwOBQKhAkr8JwraDC5GJTp7HtYW9i3GLR5CNEPmEjsd0iLpKfIL5RUR7AYBJwd/GlrRp+XGtSrUCd6K9KK0zMDmrC27zt9o7T/dKN1X7DzaMAvF+i4Brf9uOxUrFTdkGYMaWRJIWnlY0TVKLK8bVRTbQXVK/xTeKjYHgg+UCRka8uYnB5P2BAsZ3DHoZLo00RfqywdF44Pp1sjevwD39e6480noa+wg3FEQFPn1/TbvCydXHStB1DnnFxIWiDx6OiIsTzWeA1MTmhvhMAsDNB9p7RMFIwTaG3biE/On1z/qh/jsA1zaK9hj5FjaSv3V7F/pL9omE/rzwwbX50f07uplMa0j8BcuA7oI0vrzNrMzMhbKIe0Q+BY/IwQxAQ42K5cOxSS0BVYV6uHr9/QC3BdC9tz3sNPJ0PYF7wTDBCj7auxv1OcQX/Co+PLtZAcw+PMfCQAk9mnjIhKJCdUcHBax9gf4GheWIm8RJiMvETcaJjJFO9wPrRtGDjkVRiX7J8zxaPhA+Xz8HhVXCSztO9cTAX/ipQDm5RbjHc7EDqj02fYm4MnpXdRxG6kPXPpH+hcAEPuNKVgu3xAaIQkuuDoFNA5DDhbPH34ohC8CGeAgB++m7qMTQBem+cz5Tc8jvdf1S+ex1+vT6NBFx1Dnx9fhu8y2Be288ZX9NQLs3vncMiEdJL4Wjy/4EaMfPkhCUTMkqTGbIJ4ncjhKQFD/0v/G/EX9tg2EClHU/LiwzNi3itK8yaOmZ5hS0cC7bLPoqk6zfLe7+2P/vNo05G7rIPhgIOQy6Ar2HXkkkioqN4VGzQ9MGr8rdCaBF/Aiiugz7rsD2QDY5vLiN74buUHcud6TxijCEMpBvSTezdqUx4/KbgWVAfYPDgup+cb0FC2EJFQvDzUeF/gX/jPrK5AmPS+iIiwloRnJGo72r/p3BWX8DP+2/XLP6MeE7DvdTuxs7WzJiMOb4kDW+tzz4JfbcOas/lYBzOv87yQGoQ59GCErIAJjDyoYqRp+GL4pifmgEygbKSKwDjQiM++tATQOYBU2BfYQuPCB8swGuwg7AP3+TP/i77kMrAsB+xz/0xqhDXcnAx7M/9AC8iMBIjgp8y0JCMAHOx12EkIZpB8UHiYWKiGSEn0JsQfXDjoDAhG+B/TtquIN9K3hmv7R97HN0b6lypC/1d3u4yPCV8Lm04DSisZWzHvPeNm3/38KsN4D6BXxdfAuF1Um8AI5FScj1x6YIiAschc9JPUyPTSZLlw0fCc7H0E4PTPcGSoTywxs908beh0z783urOnr2MX45/ZkzVbXxuHH6w/sGPIG09zaSvErAMr4uxDoAUsBUSPXJYIQmSkAIocoKz2tQ1YkGyk8Lxwm9TsHOl8dRA9PKfEXVi5IK34NsfidD6b4Z/wF+cjmcNyw99zrUsWaxKXLbM4L8doE/s4Z3DTkF+Ss/oUepu4ECzcc8iczGVkz5BxcInxB1kEqLxA0dC1TGiw84DDVEuEIswv08VULzQXN7kXnwOlR2hnrC+u82QvOyPcY8MXqMvWC3EzHbAaz+aHzcgVY+3LwIA3NAh74IvWpAZT1Af4bAijmgdOs71jaD9qu4Du9FaKYxHKyUrQ3w+WqQ6ZUv1HEQqp+xTnS7+208ZYW1eI4/BYE7BcOJP9OPCRdQcVI50uaNUZLxzYcPjxSWk1vMb0qyy5CEMgyaSDIDdL3ew5/4QT9deVC4PjG1OXawNLJRLj2tkSr8dVq0eW7B75rw+K/ees6/rXqmAddDQYPlgysF433FhA2J8gqUh3mHG4LdwJ7KvQZ9BaMFbsTwvx9HUwNVPXQ+EYAg+6g+bPu/teN1Bf1tuxf6fjp+8cnv+Hx4/Ne7jQGgvOI+EsPZg0W7JAJoxRlLjoh5Chm+1IIeirELfQfJS45CUAJMST6DvcKMQ8a+qbuoA0S8WPr7+PX8TnfJwKg6mjgyM579lHlcBN8DTP65++KI3ARMA6CGoz84BTmKRc1pwMIGLz3Ewi2EF4kS/VdGtz7lAxK+MYPXusfEdUMEhd6CoES8OsH83sXcApTFIkPefTv6VMZqQXiEccMFgNo7Z4MPfxc6+IAqwo3EL4KsQky5+30VQ+4E9MS9R/I9uv5ggWw9Hv9bwrw67Ds8g/h8OYHXQB6A2/xEyGrB9wPhwNoIfELuDEwLN399vZ3Fv7/dA67GsjrCAKrBBIEeucs+mHmrQEF/0ASAd85/Ifwvv169IcRFeJUCmgJWAULC+4OXPA4+4QHwO/FBej5av/D6TwTeO+NAi3mhwnV1NEiI/tk/n70chg093IdXwqS6kT1eRCfEFEJZxfC5E72wvU8CHPniBgG8BIPqva6BFXkTgmyAKEJcwJYBsf1Mvd5GnkFQh7tFK8EEuuYH9PsJi22FyEZ9PeDHSvxmAyM/1wLsgFBDsoF3N+t34/0H/JH7rgJ58006BDrzOG320XxZNmD7Vrvc+ge6EzuCghDAQkZEhNvCk4L4hxcA4IvaiiVLCQn8CSlDPUZOxmIE0Md+iKXH6r6aQc47iD6LAnpGXPjOwyk4rbzqO+0Aj7aPQdl+4gEePzCAlX1rPobENQBzA1qEbkNIvpTIGf9hB7lFLQefATTFgwAKv+VBZwHfA2x+1UD981t1Nzfpehj29/8rL6b10jUX9pMwpLwK9kXAk/9sANh5bb5ARMZGwofYie5DO8W8jKZIpYsfykUKAUdwy+NA1sYShAgIt0UwSaEBsv/He8vB2XywRxFCC/3pecx6j7LKuh75Efc2+pV8JDmodk03W3XM+ZTBLgFAOGy/Wz3XwjFDhwXGPbTFa8UxBjeBlMIIv0vEckiEh+U/LAAVOgm7SsPdAdtAmUIF+6H427w2N6q53n7tPqoA836B+r114PYrQOlBQgEnAU03XLmQBG0B67/gxGF7dL5yxGN9+f5Qf5uDdgLfw7U8wjyd+khGsMKlhgZBA34VOcxDC3wZAGT+1To6vTiA4727OpF6lHUJesgAogEmemr+sLyMAuTBOoYcOJRCzMP5B3CBWENMPK/AkEhQhjCCAkB9v1C+yQe/AbwEij/VBON9gofD/ewG50JXCv9F+QQJPOy6h3muBOPD+4BKvUyzEjL+v5u+BPwKQHz2yDygP0W9pn7MgplDQciUgaA/iHw7PW/GSUi9gwZDDTigNjMEnL7FBpzDB/ygOj4CUHsDwN++v8C2guJGrwMn/+S/cIbqSJOIEct2PW0ECwXMCGVAgQQVdwK+NPt2Pag2GLedNOs3j/Rv8/zwIrAa+754qL2AeHs3NzRegeB72sCE+6E7X7uPCdIGYwd4QhAFN4Hti5RJzYNThdMGtQkrAI1C8HT7vMdBukbNeIN8SjFXt108OQEFs1u5XvGHtzR7gvvp+zT8WHy7fB95MHXSt2u2YwRSBNUAyTyV+fM1CQuLCPRLjktMRfBEQAqQhqpCZASJA/4JagErwIAxGHLnexH/17WcOjEomWvldt14xvWh+QUx4zJ++5G5CriBujOA1sKVynoHAkFvfd6QWI6NU5CScIi4h79Th1NWTuyRSD/txNOI0ooevIT9/PWkt9U5FnoYrDAs7jLscqa0+LUqboyuej27+xGBKn8yeta6ZcraikOIZUc7RTGD4hPs1K1Pdk+wzIJMaw7yD0GEF0m2yWaPrMVdh180ZLh+wDfHLvtuwa+tJa/buC45nrW/OXr2pTTB//B55zrudsaJH4PwUA1ImsLb+sVTrUzZGhiTd0vBg9+Q1YqOz97QaohOSDsI1sdvParDO7qZwxLBM0cNr9b2NrIiuXU2Oz636f2wu7ahOUf7qDy5NRS1HYI0PU2/tz0Awk/9ls4xR0TI6QMZzgYHmdQEz3dKnQlWDV2J80vxiWS+E75JBkRHLoLxwoL0E7JV/Jd75/d6uqq0WPMvvcl3HfbhNFr9T/pKQQz6SzU4saVCsP+Gh2eExH7BezIHl8WXCsYMdwSVhRgILYcGwmaHp0FoiCdKJ4x8u0D+nfojfiVChcVW88M1iDkiN2i8uvsodbAzCH9yuKf8I/hhek+24kTjvr4+w/pI/rC8aQdGBYHAQL/IQUHDesRViOi8VwK/hkwMFwd+Cvr6277uRz5JKwHABXw3FzcNP9b9i/m2OLU5SXWK/Sa2xLJerAQ8tfXuPjm5FbP6LKM/KzlKgKMAfTm+ujzAPQPkv20IPT7eCC9JwxJYgXBKW8OVzDmN5dVuPgtChgBKwUCC2gUDd+E2pj6Zt9u4VTM0sGBr43vdNyPyQC3NM4Ft6n32eyr3lnUTe6Y5wsPbBto7Fv8lRj8I2IohTxv/0IWXzzdTO0kLTO48GkCuxtUMPvvxAJf4BXbDPM28Q+7Rb412cLPotjr0rGmiqdd5QzeUvPD8v3VWNezEaQafRnjKQoTMBwWO8VGhhzKKaI34TUNWH1Vsw2CCT4arRP0I+YpA+nn5dP7de0R6jrnldAP0N/zovVPzg3VQti61eIPzBPS8yb6sA0OBIg1eDSVIR8jGS0eJdwxizB1IzMiI0ZiO+IdGRWpCf//KyTHICbwsu2v8vTbCAha/B/TatNz4HnWsePz4mbC/Mq04UTtQOX07O7nxuGzE7AV+wfMD+cKbAbIJ7EsCweHF3QmBye7Oe4zNAYmCroYWB3FH2wm6PTy9ZAFCgWb/IsKP/XX76YGlv5i3W/gWeR24FgCDQLM3oHcQPDK6I0PgRPR9j7+ZwXLCngHpBbN+9QJCCCWJoQH6w/ZBFwExCs6KYYC2gO/Bpn4KiQaHs0GmQSgCZnvOwJm9TblE+U6+ADzVOPO5bPSsc1f+r33p+ZA8hjfJt7pCBcN1vfLC8P8Av+fIY0kvgilFtcktCJqLF4t5gugBL4tWCULKRssThMV/FEgZAOc+AH1f/MT4R0D4flX1fjW7NzQ0uf4Pf9s3ufmxeXw35zs0gBi4rXv0fxc/hfzEgab7LjyYRCbDpP1QgBd2r/dYfnMA+fmUfHz4ZfOH+za6I3QoM8d193A4tHmz222xa2Ty6nE6dLM3AXNzL/l8UPxpvqjCFzyXO7zKEcxsyb4MEo0czLBUh1cMDG2M9VJY0VlSTtUxCOwH5M38iVpHCscTAHT7zwDJfOV0L3O0cT/tpzSntg1shet/bT/oX/Av9S2tDG3qs4CxyHR9+Lt2FHfDwDeBx/+jQloCfQIEjC0OCwhdh7nMMEXHDuRNVUcbg7RL2QCQgwS+fDlqNd59XPcjdqs1xjKKL6l0ELTPL8C2fvNhNFe29v4Xdd/+0cIGhKmFNIyeAwQI/AttTWLIEc1qyHsIBg4PDUNJbsqdyO0Bn4pCwjg9wbtdAyC71z9X+d12k7Fd/GE2kfhKesw1Q3TpfSG7ALjpP7q/1QOPxgvLQUO5C1TLq45AjI0QkUNhRpsIj8c3CP6Lj4ItQe4H70GjgqWB24CHwaPIoIcH/G59tMAe/mUFaYhE/O/BTUTOwFWEm8g5PgYD8kdeBIGG5Uj+ArZEZAo3CLzBckJEwKe+q8caBti8RfyRf6i43YGDPeS2XHaivyG35PrO9lby+fF3e2U2znfLuHG3hHYS/6B8w3mNfp6ATEIiB0OJq36KRlnGHMnLR5WONP0LQ0iDUIaJgRVJUvpkf1OCd0FMu7t+tv8IQE9GpcITekG4rkODwBRKN8arQGm8CkXku2YFIAHGQRc/48Q0/D/7bjsZPLX+OYIeAhN3ffwR+fP9dkClBzt30QHgfnQBEwPIirQ/LMdgRaYDvEBIAYl7nr6IxjrC3H+pvWg/3vlxCT6EEMH/wz5EqX18R4y/7P0IPibECoAnQ4ZAx33d/JNBQ79sO9n/2TmF/K4Ax8L/ujSDC7vt/gtD4wPeectBNT5hwAVEzYOyfTf8CcH8fHHAgz9xwUO9WAdou5S+c7s1gSW8O8ylRLuB3b9UQxt8xocCRrx9vwHffcZ9PP/AxcS72AMrPkaAQruyAWp6lsFlQlzEoDwxPtY7wHs6xc9Fkr/9gybC+3xQhB4Aob3MgapD0sFNwnlCDDyMPl+9/j62OWd+2HbceLY54nxzdWw+Bza0N9n7uHz+uBy9Rv4z/YfCRAEIPoA8SIfgAgkLIQiRSSQDJM5EhGRJJgexipYHb82xh26EJ4ORhdlCQ4KkRPT6V/6wutV5n3WUPKJyeDjldex3nHSau2MzGfcjN5w6vPYXum485DuIwjXCmMBggBbJEMBASLCDR0clxX6Nv4RfxqgBW4Z1gsDKkoiIQflEegL2/3P/4UIx+YVCw7pl+on2rjogcvO46DXzuI5xvnbYsgo1z7tEfbX5yX0qfR26Y8WWwstBiwTwyRKEL8ZzwH+CiEGbCsoG40a3wrDDcL28xhs+Vb7af1u/FzvNf+57TPt1vEw6jHjjOgh7kjUzOZw9Fv2IPorC6rjS/huDPQO8A4LIHwMix16GwMWHfod/6UbxhsNKmYii/td+H0VVPnBDegD8/BE98YBoea/9tblmPUb8cYD1PCe5FbesutP6UAO0AvH4j/rdvU774IY5RpC/bsSyQx2CAsFHAVk9zINySarIAMI9/qZA4z2pCfhD/IDX/5RCmv8HBvs/DX4lfmhC4QBZQoU/4boWu/5/aj9rfTUA+remfkY/S8Loe5BEGPzwxX1CBwYrNzI+CwHshmVIV0gKeks6g8Quf11HuoLUvym9s0MyObA+tTmRA7fDAIgZAuU99HpCA8UB/kdrByn4xvyne917sQJaQ9N4i/5lOnN7oXtIPXr75oK+BnyINz1fPXA/BoHKCV7KmztK/eG9izxnw/WAhDjKe3fAEX0pABx51zptuT5Avj5DPC/7ALx4vITFJwVivR6B738LgvNG20g2+4gBhfxqAeC/jUJqs3/4AflIfFD47Ps6tJV2FbrFd5D1GLV1vr2ATAj5Q067VHcEhgmD3IueyQcEuINGiTTFtQmdiJZH6wpTythJwcBJAm2/iYWnwyhGR7Ofd/d1x/st/T6AZzMUdoo4NTb2+V84RXkDOzfD9oCiu391c75JfG3H5oQpPMk5EAZlwr5LM0kMQ0XGNotHzIrNF823yNXPgcrsT0A+QwJ7fTeEvT/MRr6yHLblsxj13Hndu4xxc7QB+qL45gGUesq9drhvy4dE2co2gXMKTENr1WUM1cxNR0nTBk9gF7yR9Im8iDJMds0FR7OJ5bdqPFM6lH/vM9j5UW4jsvnyFLSiqpotgfCO9Jj8JjzKcuyyXD2h/fyNgMwJRahCJI3fiSAQvszYjM9LttbNUOGLPgYox18GeM38i+G7Rrs/fP79e325QMrvYLKMcu30+rPNuT7uCLOuNP11mXTitHv1k7eiRV+EeL+H+vTDD/2ZU/DPZwekxKWLocVLE7MNOwX+Ax5IS8VWBKzCcrt9exHCiAL89e24lHDM8kV5ILtPr5Ez2W6ZMaU2LLgHcPexsjrmeYKBsH6uu/S3FsVwP9ZFbcKkgv7/z0/ZCVXExEMXBRCFlM6bzjV/TwEnvpCBGQFeRZI2Y7n2OGU577di+/FxabQLd7b2CfR39FLzZ/Sef/n8WTjj81W4xXTBhY8DRX2oumoBWjxkSZ5H5cFug5RJgMjNiP5Jjn/BBVQHuI1EQDAG9/ovQiKDbsoQ+cdBsDZue/q8hr+eNWq4gnn1uSv/RHsZtg5yGsCRO7IFDL7qPR44QQUHP2jCfz6GAE4/i0bYBeV8ff3HPkQC6EV2So95koAZvzdDbEQiCVL65MDbQOGDfX6Bwe/3x3vVgOYBfzh9+Lw2ivXWw1VBKLnZ9q36FfT6Qu5AZ7y8vIYDQ3+GxBjBWvz4vmfIHcpFA0/H53+3AulMfhAnBb4KUkKRg0VJ1ErV/1SBaYAGf4mBuP8H87eypT3me8A9/noYsiQuC/4XupO7/nuvvE75yodxQ1w/aX9dherGK8+w0IEEDwXpSm1LpJC7EvAHMsk3DdsN5QmlScyAiP9gxx9FoPsqOgu3oPT+QWz8yfHpbs80z7KL/if923QGtam/QUCPhJoIEn7mwabPphLNy3eQIUf6SbwUhJfPS2sN9Yi6BoaNnQxogNW/f/21u80+J3vaszCwdfmMNsU3AfQnb2fr57y7Ovy7czsd+J315QaeBEsD8MTgh/JG689jja0Es8QEC7fLWUlJzHHBvYGIxnaFc374geb4ofgcfBg6zzRH9iJzjXI/ek54c/GY8PezKzJKu3V60bTndWw7G3uIvllBpf2Qf4hKKQjZA6MF5MH4AsROKI1IBPUGrIP/wcZICMYAwU4BIEIl/wO/zMAkPE4537/de5+8MPud99n080DMfDo6gnkQtMWymP96/oU8M77oPJc9ooJMg508UcGygpHHrsIlx806x7+TxOlHLEG+RfG8Rb1VBIMCP34rfuU9pDtbgRo+Ynjdd8E73reyPTd6V3P68fN4qbY1ep87VjY79iY9zHsp/YZ/vjp9PBTGUUVkg3VEToP2Q0XL8AwKhrHIGAk1xzEKrUuCgUMClkaBRR0FNcVXu+u5gD/MfEP7innu8i3vmbgh9w/zZTV/sGdvW/aO931yojYy+Zs4mDyIvM23+zecAqpCJkeLCfACEgB0CvRJW8p0TYQFsAV+SbAJFAPZBKpCi4CaRP5DRnpmeKJ7PbhXvUA+HTHOMeN1tfQIdVx41q6TcPT4WbhKdOK5UfT8d95BIkWV/zNDKwPyghTIkMychSaIi4rZSDsMVAwYRKiCYYnJhhoHrgXmPbw4rQABPgN6sbrUNQUxwPjiuygykTi69a406jpl/e10ZDsGvkgBeEF0xn7BREKlSYeLugpbUNyLMghKUM9PegoXTacNvAjyj8xNNcYWRCIJF8KBSJnHXr4+fF3CkX7egojFAQAGv6HFvgXVgb/IMwIUhRUKJw8IBA0KWkVKRLiHXww9wc8FTcHQfd89377suSy4JXxitvs3HjOKcw6tAziRc3fzZPDosyus9rjy94C0QXYT+ob4Hjz7gDJ5iD/aBgfJBoT/S/KFMgpQjtzT+kq5kPSKV8kRS3uLIQEvg6SEl4DDAts+xju0OBjCfX0efsu8mXj5dQ4AZbxUenT8JLcotfX96XwE9aU7c/mzeor9nj4MNn07HcGnhEJCSMdAP0HAq8mryEmDcAkUQjjEMsnah+gACECLAqi/fQXWg0I863rH/kq4KnyL+fE2p7XovYj37Pn5NyV10XVqwSE99nfC+bk5/7upRmPIQ36uBEEC80NqRIGJDjx1hf6EzQVU/iNAHbiNPL7EYcO1PQp9CPodNqfEPcGqv9I/g4CvegYHqwEOwTy+4EXHvmVFHn5xe736tIVPwv3/n7/9d7F30AIKQP759IDod7F7P782P035N//lvb4/e0LjAui81r4KQq++vMLpg1f94z2Yhl/BAEVURSY/Q//1CNJEpP+tQbg7d73JQ/uDJLqI/+H5xvvmvZqBlvehwAy86L0d+0BAHjeg/kyEf4PrgQWDtnsw+vaGnAPpxH/En4HMO0hH9D+bwsq/x8gU/rnG8r6r/b75u8jvgzWFNYP2vAH8egbaxfWBfMhpfK2BBf8uwOS2gAKWekRBTnqlf2oz9XsWfJp/o/voQg74NvhSQXx72v5kwKT9BzqJRsv+mIL7f7EDm71qh4/BYcF6vcjHM0BgBgmExT7Z/vADab9DfECBSjexvuU950A/9X1803SC+sv8nIGRdjJ9Z3m/eS6+mz9NfmaAhISKPxIEtQHAwup+1wsKg50FsUJzgiY9FgpkhV4DTULLAJL73L/0vuO3I72A+5u86re2eomwjLYbek/9DvjOvrK3DXfLPC95yvylAaIFf0O0SBeBrwSyQkXK64REynFDp8PHvjEIy0D/xSmEHH+rvR/EDb71vXiBAHumvEI/7j24uAm81r0dvgnAhgMdfMx/uEHCvtnCh4U5A2yEeopexhcHFUgIhokGIcscCZ4CqAP3wJP/MAUDRLl7rb7uPiJ7677xfni5T/y1fTg7w/d2eOy3oHlKAEF/r/hoPCh3vzg3PGE+cLnHwfrA1QFCwTiBCb7PxCmIWslSAuWEkr9Vv6FGrISQv+PC07+XfeHFAQAZ/oM/8T8ovC+ACvox+bg6B4ED/zv9tPwnt583jYLewL98fkC3euC9oIRRwhY8aIGNgTzFO4Ylhk4+cEEdwmJCZcJoQ5D8hQDKRA/BNUGzQBW+c/1Mhfp/ID9x/ND/+r0NRzBBvLutO1O9ZXzNAblAFPmFviJ9DTz0eN46Lvd3f8EDhIdPOnm/Hvkn/niFWQdJfW3Cr/zbPgpFs4HsACjBesI6v/jCAHtovoG8xEbCwuoAC/w8vK/7gw1xid2EyAbz/EF+M8T8Aj59FQNPPK2B/v1xPOf3ZTuxPpvCgHs+/h24RzyGRKHEur3BQPE5zH0CBfjCy/8RflT8OHwlw1t/NDv2uY6A3n3pRR2A7jwIO6BDnYGSgPGAo31AQ2WJlcuiw23F6IEoxppI3IwcgDSFcH8EwKU/k3+luqa+sX8L/hR+g3jl+fS3fQSAP4YDQ/wRwgW8RI8ohp9KCkQWxxqBHE3nBn0JWQiCDaaL10j5hNSC1AXjy65PUwAxw/a4bb0S/eZBGvbtvne1W7q2+Ca3VPUuOA97t33/exW4FLmctpBFwIKCwtb9XEBNuvRLL0QZRf2CLEjDxmCPPQiqR+PHBM7TUOIMtYykgtgFJkPXRtr5vn0rN5O8gbkI+5MweXNyL+5yobe3d7C1cvTru045J8DTO/b/O3sJCjoFzAieA5UFn0L8EOMMzIjJBTSGvQaIzoHONwDmwgD+2gG7OpN9pbEbt0Y27fmCbkxuVStSrvC1VzdscN6vnfKmsORAK/7oPxa96IQmf9/MAMggiGjG00/QTDcM7Mg/g8+C4k+K0ELE+gRIOdO6Lb+Vwpj1q/tqs9l4QvXSOS4rJHHitBl5Z7X692FwUzGX+0B68Tzsu187dfkciG3EQ0iExLHGToHfUFZLcQiAxkAIYoa2DR3Maf+OgOrBd4QkPZ/DQjI2OTC6cABK8dU4mGxN9QE5Y383MtM28TFpM7v8Tv2Tuvi614H2/TyGSoHCg/k/yAuJBBQJ7wLCg5ABMI3lC9nJ34d/wMvBHklnDcb/osYLuj09yHyDQWWya3x89+W+tbjg+/Yu+DP9upa+5/vivod4OHd3g/EAmEMHwBdBy70NSo1EQgVXgv8HpIS3jypK7sWKhfwJDEnHidnKuv2qQYcBf0R/PlRFfnZ/fwXA6YTxuVK8/nS4uPt+1IBvuAY6B3unOl/CB77K/gP82cW4ga+HDcJqwQw/X8l/B0vHlAUKgUKA+QqDymGFdUUNfeh9DkYEhfjAl8SbgliCggYBAvJ7bfyBRAdEr4If/5K3IvScgL7+jbz0fQ+5H/Z4wUJ93Lw4uwc+1DxwxZaCd/7U/0MEGwXUiXhKowBTwpVFhAl3SMaOB0QDx7WKlwo1RjWGREGTwbHKLgbZ/MB4iDt8dSLAifuUtT1w0PsldBb9RffEt3TzBAER/Y0BFoC7fh+9ws0+TGSHbYiEAn+E8Q3ZkoFJAU0ZRvnJqQmxDNX/+QOeRgnHI0NlgbszeHEXfw/71zhgdmUvLGpJOwp1D7NJ8Wn1AvK9f7M9frkf+LuA2YJyisLOawFHQ2RLD81aT1xSjATChdiLQsnsBVaF1/6vfhNHTsMAtxSz83LHsIn6/fmIriRuOTMlML41+PetL3CxlzsW+pJ7Pz3U+I767QZHh69Fbcfsg1oFJ0zJD6NEYoXGhSyE3ggiSg57Jb2mAaJ/w75TPe2wdXHIevD6XLfs9wcxSzAmOFk3ObXT96f58TiKvcD9xzq1fAjDl0LYiCbKEUH+QzFMpcs+jjdOXoVGRNLK/EriCIYKkYRow3IG04VjfTy8db6APUuBVgE8NmU06PrZN6H70rxj9Ym1Y/u+eGO5wLie9k92Av/Rv2I/Bb6KgKY+nEZACA8/74H9QdHChodCyfw/dgEFhVuDOYUCRSv+PT3xRdIDoYBH/z27wfqzQgOCg3uq/A771Dlj/6D/MzYn+Og6a7qeP+hCd/nn/NrAFAHfBEgHYr+bQabGYQf2xxvJj8RfRBqJxQlDBPWFKYUdAnDKZMbgPxY81oD+/IGFS8Mvu354dL0Ot7p72ruiNfh2x/squ4z4ubxjt3S550A6w5N7mcB2fhZ/BYbfyf4BKESMR/CHCEzlTlVGAggJDTbKvAkryPnEPQMfSK1HfADaQQ499HmLQgSAlffj+mD4OzUz/kW9S3Ttdst5l7nzfbFARLcFuESA4kCdwdUGMb8VAAAKVQq2CFXM/0imR/lPBg8Ihc8IKMgaR7JL5kyBAxkAE8JpPuhCRoQJOZ6257rst0w2LjmxscJ1MfsYfQY3dDsy90s6NwEghU6/gkNNA7fDf0mjzsZFnEe9j5wMWE5dz/fIUcckEKMLzslRxx8C0T1XhVxBi70M+6164LP9ueL2yK+58NwzhDNU9EG32++PMmz4qTuueW/BVjk9vBfDfcbmQu+J9oRrxIPMJcsdxNgGQ4g+A5jIRsPnPmo55AK5fBt+Znt9t5TwOno08aizWTMQM/lxrzigdm5xevRk9si5f3nrACl10rynvbe/74I7iNyA+gY+SIKIu0YnSPpEZwOHipsGZoBBvf1AMXpCQ27+h/sd9slAnre/fve8nTX5tl0/YPpZ+ZH6ojSqtsd+GH3M+Il7S3l0OR3+I8BLeBz+AX/ZABYDP4Tgu69/CoTRgzEEe4VivQ09oAUFwo3As0Fm/1561QXOALi8yD22Amm9x0arwNr9r3yoBqpEWweRx9JChkJpi0QJwAgbjf6E6okGSksKsUL/ygcAPgU9g8NFibjkfji7dH3Ofuj//nS9dUC+4PpSPvh+znkfN5iFbP2OP9Q97P0tvBNGBEGIvhd8GsCtPL2CgoGQuS48KL+uvoY/AkE89fl8hD5NgFe9bwK3uWO/mYNrxFt/ekMUwo8CXUkeRvZBQ4JVhuN/7ch0wYc9EvvVRo7+4wYMgDT/M3w6hiFA4EDSggT/wj+2hIwCQHos/0/8jj//QZsEd3Xk/rD7UT/Ufw9Frjas/ye/B8G8v49GPP0aQQxElEBzPkn+YQH0/vSI+EEd/kY510SNu8AIi4Is/pN7Q8PJe3UEp0Jm/UiBCIPcwWy+4cL2O7bBMMF2xLP2pL7H+GV9Nb56xFB3GX9BPmj8db8AgI07IT3uQxy90UIR/o/AJ3y3BkMAM4LRwDvBwLrtxdj+nv7gfpcB3nzWw9X/Krove33AIH2EQirB5Tn8e+UAqj6MAGZExX8pAGFFNUIdwVUEugUUwtDJE0XWQg5DFUZug7tH4UiDQXEB4wKigIMAKkUQ++pA7L3sPhS4t32x9U267Xo7vTPz4jpttRd4MTqmfqd3s3ylfby637/NgO3B/kLSSZQDcsUdw7NIqwYB0ENKxQf+BKMH3ADcCGBEqAOew6uFB3+Z/95/fPwfQDuBCsEMfOlAwHiWfRw9ZwBRecrAArlf+2z7df0597s9o74D/X//6X+DPTq/rAcexUkHPga0xayDgsqAxdhF8AchxwfFCoYWwKD+o/6HAan/8367vrx5rLqTO/y6eHj/fF52eLrl+pI7KPfcPQk4Zj1TvUC+oPiufbA+1gHvw3fElL2DgDrD6IJNQ+jE/IAtwWeGDj/af9S+N7+AvwSEAb7zfVY7IT3su4oAS75ouVE6BDzkOuo9Tj4LuOT9RH9wvup+mX/XekDAJcKJRDY+B4H3Pc+B8wPOxVc9K0K+wUwCJcIoPut7rT1aREuAeEMIPW79Bvm6BET+EMN1f+N+wXxoQfe8WD5kv1K+CcCofof9X3gse8l9ZsIaPs1BQjd+fKiCPIP4AdrFQvycACPF7IDpA2XCawLgw5EIvkBUQay76AXPAV9HzkJ4/sa8CIV5f5xFrQPd/iaBdYToA//DKMQaPBfA3j/FP+B8E34reQD9/31YPnF4Lno3vdb96oKmgiW7sz9WBcPDs8T4Qoq9QD+kRi6ELkLHgYk/j/0jg6N+qz72PsPCC8CoRbzBI70wvJCDk4PkR6yGk366wAeGdEZhx5zInT8MwYXEIcGUgKRB8783ARxB3zzj9yh2ADzB/IiBw/77uVy2j0FWu1JF+QIFgiVBSEaZgTQF5cL+A9SE7wfMhvHBLgI2gp2FwEVqR0t6Qf/ffgwB4n1LgCH2TPyROQD6vDaqtkN26bpMvMr7mHkN9fgBK/wBQ1g9776rfB4FPQAIxoOA7oHwwInGhMU1xe2EAoK4hKwFL4fUAShE/X+4RZO/0oSEd499/Pi2vZ12nfhj7lUyDnRsdsf1ALRVNBjyVrv4eFb/oX0NxA+AigatgB3DYEA5yesKrAqcyfmBxEH7hgsH6kS1ib0/YoVAfu4DUfh8vm63YH83Ngc7Nq20smZyDXeitoo4QTBdbzS5n/hsfwu99QDEPRlK5gRsCF8EHM21C8cTmM56C03Gsoyqii8N48z+QypDHoXyxasBQoVlNlt7afsZfiA2rDulsgO4HHkkvTnzarZTd0s6Vb+twi25zLqEQ6rAtggeBGuEe8HOTkgLCI7uCePKH4WqDycLVAn3SSvGiQW+xUPEB7sMfco6zH7zO+d/hG9ds971hXqLOVl+QzEXNMD5Fzxh+w0/gj3Wvh6EYQIowAPAdciyx1kQnkuLBZ8Ab4lkRhGOXYx8hzwD2sj4BRKFhIgxgE3Dm8JAA+A72cA1Nwf6VX0u/iG0yrao9i/20Xyo/aw3GnVO/nn5ZoO2AN0+nTt0SJoCdcerAvVCusCai1bJUwk+SCiGEATaCLuIzsLXyCdDPkZMAvHGCjnqf1q9+UKJv/ZDTDcreH88lrzWvZu86/lctehABznYvQ64ML9mOjQG8n2PP3A5KQMjABNJ6UYpwT697QKQQK/EFMZivYzCLIGyAuc9rAJfOKs/GoGXhQn8pcBJOd59GMK6A+e7ErrfPcA7ywEdABg5AjZ/f7H5hD8i+0o6HDi5g26/DkH6fKd92/u3BaWE14JbA46CUEJhhcQIPH73hBLCMkT6Bb/JefyGgF+DNQPAgmXDKzkDeDf/vb13eb33cbbRsvb62/cM9AbyI/ntd3E+e3w2twM2Ej58fjeDrQXh/c9/z4TrBVCEZoi+v0ZE08dLSpdBusQfvqb/88Uoh6B6nTuwvJ+7Qz5EvivyYnGYOOa2QDexdfjxD7CrO2O6zzgFuBX27Tggg6KGnH+mAlnCVMM8C6fN5MTXCD4J/4kmzLZLiUJqANhIeIXJRRVCvfnH9dXBNn7POS04crR/Mez8Prweta63U7k8ud4AicHzt9R6bMLnBZgIQwtAhH4EMkxkzIwLcs6tCGXJYA0vDCsDkMQnAivBOgcix8C7jPqs+r437n3/vk81PjQcOQU3CnuTen64FbZnAINASDxSvhx9sr6pCKaLE8GKxPnEAIVgC+mOlAajSjSItMfWCC3H9EKDg9dF5sVYgZeB7z2aO2kAnf/oOvO7gjlLt3u+xb41eJv5f3o++Tc/u//GuUS6/j8WP/gBnIKL/NF+BwXxBqvEOYemw3SEIUgJx4FBGEOvwwODPcchhaR/wH4kgf+8bERYwMM/zvsPQ0u8J0HEPdB9ijnYhDuAjP54vV855bp3Q6xEjDw2Pxl7LD3NQzdIPj6GhPrCd0T+wqAHKf/nhRMIXIm5RPAHHcBgwJLGKIWVAjADMH4X+tXBQf7dPjU9ZbvLOD3/aXzKefS3l7rwt8970TtN9P711/4X/0Q9psFaepN8/wQlhfdBLgacAl6E+oqQC9JDEYa0RybHtYpNDQoE9UVNxVoDTIJFRVX9Jz03v3O8pPuAPJs1qzRrvTe66ngMtwM0sDLg/Sx9ILf8+Cb6BDfGPwgAwboQfA5DC0ATxD3EXH5tvwtKVYjNSaFJU8TkQL/JhofVBaBFnkPH/RgFbMJoPON6zzwO9pL8czthMwyzP/cJ9pc2RXnz8ODyqzkI/T04fz+i+dH6/wF2Q6P/FgPHxK3CWwrFSwwEqAOYiR2D0AmfClICrH9ahmm/A8KGAR87oLZjP5W6kfbntbBzC68B9+W3Vu7OcI+z8jJzeDS9WDQBuUF7v3v4/PmD5zuNwSuG+McVxTzH8cVoQwuLCkkiRVvFnYVL/imE9AD5vRP7RsEdORF/pP0VeBt1on2ZuQJ6Fvu3+Jo4ZP8cAB56IQEC/iwAgsEKxau9cQZCxRxHVwfzirsEWcfNS2sJuMoISs1F2UHCSXjBhcGQf5rAt7lHRRl9c7tSOeX9zLksgKm+gnh0+gp+lX3l/dMCbfhIfPSADsFh/KXDKj10gmqF+kZKQA/EH0REBq7K8MyKQ8OGDocjgyKFwcZ/QX9CUkc7QE0BFX6YfgT8swQsv2l7eLovvLR5+kErf+t6c3wZv5P9pH/Zgk878kFWBHrD30GoxSq/RIWoSEPKNUHoxc3A6EKwAz/Duvvh/0w/VzxTAXz9gPlO+VvBDnv2QrB+3LvcuwaD6X9vANkAAr+F/htF0cKxfa+/Wf6APdjDHwF7OKU9q7z8/ztA/oOf+ZW/KL2hP31+YARK/jWCmESyQwvA/wMIgxNDHInMhQDBEkAzwWQ9N0SygDB9azwBwOS6+sDK/1V9NH3Rw6L++P58P1X8df9ohJJDrPwAf106THvpQYpC1zr0QQY9ePz4v0pAEjzbQc+DsEH3gcyAsP3jPnAGLIFzglwAj4BCO5dG/D8FwIT/yj/m+soDRf47/HW+xsAMvouBHoA1u5L/AkGjQd+9mcIDer297L9tPup41b+8Ol49t8Db/3n69X40/SF8LkKbAWd/m4AiQ7B+WQTVg0vCeoGRxvBAuUJhAnQ/vECtBaFCmz1gwEk+UQAMQnREVToqwMs72r16PDfBK7jLgjA+Oj6+u9E+WzrpPlSDFsCnQSdAKYB6fCaH28GdBMoDq0a4QDMIXoLzwl1EN8aygw1FoQQJ/cYA/MJcQwK+jsLD+dn8kjv3PZP4BICa+Yk9ovt2fLj37H4+vg5/iMAzAPI+gL/IRdyCBcXfRSnEywNfiY5DGcSkw8PDTUFZxdQBO77GQEFAO39XQELBzjmCPkX82H17+ps/27dQ/Uw7ETrCN6A61zjhes69azxn+Oz6Dn0bOu5CTIDuAOlCsMVsAZKGScRWRUiGf4gIhEKDtYITgaIBSgVIgtG+CD+FvRl6sz3Se+c5XzyF+1m5dXmwN+L4V7r8vll9SDqt+mS5CrnIv57+p73eABN/Oj4Uw/gAToEiAkoD5IGtxI9A2H/Ff0pD2X/RQmY/4H1j/KPDB359Plb+X3ycPUYBJT4uup69P/0NAE/BMUGu+v3+v794ARJBJ8S8/YZDxAMeAuaBQgOWwDVEUQW/g2YAHL+rgQZAMYb+glFAP/1HAzg87UddQIBAuL2nA9j8wYGNfUN/Gz/xAwVBPvubO/N7AH4+QZ4DTvpJ/3F8Xv7uworDXr5zhEXCooP2BQgDOgDzA4dH8QW8xMLBPYFuv2nJvMOiwbR+vcEqffBHPADvvbu+EgCpwF8ERcJ8O3X/Wn6vQSX/GYGX+Yr+sny6viq5xn0S+eo++oAmv5V6Tbvz/aI/54c/BN2/30ARAzPApUhfhHZB6QFzhU6/+AIQ/Va+ID0ORbeAs74muvH9aL1nRtEFnT1/fuS9or+rA9NF0b1Ng5P/A0M+f8ABW3qHv/5/z4KUu0e7Enbxt/kAHz3Kel+5rTfCNjJCd3ywfrj8zH/t/QnFef/jAZsBUYZGxlqC2cM/fj2BKYOxxpq9kQQdeqdBqr8zAmc4yX+ld8C/9nvWfuo2c7mMOVy7+PsLu6l6yHsIgdQ+N8DrvGICDb+/yW7DEwRpf2zFpALxiiVFhkRpQk+FWcR5A+ZD8IC8xBiEUwa5fcaBeHs5QpP+3wSjuJw9HzWYukh5RXzMNk95pfiSecZ75fmOPHt8LkLIATjFUX+/xl5DY02MCVvJkgQYyS3FCc1gyhjHNsayBgdFEcUJA8tAwwQcgImEMHkkO332g3ql+rk/QfQ6N2k1RrdafDq7zLsr+wSAD7/0RVxCRQX3wv+NQQuoDScJgUoWx18P1Q0syJFG2sW9RQhH3katvVK+Y72ngDT9FL+qtC03eLgqe0Z25XpedII3nTsQ+0x45rjl+o+6noTqQcsCEH0zw7I/t8uJx9oIO4MOCxbGJ0tYB+RGYASISS/GoQK2gnI8s/9YwVDDerbd+Vi0sHjbOV2+X3MZdlv1FzXeeXN7vPfneZR+OvtQPnn60/7/Ov+ICMNTRaL/J0TsPa7OTkgHiBvChQWdwF0JMEZ+QgUCWEN+w8bA68OCeGy9aX1kgll46j7fsyb3tfgpe3j1N7kat5X4+L3PPSy7Azk1foN6awXWQk5CBv1lRMy+XEkkhGjCjYC6hozEI0Q6Ax6AKQICRXfGzj1AgP96Xf8ywGwE0ni6/Tl4+LuSfAW/6rnTPJ99jjsjPLI55TsOuUYBxT3DwBb6AX1pOH8Fi8IOwpM+8L+vPI8FYAP2/yFAoEBjwQFBiEPZeYH/lL9bRAb+l4LGeBi92b4dQyB9gQJzfAD/I7/tgcz7Ej19fGV82QFywFt6KbkW/Mt7gsJsATp8TLwDgVz/2gHSgT7+tP9SxXyFokE2wml/80ESBV/Htr5dwn//C0FNhBvFxf5Lf5NAT/8jwCJ+b7reOZD/S/0k+3U4I3endIL+RX1Zu316+3txOWwCuwIx/rTAx8J9g2kHTsfOQelEN4Z5yK6GZ4fav8lB+Yb4yVFCakN2fb18+ELWgfA7dvwj++46YACVPPa2FPTI+pT6D8DQwAg5UbeswE9/9oKSBIxBAwKEiyOLiQbViJjFgchWDcpPx8TFRygFHAaWiY0JhP6IfaCBG/+0gDX/MHdKdpi9m/uqeUX5DrQItRK/Ln9ge3n8I/tS+6JEtQWHQPSCCUZCRfRL8orPBQlD9guzCiJKdMlLQhoAuIhvxozBisBYeki5CQAV/vR4gXlNd2r2b/rZee/1bDauu2R8I702Pal4fLimgfNCGYJzBfA+hf/piFAH7wW/Rs0DvQP1CdAInAQ/wd3EtoLqRYkEnP13O9vAjf6RvkU+OPjnuD39WHrxeV46PXfdeLA+sn1wuq36A/wgeybBLoIpfUn+GAHzP8VDqsS3/wqAPAWlhZGFV4Z4v7MAAQaWxsHBXsKY/uA+ogOBQs++Br1Ffuc8VIBa/mT7oXrhAHg9Dv+2vYZ5iLjrgJ2/9H9lAQR6LPnMv2I/Y74cQYf99f8bAtODzP8ogC0BrgKDhTGG8b2qPqRDR0KbBA4Epn2WvXUBBL6zv3b/h7zN/B0/xH0a+0k63XqI+U9/Pz5n+Z85vXp3OMu8ib+2OE57/T6y/sS//4KRu5m9oAPVhPMDskSRQa9/kEeche+DI0J4A9oATkZPBKP+vL6twM9988BUwFz4Dnkg/PS7YnwQ/Xd1d3RiOqQ6droIvXV5EXg/PiR+RzmmvRY7KHw7gPnDXbpV/SCA4wDChbFHUn92P1rGasRchoZHMEMYAHwGfAJagfmA2wCOu8OEawBVfAj6UjscttC9r34AeKV5VztLuep8Nv+/OjF9HgBOQk9Ah8SiP0o/xocCCM/DuMYHBXVCXAnISWUDqQRbBedBjwcHxfM/c337Qtp9/j+n/fd6KzZL/Xj67znU+tX4E7StPIa9M3hrPXe7YDxXwvoGlH5Kw5VD/gcqCFAN1YUMyHFLHsusijLNBMcyBNfKm4csxGeEK0JZPZFDSv8tPHH6vX0bOXZ9073F+hb5Y7z1+rj8d0CLPBH/dgEdQzy/MAT5vnsDIAVgykzC40hMhNNF5IgWiuNEBAalx+FE20T8A/Q/en1VQtK9An0zepJ5sHZ4Plq7hro9upU62Di2fMr+u/pJP6A/FL8ef84CBTtgf1rBe0JZgbXEhT5hf0DFiEWPA0oGmwL0AdUHJUWBQTyDQYHPQA4CBoAE+6a8DIAM/Y/8sDtV+RG3qL4V+t86R7zz+tf507+q/LI6Nz1D/iG+g0EdQeY9JcAHQndCIMHlhTi+xMJYRKzDZ//Iwl/9Zf5/gqT/jnuye317/jmRwZr8/TrbOV2/ZTouwMU93f1dPV6E5H8QQFh+9310vrMEvAJz/ojAWPtGvIaAggIZfMZCQDzV/t5/YMIce2UBFAAugZCBVsLuPSL/0IXNw2ID/0I3v1n9T4ZjwHIB10BlQCN7V8HKO2W8M3x6f4R9J8CyPeI7a70iQP9AXb91g3f7Kr73AHv/i7zjgez5sD47v/T/lTx8f/99G/61AjcAQz2sPnCC8/+EhKhBiv8zfQlF7T2fQ1gAbP+WffEFLn2WwM9+1T62fVNB44A3/ehBML8Q/y//5YKt+/FC6MBJAmp/WsPE+W+ANL/owXy85gH8eZd9TYE2wKM+20Ekv+i9c8MEP7F/0QDrBb6AC4UZgAE/eX6mRNPBAoMBAz49+b4ygRz/h73iQ+g8W0Emf2oBdbnKgiX7kUCV/iXB7rku/3m+ZQAWP8tBfjztPd7D0P8Pw5GCBYLo/6rIKwARRBsCFoQtARpHTkNwgMwBUYFifsoB7kIRPHs/rb2kPMh7jX5rt+r8crsMvRf4Ezz2+Zv72L8WfrE7Xr1Yf6J8gYSbgGdB/ICjhr7/Twc2wQjEtIGkSJrB/ARmAXuBDz3Yw1W/ob5rQa6+Sj5jvmY+jnjPP1P8NP8bO7u+8/ctPBW8K/28+wF+vfnCexc/oT0TvmT/T0F4vy4E4gAtAvgCSAc4A52HiMOfg01BqkW9AYaDVELdP5s+yEGOPdv8sf6y+56+Fv2Hfi15JD1X+/f+cT2pgGX5qP4cPsI/1P6NwUp9VgBlAjUBG8FUwvBC/kNhxx0EGkLxActESYF2BsTDpsGgAH3Dcf5KwuE+hX6g/pYCXf+UPvB9QjwnPMJBQEDc/XaAcX0+/lsCBUGv/miCxwDnwxtCf8KSvu/DIUQxxcYCkwK3/mX//QTqxDyBBcI8vvU90wQV/08/af/EALo/0wJl/kl9MX0wgAMA1/8SQDj5+/0pQDsBE/z/QJH5CX5NAMmCCr0fgQ09kMEnhAiDUP/QwVtDLYOVxgID+sBgACUFTEHWwyI/6r64/f6Ecz/kfzj8x3u7/DuA34AAu6K+PvoUfZC+yQCWufg/urvmwB29r79i+Q29Yb+KgTX9xL5FOks7kQQ2AjfBYYDD/10+rsZMAqoDXwMsA9WCowW0wCh/tz3qAv+BQ0DmvbK6vTlcghtAOX/swOX6wn0sQhLBMD52gXD8vwFDQh0DbPy3QCM/LcLjAXVCkvoue+z/03+ef9x/LLnm+ihBEj26/zP8t/zQvHADoQA9glU/3oNaAaQHYAT1QtBDl0YUxahFkASIPqFCGoMgxM7BjwME+/X/iMEwQdM82r7CO7X9Aj8Nvfx54Ppyfvm860CNfIE9JbsYBUjBngRe/79A1v4rR5vEwgUDBEoDwEOqRZqDyAGEA/EDE8bgwjvDQL1cwSMCVsdfATyEVHsDfqg/sIFVvJq/UrrdPBy9o/rW+pz5rL4x/U5CgD3//xn62sUsQcFHhUQkxarBwIj3xHLGmURPBGgEX0YXBTbBrEHbgM5DT4D0grt7Pb0dvS1/FDqDPJl2gPjpO4/7nvpROc35TTkzP5T86z7Eu2XCpcAnRcbCxsSKQfGKF4deyBWF7ILrwpoHCUa9AmxCHLwpfiq+8MEuuYj8r3eQuvA5vfw39P24QvhzuqH5QHoQdwb40H9QP64/un2+vZc7aoUHAwyFBsIfRIaAJYheg/sEl4K4htfExkXVwks9xz0pQTuCsz7YAHI2J7h5+jm9JTfzu+f1Y/k2uTK8Urb6+hi77X3EQANA+XvTfAKCwsHRRNAC1kFJPn+IZcTuyBKEh4V1wVcIzMV5BOKB0gHuAEqDekQwvR4/bT03/7i9YsG3Nga77/nVvn255/2w9Wm5tPwTPvT8dr21OyE6ssLMAp4BgwCUwuQ/Vke1hSGEOIPdxiJESwWSQ1H/6kEIRDDGcINjRK/8yb8pgSSEIr8tAv76mr1w/mk/yDqyfZ18Jr2JwBV/dPoU+kd/5z7/Qqd/431gunLDMoBew6LBc4Fff9WFcQO6gfHC6UFhg/yE7Aasv5FDPf6ggvvCvsX8vFJAkP3XgRsAYoHl+/29dQErwU3Apz9dfOd7uIPmwMdALv10vZt7NoOMAEJ/hL2gQKt+sQL7gIW/wgA9BHDE8cRGhNWAOwHWBMaHywQcx7O+s0H6gwxFJEBUQ2c/psGLQ6TBkL2vfGr/2b43AmQ+UXs1t16+jLqWvuX7xXtzeOIAB731PlJ+UH9vf77FaQV+gj4DV8NMRUBIjUqiA1OFMwS7BbmF9odwQB0BbgOTgyUBkQC2PDo7boLpAGn9JPpcun533wDxvZS6uDfrfAA5zED1f0W9Fry9wqNBZAO2A7R/7wE1B+SJD4Z5x0KBhQKcx2/Io0L6w7P/5/7QQyRBJ7qmOSL9IHs2/fG7R7SYsrZ6RXlCOr86drXadhz9lL5e+89+TD2J/z2EQoXfv9UB0AMuxKDI8Mq1wVPBw8PJA6SFBMZNvca9pn/iPqg9Ifyo+Dc3kv1ofRu46De+t462N71K/Tt4WfhvfbY8OkCWwZB9KT44QyNCbgRQBXxAoIIDRoJGtMVpBYeC1YJkhpYGfwHWwXBBd37YgjNBMjvme5Y+U3z5PpE+dvhlOLd9Rj1EfVu9zLqaesVAYsAvvmP/9b/tQA/DIQN6PxrAiEJ3gjZEUwV6P61AGQNXgywERsYU/4h/dQIfgNvAhUFFfZY9YwI0QGk9Uzv7fJU7KkELQIS7wbsTvgO8x8BvQb47JT2uv0qAEr8mwbh88/+3gIECcj8gAb3/ngEdA9qFrz+PQbIA7b+4RKLFFD+YQKDAz770AlOBRf31vV4/5P46/0M+t3wF+n8AP73o/NB9NLyhupMAy/+I/Bf85n6aPUzB/QImfhdAK0IEgwJEVkaNwIYBuUSqxAAD/sVBwutBnIWeAoDBSwGgAH4/EQRQw2c9KH03vGU7LH/iwTW6MrssPEt7A33W/uZ7AXt4AAv+qL+FgSn+Pf5CxAzD3UEzAz0A8gDIBijHeAMoBRJEQALBSBpIXcQ+BLAGqISRRt0GEUE3vr3D4AGlgWYA0vz6+lLA6z72/De85bscOr5+x8Bj+59+Rr4lf5HBNAUFvlfBkkQABafFxEoGA4sEJQe/hk8GXIifxYyECggyhh6DUILHAcp/UoQmxA6+YPzf/Zf6TT2//nu4nTho/Bl6Zvo0vDX4BLlv/ki/SH10gZP9WP9eBD4G8UK0RmkEq8RNRsxJsMUnxgjHtYRNRoIGmMDZ/lFCkv9owF9/NPuodwm8/bpcuZm6c3nE9348P/v296s6HnwV/Bn97ADgewd/E8BswtFAMAUpP+DB+kNaRRMB3QWpwt0AzYW/wuFAnD+RAeQ80gLavuu7xXcx/SD28DwXerv5TDaJfTx5NbqM/A48AzzagImBXn04QMk/i4F7gXlEYf2AQU8BJEDTQdPFpD9ZgZQECgIMAlNE5v/3AJrEcAJ8gCWAVn6zO9eAgz73PAG7hf68ed5+W/xA+aF4q38X+759R30re4T8LwBfvxT9bb+/fsw/1gIgArc+RgKaAgNCGwNUhJ9/L0MegzPCW8KDAwc90X4GgZG+hf8Gvoc+h/tUAq99Or3ePJzBKb2MBOTAOf5CvbNCx0CLw0ICev3aP1PBiIBAP0/BorvXf3z/QT/0fL1BQ70CQVwBGIIufK0AW/+WwOWDd4P4fui/1AOWv2JEl0ISQDu+dsSofgXCb75Fvv/8boJtfjq9uH1r/za+NgHoQQ28kQC+P16Ae4AlwkO7S0FTf1HACT3UQCe64r90f/iAif4PwOh+GL50At5BEL7cQIpB9/8eRXZBJb7APp1CnP5fRDXA2D8Vfn+Cer7EAEDAcT6iQCcBRkEhvPBBL38rgcvBNgIVe0lBg36FwX8/6QKgOyq/EH6UPdm+xsCWvVS+w0GZ/Xl/kH6QQLQ+WgVVQDfAeH46Ark+aMWMwdQ/GT9kgUu+xMF6QaY9b4ELAMqAcj0WAQn8JsENQJZCTPu9gLT8Az7bv93Ahf2vAOGAQ73Bwlu+5gAcf7IEyX+2xa0A6EI+fuOGtoEdxAvDIoFqv9kDg0EePlEBD778/3P/Ub9/OY5+T7zyPlM8RX75OQg8yr1g/QO8vv96/XF+VYHW/nH/3QBKgmaBHccpwo/EswKERbEBnUdtRThCqIKxRKQBAIIHApx+OwCvQG5+8HwIv0f7Yn8tvjO+37mhvjp7gP3afml/zXx3PqP/hjz4f7B+a//fQAoEQEBNg+OBWkPVgi3HZITtxerF5UUbQ9hFwgUegbaEEMImAiLAM4EG++n/t/3V/vM6+P0pt6C74DuTfQE46ryq+kj793xofCJ6n72xP4i/Zf/L/rA/Mj7zQ0ABv0KHgmmDY4INhmQCr8OaQyREIUPwxZ3C5sG1AQSB2wIqgTOAovyWfpL++z+xfP7/tHqyvm4+gb5vO/q+7fz/AHtA+//4fVu+kL/cwUMChgIE/1//XcHrwAJCZEEs/pK/IgISP1SA/D5+Ppv+RcIRfsZ+kHyrvkP+SkGigBP8Nr0Zvin+wn/nQJv6eD7SfvrAPD43/8Y7Mn8bgE0BML/dANC/Uj/GQwMAy0CFwNWCBgF7hH3Ajr6T/boCJz/0wzI/pDya+7/Agr5eAGO/l3txfXy/UH7M/RZ/eHzFgQ0/vf+TewL+Rr8ZgluBxIJ4e439KMAHfqCCWEFS/fg+BULPvpLC/3/QAI2AycUMQc6Bej8xAbYA14SWAh+9hj1Cv+3+6AJ9AEf8j/3EALq/X4D0gDJ9MkDkgflCTn/OQJW+f4EwA6fEcD6YANj/pQBXQ3VB8PztvgLAE/8xQp2/kH17/ACBVn8Gwag/V78aPvKD1MGDweCA+QH5AiRFB0M6P7VAxEFJA5zDmoNCPGo+pP6LQKPAKgFzfCB+jr7A/iV8bvz4PGr+OgFPvxL8RnofvtV89sPbgAS/CTzOgrH/RwSaQQTB24FRxD8CV4G+QKyAb4LjAqSEFX2Pf/E9lQHWALADUHyKwG79UUCjPriATrtKv1H9df6ifJk7uvra+0L+enz8/OU6Hv6UvA3DSH/Awf7+ewRFAXcG/cLyxESCvYTuQ8UDVMIjwEuB7YAJgvL9D7+OPBO+6nvn/r931jvHegl9srpm+0t35ziauw38Fn2o/FY9tft6wL49+EGLf51FFMOsR6+EhYR/gixGQgZnh8FHT0FjgaGBLEKPwHGBgDxq/iK7zT2e+CN6RbktvAu7471ld+p5Lbpt++a/cn+y/a78dEDMfzeDh8IWg6WBv0evhIAGfYMURYJD5wfnRd2DeMHqAlADY8PqRWE9Ib7DveTAI/03wGs4UXyJO1j+ZfnW/Pd4rbvSfrxAgL0Affs/Y/7kxTFD08HfQP2FCYOPSDjE64ToQeWHzkX3yAUGPMPFwcuFv8URwnFDkj7RQF5AjgLmuxd/YftwgD5984FlOFD8CvrN/tg+uABDPB67EP9a/cIB4IBJQi4/UwZUwk3EyAGThVNClIicxWrENUGkg1ICzsVOxbK/kYDn/9KBw4ETQ8z8v38uftfAoH1aP6l7M72FPzg/UDxFPDJ8sPwyQUT//X7ivCOAuz08Q9UAIgEBfevD7YBvhNyBQADcPzxDgwM+QvgDuf6hwLTBxgOp/wvCNH1GwLU/xwHRvBP+OL2ov6WAk0DbvNZ7iMBOfqcChIDOfxc8QkINPhoBsT6avy/9eMMpACJAWX2Lv6b+XoPkA3r/aj8zwJcAwoNoRHJ+sgC4wVVClMBWwlu9R8AjgVlClX6o/xB9Sv4QwYfBbP4D/SS9SfsnQAK+SzyZ+5t947v4fuC9inuJO9PAtcCygEXBg/3ov6fDXwVGAhWEegElgpdEL8VkP+RBd4E7wbQCIsJnO+G8IL7lflQ/336pumQ4az1vu0m9GTvqOlW5Rb76/Ti8PLs1vMR8i4GcAeB9vP4PQLhBZESoRnd/cgGnw9UFT8MIhPb/PQB9wsdEJX7Tvzg8OTsygD6/CnsXeXJ5pTe5vaE8cPhU9/v7EXrP/eK+HDtp/EHBpgK6wZBCx/81AAlG30hUA/UFBYK6ge0IOYf6wrWCkYItAMrDcYLXPXo8z78Ovtl+ib5lubX4fL1r/jp8eP1rutX6lv+LwLh9UT+ovvU/3MRRxRyAGoFiAtgEhsZCSBoCY8MeBNNFRwRARTvB1ME8xP0D8YARgAg+lT2QQfXBBfxdu877pLsi/wP/DPu7+zf9Hn0fvvs/kv1MfYlB40HJANuBUr9uP3BEWwWdQaCC+kCggK2EzgVcANeB/oJRwdhDAYMjvxn/RYIiAR0Alf/RvQG724EyP/P+9n2TvLJ58cAVP3J9zX6wvh29hcEaAVS+F3+QwE7B3UIKRBt+vL/gQnnDuoHRBF2A60FzxTSE6oGEQy2BCUF9REmDp0BDwGcATn77QZUAhn7uPOi/7z1kPsT+lnx7u29/uD2I/tC+sTv4+96BSMFBv4fAwH3Nfv/CVkT8v+5C8EInwwgEuMYbwRKDTYR6g/eDioQTQJGAIsNKgi0BuQFBvui848FUwLH+Fb9bu827NP78Prn78b0MvNp8ID+Qv7x8tLzv/88/w0IXQ+y/Jf+oA4oDQcLwxOxBBMHkRaYFnUMGhAXC0wI5haVFgIJUgcnCMb+vwnuCF324fMV/pv0cfqm+fnqcumU+QH05fFb81XowOm8+dIBFPE1/Bb4//hTBnYQIPu4BgAKKAhQEo4U4wJrAswQcAfXDqsKUwQD96EMdgGm/PP4Xfee6Dv8FPc47PHr8+xI4VHx++6M4p3kP+7o7Ezy9vsU6JDtnvru/pD9aQ74+1kClA/2EqEGFhIrCZoHmBSqFeIBiQHvCGb7jAiqA3D3CeyE+qzno/WW8tbtgeJj9pHqne147Z7vTeo6/SD/AvOc+sf5p/prB0ETrv/WDAUK2AwICycXsgJnCwcTuxJ0CgYPbARG/vERjAdGA2P+Lf957DwEvviD9HPuNPf65vL6M/ai8krxjP4e+n7/gAY0+0D/pQoxEeEEJRTXBKAFSQ2eD24A8wvYBlcE2A1+DVcBOQa/DAMIeAubDaEAO/4HCo0CnfzAAUP68fRmAhb78fQc+Cb56fHpAcX8d/Qp9nP/0vqdA5oHLf5eAckJIQW1ABcKaAM8C/0QxRGeANgLdAPJCOoQERbJAL0K/gT0AMsC6wQU92X96AHd9/P3svUF9mXzvAhb+en58PVi+i71PQtUBF39rwG7Aez89wV2Bz74BwVdAjwDzPxHAhbw6/3hAsoIx/tpBZr3D/6CB5cFFfteA08DOADHD3UEOwGuAmEKLP3uDW7+vP9q+lMGvvgBAb/8WPh09HsB5fgu9qEAe/WS/K0ENgQQ9IsEMvbQAnQDFwuX9OACZvx0AAz6iwLL9LX/KAZGAY/9GwDs+2n97RDzAdkDzv8OA7X60w+N/0ED7P43BWT2jwY//kn9lv+nBS/8l/v8/0by8/90Ap0IS/cJBzvwSf+O/wMIoPSHB9v4oP/1/N/9JPOv/4kAcf2DAGv4Q/tW+VYNPfskB/z7dAV9+SQVev8zB14CdgZ5+vEO9f+Y/TICf/6M/goC/AA282b+i/t0/3r4TQQw8Wn+4QDp/4b2QQC39Qr/4Qd0ALr+YAAiBmL/AhFJAukIkwQGExsDZRUqCioJ1QjLDycDnAcvCV79AQjQAuIDYvJn/8ruNvzB+T4DQ+hv+gzuQPO78Mb25+Rf9Uf4YvU49anyO/Nz9WQI2/omBTn9pwiF/ywWyQUWD9ULTReVC5oXUg1vDXcV6xOVESEJywoN+jsJ/QJ+CnL5uwgI8V//IPsHAB7xNgPG9i4AqP/X/f72O/36Axn9uAeb+wH/cfufDSf9AQruAUsEsAAtDukApQZOBiEGiQMWBzMADPd5/Jv5hvro+cL8eOxk9uny6/Jc81H5T+zv+EX5dfrJ8674kviC/gwF+AEG/Lz95wWRAN8NHAWbBKAEIw2LAYkMPAJmB1AGyA87A5wD8ft7/qH86AZ5AiP8Kfy39qL0cf2t/ebzV/+H+V39v/qN/OfyJwA/AbAGX/4V/wL6BP8XCkoH5QDzAUoClQLnDPME9wAGAXoHbAL/CbD91fy++/cFcP6pBHv63PrH9zcEWfw8/bn5sfrf+24H5AGU9qH67PgIAtwG0gmg81j+WPtYAj4DuwXW9g4DAAfOBvcDAwEEAqMFkRLcCfwCK/+vBh4EShO2B9T/ivulAsT72gc8/rb5OfvT/tr5vvlt9M/xHPtUABkFGPa8+FzzR/yvBo8JdfpEAXj+gQJ6DuAHSf8qA00GSQNCCnf9cvx8/MsKfASIAZj4Ufkm+eYKTAbQ/Tf+RPpJ+woK6QK598b7jPeE/ZAFUwNX9LD6ZPsnAq8BCgTi80r+DgQQCBD/4QG69BwBBwx/DCv9sP1594P76wnoAoX4bPXZ+a32ZwPg+iD2DfYEARb7bQG2+mf3m/yUCnkJHgWQAsX4j/8GC5QOkP18BObyBv3O/o0EkexQ+o/w8/un9zr5semz8dH5dv3k9IHxGu2i7wAFcQA8/ID3i/qj9PAMyP9UBFgAgwhXBYMOqAMdAnYCcQyXEOwHDAg5+C7+8AOgCYf5RwE/8L39b/4+A7XzVvrZ88H96Pu5+3/tPPAR98H31PoH80fyNu7sAQb4kwJN9toEnv4CFAoI6xEYB48PngziGDkVfBDEDcMLIg01Bc4InvhYA5385wdY86v7a+qQ9ub10QAP7/j0gew583/6L/zL9dr0QADO/ggF7v4xCEYD4xVgDu0TlQp/E80PbCBSHgwXixKmC1kK+w7mEJYAegUq+wMBLff3+aTtrfLK8hf7P+6P8Sjqge2Q/Hn/MPke+D/5sfezCnQEbwqlAkESfAnKFbEI6w5qBIgZLBKgFVAN1QjWAdwOvguDBJ4HHvupAJn9zQNB72n4ku2t+vbzEv/T6fjw7vCU9uX1jPrh8PDyKgTPARoFVP6aBIT8axh0DFwQuwLpDvoEgxs2ERMQ4QXnDBUFTw7UDGkCCwOSBC4EL/ml/wftZPjY+FcFuO+O+fbnAPNy91ADjvQc+J7ybvFb/wX9H/6n9h8GIvguCl/6Awbj+QoV9QYmErIC8Aak+0US/QtMCVEFhP/Y+wwEPgVn9mr+tfdEAJ77uARU7jb1RfW++tj2HP0Z7rHxw/i/98/4xPRQ9rrxdAZe/QIBNPfkALD2dw7YAn0CZPs9A2b+pQuqCJb/hQJgAv0ELgGjCf31cAPtACIKMfmrAeDv1PjF/jcGtfbH+oP0cfNnAdH/jvol+bb+OPfoBRX82vwK94UEAf2WBHr7Cfgc9RsF5AOJA9MBhfmr+PwFygg6/hwIAQDnBpcGmwyg95gDrP7uCEkD2Ard9Tn6gPwM/33+MwFr9Qf0f/+i+S74TPPC9bHukQAj+Fj0i++392H0ZwLlAF73pfin/3oCFgfWDfQAyAlzDV4Tbwj0D7EBugmvDLkSfwEfBkX5/fp9BfgFava398L0avK6/dX4f/H27Pf4W/QF+cn1MfG87iQCGgHT/Z7+I/kQ/G0KfxDaA+IMfQZODjsN1RURBPwNMwyKFSUOaBLX++76agWOBSsDggBp8k/qbf9K9tP2hu5z8g/rvAH6+lf0TO+9/VD9Jw2qD3L/IQGsDr0SfBZiHEsLMg8lGMAZsRHoFMwHIglTEXEQcAN8AEL76fjvAncCS/Jr7v7yTu8B92H3oOhn5xj4WPY5+Xb72vKf8sEHwggMBZ8HTAK2A24TBBcaDPgMQAxjDccPkRNZBb0G9ArjCiMGlgb4+ID1yQITAK35ovmd69joDvjT9aXwCvJ57sbuiPhu9wnz4/E1+0H68APzBGL6bPlDCbEIRwv/DjICTgFdDUoN+wZcCrYDAQTXCm8KbABTAFL/6v4gBh0F7fiX9BD69/Nl/SD8wPKn79D7mPR2+x340/ST8aQAtf38+yz/jPy//aYGuwp3/rAELQICBuUHAA8y/+IDuAdTCHAIkQur/jYAIQnaBmgFBgU1/P/4JgQqARz8svsv+oD0c/+7+o3zt/ER/O/2Nf1n/MHwPPHN/QT9EABRBJr2yPgdAiADlACQCNb94QGfB/gK+v4dBwECfAYQDR8Otf6C/9ECKv6aCaMHpfwc+HwET/rI/6/9uvV68gEA8fqP9S33vvEv8Ur7nvtX87X2A/fg9JX+3QCm97j7gwCs/moF6gkY/VQD9gaPB/4IWg0w/7EAxApaCt4D2AYCARr7YglxBEn7Pfu5/lf1EQHG+djwk+1K+A3xQfnj9rftjegr9xnzOfbx+l30pPPb/aT/U/kLA378tv+GC1gN/AHZB3oHdQeiEq8StwVSAi8KYgFJCLYGlP3b9ZQEFvpN+Nv4JPFn6nL87fiY7xLylO3e59f2uviS8S31TflY9qr+OgU3/CIBMwlUCagM5RKDB+AJzxWwFNwRuRXlC1AGjhSWEZkF3gaIBmn5nwaoAIz3BPSF+8XxY/qa+QbwCu39+V74Dvh1AHX2a/ijAw4JjP8dDTcE4AkRDkUWnAeLE3YNKxJREqEZAgYGCVIPLgvCC2YQIwL+/OUKI/5GAbv+lPpR8twBJfqz8v7wKPXc7777xv+i8mP4ff00/kH/lwxw/SwIxQi4DB0D1w+SACEGvQpWDI4DNAqDBJwB5QpiC6EBGwW8CLP/iAVGBBj71PumBTH8lv1P/R70YvEf/xz4APbz9wj3o/BF/x37Uvcv/bEBBf3uAw8FQPswA2oIyAd7BKwKzPwwA28JCAuFAPkLy/2/AFYFxQMK+/4CuP3F+nX9Uffd8Tfxr/1f8138c/UC9Jnt1ATU9e/9kvw4/Pz61ggUASD9ygTs/s0DxALwBeP1eAKY/I4C4fxeBq3xnP+b/9EBP/0SBnj2Ff9MCKYCYgHpAi7/DP8lDr4D5wLg/tIFU/rxCUn9/Pws+ucD3/b6/hT5gvKw9u7+9/kd+pr+9PLD/IAAJwEE+v8Ezvk5AOYBZwJJ9w0BzwAw/5UE7P/M9y/6WwiS/40L2QK9/3f70w5k/tsKdAOvBqf/rw3c/dP/ev9KAyEBGQYeAPr0q/0i/pIBsf0YBljwOAEQ+z8C4fh2CJLzZAMj/hoAPvgAAj/7wv9HBC3+1vhG+u0CYfokC6//Yv/p+kgNqPx9C/P/EAMjAPkPSwJvBfkBcf8mAt8HsATj+2MFB/tBAr/+igWr9MwF5vtfAan84gM89H4C4QD3ARf/IQJR+Or7DAi9/wYESQEgBBn7pw2j/AkDNP+7CqL/JQyA/2P9H/69BMf/9P9gAm/0Yf0W/Bv9/vRtAfnykv30/IX9QvMd/0T3PvwIAY39zPbR+lcBwPy3CX0C+gCC/bEMnP1aDHMERgfjAXsQDQHlAwsBJAIGAS4HKwHq9vD+9feF+o761P2S7C37xvTG+Jn0lvyo7zT9Ivx3/S73a/2m+Cb90wXc/wP+9P1PAqn5XQrn/VoCcgC0CgYAhAuqAIACowGsDEoFtwY7BZX9Wv4pA0n+rPhi/kj3WfpZ+1v4/u8q+E/31Pn/+c/5rfPt+lb/4/9lAIADyv57AH8LsgNDCcYIIgr2BrsS6AUbCUEFqw6+CokQagjSBMgByQv0BUkH4AOM/PP/3QEe/075/Px49eX85/ni+o/wBPlN9wD/KvwS/g30HPsV/98AugK7Aqz+zwEoCAkDGAazAlsGkgZhDhsISQQmAWIGngRbDCQGuv8QAaUF7wNLBrYAc/xq/ykGdQWx/4n+evgm/gEEUQWM+qEC4/WA/jUB+APZ+Y0DEPwDAs4BWgG6+Yz+Ywf6B6IIggSL/RH6nw1kB1MJ/wTT/nv7gAoyABMAu/2O/M79KQMm/Hr1u/ce/DEACv0z/qbwe/mV/hgEhfz2A+vy6vzqAjkEG/7fAhr4ef6OBvMC//t9+mT8FPz+B5gCifx1+7AFdgITCmAFgfy6/0kLtwlPBpYEUfhg/OcEBwLp+hH8zfTa+KAAhv5h9or7Bvox/ZwBeQHw9Av8NgJyBcUEfgOf8zT4QwUqBcECPAE69u31zgNq/HH7r/ls+6/76AOL+t32/vSdATADmQjcBE/6zvxFCUYKBAy+Dcf/KQY7CgULswKzCPn78wTcAvAFs/OY+Ur10fy0/zABou668Dr5Xfjj+9n3m/Hz8Rj/bflE+Dnxg/Yp9vsEbP6K++71CgFFAKoKZAc//gQBKgm0CgELSgsQ//YFRwkuDPEFXge1/xgFaQhtCWcBYf8UAGb/qAaaAoT89vdZA+X80ggz/cj9zvYcCdYBYA2+AtkEPf8EEM0LOg7kC7EIgwu6CmUMqwEACDv/Owgd/cACE/K2+ij3hwBF+8n/VfGW82L4WPkx/Kv7kvrH9zUDLftb/0D30wXPAPkPrwdCCKf/+w74CSMThRCmCXYK+Qz4DZEHtApy/gEGmP6fBOH0Q/rN8K74EPE694frV++M7nvynvQa9xzxovEb/Eb4JgBl+rf/YvrQCh0CYQsiAJsMxwMxEqAJVQkaA1INuAikCwAJP/zQ/wsCuwVJ+2gA1vEj+1j1PP+67ln3Oe068wLyrvhU7gH1h/QC9SL7Zfev9//1igVSAT4M+gLcBMD6gg/TB8kQvAnkCjYDUg8VCMUF+gPlBYoFwgWlBDT2HvqL+KL+mvkoALjsv/PT8Xr6L/Of+7nxPfUY97j3hfaA96P6uPZuAon55P9N9Q0FPvs6DDED4Ab2/SkMPgbUDP0KoALCAxgIrQseAWoIc/jBAc78eAcl8tX/3vBY/Sv3TAGj8On5jvUQ+U35q/o79WT1eAEX/McCJfsc/rD1CwvrAqYKxQIxBbX7EQutA0kGSAXwA3EFvAe4CFD9CASDAKMKBwNuCrL11P/L+1EF7v3SBaT1MPte/sj9+/y4/mX9MfzQBuX+tgA5+8EDpP4SC6MEeQMs/XsDW/+TBxwGwv+pAK0DbARrAg0G7fyqA94EgQlN/0EGgvy4BboGswsi/aQB8PxvAJYCJwQF++L65gD5+t0A//vN+8L2YwVH/HUDWfpK/Vj0lgWq/qoBB/9EAHr+LgexBqMBsgV7BqYLQwuSEL8BigglCfEOzAkXDxz/CQOaBcMFTAHLAnr7NvrdALH70/gH9zj6bPbGASL97fn99BD+SPljA5IC3v1M/aEGAwVxBeAGPQCFBc8KZg5XBXII1gSkCKYLhA+iAYsDRgNSA4kF/QQx+oL4U/9H+fT8OPj/9k3zMv/z+Mz5ZfVY9+P0iwFRAgj8PP34/cH/DgfLDPr+yQQZBjEJfAgGCygAMQHSBeIFigQgAgr8+fhBAfj9pvvr9+D3efPO+8j4hvRB9On4vPbZ/Pr6Z/bl9Zb8JvxuAdQC9v0S/XMFcwT5BN8G4gP8A+UIEQlCBKACGgSVAmwFSwbB/Zb8AwES/WIBPP9y+Rn3+f0e+nH8+Pm6+Jr3M/6J/Gb6wvlo/Gz7pwEAA879cf5iAj4AVAXeB1MANgRwBYIGRgUeB5X/9AIHAzkG1v9uAXH9gv7OAPcCmvs2/GP8Y/rN/gj+hPnJ+oP+Cvxr/6z9wvrW+hkBUP94AXYA9f8a/k0EJgTT/84EaQGQBOEEFwgI/cgDyv8iBE8BwQQx/Cj/AACi/5P+uv52+676hgDG+6T8QvqG/aD5cQIW/SH9dvrx/3v8SgQ4AB3/c/2kAnL+FwOxAg//awGLBTsC6wHNA6r+AQMYA98Dvf44Ahj+JwHLAVYDwfs5AGr+rP2oAqD/nP2I/MAAEvs2Afn7+PwG+yoC/vsRAJL9BP1//LEBUf9Y/s4At/8d/8UC4QFO/cABngFmAfkD2gJW/uMAQgFIAWUA/QJI/TcANQGI/8D9aAFH/EP+dAG3/WT9/f0Q/iX8/ALd/WL+wfwPAOr7FwMwAOT/Vf6BA+j94QHNAi7+kgBrBKYBQgAZBF39XgKdAe4ECP4vBfD+iwI+Ae0DLP4yAj0Br/44ARoAIv/z/jkEFv3/AA7/lP2W/B4C0/6z/8ABUv7Z/WIBdQHS/OAEmgBpAkoCCgRi/R4F2gBZBDYAoQbL/vYEEwPSA2T+mwbB/t4BkgOg/8T+jQF0AHn9bAL5+3/+Nv3CAoL7zAKe/Zr/WP2WA4L9dwDOAj7+EQKqAy0Cz/17Bgf8BwSG/zsENvsfBgr9/AGT/AsD0vilAZz/Tf1P/dz+Uvry/OYBk/m0/wD82P4w+hADifnAAXL8wwFF+vcBv/zv/oYAYgN5/qQAnQFm+rEDAwHSAWn/LgUK/LgDGv/dAYT8OwS1/cj/nv9l/b76MwC4//z85v+c/An8Kf+zAVL9pACY/oL+sP5xAyz8SAG+AJkBav8yBsv8GwH2AbUBMwAtBIr+q/4oAB0A9v4M/pf//vkhAGsAtP2o+///3Pns/3kAsv2M/ZIAHQBrANcCVP0bAJb/GwR3/vwFpf21AlD/jQdQ/QQGkf8WATIB9QbI/tECVwES/loCiQBvAfj6LANb/JACqvwgADj1gwEa/JkAEf0//w74vAHg/u3/x/+x/2v+XQFvBIv9PQO1/l8E5f5QCEP7rAKQ/qMFF/4pCHX7j/+G/r4C7P7RAj7/TPx2AiEBcgFX/BADA/o7BSkAvAGt+kQEePxUBfv/mQCe+7ECaQABAlQCzf4O/rwAMwTv/PgDUf1EAN//xQW7+eMB5Pl4ACz9YASf+Vr+evw7/8z9bQDZ/dr4ogIk/o0BMv6hAaP43wa5/jUEivwsAyv9fwYmAr4AqP9LAXwCaQGWBaf8HQGuANIFhf6rBnT7rAA9ANIFj/0SBcf9bwCpAZ0DGP8V/3wCV/2ZBD0BJQFz+acEDfunBbv9IgLZ+GYEKf0DA5/9yQBz+6sCzwET/hgBXv4AADcAswWL+YECDvz3A6n9sAj6+EICvfzDA6b9qgT8/fv9PQKXAXwAC/89Adb55AQBAJUB1PtEAHr5DgP+/+f+Sfu9/9H9zf9EA0/8oP6r/zED+PxIBUj7SgA+/5QG9fsyBcn7yABE/wEGy/1dAQABrv+iAlgD8f9J+2oDrv3SA4YAOQD1+IICMf3VADr8c/+X+XcBOQBR/UX9X/4g/X3/MATs+gIADf4YAq7+XQal+ygBHf7FAxP/9gNyAP//EQOKBMYBwAC4BIf9iAZIAwYDDv7HAzP8UQUX/0AB7/rrAQj9FQG8/Yf/G/mzAJr/lP1A/wD+3/xhADkDWfzkATX9VwFF/z8GrP6UAowAzQPKAbYEBAICAJIDdQMIA4sBcQLZ+yMDsf/IAe/8NwGp+gYCjf2J/+z5RgB2+wwBzv6P/nD7DgAS/9wAtAHN/4T/QgBtBFEAzANrAGwBMgGEBXH/ggFgAC8AoAEGBN/+yv5Q/hb/zQCHAQ//5PzQ/m7/ZQBV/fj+3vczAKv9pP6L+hz/jve5AZz95P8h/EYAv/5kA1UDkwG8ANkAoQU8AY8HPAEtApUAfwZT/joFu/26/nP/iQIx/fj/YvsU/Dz+df5M/gH5Kv0E+zz//v0d/+b2OQAl/McACP8tAD77zgEUAgIBcAI3/8EAUQBrBzP/0gRi/4cD8P+WB3T+ogCs/fkA+/5zAwD+tPtH/ML9LP4i/uz9a/n5/U7/gP05/On85vhx/0cAk/+h/OL/v/xAA4ABxAJF/pECLgK0A58EDARSAOsDEgW4AXoFVAAIAS4AjQSB/VYC8vo1/mv71wA0+4f8nPke/IX7OP/o+2L57/xF/bT+zv+i/1/7GgKF/2sD4P+YAjD/cAQ7BO8EBQILBGMC/gIcB7gBqANfAVIE6P/NBp39DwIt/cwCKP2OA/v8lv7F/CMByf3+/q3+x/xoAEQBOwGj/BgB//vFBMX/uwQo/fUDWP9zBQoBAwUM/84FjgKpAl0D4gFtAewC1AMm/0EDLf3nAXn98QPg/KkBV/yuAHn7WgFe/Eb+Mv5c/6b+9v5G/mL8mQFb/kwDmf5nAgv+GQUj/0QFnv1dBNn+bQVpAKAD7v7dA3oAOAJAAnH/NALi/4gDzf5TAiP8mAHI+5cC0PxRAAv8zADe/OsBw/2Y/kT+Xv9BAeT/kgFG/tUAL/5zAzf93wH//UoCyP8AA4H9IwKk/nUDPgGsATgAVgDQAQ4BXgJ+/6YB8fziAq78DQHU/T0BV/02Am39hf42/XL+mf62/80Acfwe/xb8ZgF6/BgDyvv+Ad794gPR/HQDYv09A9kAHAP2//wALgGhAJ4DMwCaAY/9IAOu/O4CIP0KAWL8PwJz+1r/+Pv3/bT8AACX/Wr9Rv6l+z3/Af0tAU78zgC6/E4C+Py9A4/7dgMu/nEEsv/0A7P//QIWAowC0ALY/5sDaP+1BZT+PwP4/S0DTf5kAxr9bP9W/Tj/nP4A/hb/nfq+/dT6AgAC+foBEvpPAUz9RgKt+20Cr/2YA+ECKANTAk0B/ANpAtoFNAFPBNX+Pwa+/uMFlv7lAQz9EQNI+24AMfwo/s38tv8r/Pz6cvyn+ob+jvyOAU/6EAFT/N0BSP2HA2b95gL/AeYC4gIpAkAB1AF0BTMALQXM/rMDof5sBZP93wLM/OYBZfwdAkn8zf3o/Ln+4PzG/Wr9kflx/b78nf9Z+xIBnPmIAMn8vAJC++4CVv1XA+ABHwS//1QCmQLnAmEFDgIyBB4AqAcGAEAG5v6gA4n9SwYv/bQDi/3HAGD9zwEa/cb9S/3c/Wv+q/6UAMH5gwBI/NMAEv0WArr7PwFr/9MAov5N/5H9E//xAcf/pAAQ/tIAdf4uA9T/DAFd/y8CpP+qArsAW/+0AesA8wFNABUBHP1TAWr/AgIW/rAAbPss/3v9fgBA/Mv+4/2F/Vj/+P0y/EH80f+U/TcCB/4nAL/8RAOP/wUDqP8tA63/JwWVAhwCgwJyAeUCCQLPBEv/ZARhAFYE//9rBG/8FAJk/oYBrv7TAOb8VP0a/1z9Jf4D/Gf/aPuyAbT9v/8x/dcB0f2IA8YABAFkANMDqgEnBCQDygHjAsYDHQS4Au8DhwJtA9QD/gMLADgCZQDiADQBzgHs/WcAg/+s/af+Zf1v/LH7RAB3/E7/Kvyp/WP7ZgD6/rv/jf9FAZn/kgKlAvn+PQJCAjQDvwPkA9j/9AJRA3sD4gFiApv/5QFtAVkCLf5lANP8o/5F/qH+efrU/PP7dvs7/gD9U/qq+4z9hfxk/0H+D/62/TkCagAqAXgAYgCBAPwEsAPtAeoBvQFVAj0EkwQw/yAC/wAHA84B6QK2/JMAof48/4/93P17+/P8pf9N/Pj75vry+nz6qACF/dX9KPzX/g/9dwKWADIAyv9fBBECCwZTAwcC6wH3BfcDpgSFAk4BygFRBBMCi/8AAPv9nv+z/6f+ePo4/aH7wPyN/eX7MfhD+/f7H/wG/+n8r/yq/NoAIv/TANX/gQBEAE4FBwMVAsQC/wAdBDgFRQV/AcUDbQJlBAcE3AKn/vcA5ADIAKL/6/6W+xj+wP4G/av7X/3E+cj9gP9z/kj8lP4z/FD+ygAeAH7/3v/eAogAMwQ1ARgBzQGzBX8D7QWZA1YCYQSeBQYEJQOyA+7/7QOGAfUBIf3WAe/77ACh/ET/RPkq/y/89P15/Ln95/lI/Y/+Rv1I/vn9xv5p/gcDqv4uABsA0AAEAv4DcwHBAbsCbgIGBGsCcwEkANgCdgIGA1kA4QCU/boByP/y/179AgBq/HQAaP9O/az7lv6I/Aj//P/p/MH97/2JACv+aACi/Tj/CP/eA+3/SALs/+EAGwKFBG0BFgLgAfUBbQODAk4BCf+XAbX/LgGu/xn/VPx8/2n/9/2a/hj9O/sc/pr/Nfxd/2H8Fv9T/S4B9/tt/xj9vgLk/oIEFv4IADH/DQMpAdEDdwHpANMCVQMoA1IBygKH/6MDvwFbApD/mwGS/7UBggFb/lf9hf7g/3r+dwEd/Bv9xfx+AP39fwDg/a7+rf4GAxr/5/93/yP/+wCAA/7/pwBKAAUCKgJJA0cAKABbAOsBzAEZAQYAQf3R/7gAk//A/qn+A/w+APAAPv+1/tX+2f0EAfYABgD1/tX/4wEdAa4C3f+l/qAARwP5AGcD9v+x/5kAKQPk/0IBvv4hADMA6AFK/x/+zv5I/mkAKAA4/wr8SP9i/jUA5P+5/mv8qv9S/0kABACS//f+5gD5AXcAWADW/3sABwFaA+n/cgAk/zwBZQCNAif/z/8x/xkBOgDWABz/RP7t/7b/aQAX/57/wv1NAY3/HQHe/YcAv/30Afr/RgGQ/sAA0f9IAb8AZQAT/9kATwHQADEBpf9h/3cAGQFVAEwAKP8IAFUAoADo/zH/P/91/0MABADA/6H+8v9F/6cAlf/M/3/+kgB2/+QAmP/n/x3/bwA2AD8Ar//E//z/QAAUAbX/8/+O/0wAPgDnAL7/EQDT/5gAHgBUAKn/zf/3/4EACgAMAKf/0f8gAEQA9v/D/9j/xP8+AA4ABQCY/+P/y/8qAOf/6v+p/wIA/v8OAP//xf+3/wMAIgD0/wkAvP/8/+7/OQDk//v/0/8YAPz/NQDq//j/9/8eABUAEgD///T/GwATAB8ABgABAO//IAAMAA0ABQD+//n/AgAHAAMA9v/7/wAAAgACAAEA+f///wEA///8//7/AQD+/wMAAAAAAP//AQAAAAIAAgAAAP7/AwACAP7/CAD+////AwD6/wAABQAEAAEA"},{ name : "R_sounds__gameOver_impact1_wav", data : "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VAR6BusDvAj8A5wIRQQABoAD9wNHA1MDfAOwAjQDAQNUA+ACrAOLAi8EggKZAyoD0gNWBNkE4wZDBswG6wRhBWUC2AXlAV8F3QPhA+8DwgSaAnAGYQPQBqcCHQWUA7oEqgMRBggEqQfgBLgHbgMcB7MDIAhKBJgG+APzBMMEvwXJBSsHEQe0ByIGigY4BhoHcwY8B6gGgAWyBXgH1AWlCKwGfQdqBtMGiAaxB7IH8AlrCCMJJghjCOQGcQctBvUG3gWzB58FJgdkBHoHjAShBQ0F0AJ0BNsCCgWrBRsGSwhHCIIKpAq8D8sN1RDODiYQYQ32D9gMPA7BCyoKzwj8CBMIcgpmCDsINwbkBr0EVAluBtMLDAiwDF0H2AoPBqoJ2QS2BwgEbAbIBDIH8QQaBkIE3gV8A0IHvgS4B1sGgAegBu0H5gcaCQ8I2gmfB8wHpgb1Bc8ENgR4A8sDCgWpBMsF8gRNBfUGbAaMBkQHgQbDB38HxAbCBwsGjgXaA/4CHQLvAf4B5wJUArsDWwN4ASYD5QEOA8gDnQOfBsgEoAiJBQUHVgRQBvgBqQYvAHMDSf4IAQr+9f9m/4YAXAHgAHwCvQHGAvwCowKTAQQCTgCJAAEBlP9pASMA7QC8//7/3P+wAPcA8wO7AxAFWQOxA4gEYQIzBtwBBwX2AfUCwQEQAtMAVAFF/20BFQB/Ai8BoAPnANECfACmATIB+gBhAvoABwO+AdMD4QOsBEYEGwUkBV4E3wSvBQ0FFAWaAxYCogJJAzsD6gS/AwQG7QKPBFgBvQI0/pMD8f4XArv/GgFgABsAmQAhA1oB4gTrAoIFygMUBtcFEAZyBjwIEQazCOgFSQckBWQF2AMaBVcE4ARLA7sEkgPSA6AE3gNLBUkFXAaXBSoGEgbyBYgHVwcnCE0H0wlfB4wJ8AZACX8HwwkaB9cHDgYaB1cGbwdhB14FHQfTBAgHhgZdBxkF6AWRBJMFXAT2BbEDsQcLAiMIqQB1B/MCJwiHAzkICwNpCAcDIwj+AssGqgUYB9MIoQhOCc8H4AcUCAAHCAizCAQIewlUCNsJwwgWCiQJbgnUB+gHawcyBx8IJge3CNEGxglBB6MGKAeABCUH7AQJCE0G7gntB4sMdQipCzkIwwqcBxsJDQe3CI4GlgmgBg8KkQZuCOkHQAjKCGMI/AlOCVAK8gnICZAJ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Qf///Uv+S/7h/Zr+Cv/+/un/HgDI/2kAWP+q/2b/p/84AJD/JAEI/14Bdv8yAQsAvQB+/5wA0f/WASEBPANWAlcDdwK+A6wCHgQ6A+UDBwOKArsCKwJNAkwCdwEAAjEAqQFYAJYBPwF/As8BowIgAtQCJgJEA1UCwgJsAkIC4wEMApMBGwJOAjECBANhAiMDtwIjAzsDbQNhA6wCdgPXAuwCWgKYAp0BuQL6AbIDEAJ2BMABHAQ4AiADSgIzAl8CVwKQAiMDogLJA9kCcwM8A3UDQwOYAwcDBAQpAroDxQFxA04B3wLeAQQChALJAe0DiwIUBesD7ATEBIUEvATGBCkEsARUA9QDZAKoAs8BowEpAWoBFgEdAWIBfwGQAVwCzwGbAwICJgQIAusD0wKWBBwE2wUPBR8HvAUaB3sF5QbKBIwF+AOGBJ4D/wPSAx0EqAPBBP0CJgXMAsIEQAPGBEMD5gR6A2MFSwSiBcsEvgUQBaoFNgX0BNIE1wQdBcYEdwWIBd4F5wUrBocFEQasBboFgQaMBd0GogVAB2AGBAhRB+IHVAeQBn8G9wXZBREGdQXOBgQG1AZrBmQGVgYTBkIGSAZiBvgGYAYGB7gGHwcNBxYGKgYfBfUEYgXGBJsF1gTzBMYE0AOWBBUDeQR5A5wEpQTXBFkGoAU4BmoF7AX5BLkF6wRTBacF9QXoBl8GXAeuBjoHqgZ/Bh8GqAUdBpMFBwZHBS4GDwURBv0FwgbwBv8GEgeSBu0GHAbQBqgGZAa6BnsFBAdwBRsH/gX8Bg0GVgcNBqsHyQWLCFIG5Qh7BgsIPQaGB7QGWgdfB1IHlgctB18Hzwd1B9QH5AaeBuoG5QUYBwgGKwdoBYoGDwV+BXYF3wT4BXEF5gXqBf4FxwVDBjMG9QWgBewFewWJBvkFZweEBpEHdgasB7sGvgfWBgoIagffCJQH1AjOB8gH2Af9BlwHpAYrB20HvAfUCO4HcwnEByQJ5AfSCD0HWQjMBskH4AbAB+IGtgdqBsUHZgafB4MGbgfiBt8G3gZmBpUGXAaWBroFBQfRBAQHlgRVBoUFTwZdBokGPQYeBuYFXgXyBfEE0QU3BWQG7wVRB+8G2QaqBgQGfwVSBY0EkgTMBGQFGAVfBdwEBgXcBLcE2wS8BHoEQQXTBO8FoQWwBZYFAQYtBXQGpwQnBnwEhAXDA9YF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cQEjAn4BCQKmAUsC+AFbAiwCKwItAhUCRAJSAkwCZAJRAmUCjwJyAmoCpALnAWkCQAEcAgEBNQIWAVMCJQEhAgoBLwITAWgCIgGgAnwBqwLyAaYCMwJdAjQC2wHxAYcB1wF9AbQBmAGsAdwBywEHAtUB/wHuAegBDgLFATMC2gFOAhUCQAJUAjYCnwJwAuAC1wKsAroCVAKCAjICUQJ0AlgCawJQAkMCSwJaAlMCTAJDAloCLgKNAjgCqgIlAuYCNAI+A0YCdAM1ApMDUgJYA3MCSAOeAjsDjAI5A08CJAMYAsoCNgJsAn8CUAJ8AikCKAIHAgkCPwJkAoMCYQJgAiIC8AHtAcMBnQHnAXYB0QFMAX4BFgGTAewAswHnALQB+wDOAf8ADQJNAUsCvQFQAtYBVwKmATgCZwHmAfoAkwGaACYBcwArAb8ATAEmAYIBcgGCAWsBFQEZAY8AzABUANoAMQAfASoALgGKADYBwgA/AYgAawE+ALMBFADHAS0A1AFJAMgBlwCuAdwAmwH/AHsBCAFpASkBYQFBAVUBGAEhAcAAqQB5AEsA0gBhAGoBgwDqAawA+gHYAKsBwABaAagAWAG9AGwB4QAkAbsA3wA1AK4A1P+sAMr/qQDt/4gAAQBwAHEAVwCXAE0AaQBiAH8AnQC1ANkA8wDYABwBhADeAA8AYwDf/ycAKAD8/0QACwBzABsAmgAgAN4AcwD3ANkA+gDbAMEAgACVAHYAWACIAPT/TgDG/wcA8f8oAB4AUQBRAE4AnQAbAMMA//+dAOb/kgC+/48Anf/DAKv/9QDM//oA+P/EAAwAZQAMAOz/z/+E/23/dP+N/5z/BQDv/4MA8v+AAKP/FQCD/wQAcf9ZAJT/ugC1/xsBlP8nAUz/GwFQ/wkBs//sAAkA5QAbAOIA0/+rAH3/QQBU//P/gv/f/8b/3v/M/+T/k/+//27/xv+3/xAARwBgALAAogDcAJMA6gBwALQAWgBmAGwASwB6ABMAQwDZ/wMA4//P//b/4/8mAEYAfgC8AIsA1wApALwAsP+IAJH/YgCS/0oAqf8dANX/IQAGAFsANQCxACoA1gAaAPgAFwADATUAywBCAF0AUAA1AJwAfAC9AOEAAwETAU0BSAE/AYcBJgG2AfAAjgF3ABoBAACZAOL/ZgAGAFIASwB5AFgAnQB8AHwApwBkAJwA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UAJ5AokCpAK3At8CBQMGAxwD+gLBAtMCdQJ5AkgCTwIdAnIC6QF3AtEBPQLLAQ0C2wHZAekByAHsAbMB8QGwAeoB3QHuAQsCGwJYAm4ChQKfAp8CnwKHAlICYQL9AUkC4wE+AgcCPwJTAkcCiwJtAo4ChAK1Aj0CwwINApkC9wFJAggCNgL8AVMC3wFkAtEBWALqAUgCHwI0Ak0CMAJwAikCQwIEAgEC1gHOAZ8BwQFBAc8BLAHBARQBpgEMAb4BMgG0AU4BqgFPAcoBQwH6ATkB8QFEAbIBTwGBAVEBOQEoARgBFQEvAV0BLQGzAfAA3AHLANIBqwDgAZkA6QGXANUBqADOAZQAoQGdAHEByABeAd8AcAHpAEkB3gAXAQYBEQE2AT0BGgFNAQYBJgEBARoBBQEUAQ4BIQEiATgBJgFDASMBQQETAR0BCAECARIBDAFIARABZgEoAS4BFAEhAeUAQAHJAF4BwQAuAfIA5QATAdEAEQHaAA0B4wAEAboA/wB8ANYAWQC4AEkAzwBIAMsAUQC6AGoAtwB/AMQAgACdAG4AfgBuAJEAnACqAMIAngDaAH4A3ABmALsATgCFAC8AbgD9/3kA7f+EANv/iQDH/3sAvP9jAND/OQDe/xsA3P8NALH/AwCk/9P/z/+v/wAAp/8xAL//MQDw/wcAKAARAHAAFwCsAAkAugADAMYAAwDSAP7/tQAWAKQAOQCSAGwAWQB7ABsAdADy/0kAu/8SAJL/+/+k/xoAtP9BAKj/RgBw/xIAZ/8CAHr/+/9///7/kP8QAJn/EQBt/yYAQ/8gAE//7v+o/+v/8v8OAO7/MQD6/xkAJwDi/0sAx/9YAL3/aACk/4oApv+lALD/jwC0/3AAuf9HANT/FAD1//T/2v/T/7z/tv/W/5r/zv9u/8n/WP/2/0L/5v8v/5D/Rv9h/0X/Tv9h/0v/dP9N/17/Xv9j/3j/if+S/6z/lf/M/5P/+P+a/wwAqv/4/8v/6//x/+b//v/E//H/tP/r/5L/r/+S/2j/sP89/7v/J/+g/yn/o/9H/6b/Z/+x/3b/w/90/9n/Vv/D/0T/if9Z/4H/gP+O/5X/fv+h/2r/ev9m/2r/W/+L/07/l/8+/3X/Gv9S/wb/Of8G/zL/+f4k//b+J/8X/yz/Jv8S/x7/E/8d/zP/GP8x/yj/Sf9d/3f/WP9+/1X/bf9y/3f/k/91/6n/k/+s/6z/i/+g/2b/lP9w/3H/hf9i/57/cP+W/3X/hv9z/5H/pf/C/7T/4/+W/9n/hP+4/4f/rv+s/7b/vf+m/8L/df+//07/yv86/9D/CP+2/8/+cf+6/kn/t/5H/7H+Uv+m/jT/tv4J/8T+Bv/X/hX/8/43/zX/X/96/4P/mP+S/6T/kv+B/5X/fv+f/6P/u/+6/7T/2v+b/ykAe/9SAFr/PwAw/wEAL//O/y7/t/8x/6H/Mf+f/wz/oP8A/6D/G/+D/xP/ev9C/4X/Wv+I/1D/bf88/2r/L/9g/zb/Q/9N/zL/bv8u/4X/OP98/yD/cP/w/ln/AP9Z/zD/e/9G/5n/Pv+c/0n/kP9d/47/Wf+L/2X/dP9k/3D/Q/9o/0n/YP98/3P/s/+L/53/l/+p/6b/xv++/73/xP+d/7b/oP+c/9H/tv8bALD/SQCy/zIAvP8CAKr/6f9r/+D/Sf/M/1j/rv99/4z/iv9W/2T/V/9e/4H/kP+o/8L/sv/N/67/uv+h/5z/qv+X/6f/mv+T/5r/g/+I/2r/c/9R/1L/Mf80/w3/M//6/lj/8f5u/wb/Y/8w/1//Rf9n/0n/jP9L/4f/YP+i/3n/zf+J//n/jP8EAIf/9f+N/wcAu/8jAMX/JAC4/+7/rf/X/8D/yf/X/73/2P+U/8P/X/+//zP/lv8k/4b/Dv+l/z3/k/92/23/p/9W/7X/d//R/47/7v+A/+3/d//U/4P/xf+b/7b/if+1/2b/rv9z/3//q/9x/67/b/+p/3P/tP9d/8//U//A/2v/tv+V/+7/y/8rAN//LgDR/xIAsv/j/6H/2/+3/+j/2//l/8//yv+7/6n/nv+g/2T/kv84/6v/Zf/g/6r//v/a/+z/1v/J/93/yP/b/9D/uP/S/6j/1//J//f/9f/9/wAA6//m//j/sP8RAJX/DACB/+P/b//j/33/4/9//+j/eP/e/4f/0P99/83/eP/d/4X/5f+p/+j/4P/k/xEA5P9NAOL/NgDI/wkA0//e//X/3f8OAOr/FQAAAP3/DwDc//b/2P/l/+j/8f/y/xEA0f8qAK//OQCi/yAAsv8TAMn//P/P//b/0/8EAOb/JgDy/ycA/f8rAPr/MgDR/0EAtf8xALv/JQDB/ywAuv8mAMT/FADU/wEA1f8OANv/CgDY/woAz/8mANv/SwD+/1IAHwBPAC8AYAAbAF8ADwBAABQAJgAKACYABgAwACwAOQA0ADIAGwARABEA+v8aAAcAFwAdAA0AGQAXABcAKQAWADYAHgAtAB4AGQAjABkAKAAYADIABgAiAAcAIwD7/yUA7/8dAOT/FwDw/xoACQAdABoAIwAQACIAFQAXAB8AGgAeACEAFwAfAA4AFgAFABQAAAAKAAQA9v8NAPH/FQDy/xYA/v8VAAAADgAAAAEACQAIAAYAFwAEABYABgAcAAoAHwAOACcADgArABYAKgAOACwADgAuABIAMAAWACIAHQAdABcAHwAVACUAFAAlABMAIgAWACUAFAAiABMAGwAVACAAGwAgAB8AJQAhACAAHAAdABwAGQAiABkAJQAgACEAHQAfAB4AIAAcAB4AHQAdACMAGwAfAB0AIAAfACQAIQAoACUAJAAjACUAIAAnACMAJAAiACQAJQAjACIAKAAiACQAIQAmACMAIwAlACUAIwAnACQAJgAkACgAJAAnACUAIwAkACcAJQAjACMAKAAkACYAHwAlACQAKAAnACcAIAAiACIAJQAkACgAIQAmACMAJQAhACYAIQAmACUAIwAkACcAIwAnACEAJgAjAA"},{ name : "R_decor_png", data : "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"},{ name : "R_sounds__tuto_success1_mp3", data : "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v/uOP//8b+VIl8dAeAa6//////+wIraqqIlONxSAtqGgPcHMTtsE3CHlkUhCDlZz7XHu0NOnnp3PGa399wIGtLM9t4m3/AiNYd8Gl7NyJAcm1Ziyym1Kz/9hCTVv658U/55o0MJs/////tzU4hAu3//+n//+IRdTGoG0S40zGQEufjiSNBn4AICkbk0p2qrStECwEYmuIszMf41v26T///w44sK+z2SPSRqTJ9+7/9aGGtP+ukop55jbV2/6f//VPq+oLSH////7TDGoaNyDpNEAAHm52OCfYzoJY4viGv9QXz6kzxghrdIG5NfP//1/tf+LwEjHRXEMeXZFIDZ89af6sSl//8p/9/////PQx00PRkC8Jyft//87nOc5zmgQIECDkBCAMCGIIV5cEDggziqLK0VkIW1avyCFAdQelW5JAKcNIXmcpasyqvFn//uSZA4ABDFj3HsqxfI9q9tMJE1eT2V9eaw+Edj3L6988xUq9jNmtKseS2pq1O8pt/jQa+19XSNvOY04qPWbNKHO+cnxAE3s9SJRGLEonnM01vfPJagbE+cYpqO3s9SD//biKWcsWzjlKCKAhfvp//1nl9zfcKZkdidsymq6IztGizljQ0l2lxxpjpULhv7YYIAwCQxCgRqgeJpwLGYPvhRn+X/6/9bv6////2v//9f//////693Jo5f///q6VIf0WZFEdoG8dJmDMQa6XTWSaS30gOdPOCvALibCc4MVTTDCRpHBjrqxndOynkkf+Ms5VBkzffyxmiql24Qba//+I+I0rnFza+JYcE3D/jeDukGsUb/mri3cMVe6SDQ9Ls9pmV5Let9x8vWWCpQWGDSZSrMg1/1f//UVfW3uk/////0W+Ngk3vNDkCIqqi2MQUFHIiyjOKm/7JXCHST2wCiUlHMGM2vCavY6N/0I/p/+f/5G///hx/0//////9P////1b4YP0XaGLRp6N2sABXramK0t4llDUv6llMYcLeORQUA2//7kkQOgCMUX11p6VNUXyvbnT2KaowxfX+noK/Rdq9u9PQeOuDCTagr3LnQsPIBWS0O+suVpSRo31zGYmD97aq4XoNR6oklsLKBdgcMFVW6/RDB8xQVjP//X//876eM2/////Q3zAIhtp1qq0rmiUsAAJZ+iiEmUIwMWogpJJTGBqq9UOLh/OioQHB/aJ/0pdgYh+yg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h2lXS/6l/b///9v///////////////wbTcjbdabCVHEogBSXIxXo+iEiFIeMRZLYO3ZblQaUNMMA3nBd1qDcca2gnrFRiEtV1aCnHHH/+5JkaYADNVze+eZUVDmLnD8Zgh2MLXN3p6CxkO0J8LTxmhJ9vTLUOLtrtTwigOdYj4xplZ1bKKMzt4kgq7JzfRpkf///q3//////Hhjg16Z+3fW56tTCIaA5XBJDrSqkumKO8m5tVxF9UWuidtj8I79z2gAseHDJH+sz5X/8oIUnPlRMR/2b///1BF+h7IWJKEAJtkqwACiEAMLjIBYA5LDF4yCPgElk4T4wX5SulB2u4DBlKQ6sZ+j6kR9b/Xk//UmNTf9qf/6PQjf/////////9ioigOM5KTFz59krVvpa6ipLG4wSrMocSIqZB2GoeMtEK6lVMKO2KDLLNacOC6QplaL/xi2k/Bof+OtL+ptV/75+ynETnu6frv/9DbI3//p///////ikBhcdYeY5TShVjmscrsSesQgYyCCCnn2dBOVHIdaOStEFHGBow1PH+1UN23/yScnQLanOVDD3Q3m1ej09ev/8j/9mX6/qp7zTC///lm///////mjoZYs0Xdjky6FBmxkN0imQBFlAXAd6XJQ3rlQB1pDSII8itURt//uSRIoBAo1eXHmCU/BUjBv9PGd+ygF1d6eY7VFMMK288xUovhzW7bVMo2pG2T/qX3NT1bKX9UV0MBzPp9nQQf/+hpif/////////q5ACAjxo51ERxaQI3Sq1ZURRKjRLQBiGxrSxbkz0MKDjTgiYS7zJpIjkyJvHBqbFe/RMgUzfKttz07tkbIALDKJHiyXjPdyE1a917lkVnbtUozP+v90+/7IpMbmDHBhDyL1NrbMjMpEoZqT//+r/////9S0lnF02MERLETQ+aGZUAzAoRvVQRdxLB3pexaGQJwAJgAAQQRySDFBdqxxqkM6hx4pqv+GzUO+LRO1Hur9l/////T//////////5hX8Iw5k6oxmttclYB4oBgUkVFPMZShtMkgLF80Y3akRGOxZP0Wtw7CbQQ2otASrQmqXY3Jr3qVX0/7HmUjummmmgbkdS1al9ieaJbdWhuYmrOCfC8pBld9ScbWV/////////84v6jqPuHwfj/6RLRYA7m6kE4DLQAWZIlfX7EZJvIpvYTaN9358DAi6////7L/9///6f/7f//7kmSkAAPxaVvrSWt0NIurvSwCxI2Bo33ssa1Q7TJt/JCd+P////////j4SBO23Fl+ICj8DYhQlTpQS7wJMAFckjsJgkAZwfVlaTuwa4dxclg9zvKeEqnh1qzllyrX8SglvMFtO9Pzee/r297t/NWZDJmpwvK79R/9Xpo/1t+qgMaev/zEmhRy4j///b6f////+ieG27MuowJxTrLBDgehnStfWw3Qy6X5YKlWCYEQSBbV6clCJPoAznYLuHTqfGvz0Sn90r///n/9f////+v/63//////////YIAx9FL5ZvEr0yQhsqJNY5WAphbgFYBJE+IQXfYmoDRczxtLmkFfLmyMlGp4W1ncjAudq4I+xgjKw6iII7QUFDOXIpI5LBrbWiJ28rN/+6M279+v3PdhGE4ev96JLN/////////+3+3lBSXfgD+PyWuX2KAAOmAlgCMFdXEZHVGXSujtiy7/wcKlQsRcwgWAEIIBV5z7f6vOc/3/39nf///////////////3//oHFnkqRGU5Uk2AU6lg0xCF68crekRTLdiEQX3/+5JktgADnGlZ+eyL0Dkrm40wJYaMlZN/56DzUQayMHTAigqkYZS8EMccFHIvmVQMHh5p9CjxZ31k5A/pb3M//sp0oPm/9EKBRjU1qI//2qd//////qhfWh42Q66oCMBo5/lxCtEKjqiqiS1pogE4dCkB9SHSpBH4nxnA6uXjiFDJzrGI4M9T3bT2nVTS8QsrQkfjyq/57kFK7mqUDPX58ziQ7t/98IP//L9P////////0IL/z/GGOl5ZHM2UkuscjAFrlLefKiEse0dcKW58I1s7i8Xa2907VWl7r2AWON7OI3b9+yIien0GboMn15qF/zfOP/p+p+GZb/9hsyf/////////R/1+o8G3+TVLFRGikV1lvgASk8/E3wbD9YBb3FI1QqY6ZsLcXa87CcW9CgTru8ittgieb+c4ECTVqUBaYXY+mQtkf//HXg7Nb9OrHfX///X/////ygub8DkuJZmHhFZjW7RyIEdILdDCWAsQv1ky3A9tJgebHFgTNEySw3fz+ys/2yF9lp9h7B86MdmIcky/KSoNZTuOCMecZ0UW//uSRMuAAtNpXemDU9RT7HwvMQWnio2jgeetTxFNrm38wR5YHKZb//dy1whGk1v9jSpj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PMdqCm2Df6YNURlRrq30l5eAEdssx1X+nWtOYGW/T9UEqb///Q3/nP/////////+ri4AQmz7kTuuqgjg2Yje3zbAMZaSjkrUVhHOLIoH/IzpEHSoPz/3LOw+O3ycDPiDrnOy5nrT7bpMDJjHGK7T5nVBKm/1/8mA8eVFvex3//////////FwLD+C2vbOxRtN2RkgjESyoSh6GlEZElcVaQDhlJKyBeli0Brcs/J0Kf/upDk1WKd9G9TBvIhSaqHm8/Q8Gwql1//9zP+n/////////9ReCGBYXZGVCg0k7r1Ks0JtsQAGmtTXGTRwoXZZkAh+bBFR88iZqos3/BuP2avy41kozlcK/vCpNefxSZvKleI52Tw8k7M1R3HUKwv1///5TjW/0N//////////hgqn6WlkZzhBKahyQAfx5DsHLBJiojHILchh/ABviomIZ6t2nSceyJuwOxFEtjz562Ttr//QvQ3250xRMD10M/2/ucg1N9EqC8SF///7f/////8fDHEUWQmooAA+pAi10P/7kkQugAKVXOB57Do0UMx7LjEnZgpdc3OnpO1RTC6uPPSc+OgfgIYkHjKO59wvyzGOGbh4TXpFvONVY2jyorc+72yq/f/WELp8wp7f9rf2EUH7HIvOzk///9v/06///9AOHPx09PHibbFa12FslVsEgA0jLVxKBwDdkMokhyLuPYhO2cD7Sh9Sf8HHlcnn9yFgGNmXmiO1jtEXz7N/70T/VrONnfT//5J/6mt//////////HweBCG8CulJ6ybhVg1MQk1bLYbULNgnqLOAuhShgsmCugZfTJdCw3T/avY/m68drmek/Lkt690bm/6Dggs/nj5Axns5kz0/+WGP+qf//+3//7///qcIhY+gTvzCVauzNwZDFTYtIoAHGhw69T/PU2PupYGqBZtEYBV40im11X5s8T6SZyZs79W5qjqn1dkHVZKrSMU7eiZJpzElyqbUkV+t/9VX1LrOK//////6v+t10nXrdAnQGOB+FwrFM8XS6Q8YRoVD7mp9cSCxy1i0ygCAAAALNsliZEIqKvT2hE/WimB+dc1P6kt/////y///+5JkSIADdGRc+wmRcjmMi20kJ44NPYdx55lNgOYesbzwinbMH//+rnf+3/////////8dAwXP9DflK612iTYzF78qZAfBlKkTaIn0kQthLGgz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"},{ name : "R_anim_shockwave_png", data : "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"},{ name : "R_screens_sc_0_png", data : "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"},{ name : "R_fonts__DS_Store", data : "AAAAAUJ1ZDEAABAAAAAIAAAAEAAAAAAlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAgLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAABAAAAQAAAAAEAAACAAAAAAQAAAQAAAAABAAACAAAAAAEAAAQAAAAAAAAAAAEAABAAAAAAAQAAIAAAAAABAABAAAAAAAEAAIAAAAAAAQABAAAAAAABAAIAAAAAAAEABAAAAAAAAQAIAAAAAAABABAAAAAAAAEAIAAAAAAAAQBAAAAAAAABAIAAAAAAAAEBAAAAAAAAAQIAAAAAAAABBAAAAAAAAAEIAAAAAAAAARAAAAAAAAABIAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAEAsAAABFAAAAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBERTREIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAYAAAAAAAAAABAAAAgAAAAAEAAAEAAAAAAQAAAgAAAAABAAAEAAAAAAIAAAgAAAAYAAAAAAAAAAABAAAgAAAAAAEAAEAAAAAAAQAAgAAAAAABAAEAAAAAAAEAAgAAAAAAAQAEAAAAAAABAAgAAAAAAAEAEAAAAAAAAQAgAAAAAAABAEAAAAAAAAEAgAAAAAAAAQEAAAAAAAABAgAAAAAAAAEEAAAAAAAAAQgAAAAAAAABEAAAAAAAAAEgAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},{ name : "R_screens_sc_2_png", data : "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YII"},{ name : "R_sounds__pass2_mp3", data : "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SkXslSVcPuI7j+QJNS8WFhZAgpEss8HHhBUyTTTPtpu7vXvbTdOb2p3Or3dzrPkY6+5Gc9e069rmdkqyexLUazaLUiM2iuToyKfpWU+R7vIxdq0qDAT30m1W3lgXdXW3KqgE/cidBvDf//uUROkAEtAcTmtMMaBXQonbaYM4C1CBP+yYawFJCmexpgx4nNwszLHGda87c4CmdPSR44kmjFkg7scVLlQc69MkkzQNwuqUpqJpHTefR7x5YhvPUUFDx6ITpEUUROOBwXS1Aucafo0tjk3srpelw2pw//FhHlAADVBEkmSkeknIuJ0oTdhOVDUNQ0AkYkiRIkSM+pIozONRIiRRDSgaBUFSwNAyGlA0DTYiBp4iBoGpYGgaPQaBoOlQoDVYLPlQ0Ij0qCz/WGvDVHEIlO4lBX8snE2LLOilDsAgpKmo2vXrMc/oCySx4NSKwVGA1/g0Ha1gqs7WGol89EvLB0Rci2CoaJVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uUZOgBAzZXTltGE2BdxZnMPMN2C6xPNww8wUDHBymwYIzWVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//uUZFGP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV"},{ name : "R_sounds__win_mp3", data : "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"},{ name : "R_archive_tuto2_png", data : "iVBORw0KGgoAAAANSUhEUgAAACAAAAA4CAMAAACrIQowAAAAB3RJTUUH3gwTADQjevFACgAAABd0RVh0U29mdHdhcmUAR0xEUE5HIHZlciAzLjRxhaThAAAACHRwTkdHTEQzAAAAAEqAKR8AAAAEZ0FNQQAAsY8L/GEFAAADAFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABXFWMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+/v7u0vPcpebKeNm4SsyMMZ1gF20AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQLy+ZIyNiFhYAAAAAAAAAAAC4SsyXZtV2g99VoOl5n8mdnqjBnYfmnGbGbj6mPxamPxYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABdLhtGIxUuFw4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1I3kvIHMoHGwhGGUaFF4TEFcMDFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADN4/mRwvFVoOlDgsAwZJcdRm0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZIDUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADq7/q3wtuFkKlTXXchKkX/+/AAAACAgIDQLy8A/wD//wAVFUf/oFwA//////+meLxYAAAAAWJLR0QV5dj5owAAAQpJREFUeJzV00sWwiAMBdAs75FuxK6EHTNiILQEwidSjyMzqEfftQHaUNwUzT+9UnUgIFWM+RpKrgTlxPsM0hVr4L3nGNlfrgD+CjBzah7SB2SRBzt7FzFJdg42iC4XYIN7z7fI5+BCKT64EwKCu4sPaaxEbgG5AzC2KWtA+rdauBKySKAtuyfWLqrYgdTiOvnz3IBXYQungZIbkI0JxjZkBRVst6m/AO0xzwBdTQD1kYbQEZpzMRoMsRa0zpsgI6+CrFzEBxAKMPP7Fj+BqweNRzTe4l/Ap5N8AqZ3pQf5JC2BBpYCAgwhb24Bk4ACK9Gmg9TMDGl7acep6qarDo6Rq9Fb58+H1xz/N69ddAlDvnhLAAAAAElFTkSuQmCC"},{ name : "R_sounds__over_mp3", data : "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"}];
haxe_MainLoop.add(hxd_System.updateCursor,-1);
var hx__registerFont;
hx__registerFont = function(name,data) {
	var s = window.document.createElement("style");
	s.type = "text/css";
	s.innerHTML = "@font-face{ font-family: " + name + "; src: url('data:font/ttf;base64," + data + "') format('truetype'); }";
	window.document.getElementsByTagName("head")[0].appendChild(s);
	var div = window.document.createElement("div");
	div.style.fontFamily = name;
	div.style.opacity = 0;
	div.style.width = "1px";
	div.style.height = "1px";
	div.style.position = "fixed";
	div.style.bottom = "0px";
	div.style.right = "0px";
	div.innerHTML = ".";
	div.className = "hx__loadFont";
	window.document.body.appendChild(div);
};
hx__registerFont("R_fonts_nokiafc22_ttf","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BgAAAAYAAAAGAAAABgAAAAYAAAAGAAAAAwAAAAUAAAAHAAAABQAAAAgAAAAHAAAABwAAAAYAAAAHAAAABgAAAAUAAAAHAAAABgAAAAcAAAAIAAAABwAAAAcAAAAGAAAABgAAAAYAAAAGAAAABQAAAAYAAAAGAAAABAAAAAYAAAAGAAAAAwAAAAQAAAAGAAAAAwAAAAkAAAAGAAAABgAAAAYAAAAGAAAABQAAAAUAAAAEAAAABgAAAAYAAAAIAAAABgAAAAYAAAAGAAAAAwAAAAQAAAAGAAAABgAAAAcAAAAHAAAAAgAAAAQAAAAEAAAABgAAAAYAAAADAAAABQAAAAMAAAAEAAAAAwAAAAMAAAAFAAAABQAAAAUAAAAGAAAABAAAAAQAAAAEAAAABgAAAAQAAAADAAAABAAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAUAAAAGAAAABgAAAAYAAAAGAAAAAwAAAAMAAAADAAAAAwAAAAQAAAAGAAAABwAAAAcAAAAHAAAABgAAAAYAAAAGAAAABgAAAAYAAAAHAAAABAAAAAYAAAAHAAAAAwAAAAcAAAAFAAAABgAAAAYAAAAGAAAABAAAAAYAAAAGAAAABgAAAAgAAAAIAAAABgAAAAYAAAAGAAAABgAAAAQAAAAEAAAABAAAAAQAAAAHAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABwAAAAIAAAADAAAABgAAAAYAAAAEAAAAAwAAAAcAAAAGAAAABgAAAAYAAAADAAAABwAAAAYAAAAGAAAABAAAAAcAAAAGAAAAAAEAAAAABQAHAAARAAARIREhESERIREhESERIREhESEBAAIA/QAEAAEA/wD+AAMA+wADAAEAAgABAP8A/gD/AP4A/wAAAgAAAAAFAAcAAAMAEwAAASERIQERIREhESERIREhESERIRECAAEA/wD/AAIA/gD/AAEAAwABAP8AAwADAPoAAQABAAEAAwABAP8A+wD/AAABAAAAAAUABwAAEwAAESERIREhESERIREhESERIREhESEEAAEA/wABAP8A/AADAP4AAgD9AAcA/wD+AP8A/gD/AAEAAgABAAIAAAAAAgAAAAAFAAcAAAMAEgAAASERKQEjJzUhESERIREhESERIQIA/wABAAEA/gIBAAIA/gD9AAEAAgAEAAEAAv4BAPkAAgACAP8AAAAAAAEAAAAABQAHAAAPAAABESERIREhESERIREhESERBQD/APwAAwD9AAQA/QADAAQA/QD/AAEAAwADAP8A/wD/AAACAAAAAAUABwAAAwATAAABESERIREhESERIREhESERIREhEQIAAQACAP8A/QD/AAEAAwD+AAIABAD9AAMA/QD/AAEABQABAP8A/wD/AAAAAAEAAAAABQAHAAANAAABIREhESERIREhESERIQEAAQABAP0ABQD/AP8A/gADAAIAAQABAP4A/gD9AAAAAAMAAAAABQAHAAADAAcAGwAAAREhEQERIREBESERIREhESERIREhESERIREhEQMA/wABAP8AAwD/AP0A/wABAP8AAQADAAEA/wAEAAIA/gD9AAIA/gACAP4A/wABAAIAAQACAAEA/wD+AP8AAAMAAAAABQAHAAADAAcAEwAAASERIQEhESEBESERIREhESERIRECAAEA/wABAP8AAQABAAEA/wABAP8A/AAFAAEA/gD9AAYA/wD/AP8A/QD/AAcAAAEAAAAABQAHAAALAAABIREhESERIREhESEBAAQA/QADAPwA/wABAAcA/wD7AP8AAQAFAAACAAAAAAUABwAAAwALAAABESERAREhESERIREDAP8AAgABAP8A/AABAAUA+wAGAP8A+wD/AAcAAAEAAAAABQAHAAAJAAABESERIREhESERBAD+AP4ABQD9AAUA/wD8AAcA/wD/AAAAAAIAAAAABQAHAAALAA8AAAERIREhESERIREhEQERIRECAP4AAQADAAEA/gD/AAEAAgD+AAYAAQD/APoAAgAEAP0AAwAAAQAAAAAFAAcAAA0AAAEhESERIREhESERIREhAQADAP4AAQACAPwA/wABAAcA/wD7AAMA/AABAAUAAAAAAQAAAAAFAAcAAAsAABEhESERIREhESERIQIAAQACAP4A/wD+AAcA/gACAPkABAD8AAAAAAEAAAAAAgAHAAADAAAxESERAgAHAPkAAAEAAAAABAAHAAAHAAAxESERIREhEQIAAgD/AAEABgD6AP8AAAEAAAAABgAHAAAbAAABIREhESERIREhESERIREhESERIREhESERIREhBAD/AP8A/gACAAEAAQACAP8A/wD/AAEAAQABAP4AAQABAP4ABwD+AAEAAQD/AP8A/wD/AP8A/wD/AAABAAAAAAQABwAABQAAESERIREhAgACAPwABwD6AP8AAAEAAAAABwAHAAAXAAABIREhESERIREhESERIREhESERIREhESEFAP8A/wD/AP4AAQABAAEAAQABAAEAAQD+AAMA/wABAP0ABwD/AP8A/wABAAEAAQD5AAABAAAAAAYABwAAEwAAIREhESERIREhESERIREhESERIREFAP8A/wD/AP4AAQABAAEAAQACAAEAAQABAP0ABwD/AP8A/wADAPkAAAAAAgAAAAAGAAcAAAMADwAAAREhEQERIREhESERIREhEQQA/gD/AP8AAQAEAAEA/wABAAUA+wD/AAEABQABAP8A+wD/AAACAAAAAAUABwAAAwANAAABESERAREhESERIREhEQMA/wACAAEA/wD+AP4AAwADAP0ABAD/AP0A/wD+AAcAAAAAAgAA/wAGAAcAAAUAFQAAAREhESERASERIREhESERIREhESERIQMAAQD+AAIA/QD/AAEABAABAP8AAQD+AAEAAQAEAPsA/wABAAUAAQD/APsA/wD/AAAAAAIAAAAABQAHAAADABEAAAERIREBESERIREhESERIREhEQMA/wADAP4A/wD+AAQAAQD/AAMAAwD9AP4A/wACAP4ABwD/AP0A/gAAAAABAAAAAAQABwAAEwAAESERIREhESERIREhESERIREhESECAP8A/wABAAMA/gABAAEA/wD9AAEAAgABAAIAAQD/AP4A/wD+AP8AAAAAAQAAAAAGAAcAAAcAAAERIREhESERBgD+AP4A/gAHAP8A+gAGAAEAAAEAAAAABQAHAAALAAABESERIREhESERIREDAAIA/wD9AP8AAgABAAYA+gD/AAEABgD6AAABAAAAAAYABwAADwAAASERIREhESERIREhESERIQIA/wD/AAIAAgACAP8A/wD+AAIAAgADAP0AAwD9AP4A/gAAAQAAAAAHAAcAABMAAAEhESERIREhESERIREhESERIREhBQACAP8A/gD/AP4A/wACAAEAAQABAAcA/AD9AAEA/wADAAQA/QABAP8AAAEAAAAABgAHAAAbAAAxESERIREhESERIREhESERIREhESERIREhESERAQABAP8A/wACAAIAAgD/AP8AAQABAP4A/gACAAEAAQABAAIA/gACAP4A/wD/AP8A/gACAP4AAAEAAAAABgAHAAAPAAABIREhESERIREhESERIREhAgD/AP8AAgACAAIA/wD/AP4ABAABAAIA/gACAP4A/wD8AAABAAAAAAUABwAAEwAAASERIREhESERIREhESERIREhESEFAP8A/wD/AAMA+wABAAEAAQD9AAUABAD/AP8A/wD/AAMAAQABAAEAAQAAAQAAAAAFAAcAAAsAAAERIREhESERIREhEQQA/gADAPsABQD9AAUA/wD9AP8ABwD/AP8AAAIAAAAABQAFAAADABEAAAEhESEBESERIREhESERIREhEQIAAQD/AAMA/AD/AAEAAgD+AAMAAQABAAIA/AABAAEAAQABAAEA/wAAAAACAAAAAAUABwAAAwANAAABIREhAREhESERIREhEQMA/wABAAEAAQD/APwAAgAEAP0ABAD/AP0A/wAHAP4AAAAAAQAAAAAEAAUAAAsAABkBIREhESERIREhEQEAAwD+AAIA/QABAAMAAQD/AP0A/wABAAAAAAIAAAAABQAHAAADAA0AAAEhESEBESERIREhESERAwD/AAEA/gD/AAEAAgACAAQA/QD/AAEAAwABAAIA+QAAAAACAAAAAAUABQAAAwARAAABIREpAREhESERIREhESERIRECAAEA/wADAP0AAwD8AP8AAQADAAMAAQD+AP8A/wABAAMAAQD/AAABAAAAAAMABwAACwAAAREhESERIREhESERAwD/AP4AAQACAP8ABQD/APwABgABAP8A/wAAAgAA/wAFAAUAAAMAEQAAASERIQEhESERIREhESERIREhAgABAP8A/wACAP4A/wABAAQA/wD9AAIAAgD8AAEAAQACAAEA+wD/AAAAAAEAAAAABQAHAAALAAAhESERIREhESERIREDAP8A/gACAAIAAQAEAPwABwD+AP8A/AAAAAACAAAAAAIABwAAAwAHAAABIREhAREhEQIA/gACAP4AAgAGAAEA+QAFAPsAAAIAAP8AAwAHAAADAAsAAAEhESEBIREhESERIQMA/gACAP0AAQACAP8A/gAGAAEA+QAFAPsA/wAAAQAAAAAFAAcAABMAACkBESERIREhESERIREhESERIREhAgD+AAIAAQACAP8A/wABAAEA/gD/AAcA/QABAP8A/wD/AP8A/wABAAAAAAEAAAAAAgAHAAADAAARIREhAgD+AAcA+QAAAAABAAAAAAgABQAADQAAASERIREhESERIREhESEGAP8A/gD/AP4ABwABAP4ABAD8AAQA/AAFAP8A/AAAAAABAAAAAAUABQAACQAAAREhESERIREhEQUA/gD/AP4ABAAEAPwABAD8AAUA/wAAAAACAAAAAAUABQAAAwAPAAABESERAREhESERIREhESERAwD/AP8A/wABAAMAAQD/AAEAAwD9AP8AAQADAAEA/wD9AP8AAAIAAP8ABQAFAAADAA0AAAERIREBESERIREhESERAwD/AAIAAQD/AP4A/gACAAIA/gADAP8A/gD/AP4ABgAAAAACAAD/AAUABQAACQANAAABESERIREhESERAREhEQUA/gD+AP8AAQACAP8ABQD6AAIAAQACAAEA/QACAP4AAAAAAQAAAAAEAAUAAAkAADERIREhESERIRECAAEAAQD+AAUA/wABAP4A/QAAAAABAAAAAAQABQAADwAAAREhESERIREhESERIREhEQQA/wD9AAIA/gABAAMA/gADAP4A/wABAAEAAgABAP8A/wAAAQAAAAADAAcAAAsAAAERIREhESERIREhEQMA/gD/AAIAAQD/AAEA/wABAAYA/gD/AP0AAAEAAAAABQAFAAAJAAABIREhESERIREhAQD/AAIAAQACAPwAAQAEAPwABAD7AAAAAAEAAAAABQAFAAAPAAABIREhESERIREhESERIREhAgD/AP8AAgABAAIA/wD/AP8AAQACAAIA/gACAP4A/gD/AAABAAAAAAcABQAAEwAAASERIREhESERIREhESERIREhESEFAAIA/wD+AP8A/gD/AAIAAQABAAEABQD9AP4AAQD/AAIAAwD9AAIA/gAAAQAAAAAFAAUAABMAADERIREhESERIREhESERIREhESERAQD/AAIAAQACAP8AAQD+AP8AAgABAAIA/gACAP4A/wD+AAIA/gAAAQAA/wAFAAUAAA8AAAERIREhESERIREhESERIREDAAIA/wD9AAIA/gD/AAIAAgADAPsA/wABAAEAAQADAP0AAAEAAAAABQAFAAARAAARIREhESERIREhESERIREhESEFAP8A/wD/AAMA+wABAAEA/gAFAP8A/wD/AP8A/wACAAEAAQAAAgAAAAACAAcAAAMABwAAESERIQEhESECAP4AAgD+AAIAAQD/AAIABQAAAAACAAAFAAMABwAAAwAHAAABIREhASERIQIAAQD/AP4AAQD/AAcA/gACAP4AAAIAAAAABQAHAAADAB8AAAEhESEBESERIREhESERIREhESERIREhESERIREhESERAgABAP8AAwD/AAEA/wD/AP8A/wD/AAEA/wABAAEAAQABAAMAAQACAP4A/wD+AP8AAQD/AAEAAgABAAIAAQD/AAEA/wAAAwAA/wAFAAcAAAMABwAjAAABIREhGQEhGQEhESERIREhESERIREhESERIREhESERIREhESECAAEA/wABAP8A/wD/AAEA/wABAAEAAQABAAEA/wABAP8A/wAEAAEA/QD/AAEA/gD/AAEAAQACAAIAAgD/AAEA/wD/AP4A/gD+AAADAAAAAAYABwAAAwAHABcAACERIREBIREhASERIREhESERIREhESERIQQAAgD6AAIA/gAEAP8A/wD/AAEAAQABAAEA/wACAP4ABwD+AP4A/gD/AAIAAgACAAEA/fsAAAADAAAAAAYABwAAAwAHAB8AAAERIREBESERKQERIREhESERIREhESERIREhESERIREhAwD/AAEA/wADAP8A/QD/AAEA/wABAAMAAQD/AAEAAQD/AAUAAQD/APwAAgD+AP8AAQADAAEAAQABAP8A/wD+AAEA/AAAAAABAAAFAAEABwAAAwAAESERIQEA/wAHAP4AAAAAAwAA/wADAAcAAAMABwAPAAAhESEZASERIQERIREhESERAwD/AAEA/wD/AP8AAQABAP8AAQAHAP8A+gABAAQAAQD6AAADAAD/AAMABwAABwALAA8AACERIREhESERASERIRkBIREBAAEAAQD/AP8A/wABAP8ABgD/APwA/wAGAAEA+QD/AAEAAAEAAAAABQAHAAAbAAABESERIREhESERIREhESERIREhESERIREhESERBQD/AP8A/wD/AP8AAQD/AAEAAQABAAEAAQD/AAMA/gABAP4AAgD/AAIAAQACAP8AAgD+AAEA/gD/AAABAAABAAUABgAACwAAASERIREhESERIREhAwD/AP4AAgABAAIA/gABAAIAAQACAP4A/wAAAQAA/wACAAIAAAcAABEhESERIREhAQABAP8A/wABAAEA/gD/AAAAAAEAAAMABAAEAAADAAAZASERBAADAAEA/wAAAAABAAAAAAIAAgAAAwAAESERIQIA/gACAP4AAAAAAQAAAAADAAcFAAsAAAEhESERIREhESERIQIA/wD/AAEAAQABAP8AAfv+BQMAAgACBfz7AAIAAAAAAgAFAAADAAcAABEhESERIREhAgD+AAIA/gAFAP4A/wD+AAACAAD/AAIABQAABwALAAARIREhESERIREhESEBAAEA/wD/AAIA/gABAAEA/gD/AAYA/gAAAQAAAAAEAAcAABcAAAERIREhESERIREhESERIREhESERIREhEQQA/wD/AP8A/wABAAEAAQABAP8A/wABAAIA/gABAAEAAQABAAEAAQABAP4A/wD/AP8AAAIAAAEABAAEAAADAAcAABkBIREBESERBAD8AAQAAQABAP8AAgABAP8AAAAAAQAAAAAEAAcAABcAAAERIREhESERIREhESERIREhESERIREhEQEAAQD/AP8AAQABAAEAAQD/AP8A/wD/AAIAAQABAAEAAgD/AP8A/wD/AP8A/wD/AAIAAAIAAAAABQAHAAADABMAAAEhESERIREhESERIREhESERIREhAQACAP4AAQABAP0ABAABAP8A/wD+AAEA/wAEAAEAAQABAP8A/wD/AP4AAAAAAQAA/wADAAcAAAcAABEhESERIREhAwD/AAEA/QAHAP8A+gD/AAAAAAEAAAAAAwAHBQALAAABIREhESERIREhESEBAP8AAQABAAEA/wD/AAQAAwX9+/4A/QAB+wABAAD/AAMABwAABwAAASERIREhESEDAP0AAQD/AAMA/wABAAYAAQAAAQAAAAAGAAEAAAMAABEhESEGAPoAAQD/AAAAAAEAAP8AAwAHAAAHAAARIREhESERIQMA/wABAP0ABwD/APoA/wAAAAABAAD/AAIABwAAAwAAESERIQIA/gAHAPgAAAAAAQAA/wADAAcAAAcAAAEhESERIREhAwD9AAEA/wADAP8AAQAGAAEAAAMAAAAABQAHAAADAAcAFwAAASERIQEhESEBIREhESERIREhESERIREhAgABAP8A/wABAP8AAQD+AAEAAQABAAEAAQD+AP8AAwABAAMA/wD6AAQAAQABAP8A/wD8AAIAAAMAAAAABQAHAAADAAcAFwAAASERIQEhESERIREhESERIREhESERIREhAwABAP8A/wABAP8A/gABAAEAAQABAAEA/gD/AAcA/wD9AAEA/AAEAAEAAQD/AP8A/AACAAAAAAIAAAAABQAHAAADABgAAAEhESERFSERIREhESERIREhESERIREhETMCAAEA/wABAP8AAQABAAEA/gD/AP4AAQD+AwABAAH+/gEAAQD/AP8A+wACAP4ABQABAAAAAwAAAAAFAAcAAAMABwAeAAABIREhASERIQEVIREhESERIREhESERIREhESERIREzBAABAP8A/gABAP8A/wABAP8AAgABAAEA/gD/AP4AAQD/AP4HAP8A/QABAAH+/gEAAQD/AP4A/AACAP4ABAABAAEAAAACAAAAAAUABwAAAwAXAAABIREhESERIREhESERIREhESERIREhESECAAEA/wABAAEAAQD8AP8AAQACAP4AAgD/AAEAAQAFAP8A/gD8AAEAAQABAAEAAQABAAAAAAMAAAAABQAHAAADAAcAGQAAASERIQEhESEBESERIREhESERIREhESERIRECAAEA/wABAAEA/wACAPwA/wABAAIA/gABAAEAAQABAAEABQD/AP4A/AABAAEAAQABAAEAAQD/AP8AAAAAAgAAAAAFAAcAAAMAHAAAASERIREVIREhESERIREhESERIREhESERIREhETMCAAEA/wABAP8AAQABAAEA/AD/AAEAAgD9AAEA/gEAAQAD/v4BAAEA/wD/APsAAQABAAEAAQABAAEAAAADAAAAAAUABwAAAwAHACAAAAEhESEBIREhASERIREhESERIREhESERIREhESERIREzFwQAAQD/AP4AAQD/AP8AAQD/AAIAAQABAPwA/wABAAIA/gD/AP4CBwD/APsAAQADAAEAAQD/AP4A/AABAAEAAQABAAEAAQACAAAABAAAAAAFAAcAAAMABwALABkAAAEhESEBIREhASERIREhESERIREhESERIREhAgABAP8AAQABAP8A/gABAP8AAwABAPwA/wABAAIA/gABAAEABQD/AAEA/wD/AP8A/AABAAEAAQABAAACAAAAAAUABwAAAwAcAAABIREhASERIREhESMnNSERIREhESERIREhESERIQQAAQD/AP0AAQABAP8A/gICAAEAAQD/AP8A/wD+AAEABwD/AP4A/wACAAEAAv7/AP8A+wABAAEA/gAGAAAAAAACAAAAAAUABwAAAwAWAAABIREhBRUhESERIREhESERIREhESERMwQAAQD/AP0AAQD/AAIAAQABAP4A/wD+AP4HAP8AAv4BAAEA/wD+APwABAD8AAYAAAAAAQAA/wAFAAcAAA8AACkBESERIREhESERIREhESECAP8A/wABAAQA/QADAP4A/wABAAUAAQD/APsA/wD/AAAAAAEAAP8ABAAFAAAPAAApAREhESERIREhESERIREhAgD/AP8AAQADAP4AAgD/AP8AAQADAAEA/wD9AP8A/wAAAAACAAAAAAUABwAAAwATAAABIREhAREhESERIREhESERIREhEQMAAQD/AAEA/gADAPsAAgABAAIA/QAHAP8A/QD/AP8A/wAFAAEA/wD/AP8AAAEAAAAABQAHAAAXAAABIREhESERIREhESERIREhESERIREhESECAAEAAQABAP0AAgD+AAMA+wABAAEAAQD/AAcA/wD/AP8A/wD/AP8A/wAFAAEA/wABAAADAAAAAAUABwAAAwAHABkAAAEhESEBIREhAREhESERIREhESERMxEhESERAgABAP8AAQABAP8AAgD9AAMA/AD/AAEA+wEFAQADAAEAAwD/AP4A/gD/AP8AAQADAAEAAQD/AP8AAAAAAAIAAAAABQAHAAADABoAAAEhESERFSERIREhESERIREhESERIREhESERMwIAAQD/AAEA/wABAAEAAQD9AAMA/AD/AAEA/gMAAQAB/v4BAAEA/wD/AP0A/wD/AAEABAABAAAAAAACAAAAAAIABwAAAwAJAAABIREhAREhESERAQD/AAEA/wABAAEABgABAPkABQABAPoAAAAAAgAAAAACAAcAAAMACQAAASERIQERIREhEQIA/wABAP4AAQABAAYAAQD5AAYA/wD7AAAAAAIAAAAAAgAHAAADAAkAAAEhESEBESERIREBAP8AAQD/AAEAAQAGAAEA+QAFAAEA+gAAAAACAAAAAAIABwAAAwAJAAABIREhAREhESERAgD/AAEA/gABAAEABgABAPkABgD/APsAAAAAAQAABAADAAcAAAsAABEhESERIREhESERIQEAAQABAP8A/wD/AAYAAQD/AP4AAQD/AAAAAAMAAAUABQAHAAADAAcADwAAASERIQEhESERIREhESERIQQAAQD/AP0A/wABAAIAAQD+AP8ABwD/AP8AAQABAP8A/wABAAAAAAMAAAAABgAHAAADAAcAFwAAASERIQERIREBESERIREhESERIREhESERAwABAP8AAQD+AP8A/wABAAEAAQACAAEA/wAHAP8A+wADAP0A/wABAAMAAQABAP8A/wD9AP8AAAIAAAAABgAHAAADABgAAAERIRkBFSERIREhESERIREhESERIREhETMEAP4AAgD+AAIAAQABAP8A/AD/AAEA/gEAAwD9AAT+/gEAAQD/AP8A/AD/AAEABAABAAAAAwAAAAAGAAcAAAMABwAcAAABIREhAREhGQEVIREhESERIREhESERIREhESERMwUAAQD/AP8A/gABAP8AAgABAAEA/wD8AP8AAQD+BwD/APsAAwD9AAT+/gEAAQD/AP4A/QD/AAEAAwACAAAAAwAAAAAFAAcAAAMABwAXAAABIREhGQEhEQERIREhESERIREhESERIREDAAEA/wD/AP8A/wABAAEAAQABAAEA/wAHAP8A+wADAP0A/wABAAMAAQABAP8A/wD9AP8AAAAAAgAAAAAFAAcAAAMAGAAAAREhEQEhESERIREhESERIREhESERMxcVIQMA/wABAP8AAQABAAEA/wD9AP8AAQD+AgEAAQADAP0ABQABAP8A/wD8AP8AAQAEAAEAAv4AAAAAAwAAAAAFAAcAAAMABwAeAAABIREhAREhEQEVIREhESERIREhESERIREhESERIREzBAABAP8A/wD/AP8AAQD/AAIAAQABAP8A/QD/AAEA/wD+BwD/APsAAwD9AAT+/gEAAQD/AP4A/QD/AAEAAwABAAEAAAACAAAAAAUABwAAAwAUAAABIREhAREhESERIREhESERIREhESEDAAEA/wD/AAEA/wABAAIA/wD9AP8AAf4HAP8A/v78AgQAAQD/APwA/wABAAQAAAACAAAAAAUABwAAAwASAAABIREhAREhESERIREhESERIREhAwABAP8A/wABAP8AAQACAPwA/wAB/gcA/wD+/vwCBAABAP8A+wABAAQAAAAAAAMAAP8ABgAGAAADAAcAFQAAASERIREhESEBESERIREhESERIREhEQIAAQD/AAIA/gADAPwA/wABAAQAAQD8AAIAAQABAAEA+wD/AAEABQABAP8A/AD/AAABAAAAAAMABwAABwAAESERIREhESEBAAIA/gD/AAYAAQD5AAUAAAAABAAAAAAFAAcAAAMABwALABcAAAEhESEBIREhAREhEQERIREhESERIREhEQMAAQD/AP4AAQD/AAIA/wD/AP8AAQADAAEA/wAHAP8AAQD/APsAAwD9AP8AAQADAAEA/wD9AP8AAAQAAAAABgAHAAADAAcACwAXAAABIREhASERIQERIREBESERIREhESERIREEAAEA/wD9AAEA/wADAP4A/wD/AAEABAABAP8ABwD/AAEA/wD7AAMA/QD/AAEAAwABAP8A/QD/AAACAAAAAAIABwAAAwAHAAABIREhASERIQIA/gACAP4AAgD+AAYAAQD+APsAAAEAAAAABgAHAAAbAAARIREhESERIREhESERIREhESERIREhESERIREhAgD+AAEA/wACAAIAAgD/AAEA/gACAP4A/gD+AAMAAQABAAEAAQD/AAEA/wD/AP8A/wD/AP4AAgAAAAAFAAD/AAQABwAABAAJAA0AEQAlAAABNzMRIQEHIxEhASERIREhESEBIREhESERIREhESERIREhESERIQMAAv7/AP4AAv4BAAEAAQD/AP8AAQABAAEA/wD+AAEA/wD/AAEAAgD/AAEABf4C/wD7AgIBAAEAAQABAP8AAQD8AP8AAQABAAEABAABAP8A/wAAAAABAAAAAAUABwAAEwAAESERIREhESERIREhESERIREhESEBAP8AAQABAAMA/gABAP8AAgD7AAEAAQABAAMAAQD/AP0A/wD/AP8AAAAAAwAAAAAFAAcAAAMABwARAAABIREhASERIRkBIREhESERIREBAAEA/wACAAEA/wACAPwA/wACAAcA/wABAP8A+wAEAPsAAQAEAPwAAAMAAAAABQAHAAADAAcAEwAAASERIQEhESEZASERIREhESERIREBAAEA/wACAAEA/wACAP8A/QD/AAIABwD/AAEA/wD7AAQA/AD/AAEABAD8AAAAAAEAAAQAAwAHAAALAAARIREhESERIREhESEBAAEAAQD/AP8A/wAGAAEA/wD+AAEA/wAAAAACAAAAAAUABwAAAwATAAABIREhESERIREhESERIREhESERIQQA/gACAP8A/wADAPwA/wABAAEAAgAGAAEA/AD/AP8A/wABAAEAAQACAAAAAAQAAAAABQAGAAADAAcACwAfAAABIREhASERIQEhESEBIREhESERIREhESERIREhESERIQQAAQD/APwAAQD/AAMA/wABAP0AAQADAAEA/wABAP8A/QD/AAEA/wAGAP8A/AD/AAQA/gAEAP8A/wD+AP8A/wABAAEAAgABAAAEAAAAAAUABwAAAwAHAAsAFwAAASERIQEhESEBIREhASERIREhESERIREhAQABAP8AAQABAP8AAQABAP8A/wD+AAEAAwABAP4A/wAHAP8A/QABAAMA/wD6AAQAAQD/APwAAgAAAgAAAAAHAAcAAAMAFwAAASERIREhESERIREhESERIREhESERIREhAgABAP8ABQD+AAEA/wACAPwA/wD+AAEAAQAEAAEAAgD/AP4A/wD+AP8AAwD9AAUAAQAAAAACAAAAAAcABQAAAwAaAAABIREhASE1NzMRIREhESERIREhESERIREhESECAAEA/wADAAEAAv7+AAIA+gD/AAEAAgD+AAUA/wABAAEAAQD+Av4A/wD/AAEAAQABAAEAAQD/AAAAAgAAAAAFAAcAAAMAEwAAAREhEQERIREhESERIREhESERIRECAP8AAwD+AAMA+wACAAEAAgD9AAcA/wABAPwA/wD/AP8ABQABAP8A/wD/AAADAAAAAAUABwAAAwAHABMAAAERIREpAREhAREhESERIREhESERAgD/AAIAAQD/AAEA/gADAPsABQD9AAcA/wABAP8A/QD/AP8A/wAFAP8A/wAAAAADAAAAAAUABwAAAwAHABkAAAEhESEBIREhAREhESERIREhESERMxEhESERAgABAP8A/wABAP8ABAD9AAMA/AD/AAEA+wEFAQADAAEAAwD/AP4A/gD/AP8AAQADAAEAAQD/AP8AAAAAAAQAAAAABQAHAAADAAcACwAZAAABIREhASERIQEhESEBESERIREhESERIREhEQMAAQD/AP8AAQD/AP8AAQD/AAQA/QADAPwA/wABAAMABwD/AP0AAQADAP8A/gD+AP8A/wABAAMAAQD/AAAAAAMAAAAAAwAHAAADAAcACwAAASERKQIRIQERIREDAP8AAQD9AAEA/wABAAIABgABAP8A+gAFAPsAAAAAAAMAAAAAAwAHAAAEAAgADgAAATU3MxEBIREhAREhESERAgAC/v4AAQD/AP8AAQABAAUA/gL/AAIA/wD6AAYA/wD7AAAAAwAAAAADAAcAAAQACAAOAAABNTczEQEhESEBESERIRECAAL+/gABAP8A/wABAAEABQD+Av8AAgD/APoABgD/APsAAAADAAAAAAMABwAAAwAHAAsAAAEhESkCESEBESERAwD/AAEA/QABAP8AAQACAAYAAQD/APoABQD7AAAAAAADAAAAAAYABwAAAwAHABcAAAEhESEBESERAREhESERIREhESERIREhEQIAAQD/AAIA/gD/AP8AAQACAAEAAQABAP8ABwD/APsAAwD9AP8AAQADAAEAAQD/AP8A/QD/AAADAAAAAAUABwAAAwAHABcAAAEhESEBESERAREhESERIREhESERIREhEQEAAQD/AAIA/wD/AP8AAQABAAEAAQABAP8ABwD/APsAAwD9AP8AAQADAAEAAQD/AP8A/QD/AAABAAAAAAUABwAAFAAAAREhESERIREhESERIREhESERIREzAgABAP8AAQABAAEA/wD9AP8AAQD+Bf77AgUAAQD/AP8A/AD/AAEABAABAAAAAAEAAAAABQAHAAAUAAABIREhESERIREhESERIRcRIREhESEBAAEAAQACAP8A/QD/AAH+AgEA/wD/AAcA/wD/APwA/wABAAQAAvwCBAABAAAAAQAAAAAFAAcAABIAAAEhESEXESERIREhESERIREhESEBAP8AAf4CAQD/AP8AAQABAAIA/AABAAQAAvwCBAABAAEA/wD/APsAAAAAAAEAAAAABQAHAAASAAABIREhETMXESERIREhESERIREhAQD/AAEA/gIBAP8AAQABAAEA/AABAAQAAQAC+wIFAAEA/wD/APsAAAIAAP8ABQAHAAADABUAAAEhESERIREhESERIREhESERIREhESEDAP8AAQD/AP4AAQADAAEA/wABAP8A/wAGAP8A/wD7AAcAAQD/AP8A/wD9AP8AAAMAAAAABgAHAAAFAAsAEwAAAREhESEZASERIREhASERIREhESECAAEAAQD/AP8AAgD9AAUA/wD7AAEABgD+AAEAAQD9AP8A/wAGAPoA/wAGAAAAAAEAAAUAAQAHAAADAAARIREhAQD/AAcA/gAAAAACAAAAAAUABwAAAwAPAAABESERAREhESERIREhESERAwD/AP8A/wABAAMAAQD/AAEABQD7AP8AAQAFAAEA/wD7AP8AAAMAAAAABQAFAAADAAcADwAAASERIREhESEBESERIREhEQMA/wABAP8AAQD+AAQA/wD8AAQA/wD/AP8AAwABAPwA/wAEAAAAAAMAAAIAAwAHAAAHAA8AEwAAAREhESERIREhESERIREhEQEhESECAP8AAQABAP8A/wD/AAEA/wADAP0ABQABAAEA/wD/AP8AAQABAP8A/gD/AAAAAAEAAAUAAgAHAAAHAAABIREhESERIQEA/wABAAEA/wAGAAEA/wD/AAADAAAAAAYABwAAAwAHABcAAAEhESEBIREhASERIREhESERIREhESERIQQAAQD/AP0AAQD/AAMAAgD/AP8A/gD/AP8AAgACAAcA/wABAP8A/wD/AP8A/QADAAEAAQD/AAACAAAAAAUABwAAAwAYAAABIREhERUhESERIREhESERIREhESERIREzAgABAP8AAQD/AAEAAQABAP4A/wD+AAEA/gMAAQAB/v4BAAEA/wD+APwAAgD+AAQAAgAAAAIAAAAABQAHAAADABoAAAEhESERFSERIREhESERIREhESERIREhESERMwIAAQD/AAEA/wABAAEAAQD8AP8AAQACAP4A/gEAAQAD/v4BAAEA/wD/APsAAQABAAEAAQACAAAAAAADAAD/AAUABwAAAwAHABcAAAEhESEBIREhGQEhESERIREhESERIREhEQEAAQD/AAIAAQD/AAIA/wD9AAIA/gD/AAIABwD/AAEA/wD8AAMA+wD/AAEAAQABAAMA/QAAAAABAAD/AAIABwAAAwAAESERIQIA/gAHAPgAAAAABAAAAAAGAAYAAAQACAAMAB4AAAE1NzMRASERIQEhESERIREhESERIREhESERIREhESEFAAL+/wABAP8A/QADAP0A/wD/AAEAAQADAP8A/gADAP0ABAD+Av8A/gD/AAUA/wD8AAEAAgABAP8A/wD/AP8A/wAAAAAAAwAA/wAFAAcAAAMABwAbAAABIREhASERIQEhESERIREhESERIREhESERIREhBAABAP8A/gABAP8A/gABAAMAAQD/AP0AAgD+AP8AAQD/AAcA/wD8AAIAAwD/AP8A+wD/AAEAAQABAAIAAgAAAgAAAAAFAAcAAAMAFQAAASERIQEhESERIREhESERIREhESERIQQAAQD/APwAAQADAP4AAQACAPwA/wABAP8ABwD/AAEA/wD+AP0AAgD9AAEAAwACAAAAAAEAAP4AAQAIAAADAAARIREhAQD/AAgA9gAAAAACAAAAAAYABwAAAwAXAAABIREpAhEhESERIREhESERIREhESERIQQAAQD/AP8AAQACAP8A/wD+AP8A/wACAAIA/wAHAP8A/wD/AP8A/QADAAEAAQD/AAEAAAAAAAMAAP8ABQAHAAADAAcAGAAAASERIQEhESEZASERIREhESERIREhESEXEQIAAQD/AAEAAQD/AAIA/wD9AAIA/gD/AAH+AgYA/wACAP8A/AADAPsA/wABAAEAAQADAAL9AgAAAAAAAAAAAAAAAAAAIgBKAHAAlgC2AN4A/AEyAVwBdgGSAaoBzAHqAgQCEAIiAlQCZAKQArYC2AL4AyQDSgNwA4QDngO+A+QEFAQ0BFoEdASaBLoE1AT0BRgFMgVYBXIFiAWkBcoF2AX2Bg4GMAZQBnAGhgamBsAG2Ab4Bx4HQgdiB4QHmgewB+oIKghaCJYIpAjGCOgJGgk0CUgJVglkCX4JkgmsCdgJ7goaCkIKVgpwCoQKkgqmCrQKyAr4CygLVguQC74L8gwmDGQMmAzODPoNGg06DWINjg3CDfQODg4oDkIOXA52DpoOyg74Dy4PXg+OD8gP8hAaEEYQWhCMEL4Q1BEGEU4RdBGaEcQR3hIGEkQSdhKkEtYS/hMoE1wTkhOwE9IT9BQSFEIUchSaFMIU6BUMFTYVYBVuFW4VkBW0Fd4V8hYiFlAWghayFsAW/BcyF14XbBeaF8wAAAACAAAAAAAA/wABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKwAAAECAAIBAwAVABwAFgAXABgAGQAaABsAJQAmACcAKQAkACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQAoAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgAdAB4AHwAgACEAIgA+AD8AQABCAF4AXwBgAK0AyQDHAK4AagBpAGsAbQBsAGYAeABkAG8AZQDIAHAAcgDPAMwAdQB0AEEAYQDQANEArwB5AHsAfQDUAH4AIwAUAHwAZwCjAJYAhgCFAIEAaADYAKIAvQBiAJAAoADLAMoAcQBzAM4AzQB2AHcA0wB6ANUA1gB/AIAAiQCRALcAAwATAKEAngBDALsAYwBuALoA6AEEAAAAAADlAOsA7AUubnVsbAx2aXNpYmxlc3BhY2UERXVybwAA");
hx__registerFont("R_fonts_upheavtt_ttf","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BwMGBQgEBgQDCAYEBgQEAwYFAwMCBAYHBwcGBgYGBgYGBwYGBgYGBgYGBgcGBgYGBgYFBgYGBgYHBgYGBgYGBgYHBgYGBgYGBgYGBwYGBgYGBgUGBgYGBgcGBwAFAAAACwoIBAMEBwcHBwIEBAYHAgcCBwcDBwcHBwcHBwcCAgUHBQcIBwcHBwcHBwcGBwcHCAcHBwcHBwYHBwgHBwcEBwQGBwIHBwcHBwcHBwYHBwcIBwcHBwcHBgcHCAcHBwUDBQgHBwcCBQQFBwcECgcDCAcHBwcDAwYGBAMHBAgHAwgHBwcEAwcHBgcDBwUIBAYEAwgHBAcEBAMHBQMDAgQGBwcHBwcHBwcHBwgHBwcHBwYGBgYHBwcHBwcHBQcHBwcHBwcHBwcHBwcHCAcHBwcHBgYGBgcHBwcHBwcGBwcHBwcHBwcABgAAAAwLCQQDBQcHCAcCBQUGBwIHAggHAwcHBwcHBwcHAgIFBwUHCAcHBwcHBwcHBwcIBwgHBwcHBwcHBwcIBwgHBQgFBgcCBwcHBwcHBwcHBwgHCAcHBwcHBwcHBwgHCAcFAwUJBwcHAgUFBQcHBQsHBAgHBwcHAwMGBgUDBwUJBwQIBwcIBAMHCAcIAwcFCQQHBQMJBwUHBAQDBwUDAwIEBwgICAcHBwcHBwcIBwcHBwcHBwcHCAcHBwcHBwUHBwcHBwgHBwcHBwcHBwgHBwcHBwcHBwcIBwcHBwcHBgcHBwcHCAcIAAYAAAANDAoFAwUICAgIAwUFBwgDCAMICAMICAgICAgICAMDBggGCAkICAgICAgICAcICAgJCAgICAgIBwgICQgICAUIBQcIAwgICAgICAgIBwgICAkICAgICAgHCAgJCAgIBgMGCggICAMGBQYICAUMCAQJCAgICAMDBwcFAwgFCggECQgICAUDCAgHCAMIBgoFBwUDCggFCAUFAwgGAwMCBQcICAgICAgICAgICQgICAgIBwcHBwgICAgICAgGCAgICAgICAgICAgICAgJCAgICAgHBwcHCAgICAgICAcICAgICAgICAAHAAAADw4LBQQGCQkKCQMGBggJAwkDCgkECQkJCQkJCQkDAwcJBwkLCQkJCQkJCQkICQoJCwkJCQkJCQgJCQsJCgkGCgYICQMJCQkJCQkJCQgJCgkLCQkJCQkJCAkJCwkKCQcEBwsJCQkDBwYHCQkGDgkFCwkJCQkEBAgIBgQJBgsJBQsJCQoFBAkKCAoECQcLBQgGBAsJBgkFBQQJBwQEAgUICgoKCQkJCQkJCQsJCQkJCQgICAgKCQkJCQkJBwkJCQkJCgkJCQkJCQkJCwkJCQkJCAgICAoJCQkJCQkICQkJCQkKCQoACAAAABAPDAYEBgoKCgoDBgYICgMKAwoKBAoKCgoKCgoKAwMHCgcKCwoKCgoKCgoKCQoKCgsKCgoKCgoJCgoLCgoKBgoGCAoDCgoKCgoKCgoJCgoKCwoKCgoKCgkKCgsKCgoHBAcMCgoKAwcGBwoKBg8KBQsKCgoKBAQICAYECgYMCgULCgoKBgQKCgkKBAoHDAYJBgQMCgYKBgYECgcEBAIGCQoKCgoKCgoKCgoLCgoKCgoJCQkJCgoKCgoKCgcKCgoKCgoKCgoKCgoKCgsKCgoKCgkJCQkKCgoKCgoKCAoKCgoKCgoKAAgAAAAREA0GBAcKCgsKAwcHCQoDCgMLCgQKCgoKCgoKCgMDCAoICgwKCgoKCgoKCgkKCwoMCgoKCgoKCQoKDAoLCgcLBwkKAwoKCgoKCgoKCQoLCgwKCgoKCgoJCgoMCgsKCAQIDQoKCgMIBwgKCgcQCgUMCgoKCgQECQkHBAoHDQoFDAoKCwYECgsJCwQKCA0GCQcEDQoHCgYGBAoIBAQDBgkLCwsKCgoKCgoKDAoKCgoKCQkJCQsKCgoKCgoICgoKCgoLCgoKCgoKCgoMCgoKCgoJCQkJCwoKCgoKCgkKCgoKCgsKCwAJAAAAExIOBwUICwsMCwQICAoLBAsEDAsFCwsLCwsLCwsEBAkLCQsNCwsLCwsLCwsKCwwLDQsLCwsLCwoLCw0LDAsIDAgKCwQLCwsLCwsLCwoLDAsNCwsLCwsLCgsLDQsMCwkFCQ4LCwsECQgJCwsIEgsGDQsLCwsFBQoKCAULCA4LBg0LCwwHBQsMCgwFCwkOBwoIBQ4LCAsHBwULCQUFAwcKDAwMCwsLCwsLCw0LCwsLCwoKCgoMCwsLCwsLCQsLCwsLDAsLCwsLCwsLDQsLCwsLCgoKCgwLCwsLCwsKCwsLCwsMCwwACgAAABUUDwcFCA0NDg0ECAgLDQQNBA4NBQ0NDQ0NDQ0NBAQJDQkNDw0NDQ0NDQ0NDA0ODQ8NDQ0NDQ0MDQ0PDQ4NCA4ICw0EDQ0NDQ0NDQ0MDQ4NDw0NDQ0NDQwNDQ8NDg0JBQkQDQ0NBAkICQ0NCBQNBg8NDQ0NBQULCwgFDQgQDQYPDQ0OBwUNDgwOBQ0JEAcMCAUQDQgNBwcFDQkFBQMHDA4ODg0NDQ0NDQ0PDQ0NDQ0MDAwMDg0NDQ0NDQkNDQ0NDQ4NDQ0NDQ0NDQ8NDQ0NDQwMDAwODQ0NDQ0NCw0NDQ0NDg0OAAsAAAAYFxIIBgoODhAOBQoKDA4FDgUQDgYODg4ODg4ODgUFCw4LDhEODg4ODg4ODg0OEA4RDg4ODg4ODQ4OEQ4QDgoQCgwOBQ4ODg4ODg4ODQ4QDhEODg4ODg4NDg4RDhAOCwYLEg4ODgULCgsODgoXDgcRDg4ODgYGDAwKBg4KEg4HEQ4OEAgGDhANEAYOCxIIDQoGEg4KDggIBg4LBgYECA0QEBAODg4ODg4OEQ4ODg4ODQ0NDRAODg4ODg4LDg4ODg4QDg4ODg4ODg4RDg4ODg4NDQ0NEA4ODg4ODgwODg4ODhAOEAAMAAAAGxoUCQcLEBASEAULCw4QBRAFEhAHEBAQEBAQEBAFBQwQDBATEBAQEBAQEBAPEBIQExAQEBAQEA8QEBMQEhALEgsOEAUQEBAQEBAQEA8QEhATEBAQEBAQDxAQExASEAwHDBQQEBAFDAsMEBALGhAIExAQEBAHBw4OCwcQCxQQCBMQEBIJBxASDxIHEAwUCQ8LBxQQCxAJCQcQDAcHBAkPEhISEBAQEBAQEBMQEBAQEA8PDw8SEBAQEBAQDBAQEBAQEhAQEBAQEBAQExAQEBAQDw8PDxIQEBAQEBAOEBAQEBASEBIADgAAAB0cFQoHDBERExEGDAwPEQYRBhMRBxERERERERERBgYNEQ0RFBEREREREREREBETERQREREREREQEREUERMRDBMMDxEGEREREREREREQERMRFBERERERERARERQRExENBw0WERERBg0MDRERDBwRCRQRERERBwcPDwwHEQwWEQkUERETCgcRExATBxENFgoQDAcWEQwRCgoHEQ0HBwQKEBMTExEREREREREUEREREREQEBAQExEREREREQ0RERERERMRERERERERERQRERERERAQEBATERERERERDxERERERExETAA8AAAAgHhgLCA0TExUTBg0NEBMGEwYVEwgTExMTExMTEwYGDhMOExYTExMTExMTExITFRMWExMTExMTEhMTFhMVEw0VDRATBhMTExMTExMTEhMVExYTExMTExMSExMWExUTDggOGBMTEwYODQ4TEw0eEwoWExMTEwgIEBANCBMNGBMKFhMTFQsIExUSFQgTDhgLEg0IGBMNEwsLCBMOCAgFCxIVFRUTExMTExMTFhMTExMTEhISEhUTExMTExMOExMTExMVExMTExMTExMWExMTExMSEhISFRMTExMTExATExMTExUTFQAQAAAAIR8YDAgNFBQVFAcNDREUBxQHFRQIFBQUFBQUFBQHBw8UDxQXFBQUFBQUFBQSFBUUFxQUFBQUFBIUFBcUFRQNFQ0RFAcUFBQUFBQUFBIUFRQXFBQUFBQUEhQUFxQVFA8IDxkUFBQHDw0PFBQNHxQKFxQUFBQICBERDQgUDRkUChcUFBUMCBQVEhUIFA8ZDBINCBkUDRQMDAgUDwgIBQwSFRUVFBQUFBQUFBcUFBQUFBISEhIVFBQUFBQUDxQUFBQUFRQUFBQUFBQUFxQUFBQUEhISEhUUFBQUFBQRFBQUFBQVFBUAEQAAACUjGw0JDxYWGBYHDw8TFgcWBxgWCRYWFhYWFhYWBwcRFhEWGhYWFhYWFhYWFBYYFhoWFhYWFhYUFhYaFhgWDxgPExYHFhYWFhYWFhYUFhgWGhYWFhYWFhQWFhoWGBYRCREcFhYWBxEPERYWDyMWCxoWFhYWCQkTEw8JFg8cFgsaFhYYDQkWGBQYCRYRHA0UDwkcFg8WDQ0JFhEJCQYNFBgYGBYWFhYWFhYaFhYWFhYUFBQUGBYWFhYWFhEWFhYWFhgWFhYWFhYWFhoWFhYWFhQUFBQYFhYWFhYWExYWFhYWGBYYABMAAAAqKB8PCxEZGRsZCBERFRkIGQgbGQsZGRkZGRkZGQgIExkTGR0ZGRkZGRkZGRcZGxkdGRkZGRkZFxkZHRkbGREbERUZCBkZGRkZGRkZFxkbGR0ZGRkZGRkXGRkdGRsZEwsTIBkZGQgTERMZGREoGQ0dGRkZGQsLFRURCxkRIBkNHRkZGw8LGRsXGwsZEyAPFxELIBkRGQ8PCxkTCwsGDxcbGxsZGRkZGRkZHRkZGRkZFxcXFxsZGRkZGRkTGRkZGRkbGRkZGRkZGRkdGRkZGRkXFxcXGxkZGRkZGRUZGRkZGRsZGwAVAAAALiwiEAwSHBweHAkSEhccCRwJHhwMHBwcHBwcHBwJCRUcFRwgHBwcHBwcHBwZHB4cIBwcHBwcHBkcHCAcHhwSHhIXHAkcHBwcHBwcHBkcHhwgHBwcHBwcGRwcIBweHBUMFSMcHBwJFRIVHBwSLBwOIBwcHBwMDBcXEgwcEiMcDiAcHB4QDBweGR4MHBUjEBkSDCMcEhwQEAwcFQwMBxAZHh4eHBwcHBwcHCAcHBwcHBkZGRkeHBwcHBwcFRwcHBwcHhwcHBwcHBwcIBwcHBwcGRkZGR4cHBwcHBwXHBwcHBweHB4AFwAAADIwJRINFB4eIR4KFBQZHgoeCiEeDR4eHh4eHh4eCgoXHhceIx4eHh4eHh4eHB4hHiMeHh4eHh4cHh4jHiEeFCEUGR4KHh4eHh4eHh4cHiEeIx4eHh4eHhweHiMeIR4XDRcmHh4eChcUFx4eFDAeDyMeHh4eDQ0ZGRQNHhQmHg8jHh4hEg0eIRwhDR4XJhIcFA0mHhQeEhINHhcNDQgSHCEhIR4eHh4eHh4jHh4eHh4cHBwcIR4eHh4eHhceHh4eHiEeHh4eHh4eHiMeHh4eHhwcHBwhHh4eHh4eGR4eHh4eIR4hABkAAAA2MygTDhYgICMgCxYWGyALIAsjIA4gICAgICAgIAsLGCAYICYgICAgICAgIB4gIyAmICAgICAgHiAgJiAjIBYjFhsgCyAgICAgICAgHiAjICYgICAgICAeICAmICMgGA4YKSAgIAsYFhggIBYzIBAmICAgIA4OGxsWDiAWKSAQJiAgIxMOICMeIw4gGCkTHhYOKSAWIBMTDiAYDg4IEx4jIyMgICAgICAgJiAgICAgHh4eHiMgICAgICAYICAgICAjICAgICAgICAmICAgICAeHh4eIyAgICAgIBsgICAgICMgIwAbAAAAOjcrFA8XIyMmIwwXFx0jDCMMJiMPIyMjIyMjIyMMDBojGiMpIyMjIyMjIyMgIyYjKSMjIyMjIyAjIykjJiMXJhcdIwwjIyMjIyMjIyAjJiMpIyMjIyMjICMjKSMmIxoPGiwjIyMMGhcaIyMXNyMRKSMjIyMPDx0dFw8jFywjESkjIyYUDyMmICYPIxosFCAXDywjFyMUFA8jGg8PCRQgJiYmIyMjIyMjIykjIyMjIyAgICAmIyMjIyMjGiMjIyMjJiMjIyMjIyMjKSMjIyMjICAgICYjIyMjIyMdIyMjIyMmIyYA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Jf8mESYqJjwmWicjJ7goZykJKVUplinXKk8quSsNK1krmSvpLCIsYizQLRwtVC2MLgAuPC6ALvgvNS9yL+YwSzCcMRoxYjGYMc4yOzKBMsoy9jM3M3gzuTQxNJs07zU7NXs1yzYENkQ2sjb+NzY3bjfiOB44YjjaORc5VDnIOi06fjqnOu87JTtbO8g8DjxXPIM82zzbPNsAAQAAAOMCAAAFAAAAAAACAAAAAAAUAAACAAKmAAAAAQAAAA4ArgABAAAAAAAAACsAAAABAAAAAAABABEAKwABAAAAAAACAAcAPAABAAAAAAADABIAQwABAAAAAAAEABEAVQABAAAAAAAFAAwAZgABAAAAAAAGAA8AcgADAAEECQAAAFYAgQADAAEECQABACIA1wADAAEECQACAA4A+QADAAEECQADACQBBwADAAEECQAEACIBKwADAAEECQAFABgBTQADAAEECQAGAB4BZcZOSUdNQSBGT05UUyAgIFtlLW1haWxdICBrZW50cHdAbm9yd2ljaC5uZXRVcGhlYXZhbCBUVCAoQlJLKVJlZ3VsYXJGT05UTEFCMzA6VFRFWFBPUlRVcGhlYXZhbCBUVCAtQlJLLVZlcnNpb24gMi4wOVVwaGVhdmFsVFQtQlJLLQDGAE4ASQBHAE0AQQAgAEYATwBOAFQAUwAgACAAIABbAGUALQBtAGEAaQBsAF0AIAAgAGsAZQBuAHQAcAB3AEAAbgBvAHIAdwBpAGMAaAAuAG4AZQB0AFUAcABoAGUAYQB2AGEAbAAgAFQAVAAgACgAQgBSAEsAKQBSAGUAZwB1AGwAYQByAEYATwBOAFQATABBAEIAMwAwADoAVABUAEUAWABQAE8AUgBUAFUAcABoAGUAYQB2AGEAbAAgAFQAVAAgAC0AQgBSAEsALQBWAGUAcgBzAGkAbwBuACAAMgAuADAAOQBVAHAAaABlAGEAdgBhAGwAVABUAC0AQgBSAEsALQAAAAACAAAAAAAA/5wAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAOMAAAADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPAO8AEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEBAgEDAQQAxACmAMUAqwCCAMIA2ADGAOQAvgCwAQUBBgEHAQgAtgC3ALQAtQCHALIAswDZAIwA5QC/ALEBCQEKALsBCwCjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAAQAIoBDACDAJMA8gDzAI0AlwCIAQ0A3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBDgACBS4wMTI3BS4wMTI4BS4wMTI5BS4wMTQxBS4wMTQyBS4wMTQzBS4wMTQ0BS4wMTU3BS4wMTU4BS4wMTYwBm1hY3Jvbg5wZXJpb2RjZW50ZXJlZAUubnVsbLgAACu6AAAABAAHKw==");
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
h2d_Object.tmpPoint = new h2d_col_PointImpl(0.,0.);
h2d_Element.ANIMATED = [];
Fx.FIT_PIX = false;
Fx.ALL = [];
Fx.SOLO_BACKUP = [];
Fx.PLAYING = [];
Fx.DEATH_CONDITIONS = new haxe_ds_ObjectMap();
Cons.DIR = [[1,0],[0,1],[-1,0],[0,-1]];
Cons.DIR8 = [[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1],[0,-1],[1,-1]];
Cons.DIAG = 1.414;
Main.WIDTH = 256;
Main.HEIGHT = 256;
Main.BUTS = [];
Main.t = 0;
Main.newRecord = -1;
Main.SAVE_ID = "snowballJuggling";
Dev.FORMAT = false;
Dev.FINAL = true;
Dev.MODE = -1;
Gameplay.LIFE_CHALLENGER = 2;
Gameplay.CHALLENGE_GOAL = 10;
Snowman.TORSO_RAY = 38;
Snowman.HEAD_RAY = 32;
Snowman.ARM_LENGTH = 28;
Head.RAY = 16;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
format_gif_Tools.LN2 = Math.log(2);
format_mp3_MPEG.V1 = 3;
format_mp3_MPEG.V2 = 2;
format_mp3_MPEG.V25 = 0;
format_mp3_MPEG.Reserved = 1;
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_Bad]];
format_mp3_CLayer.LReserved = 0;
format_mp3_CLayer.LLayer3 = 1;
format_mp3_CLayer.LLayer2 = 2;
format_mp3_CLayer.LLayer1 = 3;
format_mp3_CChannelMode.CStereo = 0;
format_mp3_CChannelMode.CJointStereo = 1;
format_mp3_CChannelMode.CDualChannel = 2;
format_mp3_CChannelMode.CMono = 3;
format_mp3_CEmphasis.ENone = 0;
format_mp3_CEmphasis.EMs50_15 = 1;
format_mp3_CEmphasis.EReserved = 2;
format_mp3_CEmphasis.ECCIT_J17 = 3;
h2d_HtmlText.REG_SPACES = new EReg("[\r\n\t ]+","g");
h3d_impl_RenderContext.STRICT = true;
h2d_RenderContext.BUFFERING = false;
h2d_col_Matrix.tmp = new h2d_col_Matrix();
h2d_filter_Filter.defaultUseScreenResolution = false;
h3d_shader_ScreenShader.SRC = "HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA";
h2d_filter__$Mask_MaskShader.SRC = "HXSLG2gyZC5maWx0ZXIuX01hc2suTWFza1NoYWRlcg0BBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQoCAAALBG1hc2sKAgAADAhtYXNrTWF0QQULAgAADQhtYXNrTWF0QgULAgAADgtzbW9vdGhBbHBoYQICAAEAAAAAAA8IX19pbml0X18OBgAAEAZ2ZXJ0ZXgOBgAAEQhmcmFnbWVudA4GAAADAg8AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAQAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAERAAAFBQgSBWNvbG9yBQwEAAAJAyEOAgIKCgIDBQoFDAAIEwJ1dgULBAAACQMpDgICAwUKAQMAAAAAAADwPwMFCwAIFAFrBQwEAAAJAyEOAgILCgkDKA4CCQMdDgICEwULAgwFCwMJAx0OAgITBQsCDQULAwUKBQwACBUFYWxwaGEDBAAACwIOAgoCFAUMDAADCQMmDgEGBwoCFAUMDAADAQMAAAAAAAAAAAMCAwMABgQCBwUMBgECEgUMAhUDBQwFDAA";
h3d_Buffer.GUID = 0;
h3d_Engine.SOFTWARE_DRIVER = false;
h3d_Engine.ANTIALIASING = 0;
h3d_MatrixImpl.tmp = new h3d_MatrixImpl();
h3d_MatrixImpl.lumR = 0.212671;
h3d_MatrixImpl.lumG = 0.71516;
h3d_MatrixImpl.lumB = 0.072169;
h3d_MatrixImpl.SQ13 = 0.57735026918962576450914878050196;
h3d_anim_Animation.EPSILON = 0.000001;
h3d_col_ObjectCollider.TMP_RAY = new h3d_col_Ray();
h3d_col_ObjectCollider.TMP_MAT = new h3d_MatrixImpl();
h3d_scene_Object.ROT2RAD = -0.017453292519943295769236907684886;
h3d_scene_Object.tmpMat = new h3d_MatrixImpl();
h3d_impl_GlDriver.UID = 0;
h3d_impl_GlDriver.ALLOW_WEBGL2 = true;
h3d_impl_GlDriver.BLACK = (function($this) {
	var $r;
	var x = 0;
	var y = 0;
	var z = 0;
	var w = 0;
	if(w == null) {
		w = 1.;
	}
	if(z == null) {
		z = 0.;
	}
	if(y == null) {
		y = 0.;
	}
	if(x == null) {
		x = 0.;
	}
	$r = new h3d_Vector4Impl(x,y,z,w);
	return $r;
}(this));
h3d_impl_GlDriver.outOfMemoryCheck = false;
h3d_impl_GlDriver.STREAM_POS = 1;
h3d_impl_GlDriver.TFILTERS = [[[9728,9728],[9729,9729]],[[9728,9984],[9729,9985]],[[9728,9986],[9729,9987]]];
h3d_impl_GlDriver.TWRAP = [33071,10497];
h3d_impl_GlDriver.FACES = [0,1028,1029,1032];
h3d_impl_GlDriver.BLEND = [1,0,770,768,772,774,771,769,773,775,32769,32771,32770,32772,776];
h3d_impl_GlDriver.COMPARE = [519,512,514,517,516,518,513,515];
h3d_impl_GlDriver.STENCIL_OP = [7680,0,7681,7682,34055,7683,34056,5386];
h3d_impl_GlDriver.OP = [32774,32778,32779,32775,32776];
h3d_impl_GlDriver.CUBE_FACES = [34069,34070,34071,34072,34073,34074];
h3d_impl_GlDriver.CBUFFERS = (function($this) {
	var $r;
	var _g = [];
	{
		var _g1 = 0;
		while(_g1 < 32) {
			var i = _g1++;
			var _g2 = [];
			var _g3 = 0;
			var _g4 = i;
			while(_g3 < _g4) {
				var k = _g3++;
				_g2.push(36064 + k);
			}
			_g.push(_g2);
		}
	}
	$r = _g;
	return $r;
}(this));
h3d_impl_MemoryManager.MAX_MEMORY = 4294967296.;
h3d_impl_MemoryManager.SIZE = 65532;
h3d_impl_MemoryManager.ALL_FLAGS = h3d_BufferFlag.__empty_constructs__.slice();
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5;
h3d_mat_Defaults.loadingTextureColor = -65281;
h3d_mat_MaterialSetup.current = new h3d_mat_MaterialSetup("Default");
h3d_mat_Pass.enableLights_bits = 1;
h3d_mat_Pass.enableLights_offset = 0;
h3d_mat_Pass.enableLights_mask = 1;
h3d_mat_Pass.dynamicParameters_bits = 1;
h3d_mat_Pass.dynamicParameters_offset = 1;
h3d_mat_Pass.dynamicParameters_mask = 2;
h3d_mat_Pass.isStatic_bits = 1;
h3d_mat_Pass.isStatic_offset = 2;
h3d_mat_Pass.isStatic_mask = 4;
h3d_mat_Pass.batchMode_bits = 1;
h3d_mat_Pass.batchMode_offset = 3;
h3d_mat_Pass.batchMode_mask = 8;
h3d_mat_Pass.culling_bits = 2;
h3d_mat_Pass.culling_offset = 0;
h3d_mat_Pass.culling_mask = 3;
h3d_mat_Pass.depthWrite_bits = 1;
h3d_mat_Pass.depthWrite_offset = 2;
h3d_mat_Pass.depthWrite_mask = 4;
h3d_mat_Pass.depthTest_bits = 3;
h3d_mat_Pass.depthTest_offset = 3;
h3d_mat_Pass.depthTest_mask = 56;
h3d_mat_Pass.blendSrc_bits = 4;
h3d_mat_Pass.blendSrc_offset = 6;
h3d_mat_Pass.blendSrc_mask = 960;
h3d_mat_Pass.blendDst_bits = 4;
h3d_mat_Pass.blendDst_offset = 10;
h3d_mat_Pass.blendDst_mask = 15360;
h3d_mat_Pass.blendAlphaSrc_bits = 4;
h3d_mat_Pass.blendAlphaSrc_offset = 14;
h3d_mat_Pass.blendAlphaSrc_mask = 245760;
h3d_mat_Pass.blendAlphaDst_bits = 4;
h3d_mat_Pass.blendAlphaDst_offset = 18;
h3d_mat_Pass.blendAlphaDst_mask = 3932160;
h3d_mat_Pass.blendOp_bits = 3;
h3d_mat_Pass.blendOp_offset = 22;
h3d_mat_Pass.blendOp_mask = 29360128;
h3d_mat_Pass.blendAlphaOp_bits = 3;
h3d_mat_Pass.blendAlphaOp_offset = 25;
h3d_mat_Pass.blendAlphaOp_mask = 234881024;
h3d_mat_Pass.wireframe_bits = 1;
h3d_mat_Pass.wireframe_offset = 28;
h3d_mat_Pass.wireframe_mask = 268435456;
h3d_mat_Pass.reserved_bits = 1;
h3d_mat_Pass.reserved_offset = 29;
h3d_mat_Pass.reserved_mask = 536870912;
h3d_mat_Stencil.readMask_bits = 8;
h3d_mat_Stencil.readMask_offset = 0;
h3d_mat_Stencil.readMask_mask = 255;
h3d_mat_Stencil.writeMask_bits = 8;
h3d_mat_Stencil.writeMask_offset = 8;
h3d_mat_Stencil.writeMask_mask = 65280;
h3d_mat_Stencil.reference_bits = 8;
h3d_mat_Stencil.reference_offset = 16;
h3d_mat_Stencil.reference_mask = 16711680;
h3d_mat_Stencil.frontTest_bits = 3;
h3d_mat_Stencil.frontTest_offset = 0;
h3d_mat_Stencil.frontTest_mask = 7;
h3d_mat_Stencil.frontPass_bits = 3;
h3d_mat_Stencil.frontPass_offset = 3;
h3d_mat_Stencil.frontPass_mask = 56;
h3d_mat_Stencil.frontSTfail_bits = 3;
h3d_mat_Stencil.frontSTfail_offset = 6;
h3d_mat_Stencil.frontSTfail_mask = 448;
h3d_mat_Stencil.frontDPfail_bits = 3;
h3d_mat_Stencil.frontDPfail_offset = 9;
h3d_mat_Stencil.frontDPfail_mask = 3584;
h3d_mat_Stencil.backTest_bits = 3;
h3d_mat_Stencil.backTest_offset = 12;
h3d_mat_Stencil.backTest_mask = 28672;
h3d_mat_Stencil.backPass_bits = 3;
h3d_mat_Stencil.backPass_offset = 15;
h3d_mat_Stencil.backPass_mask = 229376;
h3d_mat_Stencil.backSTfail_bits = 3;
h3d_mat_Stencil.backSTfail_offset = 18;
h3d_mat_Stencil.backSTfail_mask = 1835008;
h3d_mat_Stencil.backDPfail_bits = 3;
h3d_mat_Stencil.backDPfail_offset = 21;
h3d_mat_Stencil.backDPfail_mask = 14680064;
h3d_mat_Texture.UID = 0;
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647;
h3d_mat_Texture.PREVENT_FORCED_DISPOSE = -1;
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA;
h3d_mat_Texture.TRILINEAR_FILTERING_ENABLED = true;
h3d_mat_Texture.DEFAULT_WRAP = h3d_mat_Wrap.Clamp;
h3d_mat_Texture.checkerTextureKeys = new haxe_ds_IntMap();
h3d_mat_Texture.noiseTextureKeys = new haxe_ds_IntMap();
h3d_mat_Texture.genTextureKeys = new haxe_ds_StringMap();
h3d_pass_Blur.__meta__ = { obj : { ignore : ["shader"]}};
h3d_pass__$Border_BorderShader.SRC = "HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA";
h3d_pass__$Copy_ArrayCopyShader.SRC = "HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA";
h3d_pass__$Copy_CopyShader.SRC = "HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA";
h3d_pass__$CubeCopy_CubeCopyShader.SRC = "HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA";
h3d_scene_Mesh.tmpMat = new h3d_MatrixImpl();
h3d_scene_ObjectFlags.FPosChanged = 1;
h3d_scene_ObjectFlags.FVisible = 2;
h3d_scene_ObjectFlags.FCulled = 4;
h3d_scene_ObjectFlags.FFollowPositionOnly = 8;
h3d_scene_ObjectFlags.FLightCameraCenter = 16;
h3d_scene_ObjectFlags.FAllocated = 32;
h3d_scene_ObjectFlags.FAlwaysSyncAnimation = 64;
h3d_scene_ObjectFlags.FInheritCulled = 128;
h3d_scene_ObjectFlags.FModelRoot = 256;
h3d_scene_ObjectFlags.FIgnoreBounds = 512;
h3d_scene_ObjectFlags.FIgnoreCollide = 1024;
h3d_scene_ObjectFlags.FIgnoreParentTransform = 2048;
h3d_scene_ObjectFlags.FCullingColliderInherited = 4096;
h3d_scene_ObjectFlags.FFixedPosition = 8192;
h3d_scene_ObjectFlags.FFixedPositionSynced = 16384;
h3d_scene_ObjectFlags.FAlwaysSync = 32768;
h3d_scene_RenderContext.__meta__ = { fields : { cameraView : { global : ["camera.view"]}, cameraNear : { global : ["camera.zNear"]}, cameraFar : { global : ["camera.zFar"]}, cameraProj : { global : ["camera.proj"]}, cameraPos : { global : ["camera.position"]}, cameraProjDiag : { global : ["camera.projDiag"]}, cameraProjFlip : { global : ["camera.projFlip"]}, cameraViewProj : { global : ["camera.viewProj"]}, cameraInverseViewProj : { global : ["camera.inverseViewProj"]}, globalTime : { global : ["global.time"]}, pixelSize : { global : ["global.pixelSize"]}, globalModelView : { global : ["global.modelView"]}, globalModelViewInverse : { global : ["global.modelViewInverse"]}}};
h3d_scene_Skin.TMP_MAT = new h3d_MatrixImpl();
h3d_shader_AmbientLight.SRC = "HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA";
h3d_shader_Base2d.SRC = "HXSLEWgzZC5zaGFkZXIuQmFzZTJkGwEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCXZpZXdwb3J0QQULAgAAHAl2aWV3cG9ydEIFCwIAAB0Ob3V0cHV0UG9zaXRpb24FDAQAAB4IX19pbml0X18OBgAAHwZ2ZXJ0ZXgOBgAAIAhmcmFnbWVudA4GAAADAh4AAAUGBgQCCwUMCQMqDgMCAgUKAgkDAQMAAAAAAADwPwMFDAUMCwIQAgUDBgQKAgwFDAAAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhIFCwMDBgQKAgwFDAQAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhMFCwMDBgQKAgwFDDkABQoKAgsFDDkABQoFCgAGBAIMBQwCCwUMBQwABgQCDwUKCwIWAgYABgECAwUKCgIXBQw5AAUKBQoKAhcFDBEABQoFCgIDBQoFCgUKBgQCDQUMCwIQAgYBAhEFDAIEBQwFDAIEBQwFDAUMBgQCDgUMCQMhDgICCgoCDwUKBQwFDAaBAg0FDAIOBQwFDAAAHwAABQUIIQN0bXAFCwQAAAkDKQ4CCgIMBQwRAAUKAQMAAAAAAADwPwMFCwAGBAIhBQsJAykOAwkDHQ4CAiEFCwIUBQsDCQMdDgICIQULAhUFCwMBAwAAAAAAAPA/AwULBQsGBAIdBQwJAyoOAwkDHQ4CAiEFCwIbBQsDCQMdDgICIQULAhwFCwMKAgwFDDkABQoFDAUMCwIZAgaDCgIdBQwRAAUKAhoFCgUKAAAGBAIGBQwCHQUMBQwAASAAAAUCCwYOAhgCBgkKAg0FDAwAAwED/Knx0k1iUD8DAgIMAAAABgQCBwUMAg0FDAUMAA";
h3d_shader_BaseMesh.SRC = "HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA";
h3d_shader_Blur.SRC = "HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA";
h3d_shader_ColorAdd.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA";
h3d_shader_ColorKey.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA";
h3d_shader_ColorMatrix.SRC = "HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgEAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADB2VuYWJsZWQCAgABAAAAAAAECGZyYWdtZW50DgYAAAEBBAAABQELAgMCBgQCAQUMCQMqDgIKBAYBCQMqDgIKAgEFDJIABQsBAwAAAAAAAPA/AwUMAgIHBQwFDJIABQsKBAYBAgEFDAICBwUMBQwMAAMFDAUMAAAA";
h3d_shader_DirShadow.SRC = "HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EAEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFC1BDRl9TQU1QTEVTAQIAAQAAAAAABghwY2ZTY2FsZQMCAAAHCXNoYWRvd1JlcwUKAgAACAlzaGFkb3dNYXARAQIAAAkKc2hhZG93UHJvaggCAAAKCnNoYWRvd0JpYXMDAgAACxN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAMBnNoYWRvdwMEAAANCWRpclNoYWRvdwMEAAAOC3BvaXNzb25EaXNrDwUMBQIAAA8EcmFuZA4GAAAQCGZyYWdtZW50DgYAAAIDDwERAXYDBAAAAwUCCBICZHADBAAACQMdDgIJAyoOAQIRAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhIDAwEDUPwYc9Fd5UADAwMAAAEQAAAFAgsCAQIFAQsCBAIFCwYEAgwDAQMAAAAAAADwPwMDCBMJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgUCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBUIc2hhZG93VXYFCgQAAAkDOg4BCgIUBQsRAAUKBQoACBYEek1heAMEAAAJAzUOAQoCFAULCAADAwAIFwNyb3QDBAAABgEGAQkCDw4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwAIGARjb3NSAwQAAAkDAw4BAhcDAwAIGQRzaW5SAwQAAAkDAg4BAhcDAwAIGg5zYW1wbGVTdHJlbmd0aAMEAAAGAgEDAAAAAAAA8D8DCQMmDgECBQEDAwAIGwhvZmZTY2FsZQUKBAAABgECEwUKAgYDBQoADhwBaQEEAAAGFQECAAAAAAECBQEPAQAABQQIHQZvZmZzZXQFCgQAAAYBChECDg8FDAUCHAEFDBEABQoCGwUKBQoABgQCHQUKCQMoDgIGAwYBAhgDCgIdBQoAAAMDBgECGQMKAh0FCgQAAwMDBgAGAQIYAwoCHQUKBAADAwYBAhkDCgIdBQoAAAMDAwUKBQoIHgVkZXB0aAMEAAAJA0AOAwIIEQEGAAIVBQoCHQUKBQoBAwAAAAAAAAAAAwMABoMCDAMLBAYHBgMCFgMCCgMDAh4DAgICGgMBAwAAAAAAAAAAAwMDAAAACwICAgUFCB8Jc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIIAVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCHwULEQAFCgUKAwAIIQR6TWF4AwQAAAkDNQ4BCgIfBQsIAAMDAAgiBWRlbHRhAwQAAAYDCQMVDgIEBgACIAMCCgMDAwIhAwMCIQMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAiIDAwMDAwAFBAgjCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCQIc2hhZG93VXYFCgQAAAkDOg4BCgIjBQsRAAUKBQoACCUFZGVwdGgDBAAACQM/DgICCBEBCgIkBQoRAAUKAwAGBAIMAwsGBwYDCQM1DgEKAiMFCwgAAwMCCgMDAiUDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA";
h3d_shader_GenTexture.SRC = "HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA";
h3d_shader_LineShader.SRC = "HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA";
h3d_shader_MinMaxShader.SRC = "HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA";
h3d_shader_CubeMinMaxShader.SRC = "HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA";
h3d_shader_NormalMap.SRC = "HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA";
h3d_shader_Shadow.SRC = "HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsEAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA";
h3d_shader_SignedDistanceField.SRC = "HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA8BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEA1hdXRvU21vb3RoaW5nAgIAAQAAAAAAEQthbHBoYUN1dG9mZgMCAAASCXNtb290aGluZwMCAAATBm1lZGlhbg4GAAAUCGZyYWdtZW50DgYAAAIDEwMVAXIDBAAAFgFnAwQAABcBYgMEAAADBQENCQMWDgIJAxUOAgIVAwIWAwMJAxUOAgkDFg4CAhUDAhYDAwIXAwMDAAABFAAABQUIGA10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgZCGRpc3RhbmNlAwQAAAAABgQCGQMLBgUCDwEBAgAAAAABAgoCGAUMAAADCwYFAg8BAQIBAAAAAQIKAhgFDAQAAwsGBQIPAQECAgAAAAECCgIYBQwIAAMLBgUCDwEBAgMAAAABAgoCGAUMDAADCQITDgMKAhgFDAAAAwoCGAUMBAADCgIYBQwIAAMDAwMDAwMIGglzbW9vdGhWYWwDBAAACwIQAgkDDw4BBgEJAz4OAQIZAwMBAwAAAAAAAOA/AwMDAhIDAwAGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEQMCGgMDBgACEQMCGgMDAhkDAwUMBQwA";
h3d_shader_SkinBase.SRC = "HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UGARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAA";
h3d_shader_Skin.SRC = "HXSLD2gzZC5zaGFkZXIuU2tpbgkBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAURZm91ckJvbmVzQnlWZXJ0ZXgCAgABAAAAAAAGDWJvbmVzTWF0cml4ZXMPCAQCAAEIBwVpbnB1dA0BBAgIcG9zaXRpb24FCwEHAAkGbm9ybWFsBQsBBwAKB3dlaWdodHMFCwEHAAsHaW5kZXhlcwkEAAAAAQcAAQAADBJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA0GdmVydGV4DgYAAAEADQAABQQGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAAAAwEIBQsFCwoCCgULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyUOAQoCCwkEAAAABAADAQgFCwULCgIKBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAgAAwEIBQsFCwoCCgULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgsJBAAAAAAAAwEIBgULBQsKAgoFCwAAAwULBgEEBgECCQULCQMyDgERAgYPCAQJAyUOAQoCCwkEAAAABAADAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgsJBAAAAAgAAwEIBgULBQsKAgoFCwgAAwULBQsFCwsCBQIFAwgOAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCgULAAADCgIKBQsEAAMDCgIKBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAwAAwEIBQsFCwIOAwULBQsGgAIDBQsGAQQGAQIJBQsJAzIOARECBg8IBAkDJQ4BCgILCQQAAAAIAAMBCAYFCwULAg4DBQsFCwAAAAYEAgMFCwkDHw4BAgMFCwULBQsA";
h3d_shader_SkinTangent.SRC = "HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQJARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAcFaW5wdXQNAQUICHBvc2l0aW9uBQsBBwAJBm5vcm1hbAULAQcACgd0YW5nZW50BQsBBwALB3dlaWdodHMFCwEHAAwHaW5kZXhlcwkEAAAAAQcAAQAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA4GdmVydGV4DgYAAAEADgAABQYGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAAAAwEIBQsFCwoCCwULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyUOAQoCDAkEAAAABAADAQgFCwULCgILBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBQsFCwoCCwULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAAAAwEIBgULBQsKAgsFCwAAAwULBgEEBgECCQULCQMyDgERAgYPCAQJAyUOAQoCDAkEAAAABAADAQgGBQsFCwoCCwULBAADBQsFCwYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwYECgINBQySAAULBgAGAAYBBAYBCgIKBQuSAAULCQMyDgERAgYPCAQJAyUOAQoCDAkEAAAAAAADAQgGBQsFCwoCCwULAAADBQsGAQQGAQoCCgULkgAFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAQAAwEIBgULBQsKAgsFCwQAAwULBQsGAQQGAQoCCgULkgAFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwsCBQIFBAgPAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAwAAwEIBQsFCwIPAwULBQsGgAIDBQsGAQQGAQIJBQsJAzIOARECBg8IBAkDJQ4BCgIMCQQAAAAIAAMBCAYFCwULAg8DBQsFCwaACgINBQySAAULBgEEBgEKAgoFC5IABQsJAzIOARECBg8IBAkDJQ4BCgIMCQQAAAAMAAMBCAYFCwULAg8DBQsFCwAAAAYEAgMFCwkDHw4BAgMFCwULBQsGBAoCDQUMkgAFCwkDHw4BCgINBQySAAULBQsFCwA";
h3d_shader_SpecularTexture.SRC = "HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA";
h3d_shader_Texture.SRC = "HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA";
h3d_shader_UVDelta.SRC = "HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA";
h3d_shader_VertexColorAlpha.SRC = "HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA";
h3d_shader_VolumeDecal.SRC = "HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA";
haxe_EntryPoint.pending = [];
haxe_EntryPoint.threadCount = 0;
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	var h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
hxd_Precision.F32 = 0;
hxd_Precision.F16 = 1;
hxd_Precision.U8 = 2;
hxd_Precision.S8 = 3;
hxd_Precision.SIZES = [4,2,1,1];
hxd_InputFormat.DFloat = 1;
hxd_InputFormat.DVec2 = 2;
hxd_InputFormat.DVec3 = 3;
hxd_InputFormat.DVec4 = 4;
hxd_InputFormat.DBytes4 = 9;
hxd_BufferFormat._UID = 0;
hxd_BufferFormat.ALL_FORMATS = new haxe_ds_StringMap();
hxd_MultiFormat.UID = 0;
hxd_MultiFormat.CACHE = new haxe_ds_IntMap();
hxd_MultiFormat._UID = 0;
hxd_MultiFormat.MAX_FORMATS = 16;
hxd_Charset.ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
hxd_Charset.LATIN1 = "-";
hxd_Charset.CYRILLIC = "";
hxd_Charset.POLISH = "";
hxd_Charset.TURKISH = "I";
hxd_Charset.JP_KANA = "";
hxd_Charset.UNICODE_SPECIALS = "";
hxd_Charset.DEFAULT_CHARS = hxd_Charset.ASCII + hxd_Charset.LATIN1;
hxd_Charset.complementChars = (function($this) {
	var $r;
	var str = "";
	var _g = new haxe_ds_IntMap();
	{
		var _g1 = 0;
		var _g2 = str.length;
		while(_g1 < _g2) {
			var i = _g1++;
			_g.h[HxOverrides.cca(str,i)] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxd_Key.BACKSPACE = 8;
hxd_Key.TAB = 9;
hxd_Key.ENTER = 13;
hxd_Key.SHIFT = 16;
hxd_Key.CTRL = 17;
hxd_Key.ALT = 18;
hxd_Key.ESCAPE = 27;
hxd_Key.SPACE = 32;
hxd_Key.PGUP = 33;
hxd_Key.PGDOWN = 34;
hxd_Key.END = 35;
hxd_Key.HOME = 36;
hxd_Key.LEFT = 37;
hxd_Key.UP = 38;
hxd_Key.RIGHT = 39;
hxd_Key.DOWN = 40;
hxd_Key.INSERT = 45;
hxd_Key.DELETE = 46;
hxd_Key.QWERTY_EQUALS = 187;
hxd_Key.QWERTY_MINUS = 189;
hxd_Key.QWERTY_TILDE = 192;
hxd_Key.QWERTY_BRACKET_LEFT = 219;
hxd_Key.QWERTY_BRACKET_RIGHT = 221;
hxd_Key.QWERTY_SEMICOLON = 186;
hxd_Key.QWERTY_QUOTE = 222;
hxd_Key.QWERTY_BACKSLASH = 220;
hxd_Key.QWERTY_COMMA = 188;
hxd_Key.QWERTY_PERIOD = 190;
hxd_Key.QWERTY_SLASH = 191;
hxd_Key.INTL_BACKSLASH = 226;
hxd_Key.LEFT_WINDOW_KEY = 91;
hxd_Key.RIGHT_WINDOW_KEY = 92;
hxd_Key.CONTEXT_MENU = 93;
hxd_Key.PAUSE_BREAK = 19;
hxd_Key.CAPS_LOCK = 20;
hxd_Key.NUM_LOCK = 144;
hxd_Key.SCROLL_LOCK = 145;
hxd_Key.NUMBER_0 = 48;
hxd_Key.NUMBER_1 = 49;
hxd_Key.NUMBER_2 = 50;
hxd_Key.NUMBER_3 = 51;
hxd_Key.NUMBER_4 = 52;
hxd_Key.NUMBER_5 = 53;
hxd_Key.NUMBER_6 = 54;
hxd_Key.NUMBER_7 = 55;
hxd_Key.NUMBER_8 = 56;
hxd_Key.NUMBER_9 = 57;
hxd_Key.NUMPAD_0 = 96;
hxd_Key.NUMPAD_1 = 97;
hxd_Key.NUMPAD_2 = 98;
hxd_Key.NUMPAD_3 = 99;
hxd_Key.NUMPAD_4 = 100;
hxd_Key.NUMPAD_5 = 101;
hxd_Key.NUMPAD_6 = 102;
hxd_Key.NUMPAD_7 = 103;
hxd_Key.NUMPAD_8 = 104;
hxd_Key.NUMPAD_9 = 105;
hxd_Key.A = 65;
hxd_Key.B = 66;
hxd_Key.C = 67;
hxd_Key.D = 68;
hxd_Key.E = 69;
hxd_Key.F = 70;
hxd_Key.G = 71;
hxd_Key.H = 72;
hxd_Key.I = 73;
hxd_Key.J = 74;
hxd_Key.K = 75;
hxd_Key.L = 76;
hxd_Key.M = 77;
hxd_Key.N = 78;
hxd_Key.O = 79;
hxd_Key.P = 80;
hxd_Key.Q = 81;
hxd_Key.R = 82;
hxd_Key.S = 83;
hxd_Key.T = 84;
hxd_Key.U = 85;
hxd_Key.V = 86;
hxd_Key.W = 87;
hxd_Key.X = 88;
hxd_Key.Y = 89;
hxd_Key.Z = 90;
hxd_Key.F1 = 112;
hxd_Key.F2 = 113;
hxd_Key.F3 = 114;
hxd_Key.F4 = 115;
hxd_Key.F5 = 116;
hxd_Key.F6 = 117;
hxd_Key.F7 = 118;
hxd_Key.F8 = 119;
hxd_Key.F9 = 120;
hxd_Key.F10 = 121;
hxd_Key.F11 = 122;
hxd_Key.F12 = 123;
hxd_Key.F13 = 124;
hxd_Key.F14 = 125;
hxd_Key.F15 = 126;
hxd_Key.F16 = 127;
hxd_Key.F17 = 128;
hxd_Key.F18 = 129;
hxd_Key.F19 = 130;
hxd_Key.F20 = 131;
hxd_Key.F21 = 132;
hxd_Key.F22 = 133;
hxd_Key.F23 = 134;
hxd_Key.F24 = 135;
hxd_Key.NUMPAD_MULT = 106;
hxd_Key.NUMPAD_ADD = 107;
hxd_Key.NUMPAD_ENTER = 108;
hxd_Key.NUMPAD_SUB = 109;
hxd_Key.NUMPAD_DOT = 110;
hxd_Key.NUMPAD_DIV = 111;
hxd_Key.MOUSE_LEFT = 0;
hxd_Key.MOUSE_RIGHT = 1;
hxd_Key.MOUSE_MIDDLE = 2;
hxd_Key.MOUSE_BACK = 3;
hxd_Key.MOUSE_FORWARD = 4;
hxd_Key.MOUSE_WHEEL_UP = 5;
hxd_Key.MOUSE_WHEEL_DOWN = 6;
hxd_Key.LOC_LEFT = 256;
hxd_Key.LOC_RIGHT = 512;
hxd_Key.LSHIFT = 272;
hxd_Key.RSHIFT = 528;
hxd_Key.LCTRL = 273;
hxd_Key.RCTRL = 529;
hxd_Key.LALT = 274;
hxd_Key.RALT = 530;
hxd_Key.initDone = false;
hxd_Key.keyPressed = [];
hxd_Key.ALLOW_KEY_REPEAT = false;
hxd_Math.PI = 3.14159265358979323;
hxd_Math.EPSILON = 1e-10;
hxd_Math.EPSILON2 = 1e-20;
hxd_Channel.R = 0;
hxd_Channel.G = 1;
hxd_Channel.B = 2;
hxd_Channel.A = 3;
hxd_Save.cur = new haxe_ds_StringMap();
hxd_Save.SALT = "s*al!t";
hxd_Timer.wantedFPS = 60.;
hxd_Timer.maxDeltaTime = 0.5;
hxd_Timer.smoothFactor = 0.95;
hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
hxd_Timer.elapsedTime = 0.;
hxd_Timer.frameCount = 0;
hxd_Timer.dt = 1 / hxd_Timer.wantedFPS;
hxd_Timer.currentDT = 1 / hxd_Timer.wantedFPS;
hxd_System.setCursor = hxd_System.setNativeCursor;
hxd_System.loopInit = false;
hxd_System.fpsLimit = -1;
hxd_clipper__$Clipper_ClipperBase.HORIZONTAL = -9007199254740992.;
hxd_clipper__$Clipper_ClipperBase.TOLERANCE = 1E-20;
hxd_clipper__$Clipper_ClipperBase.SKIP = -2;
hxd_clipper__$Clipper_ClipperBase.UNASSIGNED = -1;
hxd_fmt_hmd_Position.QTMP = new h3d_Quat();
hxd_fmt_hmd_Data.CURRENT_VERSION = 3;
hxd_fmt_hmd_Reader.BLEND = h2d_BlendMode.__empty_constructs__.slice();
hxd_fmt_hmd_Reader.CULLING = h3d_mat_Face.__empty_constructs__.slice();
hxd_fs_EmbedFileSystem.invalidChars = new EReg("[^A-Za-z0-9_]","g");
hxd_impl_BufferFlags.Dynamic = 0;
hxd_impl_BufferFlags.Static = 1;
hxd_impl_BufferFlags.UniformDynamic = 2;
hxd_poly2tri_Point.C_ID = 0;
hxd_res_Resource.LIVE_UPDATE = false;
hxd_res_FontBuilder.FONTS = new haxe_ds_StringMap();
hxd_res_ImageFormat.Jpg = 0;
hxd_res_ImageFormat.Png = 1;
hxd_res_ImageFormat.Gif = 2;
hxd_res_ImageFormat.Tga = 3;
hxd_res_ImageFormat.Dds = 4;
hxd_res_ImageFormat.Raw = 5;
hxd_res_ImageFormat.Hdr = 6;
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear;
hxd_res_Image.MIPMAP_MAX_SIZE = 0;
hxd_res_Image.ENABLE_AUTO_WATCH = true;
hxd_res_Image.BLACK_1x1 = hxd_Pixels.alloc(1,1,hxd_PixelFormat.RGBA);
hxd_res_Image.LOG_TEXTURE_LOAD = false;
hxd_res_NanoJpeg.BLOCKSIZE = 64;
hxd_res_NanoJpeg.W1 = 2841;
hxd_res_NanoJpeg.W2 = 2676;
hxd_res_NanoJpeg.W3 = 2408;
hxd_res_NanoJpeg.W5 = 1609;
hxd_res_NanoJpeg.W6 = 1108;
hxd_res_NanoJpeg.W7 = 565;
hxd_res_NanoJpeg.CF4A = -9;
hxd_res_NanoJpeg.CF4B = 111;
hxd_res_NanoJpeg.CF4C = 29;
hxd_res_NanoJpeg.CF4D = -3;
hxd_res_NanoJpeg.CF3A = 28;
hxd_res_NanoJpeg.CF3B = 109;
hxd_res_NanoJpeg.CF3C = -9;
hxd_res_NanoJpeg.CF3X = 104;
hxd_res_NanoJpeg.CF3Y = 27;
hxd_res_NanoJpeg.CF3Z = -3;
hxd_res_NanoJpeg.CF2A = 139;
hxd_res_NanoJpeg.CF2B = -11;
hxd_res_Sound.ENABLE_AUTO_WATCH = true;
hxd_snd_Channel.ID = 0;
hxd_snd_Source.ID = 0;
hxd_snd_Manager.STREAM_DURATION = 5.;
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100;
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2;
hxd_snd_Manager.MAX_SOURCES = 16;
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256;
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5;
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16;
hxd_snd_webaudio_BufferPlayback.FADE_SAMPLES = 10;
hxsl_Tools.UID = 0;
hxsl_Tools.SWIZ = hxsl_Component.__empty_constructs__.slice();
hxsl_Tools.MAX_CHANNELS_BITS = 3;
hxsl_BatchShader.SRC = "HXSLEGh4c2wuQmF0Y2hTaGFkZXIDAQ9CYXRjaF9IYXNPZmZzZXQCAgABAAAAAAACC0JhdGNoX0NvdW50AQIAAQAAAAEAAwxCYXRjaF9CdWZmZXIQBQwCAgAAAA";
hxsl_GlslOut.KWD_LIST = ["input","output","discard","sample","dvec2","dvec3","dvec4","hvec2","hvec3","hvec4","fvec2","fvec3","fvec4","int","float","bool","long","short","double","half","fixed","unsigned","superp","lowp","mediump","highp","precision","invariant","discard","struct","asm","union","template","this","packed","goto","sizeof","namespace","noline","volatile","external","flat","input","output","out","attribute","const","uniform","varying","inout","void"];
hxsl_GlslOut.KWDS = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var _g1 = 0;
		var _g2 = hxsl_GlslOut.KWD_LIST;
		while(_g1 < _g2.length) {
			var k = _g2[_g1];
			++_g1;
			_g.h[k] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxsl_GlslOut.GLOBALS = (function($this) {
	var $r;
	var gl = [];
	{
		var _g = 0;
		var _g1 = hxsl_TGlobal.__empty_constructs__.slice();
		while(_g < _g1.length) {
			var g = _g1[_g];
			++_g;
			var n = "" + Std.string(g);
			n = n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
			gl[g._hx_index] = n;
		}
	}
	gl[hxsl_TGlobal.ToInt._hx_index] = "int";
	gl[hxsl_TGlobal.ToFloat._hx_index] = "float";
	gl[hxsl_TGlobal.ToBool._hx_index] = "bool";
	gl[hxsl_TGlobal.LReflect._hx_index] = "reflect";
	gl[hxsl_TGlobal.Mat3x4._hx_index] = "_mat3x4";
	gl[hxsl_TGlobal.VertexID._hx_index] = "gl_VertexID";
	gl[hxsl_TGlobal.InstanceID._hx_index] = "gl_InstanceID";
	gl[hxsl_TGlobal.IVec2._hx_index] = "ivec2";
	gl[hxsl_TGlobal.IVec3._hx_index] = "ivec3";
	gl[hxsl_TGlobal.IVec4._hx_index] = "ivec4";
	gl[hxsl_TGlobal.BVec2._hx_index] = "bvec2";
	gl[hxsl_TGlobal.BVec3._hx_index] = "bvec3";
	gl[hxsl_TGlobal.BVec4._hx_index] = "bvec4";
	gl[hxsl_TGlobal.FragCoord._hx_index] = "gl_FragCoord";
	gl[hxsl_TGlobal.FrontFacing._hx_index] = "gl_FrontFacing";
	gl[hxsl_TGlobal.FrontFacing._hx_index] = "gl_FrontFacing";
	gl[hxsl_TGlobal.FloatBitsToUint._hx_index] = "_floatBitsToUint";
	gl[hxsl_TGlobal.UintBitsToFloat._hx_index] = "_uintBitsToFloat";
	{
		var _g = 0;
		while(_g < gl.length) {
			var g = gl[_g];
			++_g;
			hxsl_GlslOut.KWDS.h[g] = true;
		}
	}
	$r = gl;
	return $r;
}(this));
hxsl_GlslOut.MAT34 = "struct _mat3x4 { vec4 a; vec4 b; vec4 c; };";
hxsl__$Linker_ShaderInfos.UID = 0;
hxsl_Printer.SWIZ = ["x","y","z","w"];
hxsl_RuntimeShader.UID = 0;
hxsl_Serializer.TVECS = new haxe_ds_IntMap();
hxsl_Serializer.BOPS = (function($this) {
	var $r;
	var ops = haxe_macro_Binop.__empty_constructs__.slice();
	ops.splice(haxe_macro_Binop.OpAssignOp(null)._hx_index,0,null);
	$r = ops;
	return $r;
}(this));
hxsl_Serializer.UNOPS = haxe_macro_Unop.__empty_constructs__.slice();
hxsl_Serializer.TGLOBALS = hxsl_TGlobal.__empty_constructs__.slice();
hxsl_Serializer.TSWIZ = new haxe_ds_IntMap();
hxsl_Serializer.REGS = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Serializer.VKINDS = hxsl_VarKind.__empty_constructs__.slice();
hxsl_Serializer.PRECS = hxsl_Prec.__empty_constructs__.slice();
hxsl_Serializer.FKIND = hxsl_FunctionKind.__empty_constructs__.slice();
hxsl_Serializer.SIGN = 9139229;
hxsl_ShaderList.MAX_LIST_SIZE = 0;
hxsl_ShaderList.ALLOW_DUPLICATES = true;
hxsl_ShaderInstance.UID = 0;
hxsl_SharedShader.UNROLL_LOOPS = false;
seq_Tuto.SCENARIO = [TutotAction.GIVE_BALL(0),TutotAction.TXT("This is a snowball. you can throw it by pressing the SPACE key"),TutotAction.TXT("Try to catch it with my left hand !"),TutotAction.TEST_CATCH,TutotAction.TXT("Nice !"),TutotAction.TXT("You can throw the ball higher if you hold SPACE a little !"),TutotAction.GIVE_BALL(0),TutotAction.TXT("Now you have two snowballs."),TutotAction.TXT("You can pass a snowball with the LEFT CLICK."),TutotAction.TXT("Will you be able to swap their positions without letting one fall ?"),TutotAction.TEST_SWAP,TutotAction.TXT("Impressive !"),TutotAction.TXT("Here's your last test :"),TutotAction.GIVE_BALL(0),TutotAction.TXT("Try to juggle with those three snowballs."),TutotAction.TXT("Be carefull, once  you start you wont be able to carry two ball in one hand !"),TutotAction.TXT("Juggle 10x time in a row to pass the test."),TutotAction.TEST_JUGGLE,TutotAction.TXT("Congratulations !"),TutotAction.UNLOCK_CHALLENGE,TutotAction.TXT("See you later on the floe !")];
seq_Tuto.HELLO = "54,-47,54,-47,54,-47,54,-47,54,-48,54,-49,54,-51,54,-53,54,-54,54,-56,54,-59,53,-61,51,-65,50,-66,47,-70,46,-71,43,-75,41,-76,38,-79,36,-80,34,-83,33,-84,32,-86,32,-87,32,-88,32,-89,36,-89,37,-90,43,-90,45,-89,56,-83,56,-83,58,-81,58,-78,59,-75,59,-74,59,-74,59,-74,59,-74,57,-76,54,-79,51,-83,46,-86,44,-87,41,-88,39,-88,37,-88,36,-88,33,-85,33,-84,33,-83,33,-82,33,-80,34,-79,38,-75,39,-75,43,-73,47,-71,53,-71,54,-71,55,-72,55,-73,56,-76,56,-77,54,-80,52,-81,47,-84,44,-85,40,-86,38,-86,31,-86,31,-86,29,-84,30,-81,33,-76,35,-75,38,-73,39,-72,42,-70,43,-70,45,-70,48,-70,51,-71,52,-72,53,-73,53,-74,53,-75,53,-76,53,-79,52,-80,51,-81,49,-81,45,-82,43,-83,37,-83,36,-83,35,-82,34,-81,35,-78,35,-76,37,-73,38,-71,42,-66,43,-65,44,-63,45,-62,46,-59,46,-59,47,-57,47,-56,47,-56,47,-56";
{
	Main.main();
	haxe_EntryPoint.run();
}
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
